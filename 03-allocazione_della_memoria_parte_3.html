<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Allocazione della Memoria (Parte 3)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="allocazione-della-memoria---malnati-3"><a class="header" href="#allocazione-della-memoria---malnati-3">Allocazione della memoria - Malnati 3 <!-- omit in toc --></a></h1>
<h1 id="indice"><a class="header" href="#indice">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="#1-ciclo-di-vita-delle-variabili">1. Ciclo di vita delle variabili</a>
<ul>
<li><a href="#11-esempio-costruttore-e-distruttore">1.1 Esempio costruttore e distruttore</a></li>
</ul>
</li>
<li><a href="#2-allocazione-della-memoria">2. Allocazione della memoria</a></li>
<li><a href="#3-rilascio-della-memoria">3. Rilascio della memoria</a></li>
<li><a href="#4-puntatori">4. Puntatori</a>
<ul>
<li><a href="#41-indirizzo-valido">4.1 Indirizzo valido?</a></li>
<li><a href="#42-quanto-%C3%A8-grosso-il-blocco-puntato">4.2 Quanto è grosso il blocco puntato?</a></li>
<li><a href="#43-fino-a-quando-%C3%A8-garantito-laccesso">4.3 Fino a quando è garantito l’accesso?</a></li>
<li><a href="#44-se-ne-pu%C3%B2-modificare-il-contenuto">4.4 Se ne può modificare il contenuto?</a></li>
<li><a href="#45-occorre-rilasciarlo">4.5 Occorre rilasciarlo?</a></li>
<li><a href="#46-lo-si-pu%C3%B2-rilasciare-o-altri-conoscono-lo-stesso-indirizzo">4.6 Lo si può rilasciare o altri conoscono lo stesso indirizzo?</a></li>
<li><a href="#47-viene-usato-come-modo-per-esprimere-lopzionalit%C3%A0-del-dato">4.7 Viene usato come modo per esprimere l’opzionalità del dato?</a></li>
</ul>
</li>
<li><a href="#5-rischi">5. Rischi</a>
<ul>
<li><a href="#51-esempi">5.1 Esempi</a>
<ul>
<li><a href="#511-dangling-pointer">5.1.1 Dangling Pointer</a></li>
<li><a href="#512-memory-leakage">5.1.2 Memory Leakage</a></li>
<li><a href="#513-double-free">5.1.3 Double free</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-gestire-i-puntatori">6. Gestire i puntatori</a></li>
</ul>
<h1 id="1-ciclo-di-vita-delle-variabili"><a class="header" href="#1-ciclo-di-vita-delle-variabili">1. Ciclo di vita delle variabili</a></h1>
<p><img src="images/allocazione_della_memoria_3/image.png" alt="image.png" /></p>
<p>Abbiamo cominciato a vedere la divisione tra stack e heap e abbiamo visto sostanzialmente come le variabili locali esistono nel contesto del blocco in cui sono definite.</p>
<p>Quando entro all'interno di un blocco e incontro la definizione di una variabile globale, questa comincia a esistere, viene allocata sullo stack, quando arrivo alla parentesi graffa corrispondente alla chiusura del blocco la variabile viene buttata via, perdendo il dato che aveva al suo interno.</p>
<p>In generale, adesso vogliamo focalizzarci sul controllo del ciclo di vita che ciascuna di variabili ha e di come noi andiamo a intervenire.</p>
<p>Allora, le variabili globali esistono da sempre, <strong>quindi prima che parta il main e cessano di esistere dopo che il main è finito</strong>.
Sono accessibili in ogni momento e in generale se contengono del codice di inizializzazione, questo viene eseguito prima che il main parta.
Se contengono del codice di finalizzazione, questo viene eseguito dopo l'uscita del main.</p>
<p>L'altra caratteristica delle variabili globali è che hanno un <strong>indirizzo assoluto</strong>, il compilatore sa già dove le mette e quindi può, tutte le volte che incontra una variabile globale, scrivere già <em>“quella lì sta all'indirizzo 3b7f5942”</em>.</p>
<p>Le variabili locali, viceversa, incominciano a esistere quando si arriva alla loro definizione, cioè alla riga dove compare quella variabile locale lì, int i=5, in quel momento comincia a esistere, cessano di esistere quando arrivo alla chiusura graffa corrispondente e hanno un indirizzo che è <strong>relativo alla cima dello stack</strong>.</p>
<p>Quindi quando il compilatore genera il codice, per riferirsi a quella variabile locale lì, tendenzialmente dice <code>base_ptr+27</code>, <code>base_ptr+32</code>, qualcosa del genere, dove <code>base_ptr</code> è un registro ausiliario, nel caso dell'x86, che serve a contenere una copia dell’indirizzo dello stack all'inizio della funzione stessa, in modo da poter definire questo “offset” relativo da cui partire.</p>
<p><img src="images/allocazione_della_memoria_3/image%201.png" alt="image.png" /></p>
<p>Le variabili locali hanno un valore iniziale casuale.
Se io dichiaro solo <code>int i</code> e non gli assegno direttamente un valore di inizializzazione, lo stack si abbassa di 4 byte e cosa c'è in quello spazio nello stack? Quello che c’è.</p>
<p>Non sono in grado di prevedere il suo contenuto.</p>
<p><img src="images/allocazione_della_memoria_3/image%202.png" alt="image.png" /></p>
<p>Poi abbiamo le variabili dinamiche, cioè sono quelle che contengono un dato e che noi possiamo referenziare solo tramite puntatori.
Tocca al programmatore controllare nel ciclo di vita.</p>
<p>Una variabile dinamica comincia a esistere nel momento in cui io esplicitamente la alloco, e cessa di esistere quando la rilascio.</p>
<p>Come si fanno allocazione e rilascio?
Dipende dal linguaggio.</p>
<p>Se sto scrivendo del codice in C, l'allocazione si fa con <code>malloc</code>, o le sue funzioni parenti <code>calloc</code>, <code>realloc</code>, e il rilascio si fa con <code>free</code>.</p>
<p>Se sto lavorando in C++, che mi dà un supporto più avanzato alla gestione dei tipi, l'allocazione dinamica si fa con l'operatore <code>new</code> e il rilascio si fa con l'operatore <code>delete</code>.
Se ho una classe di tipo <code>automobile</code>, che rappresenta un veicolo, posso dire, la mia variabile <code>auto* a = new auto;</code>.</p>
<p>L'effetto di scrivere new auto è duplice.
Viene cercato sullo heap un blocco di memoria grande quanto serve a contenere un'automobile. Quanto ne serve dipende da come è definita quella classe, da quanti campi internamente avrà.</p>
<p>Subito dopo, trovato questo blocco, viene invocato il <strong>costruttore della classe</strong>, che si occupa di riempire quel blocco con i dati iniziali.</p>
<p>Esattamente come in Java, in C++ le classi hanno dei costruttori che ci permettono di garantire che la memoria sia inizializzata correttamente.</p>
<p><em>Come rilasciamo i blocchi di memoria che allochiamo dinamicamente?</em>
Li rilascio con <code>delete</code>.</p>
<p><em>Cosa succede quando chiamo delete?</em>
Anche qui due cose.</p>
<p>Prima di tutto <strong>viene chiamato il <em>distruttore</em></strong>.
<em>Cos'è il distruttore?</em>
È un particolare metodo che il C++ ci mette a disposizione, all'interno del quale noi possiamo scrivere cosa fare nel momento in cui la variabile cessa di esistere.
Il distruttore ci è utile quando una classe contiene, all'interno dei propri campi, delle risorse che devono essere lasciate.</p>
<p>Ad esempio, io potrei avere una classe che gestisce un file, il costruttore potrebbe essere responsabile di aprire il file, il distruttore è responsabile di chiudere il file.</p>
<p>Così sono tranquillo che quando quell'oggetto cessa di esistere, il file sarà chiuso.</p>
<p>Il costruttore lo chiamate <em><strong>voi</strong></em> esplicitamente nel momento in cui fate <code>new</code> o semplicemente dichiarate una variabile di quel tipo, il distruttore viene chiamato esclusivamente dal <em><strong>compilatore</strong></em>.</p>
<p>Viene chiamato, in qualche modo, sotto il vostro diretto controllo quando fate <code>delete</code>, per cui lui distrugge e poi rilascia la memoria, cioè notifica che quel gruppo di byte può essere riusato per altro.
Nel caso delle variabili locali viene chiamato nel momento in cui la variabile viene egettata.</p>
<h2 id="11-esempio-costruttore-e-distruttore"><a class="header" href="#11-esempio-costruttore-e-distruttore">1.1 Esempio costruttore e distruttore</a></h2>
<p>Facciamo una prova velocissima per renderci conto di questa cosa qua.</p>
<p><img src="images/allocazione_della_memoria_3/image%203.png" alt="image.png" /></p>
<p>Vediamo che il programma parte, mi stampa “main()”.
Subito dopo aver chiamato main, e subito dopo aver fatto la stampa, dichiara la variabile <code>t</code> di tipo <code>Test</code>, che quindi viene automaticamente costruita, e qui mi dice <em>“l’ho costruito all’indirizzo 16db8353b”</em>, poi va avanti, stampa “fine main()”, e poi esegue return 0, chiusa graffa.</p>
<p>In corrispondenza di quella chiusa graffa lì, lui dice “<em>devo pulire lo stack</em>”<em>.</em>
Cosa c’era nello stack?
Avevo un oggetto <code>Test</code>, quindi automaticamente invoca il distruttore, e vediamo “distrutto Test”, proprio a quell’indirizzo lì.</p>
<p><img src="images/allocazione_della_memoria_3/image%204.png" alt="image.png" /></p>
<p><em>Cosa succede se facciamo così?</em></p>
<p>Parte dal main, inizia il ciclo for, all’interno del ciclo for dichiaro la variabile <code>t</code>, che viene costruita, viene costruita dove?</p>
<p>Abbassando leggermente lo stack, e quindi sta all’indirizzo 37, quello che finisce con 37.
Poi subito dopo stampa iterazione numero 0, e arriva la chiusa graffa, dove test finisce, e quindi che cosa fa? Distrugge l’oggetto <code>t</code>.</p>
<p>E chiaramente l’ha costruito all’indirizzo 37, e lo distrugge all’indirizzo 37, quindi lo stack risale un po’, poi torna a fare l’iterazione successiva.</p>
<p>Dice “<em>ah, ho bisogno di un Test</em>”, riabbassa lo stack, stampa iterazione numero 1, rialza lo stack, e lo fa tre volte.</p>
<p>Poi arriva al fondo, stampa “fine del main”, chiusa.</p>
<p>Quindi, vediamo che, dichiarata dentro un ciclo for, la variabile viene creata tante volte quante sono le iterazioni del ciclo, e viene distrutta al termine dell’iterazione del ciclo.</p>
<p><img src="images/allocazione_della_memoria_3/image%205.png" alt="image.png" /></p>
<p>Se io dichiarassi anche una variabile globale, <code>Test t1</code>, vedete che questa volta dice <em>“ho costruito un Test all’indirizzo 1000a8000”</em>, prima ancora di chiamare main.</p>
<p>Perché? Perché il costruttore delle variabili globali parte prima che inizi il main!</p>
<p>Fa tutte le sue cose, mi dirà “fine main”, e poi mi distrugge quella parte lì.</p>
<p>Qui non riusciamo bene a distinguere che cosa avviene dove e quando, perché anche prima ci stampava “distrutto” dopo aver scritto “fine del main”, perché noi la scritta “fine del main” non la possiamo mettere in corrispondenza del chiusa graffa, possiamo solo metterla in corrispondenza subito prima del chiusa graffa, quindi la vera distruzione avviene tra la stampa e il chiusa graffa, se fosse locale.</p>
<p>Quella globale avviene dopo il chiusa graffa.</p>
<p>Comunque, sostanzialmente le cose sono fatte così.</p>
<p>Tutte queste sono variabili che hanno un ciclo di vita ben definito.</p>
<p><img src="images/allocazione_della_memoria_3/image%206.png" alt="image.png" /></p>
<p><em>Cosa succede se noi invece allocassimo delle cose dinamicamente?</em></p>
<p>Scritto in questo modo, <code>new Test()</code> dice <em>“questa variabile non deve stare nello stack, deve stare nello heap e la voglio tenere fin quando mi viene comoda”</em>.</p>
<p>Ad esempio, dentro il ciclo for potrei dire <code>if i==1 delete pt</code>.
Quindi invece di far coincidere la vita di questa variabile con un blocco, la creo prima del for e la distruggo a metà delle iterazioni del for.</p>
<p>Quindi avrò delle iterazioni del for in cui quella variabile lì non è più valida.</p>
<p>Parte, è sempre costruita la variabile globale t1 che questa volta parte all’indirizzo 1049d8000, poi viene stampato “main()”, e poi viene stampato <code>Costruito Test @ 0x600000744040</code>, e notiamo che l’indirizzo è totalmente diverso: 60000744040.</p>
<p>Questo perché vive in una zona totalmente distinta, nell’heap!</p>
<p>Poi c’è l’iterazione numero 0, poi dovrebbe arrivare nell’iterazione numero 1 e in effetti ci entra ma subito prima della stampa viene eseguita la delete.</p>
<p>Poi fa l’iterazione numero 2, il ciclo for finisce, finisce il main, ma c’è ancora una variabile globale, che quindi viene buttata via invocando il distruttore.</p>
<p>Quindi le variabili possono avere un codice di inizializzazione, lo chiamiamo <strong>costruttore</strong>, possono avere un codice di rilascio, che chiamiamo <strong>distruttore</strong>.</p>
<p>Il costruttore implicitamente lo andiamo a chiamare nel momento in cui mettiamo in gioco la variabile, il distruttore è sempre solo chiamato dal compilatore: noi non abbiamo nessuna chiamata <code>~Test()</code>.</p>
<p>E viene chiamato nel momento giusto, quando quella variabile cessa di esistere.</p>
<p><img src="images/allocazione_della_memoria_3/image%207.png" alt="image.png" /></p>
<p>Quindi le variabili dinamiche hanno un indirizzo che è assoluto.
Peccato che non si può sapere a compile time, solo a run time me lo verrà detto, quando io invoco <code>new *qualcosa*</code>, in quel momento verrà cercato un posto grande a sufficienza per far stare la mia variabile.</p>
<p>E accedo alle variabili dinamiche solo tramite puntatori, mentre alle altre accedo con variabili che hanno un nome.</p>
<p>Il fatto che sia inizializzato o meno il valore iniziale dipende da cosa ho scritto nel costruttore, dipende anche dal linguaggio.
Se faccio <code>malloc</code>, malloc non mi dà garanzie di inizializzazione, mi prende un blocco grande quanto gli chiedo, ad esempio 84, e lui mi cerca 84 byte, ma non è che li pulisce, mi dà il puntatore al primo di 84 byte e basta, dentro ci può essere qualunque cosa.</p>
<p>Quando faccio in C++ <code>new</code>, new passa attraverso il costruttore che di solito si prende la briga di inizializzare le cose.</p>
<p>Chiaramente perché possano funzionare le variabili dinamiche ci vuole un sistema di supporto, quando io chiamo <code>malloc</code> o <code>new</code>, come fa l’implementazione di <code>malloc</code> o <code>new</code> a darmi un indirizzo?</p>
<p>Deve cercare!
Vuol dire che internamente <code>malloc</code> e <code>new</code> sono in realtà delle funzioni sofisticate che si appoggiano a una loro rappresentazione della memoria, sanno che per esempio all’inizio lo heap va dall’indirizzo 60000 all’indirizzo 70000, prendiamo dei numeri a caso, ed è tutto libero, quindi alla domanda <em>“dammene un pezzo”</em> magari vi danno l’inizio, poi dopo un po’ chiedo un altro pezzo, mi danno quello che viene subito dopo, poi magari gli rilascio il pezzo iniziale e a questo punto l’heap che prima era tutto bello compatto è diventato con un buchino.</p>
<p>Quando gli chiederò un’altra cosa, probabilmente cercheranno se tra i rotti c’è un pezzo piccolo dove ci sta già quello che io gli chiedo, perché?</p>
<p>Perché vale il principio che se posso uso gli sfridi, non vado a intaccare il pezzo grosso.</p>
<p>Chiaramente andare a cercare qual è il punto più conveniente può essere lento, perché io ho tante alternative, potrei accontentarmi della prima ma non è detto che la prima sia la più furba.</p>
<p>Probabilmente <code>malloc</code> e <code>new</code> possono tenersi i loro pezzettini organizzati in tanti modi, il modo più becero è una lista, però se è una lista per sapere quale pezzettino più adatto la devo visitare tutta, e quella lista può essere molto lunga, ci mette un mucchio a saperlo, oppure posso tenerla organizzata ad albero, è molto più articolata, tengo un albero dove parto da un punto medio, a destra metto i pezzi piccoli, a sinistra metto i pezzi grandi e così via, quella potrebbe essere un’altra strategia.</p>
<p>L’unico problema è che quando io seguo un pezzo devo ribilanciarmi l’albero, perché adesso mi sono trovato un pezzettino, uno sfridino piccolo che deve andare da qualche parte e devo andare a spostare, oppure quando qualcuno mi restituisce se riesco a compattare devo fare un pezzo grosso.</p>
<p>Quindi le operazioni di allocazione e rilascio sono potenzialmente operazioni lente e complesse, che richiedono di tenere allineate un mucchio di cose, consumano.</p>
<p>Se <code>malloc</code> deve farsi l’albero vuol dire che una parte della memoria che globalmente ha a disposizione la usa per se stesso e non la potrà mai dare al programma — più è sofisticata quella struttura lì fatta di puntatori, mappe, tabelle e schifezze di ogni tipo, meno sarà la memoria per il programma.
Probabilmente sarà più efficiente nel comportamento, ma c’è un bilanciamento da trovare.</p>
<p><em>Cosa succede quando il programmatore chiama</em> <code>free</code> <em>piuttosto che</em> <code>delete</code><em>?</em>
Restituisce quel pezzettino che aveva ricevuto.</p>
<p>Che cosa se ne fa la funzione <code>free</code> o la funzione <code>delete</code>?
Va a vedere nell’albero, nella lista, in generale nella struttura dati se questo pezzettino A è suo o meno, perché io potrei fare il furbo — ad esempio se <code>malloc</code> mi dava gli indirizzi da 60.000 a 70.000 e io gli dò un indirizzo che è 1.000, ma lui mi dirà che non è mio.</p>
<p>Supponendo che sia suo va a cercare se quel pezzettino lì gli risultava come occupato e lo deve marcare come libero e possibilmente lo deve accorpare ad altri pezzi liberi e adiacenti, in modo da fare un pezzo più grosso.</p>
<p>Cosa succede se gli restituisco un pezzo, e poi senza averglielo chiesto, glielo restituisco di nuovo?
Cioè se io nel programma che ho scritto, là dove ho messo <code>delete</code>, mettessi <code>delete</code> due volte?
La prima volta tutto bene, prende quel pezzo e lo mette a suo posto.</p>
<p>La seconda volta dipende come è implementata.
Un’implementazione di <code>delete</code> molto lenta ma attenta potrebbe rigettarmelo dicendo <em>“che è sta roba? No, non va bene”</em>.
Un’implementazione un po’ più veloce, che magari è più desiderabile perché io ho bisogno di fare tante <code>new</code> e tante <code>delete</code> nell’arco della vita del mio programma, potrebbe prendere per buono che quell’indirizzo che gli passo sia effettivamente indirizzo in uso e aggiornare le sue strutture dati.</p>
<p>Peccato che le strutture erano già aggiornate, e quindi si spacca tutto.
E a quel punto lì alle prossime richieste a <code>new</code> non ci capisce niente.</p>
<p>Se io non rilascio, resta il buco.
Se io rilascio due volte, spacco.</p>
<p>Se poi rilasci una cosa sbagliata, supponiamo, gli ho chiesto un indirizzo e lui mi ha dato 6.300, io gli restituisco 6.500, che è solo un pezzo. Potrebbe non accorgersene, ma a quel punto fa casino totale. Qui la grande responsabilità del programmatore è di fare le operazioni giuste.</p>
<h1 id="2-allocazione-della-memoria"><a class="header" href="#2-allocazione-della-memoria">2. Allocazione della memoria</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%208.png" alt="image.png" /></p>
<p>In C abbiamo <strong><code>malloc</code></strong> che ci restituisce un void asterisco, cioè un puntatore opaco, un puntatore ad una cosa qualunque. Prende come parametro un numero di byte e ci restituisce, se può, un puntatore valido.</p>
<p><strong><code>Calloc</code></strong> che prende in ingresso un numero di byte e un moltiplicatore.
Serve per fare gli array. Ad esempio, ho bisogno di un array di 25 automobili. Fornisco quanti elementi voglio, e quanto è grande un elemento di tipo auto, ad esempio 16 byte.
Quindi devo dare 25 x 16, 400 byte.</p>
<p><strong><code>Rialloc</code></strong> è particolare, dice “<em>cara malloc, tu mi avevi dato questo puntatore, guarda, adesso me serve uno un po’ più grande”</em>, oppure <em>“mi serve un po’ più piccolo”</em>.</p>
<p>Un po’ più grande, non è detto sempre, un po’ più piccolo è facile. Vuol dire che lei si segna che c’è un pezzo in fondo che è diventato libero.</p>
<p>Un po’ più grande è più complicato, perché non è detto che al fondo ci sia ancora spazio. Quindi Rialloc non sempre funziona: se fallisce restituisce null.
Dice <em>“guarda, quello che avevi è ancora buono, però non posso dartene di più, non ce l’ho o non ce l’ho lì, devo spostarlo”</em>.</p>
<p><img src="images/allocazione_della_memoria_3/image%209.png" alt="image.png" /></p>
<p>In C++ invece abbiamo un <code>new</code> che prende il nome del tipo ed eventualmente tra parentesi gli argomenti.</p>
<p>Le parentesi nella versione vecchia del C++ erano sempre tonde, nella versione moderna del C++ sono graffe, perché questo semplifica, toglie delle ambiguità possibili.</p>
<p>Nel C++ potete fare <code>new</code> del tipo e basta, oppure <code>new[]</code>.
New con le quadre serve per gli array, più o meno ha la stessa differenza che c’è tra malloc e calloc in C.</p>
<p><img src="images/allocazione_della_memoria_3/image%2010.png" alt="image.png" /></p>
<p>Se allocate un array, specifichiamo quanti elementi vogliamo e lui inizializza tanti pezzi uno di fianco all’altro.</p>
<h1 id="3-rilascio-della-memoria"><a class="header" href="#3-rilascio-della-memoria">3. Rilascio della memoria</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2011.png" alt="image.png" /></p>
<p>Se avete ottenuto il puntatore con una certa funzione, dovete rilasciarlo con la funzione <em><strong>duale</strong></em>.</p>
<p>Le cose create con <code>malloc</code>, <code>calloc</code>, <code>realloc</code> si rilasciano con <code>free</code>.</p>
<p>Le cose allocate con <code>new</code> si rilasciano con <code>delete</code>.
Le cose allocate con <code>new[n]</code> vengono rilasciate con <code>delete[]</code>.</p>
<p>È necessario fare così, perché altrimenti il compilatore non capisce.</p>
<p>Se il blocco non viene rilasciato si crea una perdita di memoria, se invece viene rilasciato due volte si spacca tutto: si corrompono le strutture dati che internamente vengono usate e poi di lì in avanti è assolutamente impossibile dire cosa capita.</p>
<h1 id="4-puntatori"><a class="header" href="#4-puntatori">4. Puntatori</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2012.png" alt="image.png" /></p>
<p>L’idea del puntatore non è solo collegato alla memoria dinamica.</p>
<p>Certo, non c’è altro modo in C e C++ di avere accesso a memoria dinamica se non tramite puntatori, perché il linguaggio vi pone questo.</p>
<p>In realtà i puntatori sono presenti in tantissimi altri linguaggi (li abbiamo anche in javascript, in java, in python e così via..), ma semplicemente non lo sapete, perché la cosa viene tenuta in qualche modo nascosta.
Quei puntatori lì sono essenziali per l’ottimizzazione degli algoritmi.</p>
<p>Perché? Perché se io devo passarti un dato, se quel dato è piccolo va bene, me lo passi — un intero ad esempio non è un grosso problema.
Ma se io devo passarti, ad esempio, un array che contiene mille elementi, mica te lo posso copiare.</p>
<p>Sì, in alcuni casi te lo copierò se ho davvero bisogno di mantenere due informazioni disgiunte. Ma altrimenti è onerosissimo.
L’idea di poterti passare il puntatore mi dà un mucchio di efficienza, è comodo.</p>
<p>Quindi, il fatto che io abbia lo spazio dinamico (quindi che posso chiedere quando mi serve e rilasciare quando mi serve, che è già un grande vantaggio perché posso chiedere delle cose grandi a piacere senza saperlo a priori, posso tenerle a lungo per quanto mi serve etc…) abilita un mucchio di cose che altrimenti non riuscirei a fare.</p>
<p>Una linked list, ad esempio, se non avete la memoria dinamica, non la potete fare.
Perché la linked list, ogni volta che aggiungete un elemento, ha bisogno di prenderne un pezzo in più e di metterlo al fondo.</p>
<p>Però vi pone il problema di gestire correttamente il rilascio.</p>
<p>I puntatori, al di là dell’uso della memoria dinamica, servono comunque tantissimo e abilitano tanti meccanismi che adesso vediamo nel dettaglio.</p>
<p>Però, se li usiamo male è un disastro, perché portano gli <em><strong>undefined behaviours</strong></em> che hanno conseguenze disastrose.</p>
<p><img src="images/allocazione_della_memoria_3/image%2013.png" alt="image.png" /></p>
<p>Vediamo l’uso tipico dei puntatori.</p>
<p>Il pezzo più semplice dell’uso dei puntatori, che non necessitano direttamente la memoria dinamica, è banalmente quando io devo dare l’accesso a una variabile senza dover copiare la variabile.</p>
<p>Io ho la variabile <code>A</code>, che vale 10, e voglio permettere a qualcun altro di andarci a guardare dentro.
Recupero dalla variabile il suo puntatore e passo il puntatore a chi gli interessa.
Quest’altro, dereferenziando il puntatore, potrà leggere cosa c’è scritto in quella variabile, potrà scrivere cosa c’è scritto in quella variabile.</p>
<p>Questo è un uso comunissimo.</p>
<p>Oppure posso avere dei puntatori che sono allocati per uno scopo particolare.
Lì ho <code>int* pB = new int{24}</code>, voglio un intero dinamico che inizialmente vale 24 e che potrò cancellare in un qualche momento.
Magari lo darò a qualcun altro per cancellarlo al posto mio o cose del genere.</p>
<p>I puntatori possono essere resi esplicitamente <strong>invalidi</strong>.
La convenzione che viene assunta in C è che un puntatore è invalido se contiene il numero 0.
Il puntatore dentro di sé non è nient’altro che un numero, è l’offset nello spazio virtuale di indirizzamento. Se io gli scrivo 0, per convenzione quello è un puntatore invalido.
Nel linguaggio C si usa di solito la macro NULL, che è definita come <code>((void*)0)</code>.
Nel C++ si usa la parola chiave <code>nullptr</code>.</p>
<p><em>Perché questo è utile?</em>
Perché in certe situazioni avere dei puntatori nulli mi permette di capire che certe cose non continuano oltre quel puntatore nullo.</p>
<p>Pensate a una lista collegata: ho il puntatore al primo elemento, che contiene il puntatore al secondo elemento, che contiene il puntatore al terzo elemento, che finalmente contiene null — vuol dire che finisce lì la lista.</p>
<p>Quindi avere una convenzione che mi dice quando un puntatore smette di essere buono è utile.
Altrimenti non implementereste tantissime cose.</p>
<p><img src="images/allocazione_della_memoria_3/image%2014.png" alt="image.png" /></p>
<p>Il problema è che ci sono tante responsabilità.</p>
<h2 id="41-indirizzo-valido"><a class="header" href="#41-indirizzo-valido">4.1 Indirizzo valido?</a></h2>
<p>Quando io ricevo una variabile di tipo puntatore e ci guardo dentro, leggo un numero, ad esempio <code>3b7f5944</code>… <em>posso dire se quel numero è <strong>valido</strong>?</em></p>
<p>Se ci leggo 0 posso sicuramente dire che <strong>non è valido.</strong></p>
<p>Ma se c’è scritto <code>3b7f5944</code> potrebbe <em>essere stato valido</em>, ma magari io l’ho appena rilasciato, e se dopo averlo rilasciato ci vado a scrivere ancora, potrei fare dei danni (perchè magari ora quel blocco apparterrebbe a qualcun altro).</p>
<p>Nell’esempio di codice che abbiamo visto prima, nel ciclo for alla seconda iterazione buttavamo via la variabile dinamica <code>pt</code>, ma nella variabile <code>pt</code> mi era rimasto l’indirizzo a quel blocco di memoria che abbiamo rilasciato nel for.
E se dopo che ho fatto <code>delete</code> ci andassi a scrivere sopra, farei del danno.</p>
<p>Per cui se io vedo un numero diverso da 0 <strong>non posso sapere direttamente se quello lì è mai stato buono, è buono o è ancora buono</strong>.</p>
<p>Questo è il primo grossissimo problema che abbiamo con i puntatori.</p>
<h2 id="42-quanto-è-grosso-il-blocco-puntato"><a class="header" href="#42-quanto-è-grosso-il-blocco-puntato">4.2 Quanto è grosso il blocco puntato?</a></h2>
<p>Secondo problema, quanto è grosso il blocco puntato?
Un puntatore è un singolo numero che rappresenta <strong>un solo byte</strong>.
Da cosa capisco <em>quanti byte posso andare a vedere, a partire da quello puntato?</em>
Potremmo pensare dal tipo: se quello lì è un puntatore a <code>int</code>, supponendo che l’int sia di 4 byte, so che posso andare a guardare da quella cella lì fino alle tre successive, se fosse buono.</p>
<p>Ma se io avessi alloccato un <code>int[]</code> array? Non posso sapere quanti <code>int</code> ci sono in quell’array, quindi non so fino a dove posso leggere lecitamente…
E l’idea di andare a contare finché non trovo lo 0 è un’idea peregrinissima, perché potrebbe non esserci lo 0 e magari finisco a leggere in zone che non sono mie…</p>
<p>Dunque, il tipo non mi dà queste informazioni.
Dire che quello lì è un <code>char*</code> mi dice sì che se vado alla fine di questo puntatore troverò un char, ma quanti char non lo so.</p>
<aside>
💡
<p><strong>From ChatGPT</strong></p>
<p><img src="images/allocazione_della_memoria_3/image%2015.png" alt="image.png" /></p>
</aside>
<h2 id="43-fino-a-quando-è-garantito-laccesso"><a class="header" href="#43-fino-a-quando-è-garantito-laccesso">4.3 Fino a quando è garantito l’accesso?</a></h2>
<p><em>Fino a quando è garantito l’accesso?</em>
Non lo sappiamo.</p>
<p>Se quello lì è un puntatore ad una variabile locale, è garantito fino a che il codice che l’ha allocata non ha raggiunto la graffa finale.
Ma se io ho copiato questo puntatore in una struttura, quando andrò a dare la struttura in giro, non posso sapere se quella variabile lì era già finita di vivere o meno.
<strong>Ho perduto questa informazione.</strong></p>
<h2 id="44-se-ne-può-modificare-il-contenuto"><a class="header" href="#44-se-ne-può-modificare-il-contenuto">4.4 Se ne può modificare il contenuto?</a></h2>
<p>Posso modificare il contenuto?
Non lo sappiamo.</p>
<p>Teoricamente il tipo di puntatore potrebbe aiutarmi.</p>
<p>C e C++ distinguono il <code>const T*</code> dagli <code>T*</code> — <code>char*</code> mi dice <em>“quello è un puntatore a caratteri che puoi modificare”</em>, <code>const char*</code> mi dice <em>“quello è un puntatore a caratteri che non puoi modificare, che devi solo leggere”</em>.</p>
<p>Ma è un po’ debole come cosa, perché io posso castare e far diventare un <code>const char*</code> un <code>char*</code> semplice. E a quel punto non ne so più niente se quella era una cosa che non dovevo toccare...</p>
<h2 id="45-occorre-rilasciarlo"><a class="header" href="#45-occorre-rilasciarlo">4.5 Occorre rilasciarlo?</a></h2>
<p><em>Sono responsabile del suo rilascio?</em>
Non lo sappiamo.</p>
<p>Dipende come è nato quel puntatore.</p>
<p>Se io mi sono procurato quel puntatore dalla variabile <code>l</code> tramite l’operatore <code>&amp;</code>, non sono responsabile, perché la variabile <code>l</code> ha il suo ciclo di vita predefinito, e quando arriverà al fondo del suo blocco verrà buttata via.</p>
<p>Ma se io invece mi sono procurato il puntatore con <code>new</code>, sono responsabile io del suo rilascio.</p>
<p>Peccato che non c’è modo di capirlo.
Sì è vero, abbiamo visto nell’esempio di prima che l’indirizzo di una zona nell’heap è diverso dall’indirizzo di una zona nello stack, ma non posso guardare quella cosa lì, perché ogni volta che lancio il programma lo spazio di indirizzamento è randomizzato e posso avere delle cose a caso.</p>
<p>Quindi non posso basarmi su questa informazione qua.</p>
<p>E i linguaggi C e C++ non mi danno nessun suggerimento per distinguere quello che è un puntatore dello heap, di cui qualcuno si deve occupare di rilasciare, da quello che è un puntatore allo stack, dove è il linguaggio che garantisce il rilascio.</p>
<h2 id="46-lo-si-può-rilasciare-o-altri-conoscono-lo-stesso-indirizzo"><a class="header" href="#46-lo-si-può-rilasciare-o-altri-conoscono-lo-stesso-indirizzo">4.6 Lo si può rilasciare o altri conoscono lo stesso indirizzo?</a></h2>
<p>Supponendo che io possa per qualche via traversa sapere che sono responsabile del rilascio, lo posso rilasciare in questo momento? O c’è una copia di questo stesso puntatore in giro in casa di qualcuno che potrebbe andarci a guardare dentro?
Non lo sappiamo.</p>
<h2 id="47-viene-usato-come-modo-per-esprimere-lopzionalità-del-dato"><a class="header" href="#47-viene-usato-come-modo-per-esprimere-lopzionalità-del-dato">4.7 Viene usato come modo per esprimere l’opzionalità del dato?</a></h2>
<p>È difficile capire se questo puntatore viene usato per fornire un accesso efficiente ai dati oppure per esprimere il concetto di <em>opzionalità</em>.
Per esempio, una funzione che cerca un valore in un array potrebbe restituire un puntatore al valore se lo trova, oppure null se non lo trova.
Non abbiamo modo di saperlo.</p>
<p>Quello lì è un puntatore, non ha al suo interno altro tipo di informazioni per specificare cose di questo tipo.</p>
<p>Quindi il linguaggio, pur dandomi degli strumenti potenzialmente potenti per poter ottimizzare l’accesso, mi lascia però con sette domande a cui non ho risposta.</p>
<p>E se da programmatore devo mettere le mani al codice, quella risposta lì la devo dare io.</p>
<p><em>E come facciamo a darla?</em>
Andando a leggere tutto il codice, non solo un pezzettino, ma tutto.
Perché se di quel puntatore ce n’è una copia sperduta da qualche parte, io non posso farci tante cose.</p>
<p>Il problema è che <em>“tutto quel codice”</em> comprende tutto il codice che scrivo io, tutto il codice che sta nelle librerie, e tutto il codice nascosto da qualche parte che in qualche modo interagisce con il mio.
E se non lo capisco, faccio delle assunzioni che possono essere sbagliate.</p>
<p>E ciò può causare problemi tutte le volte che provo poi a rieseguire il mio programma.
Il problema è che buona parte di questi malfunzionamenti non sono ripetibili, ma nascono da combinazioni astrali, dal fatto che sono successe certe cose, che alcune sono successe più in fretta di altre, e cose simili… <strong>tutte cose che sono fuori dal nostro controllo.</strong></p>
<p>E quindi diventa complicatissimo sviluppare i programmi.</p>
<p>Per questi motivi, i programmi scritti in C e C++ sono un <em>florilegio</em> di bug.</p>
<p><img src="images/allocazione_della_memoria_3/image%2016.png" alt="image.png" /></p>
<p>In C e C++ usiamo i puntatori in tanti modi.</p>
<p>Il più semplice è quello per accedere, qua e ora, ad un dato valore.
Mi serve sostanzialmente per ottimizzare: evito di spostare una grossa struttura dati, e piuttosto ti passo il puntatore alla struttura.</p>
<p>Ti dico “<em>Cara funzione, io te lo passo e tu lo usi adesso, per il tempo della tua chiamata. Ci guardi dentro, ci scrivi se devi scrivere, <strong>ma non te lo copi.</strong> Perché quando tu sarai tornata io non posso più garantirti che questo dato rimanga valido, quindi lo devi usare solo adesso</em>”.</p>
<p>Il problema è che non riesco a trasmettere in codice questa informazione.</p>
<p>Il meglio che posso fare è scriverla in un commento, ma il commento lascia il tempo che trova, perché bisogna che qualcuno lo legga.
Bisogna prima che qualcuno l’abbia scritto, e poi bisogna che qualcuno lo legga e ne faccia uso.</p>
<p>Un puntatore lo posso usare per indicare a una funzione dove dovrà mettermi le sue risposte.</p>
<p>È il caso, ad esempio, della funzione <code>scanf</code>.
Quando in C usiamo <code>scanf</code> per leggere la tastiera, cosa facciamo?
Scriviamo <code>scanf(”%d”, &amp;i)</code>, cioè passiamo il puntatore a una nostra variabile, dentro cui <code>scanf</code>, se trova un intero, ci scriverà il valore che ha letto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2017.png" alt="image.png" /></p>
<p>Qua c’è un esempio, ho una funzione ipotetica <code>read_data1</code>, che usa il valore di ritorno per dirmi se è riuscita o meno a leggere i dati, e quindi mi dà come valore di ritorno un booleano.</p>
<p>Nel caso in cui il booleano sia true, vuol dire <em>“ho letto i dati”</em>, e il dato che legge me lo mette dentro il parametro.</p>
<p>Ovviamente siccome il parametro è passato per copia, io non posso passargli un int, perché quell’int lì, quando la funzione ritorna ve l’avrebbe buttato via.
Io gli devo passare un puntatore, in modo tale che la funzione lo dereferenzia, ci scrive dentro e anche se poi il puntatore viene buttato via, siccome io ho l’originale, dall’originale prendo quello che mi serve.</p>
<p>E quindi, se qualcuno mi ha passato un risultato buono e ho dei dati disponibili, vado a prendermi i dati, li metto dentro il puntatore, <code>*result = get_some_data()</code> , quello che devo metterci. E in questo caso ritorno true.</p>
<p>Se non mi hai passato un puntatore buono, oppure non ho niente da dirti, ti rispondo false e lascio perdere.</p>
<p><img src="images/allocazione_della_memoria_3/image%2018.png" alt="image.png" /></p>
<p>Posso usare un puntatore per accedere a un blocco di dati.</p>
<p>Questo è uno dei grossi casini del C, perché automaticamente quando voi dichiarate un array di n elementi, la vostra dichiarazione <code>int[10]</code>, quell’array lì si dimentica di essere un array <em>lungo 10 elementi</em>: viene <em><strong>demoted</strong></em>, ridotto a puntatore al primo elemento. Fine.</p>
<p>Ma quando io lo passo a qualcun altro, quell’altro che ne sa che lì ce ne sono davvero 10?Potrebbero essere solo 5.</p>
<p>Per questo in C++ c’è un tipo apposito, l’<strong><code>std::array</code></strong>, che ha nella firma del tipo la dimensione e questo permette di capire quanto è grande.</p>
<p><img src="images/allocazione_della_memoria_3/image%2019.png" alt="image.png" /></p>
<p>Posso usare il puntatore per farti accedere a una sequenza di dati più o meno grande, non nota priori, è il caso delle stringhe del C.</p>
<p>Le stringhe del C io ti passo il puntatore all’inizio e chi ha bisogno da quel puntatore va avanti a cercare quello che gli serve, fino a quando non incontra lo <code>/0</code>.</p>
<p>Tecnica pericolosissima, perché è una di quelle più facilmente hackerabile.</p>
<p><img src="images/allocazione_della_memoria_3/image%2020.png" alt="image.png" /></p>
<p>Posso usare i puntatori per accedere a dati dinamici, ed è tutto quello che facciamo normalmente quando ci serve allocare delle mappe, delle liste, delle cose la cui dimensione non è nota a priori.</p>
<p>Il problema è che in questa situazione c’è sicuramente la responsabilità del rilascio: in C++ se ho ottenuto il dato con una <code>new</code>, qualcuno lo dovrà rilasciare con la <code>delete</code>, oppure se in C l’ho ottenuto con la <code>malloc</code>, qualcuno lo dovrà rilasciare con la <code>free</code>.</p>
<p>Di nuovo il C++ mi facilita perché mi mette a disposizione delle classi già fatte che si occupano nel loro costruttore di prendere i pezzi di cui hanno bisogno e nel loro distruttore di buttare via tutto quello che avevano preso.</p>
<p>Rendendo quindi la vita del programmatore un pochino più sicura, ma solo un po’.</p>
<p>E poi posso usare il puntatore come modo per esprimere l’opzionalità di un risultato, ovvero ti ritorno null se non ho trovato niente, o ti ritorno un puntatore valido se ho trovato qualcosa.
<strong>Ma non è chiaro se quel puntatore valido va rilasciato o meno.</strong></p>
<p><img src="images/allocazione_della_memoria_3/image%2021.png" alt="image.png" /></p>
<p>Oppure posso usare il puntatore per fare delle strutture articolate come le liste, le mappe, etc...</p>
<p><img src="images/allocazione_della_memoria_3/image%2022.png" alt="image.png" /></p>
<p>Quindi, lavorando in C non c’è salvezza.
Tutte quelle sette domande elencate prima non hanno nessuna risposta.
È il programmatore che deve trovarsela.</p>
<p>C++ mi aiuta un po’ di più.
Mi aiuta un po’ di più perché mi dà un supporto sintattico attraverso dei tipi più elaborati, mediante i quali <em>alcune cose</em> mi vengono gestite.</p>
<p>Ad esempio, per i puntatori dinamici mi dice “<em>guarda, io ti do una cosa che si chiama <strong>Smart Pointer</strong>, che è fatta in modo tale per cui tu la crei e automaticamente quando questa cessa di essere visibile distrugge il dato a cui punta</em>”.</p>
<p>Anzi te ne do due.
Uno che si chiama <em><strong>Unique Pointer</strong></em>, che non può essere copiato.
Un altro che si chiama <em><strong>Shared Pointer</strong></em>, che può essere copiato.</p>
<p>Quello che può essere copiato conta quante copie ci sono e quando l’ultima copia muore, rilascia il dato, così non c’è rischio di perdere l’informazione.</p>
<p>Lo Unique Pointer invece è molto più agile, ma non può essere copiato.
Se cerchi di copiarlo ti dice <em>“no, al massimo lo <strong>cedi</strong>”</em>: il C++ introduce un concetto che si chiama <em><strong>movimento</strong></em>.</p>
<p><em>Cosa vuol dire “Lo cedi”?</em>
Beh: lo dai a lui, però poi non è più tuo.</p>
<p><img src="images/allocazione_della_memoria_3/image%2023.png" alt="image.png" /></p>
<p>Il programmatore ha tutta una serie di responsabilità.</p>
<ul>
<li>Deve limitare gli accessi a un blocco <strong>nello spazio</strong>, cioè non devo andare oltre la zona a cui quel puntatore lecitamente può arrivare, e neanche prima, e <strong>nel tempo</strong>, cioè devo accederci solo quando quel dato lì effettivamente esiste.</li>
<li>Non devo assegnare ai puntatori valori che corrispondono agli accessi non mappati.
Se io dichiaro una variabile locale di tipo <code>int*</code> e non la inizializzo, non è che dentro non c’è scritto niente, c’è scritto una schifezza qualunque che era presente sullo stack quando lo stack è stato abbassato. Magari c’è scritto <code>0</code>, se sono fortunato. Magari c’è scritto <code>3b7f5962</code>. Ma non è un vero indirizzo, è semplicemente che sono dei byte a caso che c’erano scritti lì, e se io provo e vado ad accedere, chissà che succede.</li>
<li>Devo rilasciare tutta la memoria dinamica allocata una e una sola volta, usando la funzione duale di quella che è servita per l’allocazione. Perché se io ho allocato con <code>new</code> non posso rilasciare con <code>free</code>. Perché <code>free</code> ha delle strutture dati diverse da quelle di <code>new</code>.</li>
</ul>
<h1 id="5-rischi"><a class="header" href="#5-rischi">5. Rischi</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2024.png" alt="image.png" /></p>
<p><em>Cosa succede se faccio casino?</em></p>
<ul>
<li>Allora, se accedo a un indirizzo, quando il corrispondente ciclo di vita del valore a cui quell’indirizzo punta è terminato, andiamo incontro ad effetti impredicibili.
Quella situazione lì si chiama <em><strong>dangling pointer</strong></em>.</li>
<li>Se io non rilascio tutta la memoria che ho allocato, faccio un <em><strong>memory leakage</strong></em>.
Memory leakage è uno spreco in primis, ed è un problema in secondis.
Nel momento in cui il mio programma vive abbastanza a lungo, specialmente se sto creando un server. Perché sul server se a ogni richiesta io mi perdo una manciata di byte, dopo un po’ di richieste non ho più.</li>
<li>Rilasciare la memoria più volte corrompe le strutture dell’heap ed è l’origine del problema del <em><strong>Double Free</strong></em>.</li>
</ul>
<aside>
💡
<p>Agli inizi della storia di Microsoft, Windows NT, aveva un mucchio di leakage e ti dicevano <em>“Sai che c’è? Ogni notte lo spegni, e poi lo riaccendi”</em>.
Ma se hai una server farm con 500 macchine, non è molto comodo ricordare di spegnerle tutte e riaccenderle, e inoltre nel tempo in cui Windows NT fa il bootstrap (e ci metteva un bel po’ a farlo) sei completamente out of service.</p>
<p><em>E perché si doveva fare?</em>
Perché aveva così tanto leakage che se lo facevi girare più di 24 ore lui esauriva tutta la memoria.</p>
<p>Windows NT era comunque un sistema operativo fatto da zero e quindi ci sta che fosse complicato a realizzarlo, però era un problema reale che ha causato danni seri alle aziende che lo usavano, e a Microsoft stessa.</p>
</aside>
<p><img src="images/allocazione_della_memoria_3/image%2025.png" alt="image.png" /></p>
<p>Se assegno a un puntatore un indirizzo non mappato, o non gli assegno niente e quindi mi tengo un dato a caso che c’è dentro, diventa un <em><strong>wild pointer</strong></em>: non so minimamente cosa possa essere.</p>
<h2 id="51-esempi"><a class="header" href="#51-esempi">5.1 Esempi</a></h2>
<h3 id="511-dangling-pointer"><a class="header" href="#511-dangling-pointer">5.1.1 Dangling Pointer</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2026.png" alt="image.png" /></p>
<p>Ho questo blocco, non ha importanza se è parte di una funzione o di una cosa più o meno complicata. Nello stack c’è già qualcosa, non mi interessa.</p>
<p><img src="images/allocazione_della_memoria_3/image%2027.png" alt="image.png" /></p>
<p>Arrivo a eseguire questa istruzione <code>char* ptr = null</code>: lo stack cresce di 8 byte (nel caso di sistema a 64 bit), devo farci stare un puntatore.</p>
<p>Cosa ci metto in questi 8 byte? NULL, ossia 0x0, perfetto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2028.png" alt="image.png" /></p>
<p>Aperta graffa vuol dire che inizia un nuovo <strong>scope sintattico</strong>: le variabili locali dichiarate qua dentro esisteranno fino alla chiusa graffa corrispondente.</p>
<p>Dopo l’aperta graffa c’è <code>char ch = '!'</code>: lo stack si abbassa di 1 byte e in quel byte ci scrivo il codice esadecimale 21, che è il punto esclamativo.
E subito dopo dico <em>“inizializza quel puntatore di prima che valeva</em> <code>NULL</code> <em>con l’indirizzo di</em> <code>ch</code><em>”</em>.</p>
<p>Vado a vedere quanto vale lo stack pointer che c’è in questo momento (che in pratica è l’indirizzo a cui troviamo il valore di ch), e lo scrivo là dentro.</p>
<p>Quindi il mio puntatore viene sostituito con l’indirizzo giusto di <code>ch</code>.</p>
<p><img src="images/allocazione_della_memoria_3/image%2029.png" alt="image.png" /></p>
<p>Chiusa graffa lo stack pointer sale di 1 byte.
Il puntatore che c’era scritto lì continua a puntare dove non doveva!</p>
<p><img src="images/allocazione_della_memoria_3/image%2030.png" alt="image.png" /></p>
<p>A questo punto provo a chiamare <code>printf</code>.</p>
<p>Cosa fa la chiamata printf?
Eh, pusha sullo stack: comincia a metterci lo spazio per il valore di ritorno, l’indirizzo a cui chiamare <code>printf</code>, i suoi parametri etc...</p>
<p>Il mio puntatore a questo punto punta delle cose strampalate. Cerco di stampare e non so minimamente che cosa ottengo.</p>
<h3 id="512-memory-leakage"><a class="header" href="#512-memory-leakage">5.1.2 Memory Leakage</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2031.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2032.png" alt="image.png" /></p>
<p>Entro nel mio blocco, dichiaro un puntatore come prima, lo stack cresce di 8 byte, per fare spazio a questo puntatore nullo.</p>
<p><img src="images/allocazione_della_memoria_3/image%2033.png" alt="image.png" /></p>
<p>Alloco un blocco, nello heap da qualche parte cerco un pezzo grande quanto gli ho chiesto, 10 byte. Lo trovo e il mio puntatore punta dove deve.</p>
<p>Nel frattempo la struttura di malloc in questo caso si organizza e si segna che quel segmentino lì adesso è in uso e quindi si segna che deve saltarne un pezzo perché quella memoria non può essere usata in quanto l’ha data in prestito a chi gliel’ha chiesta.</p>
<p><img src="images/allocazione_della_memoria_3/image%2034.png" alt="image.png" /></p>
<p>Dentro quella stringa ci scrivo quello che voglio, non ha importanza, la uso come mi pare.</p>
<p><img src="images/allocazione_della_memoria_3/image%2035.png" alt="image.png" /></p>
<p>La stampo, va tutto bene.</p>
<p><img src="images/allocazione_della_memoria_3/image%2036.png" alt="image.png" /></p>
<p>E ritorno.</p>
<p>A questo punto il mio puntatore viene egettato, non lo posso più restituire perché dove stava questa stringa non lo so più, è perduto per sempre.</p>
<p>La <code>malloc</code> è fatta apposta per dare della memoria che potrebbe essere usata per un po’ di tempo e quindi dice <em>“vabbè, non me l’ha restituita adesso, me la darà dopo..”</em>, ma noi “dopo” non possiamo più dargliela perché non si sa più dov’è.</p>
<p>Abbiamo fatto del memory leakage.</p>
<h3 id="513-double-free"><a class="header" href="#513-double-free">5.1.3 Double free</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2037.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2038.png" alt="image.png" /></p>
<p>Alloco un primo puntatore, ne alloco un secondo che metto uguale al primo.
Adesso ne ho due che puntano lì.</p>
<p>Di per sé non è una tragedia averne due che puntano lì, posso avere dei motivi validi per farlo: pensate a una double linked list, in cui ciascun blocco è puntato dall’elemento precedente e dall’elemento successivo.</p>
<p>Quindi non è un problema di per sé il fatto che ci sono due puntatori.
Il problema è che devo rilasciare una volta sola.</p>
<p><img src="images/allocazione_della_memoria_3/image%2039.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2040.png" alt="image.png" /></p>
<p>Qui cosa succede?</p>
<p>Uso questa struttura in qualche modo, chiamo la <code>free</code> su uno dei due (non importa quale) e a questo punto le strutture di <code>malloc</code> prendono il possesso di nuovo di quel blocchettino che avevano segnato prima essere in uso e fin qui va tutto bene.</p>
<p><img src="images/allocazione_della_memoria_3/image%2041.png" alt="image.png" /></p>
<p>Poi faccio la seconda free e a questo punto non capisce più niente, si spacca.</p>
<h1 id="6-gestire-i-puntatori"><a class="header" href="#6-gestire-i-puntatori">6. Gestire i puntatori</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2042.png" alt="image.png" /></p>
<p>Chi alloca un puntatore è responsabile quindi di mettere in atto un meccanismo che mi garantisca il suo <strong>rilascio</strong>.</p>
<p>Colui che è responsabile del rilascio del blocco viene chiamato <em><strong>il possessore</strong></em>.
<strong>Possedere un blocco vuol dire essere responsabile del rilascio.</strong></p>
<p>Il possesso non è un diritto, è un dovere.
Certo, ti dà diritto ad accedere al blocco. Ma ti dà anche <strong>il dovere di rilasciarlo.</strong></p>
<p>Se io questo puntatore che possiede il blocco lo duplico, e quindi a questo punto ho due puntatori che conoscono il blocco, chi è il possessore dei due? Boh.</p>
<p>I linguaggi come Java, i linguaggi <em>managed</em>, dicono che il possesso è <em>equidistribuito</em>: fin tanto che c’è almeno uno che conosce quel blocco, il blocco non è rilasciabile.
Quando non ci sarà più nessuno che conosce quel blocco, il blocco è rilasciabile perché non è più posseduto.
Piccolo problema: non viene rilasciato subito, è solo segnato come rilasciabile.</p>
<p>Quella memoria diventerà utilizzabile al primo ciclo di garbage collection, che potrebbe avvenire tra un bel po’ e questo potrebbe essere un problema perché io a forza di prendere pezzi di memoria potrei trovarmi in difficoltà.</p>
<p>Quindi in qualche modo se io copio un puntatore che possiede l’indirizzo, cioè è responsabile del rilascio di quella cosa lì, il secondo puntatore si trova malgrado a diventare possessore anche lui, partecipa al ciclo di vita e questo ci fa casino, rende ad esempio scrivere l’algoritmo della linked list non così banale: chi è che rilascia? I puntatori in avanti o i puntatori all’indietro?</p>
<p>Quindi bisogna introdurre un meccanismo che gestisca efficacemente la semantica del puntatore e per questo motivo in Rust i puntatori sono svariati: ci sono i puntatori che posseggono e i puntatori che non posseggono, i puntatori che possono scrivere e i puntatori che possono leggere.</p>
<p><strong>Rendiamo esplicito nel tipo che cosa puoi fare</strong>, e qui il compilatore ti aiuta perché usa le informazioni che noi gli diamo per verificare che lo usiamo in modo giusto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2043.png" alt="image.png" /></p>
<p>Il vincolo di rilascio è particolarmente problematico per via dell’ambiguità dei puntatori.</p>
<p>In C e in C++ non ho niente che mi distingue un puntatore con possesso da un puntatore senza possesso. Si chiamano tutti <code>int*</code>.</p>
<p>Il fatto che uno possegga e l’altro no è solo nella testa del programmatore.</p>
<p>L’ho ottenuto da una variabile locale o una variabile globale che già esisteva, di cui non sono responsabile del rilascio perché lo è il compilatore → non posseggo.
L’ho ottenuto con new o con malloc → posseggo.</p>
<p>Solo che quando sto puntatore passa di mano, chi lo sa più come è nato.
Il tipo non mi dice niente.</p>
<p>Quindi chi è possessore ha la responsabilità di liberarlo.</p>
<p>C++ fa un passo avanti: dice <em>“guarda io ho i puntatori standard come quelli del C, poi ho gli smart pointer”</em>.
Gli smart pointer posseggono. Anzi alcuni smart pointer posseggono, perché ce ne è anche un terzo tipo che si chiama <strong><code>Weak</code></strong> che non possiede: partecipa al ciclo di vita senza possedere.</p>
<p><img src="images/allocazione_della_memoria_3/image%2044.png" alt="image.png" /></p>
<p>Non tutti i puntatori posseggono il blocco a cui puntano.
Se ad un puntatore viene assegnato l’indirizzo di un’altra variabile, la proprietà di quella memoria è della libreria di esecuzione.</p>
<p>Quindi quando dico <code>int* ptr = &amp;i</code>, la proprietà è di <code>i</code>.</p>
<p><code>i</code> è una variabile che è allocata, è stata allocata dal compilatore e viene rilasciata al compilatore.</p>
<p>Il puntatore è solo un alias.
Può guardarla ma non deve partecipare diversamente.</p>
<p>Tutto si complica se un puntatore che possiede il proprio blocco viene copiato.</p>
<p>Quale delle due copie è responsabile del rilascio?
Tendenzialmente l’ultima. Ma che ne so io qual è l’ultima?</p>
<p><img src="images/allocazione_della_memoria_3/image%2045.png" alt="image.png" /></p>
<p>Nel momento in cui io creo delle strutture dati complesse, come una linked list, come una mappa, come un oggetto più sofisticato, spesso ho bisogno di crearmi qualcosa che punta a qualcos’altro che punta qualcos’altro per poter gestire la semantica di questa faccenda qua.</p>
<p>Ad esempio gli oggetti vector (sono quelli che in Java si chiamano array lists), hanno dentro di sé un puntatore a un blocco dinamico.</p>
<p>Inizialmente piccolo, poi se voi ci mettete dentro delle cose, se per un po’ vengono aggiunti, quando non ci stanno più, quel blocco dinamico viene riallocato grosso il doppio, i vecchi elementi vengono copiati nel blocco nuovo, il blocco vecchio viene rilasciato e faccio spazio per aggiungere cose e quindi piano piano posso ospitare tanti elementi.</p>
<p>Nel momento in cui quel vector viene distrutto, raggiunge la fine del suo ciclo di vita, deve ricordarsi di buttare via tutto.</p>
<p>In qualche modo questo blocco è una dipendenza del vector, quindi la struttura vector ha dentro di sé delle appendici come fosse un grappolo d’uva che dal tralcio si dipana con tanti pezzettini e quando quella cosa lì viene distrutta deve prendersi la briga di buttare via tutti i suoi pezzettini in modo congruo.</p>
<p>Non ci sono solo le dipendenze legate alla memoria, possono esserci dipendenze legate ad altri risorse del sistema operativo.</p>
<p>Se io ho un oggetto che ha aperto un file, quando questo oggetto finisce di vivere quel file deve garantirmi che è chiuso, altrimenti il sistema operativo penserà che quel file lì sia ancora in uso.
Se io ho creato un socket per ricevere dalla rete, analogamente il socket lo devo chiudere.
Se ho creato un thread devo garantire che questo thread abbia finito di vivere e così via.</p>
<p>Quindi questo insieme di cose, di risorse ulteriori, la memoria, i file, i socket, altri pezzi del sistema operativo, che hanno un ciclo di vita che deve essere riportato al ciclo di vita dell’oggetto, prendono il nome di <em><strong>dipendenze</strong></em>.</p>
<p><img src="images/allocazione_della_memoria_3/image%2046.png" alt="image.png" /></p>
<p>C non dà nessun supporto per la gestione delle dipendenze.</p>
<p>C++ ci mette a disposizione il concetto di costruttore e distruttore.
Nel costruttore inizializzo le mie dipendenze, nel distruttore mi libero delle mie dipendenze.</p>
<p><img src="images/allocazione_della_memoria_3/image%2047.png" alt="image.png" /></p>
<p>Innanzitutto, raramente i programmi sono scritti da una persona sola.
Ognuno di tanti che scrive lo fa con le sue convenzioni, con i suoi assunti, con un proprio schema mentale.</p>
<p>Non è detto che i suoi compagni o colleghi li conoscano, non è detto manco che si conoscano reciprocamente, perché io sono subentrato in un’azienda dove ho trovato del software che ha scritto qualcun altro che se ne è già andato da tempo.</p>
<p>Al crescere delle dimensioni del programma la quantità di particolari a cui bisogna badare esplode.</p>
<p>Finché voi avete un puntatore vi prendete la briga di seguirlo, ma quando avete un milione di puntatori che hanno storie diverse, non li seguite manco per idea.</p>
<p>Il 70% delle vulnerabilità elevate all’interno di Windows sono dovute a problemi di gestione della memoria. Non è che Microsoft assume gli imbecilli, ma nonostante ci siano dei professionisti, la possibilità di sbagliare è altissima.</p>
<p><img src="images/allocazione_della_memoria_3/image%2048.png" alt="image.png" /></p>
<p>Nella maggior parte dei linguaggi di alto livello il problema non si pone.</p>
<p>Perché non siete mai stati abbastanza stressati con tutte queste cose?
Eh perché fin tanto che scrivete in Python va tutto bene.</p>
<p>Piccolo problema.
È vero che questi hanno dentro di sé il concetto di puntatore, ma non vi lasciano controllare quando quella memoria viene veramente rilasciata.</p>
<p>E quindi certe cose in Python, in C#, in Java non le potete fare.</p>
<p>In questo corso vogliamo occuparci di quella zona in cui con quei linguaggi lì non si può lavorare, perché abbiamo bisogno di stare più vicini all’hardware.</p>
<p>Il fatto che ci sia il garbage collector libera completamente il programmatore dalla responsabilità del rilascio, ma in compenso ci fa perdere il controllo sul quando e come il rilascio avvenga.</p>
<p>E quindi in generale c’è un bisogno di risorse molto più grande.</p>
<p>La maggior parte di questi linguaggi usa gli algoritmi di <em><strong>Mark and Sweep</strong></em>, che sono quelli che fondamentalmente permettono di identificare quali zone sono ancora referenziate, vengono marcate, e tutto ciò che non viene marcato viene <em>Sweeped</em>, scopato via, tolto insieme alla polvere.</p>
<p>Sono algoritmi belli, interessanti, però sono anche estremamente dispendiosi.
Quando parte la garbage collection il programma si deve arrestare.</p>
<p><img src="images/allocazione_della_memoria_3/image%2049.png" alt="image.png" /></p>
<p>Cosa succede tra C/C++, linguaggi che ci danno controllo a basso livello, e Java, piuttosto che C#, piuttosto che Python.</p>
<p>Allora in C++ noi abbiamo un controllo manuale del rilascio. Dobbiamo ricordarci noi di chiamare <code>delete</code> o <code>free</code> o quello che sia.</p>
<p>Di là ce ne freghiamo attentamente, lo fa il garbage collector.</p>
<p>Il problema è che in C/C++ noi possiamo controllare quando rilasciare.
Di là, siccome lo fa il garbage collector, la memoria è rilasciata al piacere del garbage collector.</p>
<p>In C++ gli oggetti dispongono di un distruttore, che permette di gestire le dipendenze, di fare il rilascio esplicito delle dipendenze.</p>
<p>In tutti gli altri linguaggi, tranne Java, che ha un finalizer, che però ora è stato deprecato, non c’è il concetto di distruttore.
Non ce n’è bisogno.</p>
<p>In C/C++ il rilascio non comporta dei tempi supplementari di attesa.
Non devo fare una ricerca, perché io ho già la mia ricetta nel distruttore che mi dice cosa devo fare.
Di là, in realtà, il rilascio comporta delle pause, pause che possono essere molto lunghe e che in contesto di realtà sono semplicemente inaccettabili.
Però in C e in C++ possono verificarsi doppi rilasci, memory leakage, dangling pointer, wild pointer e tutte queste serie di cose che abbiamo visto prima.
Di là no. Motivo per cui, per i programmi applicativi, la strada è quella là.
Per i programmi di sistema, la strada passa di qua.</p>
<p><img src="images/allocazione_della_memoria_3/image%2050.png" alt="image.png" /></p>
<p><em>Come sopravviviamo?</em></p>
<p>Certamente usando dei programmi che ci aiutano a diagnosticare l’uso della memoria nei processi, come Valgrind, se siamo in Linux, Dr.Memory se siamo su Windows.</p>
<p>Certamente usando dei tipi più sofisticati, invece che <code>int*</code>, o cose del genere, cioè il puntatore nativo del C++, le versioni moderne di C++ ci offrono una serie di classi che ci facilitano la vita.</p>
<p>I vari tipi di smart pointer, le tuple, gli iteratori, gli span, gli optional e così via, sono tutti tipi più sofisticati che evitano di dover usare i puntatori, pur dandoci delle strutture che sintatticamente sembrano puntatori e che quindi hanno tante caratteristiche che gli assomigliano, ma sono tracciate per la loro semantica.</p>
<p>Terza strada, ed è quella che seguiremo nel corso, usiamo dei linguaggi che sono intrinsecamente Memory Safe: Rust.</p>
<p><img src="images/allocazione_della_memoria_3/image%2051.png" alt="image.png" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="02-allocazione_della_memoria_parte_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="04-introduzione_al_linguaggio.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="02-allocazione_della_memoria_parte_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="04-introduzione_al_linguaggio.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
