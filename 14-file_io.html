<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>File I/O</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="file-e-io---malnati-19"><a class="header" href="#file-e-io---malnati-19">File e I/O - Malnati 19 <!-- omit in toc --></a></h1>
<h1 id="indice"><a class="header" href="#indice">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="#1-introduzione">1. Introduzione</a></li>
<li><a href="#2-percorsi--path-e-pathbuf">2. Percorsi — <code>Path</code> e <code>PathBuf</code></a></li>
<li><a href="#3-navigare-il-file-system">3. Navigare il file system</a></li>
<li><a href="#4-manipolare-i-file-nel-file-system">4. Manipolare i file nel file system</a></li>
<li><a href="#5-i-tratti-relativi-a-io">5. I tratti relativi a I/O</a>
<ul>
<li><a href="#51-il-tratto-read">5.1 Il tratto <code>Read</code></a></li>
<li><a href="#52-il-tratto-bufread">5.2 Il tratto BufRead</a>
<ul>
<li><a href="#521-esempio">5.2.1 Esempio</a></li>
</ul>
</li>
<li><a href="#53-il-metodo-write">5.3 Il metodo <code>Write</code></a></li>
<li><a href="#54-il-tratto-seek">5.4 Il tratto <code>Seek</code></a></li>
</ul>
</li>
<li><a href="#6-il-framework-serde">6. Il framework <code>Serde</code></a></li>
</ul>
<h1 id="1-introduzione"><a class="header" href="#1-introduzione">1. Introduzione</a></h1>
<p>Spessissimo le nostre applicazioni hanno l'<strong>esigenza di mantenere nel tempo</strong> delle informazioni.</p>
<p>Il modo base con cui i sistemi operativi offrono l'approccio alla persistenza è tramite il <strong>concetto di file</strong> e <strong>Rust</strong>, di conseguenza, attraverso la sua libreria standard, ci offre meccanismi per poter accedere ai file system.</p>
<p>Sapendo che i file system, pur concettualmente essendo presenti in <em>tutti i sistemi operativi</em>, sono praticamente diversi nelle loro varie installazioni.</p>
<p>Per cui, ad esempio, nel mondo <strong>Windows</strong> esistono molteplici file system che convivono parallelamente, per cui voi avete per ciascun volume in realtà una cartella radice che rappresenta quel disco, quindi i due punti, i due punti, ecc. — Sono in qualche modo separati.</p>
<p>Nel mondo <strong>Unix</strong>, viceversa, l'intero file system viene ricondotto a un'unica radice su cui eventualmente sono montati all'interno di particolari cartelle degli altri volumi, che però diventano parte di un'unica gerarchia.</p>
<p>Le notazioni usate nei file system sono simili ma diverse, banalmente i separatori di cartella nel mondo Unix sono basati sullo <code>/</code> (slash), in avanti nel mondo Windows sono basati sul <code>\</code> (backslash).</p>
<p>La natura dei nomi dei file nel tempo ha avuto delle manifestazioni.</p>
<p>Questi sono gli elementi <em>macroscopici</em> del file system, poi ci sono tutta una serie di dettagli ulteriori.</p>
<p>I singoli file all'interno del file system dispongono di <strong>metadati</strong>.</p>
<p>Esiste un <strong>owner</strong> di quel file lì, cioè quell'utente che è possessore del file stesso e che può avere, in quanto owner, certi <em>diritti di lettura, di scrittura, di esecuzione.</em></p>
<p>Nel mondo Unix si aggiunge il concetto di <em><strong>gruppo</strong></em>.
Quell'unico file lì appartiene anche a un certo gruppo, e di conseguenza tutti gli utenti che fanno parte del medesimo gruppo possono avere permessi dettagliati.</p>
<p>Poi ci sono tutti gli utenti che non sono né owner, né quelli che appartengono al gruppo di cui è dichiarato appartenere il file. Questi sono genericamente gli <em><strong>others</strong></em>, che hanno ulteriori caratteristiche.</p>
<p><em>Nel mondo Windows questa distinzione è molto più complessa, perché?</em>
Sebbene ci sia ancora l’owner, i privilegi di accesso ai file sono molto più complessi in quanto io posso aggiungere regole ad hoc che dicono <em>"Questo file lo vedono tutti tranne tizio"</em> oppure tranne quelli che hanno <em>certe caratteristiche</em>.
Quindi andando a dare delle espressioni molto più articolate rispetto a quelle del sistema Unix e Unix-like.</p>
<p>Poi ci sono i <em>finti file</em>, ovvero delle cose che <em>appaiono</em> come elementi del file system, ma in realtà non sono dei veri file che risiedono sul disco, ma vengono fatti apparire come tali.
Ad esempio se avete una mattina Linux avete una cartella che si chiama <code>/proc</code>. Le cartelle presenti all'interno di <code>/proc</code> non sono veri file. I loro nomi sono numeri e corrispondono agli id dei processi in questo momento in funzione.</p>
<p>Per cui <code>/proc/3274</code> contiene degli altri finti file che danno informazioni ulteriori circa quello che sta facendo il processo 3274. Quindi ci trovate la mappa ad esempio della sua memoria, ci trovate i consumi che vengono fatti della CPU, tutta una serie di informazioni...
Se andiamo a guardare dentro il disco non c'è quella cartella, nel momento in cui il processo 3274 finisce, quella cartella svanisce.</p>
<p>Ci sono poi i file speciali. Di nuovo, il mondo Unix è pieno di queste cose qua:</p>
<ul>
<li>Alcuni file sono quelli presenti nella cartella <code>/dev</code>, ad esempio <code>/dev/tty</code> per esempio sembra un file ma in realtà mappa sulla porta seriale 1. Fisicamente se voi scrivete dei byte lì sopra e collegaste un dispositivo alla porta seriale vedreste i bit che salgono e scendono in concomitanza delle vostre scritture. Al contrario se cercate di leggere da quel file, leggete solo se qualcuno sta mandando dei byte a quella porta seriale altrimenti non ci leggete niente</li>
<li>Poi ci sono i symbolic link, ovvero io posso dire che c'è nella cartella <code>alfa/beta</code> il file <code>gamma</code> che in realtà non è lui ma è un symbolic link al file che sta nella cartella <code>omega/zeta</code> e quindi tutte le volte che apro <code>alfa/beta/gamma</code> in realtà sto aprendo <code>omega/zeta</code>, questo però permette in certe situazioni di far sembrare una cosa che in realtà è un'altra</li>
</ul>
<p>Questo ci dà l'idea che il concetto di file system e l'accesso alla persistenza è qualcosa di molto più elaborato di quanto normalmente possiamo pensare.</p>
<p><em>Allora, Rust come ci dà accesso a queste cose qua?</em></p>
<p><img src="images/file_io/Untitled.png" alt="Untitled" /></p>
<p>Di base l'idea di file è una pura astrazione che i sistemi operativi ci mettono a disposizione dicendo <em>"Io posso associare a un nome, più o meno articolato, un insieme di byte".</em></p>
<p><em>Questo insieme di byte non rimane fisso nel tempo: ti fornisco degli strumenti per modificarlo in vari modi — sostituendolo completamente, aggiungendo contenuto alla fine, o modificando parti specifiche al suo interno.</em> E ti permetto anche di leggere questo insieme di byte</p>
<p>Quindi il file system sostanzialmente ci dà l'astrazione per poter, dato un nome articolato (lo chiamiamo path) che ci permette di riconoscere la sua posizione, accedere a questo blocco di byte che può avere una dimensione arbitraria molto più grande della massima quantità di spazio allocabile all'interno del processo — ciò che caratterizza i file è che tendenzialmente sono strutturati per poter contenere una quantità grande di informazione, che vuol dire che spesso e volentieri il nostro accesso al file avviene in una modalità di <em><strong>streaming,</strong></em> ovvero ne leggiamo un pezzo per volta e piano piano ne elaboriamo il contenuto.</p>
<p>Concettualmente i sistemi operativi ci permettono di raggruppare i file in cartelle e alle cartelle danno un meccanismo di accesso per cui io posso creare dei cammini per accedere a tali files, con alcune convenzioni che sono abbastanza standard.</p>
<p>Ad ogni file sono associati i vincoli di sicurezza che dicono <em>“Non tutti gli utenti della macchina possono accedere a questo file ma solo alcuni”</em> — <em>come?</em> I dettagli qua differiscono molto..</p>
<p>Tendenzialmente l'accesso al file system è uno di quelle zone che per prima ha avuto, nei vari linguaggi di programmazione, un meccanismo standardizzato multi piattaforma, per cui se voi in C dovete aprire un file usate la funzione <code>fopen</code> , se voi lo dovete fare in Java create un oggetto di tipo <code>FileInputStream</code> se lo leggete o <code>FileOutputStream</code> se lo volete scrivere e così via..</p>
<p>Ogni linguaggio ha trovato delle astrazioni che sono ragionevolmente indipendenti della piattaforma.
Anche Rust l’ha fatto e ci ha messo a disposizione sostanzialmente tutto un create che è <code>std::fs</code>.</p>
<p>All’interno di <code>std::fs</code> ci sono alcune astrazioni principali: una delle principali astrazioni che troviamo è l'astrazione che si chiama <strong><code>std::fs::File</code></strong> , che modella il concetto di file presente sul disco nel suo accesso sia in lettura che in scrittura.</p>
<p>Notate che mentre il singolo file è una cosa che standard lo è stata fin dall'inizio, il concetto di cartella e di accesso alla cartella <em>manco per idea.</em>
Nel caso del C non c'è un bel niente: <em>come faccio a sapere quali file sono presenti in una cartella?</em>
Il C non mi da nessuna funzione sua standard della libreria per poterlo sapere, perché in Windows io devo cominciare a fare <code>FindFirstFile</code> e poi <code>FindFirstNext</code> tante altre volte finché non mi dice non ce ne sono altri, in Unix ho un altra api e così via… quindi i singoli stream operativi hanno delle funzioni che permettono di enumerare i file ma queste nel caso del C non sono state portate nella libreria standard.</p>
<p>Nel caso del C++ sono entrati nella libreria standard a partire dalla versione 17, quindi pochi anni fa. Viceversa, altrove fortunatamente, in Java ad esempio la classe <code>File</code> del package <code>java.utils</code> fin dalla versione 1.0 di Java aveva permesso di lavorare decentemente con le cartelle, per cui in Java la classe <code>java.utils.File</code> non modella i dati del file, ma modella l'entità file col suo nome e ci offre metodi come <strong><code>exists</code></strong> (per sapere se a quel nome ha associato o meno un file), ci offre il metodo <strong><code>erase</code></strong> (che ci consente di cancellarlo), ci permette di usare il metodo <strong><code>mkdir</code></strong> (che ci consente, se quel file non esiste già, di creare una cartella nella posizione indicata dal file con quel particolare nome) e così via..</p>
<p>Nel caso di di Rust noi abbiamo tutta una serie di classi che fanno parte di <strong><code>std::fs</code></strong> che ci aiutano.</p>
<h1 id="2-percorsi--path-e-pathbuf"><a class="header" href="#2-percorsi--path-e-pathbuf">2. Percorsi — <code>Path</code> e <code>PathBuf</code></a></h1>
<p><img src="images/file_io/Untitled%201.png" alt="Untitled" /></p>
<p>Siccome Rust pone tanta attenzione sulla <strong>indipendenza dalla piattaforma</strong> introduce un paio di classi che si chiamano <strong><code>Path</code></strong> e <strong><code>PathBuf</code></strong> che sono sostanzialmente analoghi per tante caratteristiche a <code>&amp;str</code> (uno slice di caratteri) e un oggetto <code>String</code>.
L'oggetto <code>Path</code> rappresenta un cammino all'interno del file system che è accessibile in sola lettura, perché non lo possediamo.
Viceversa l'oggetto <code>PathBuf</code>, come <code>String</code>, rappresenta un cammino di cui abbiamo il possesso come contenuto e quindi lo possiamo modificare.</p>
<p><em>Perché allora non sono stati usati</em> <code>&amp;str</code> <em>e</em> <code>String</code><em>?</em>
Sostanzialmente perché rispetto ad una stringa, che ha certe caratteristiche (una stringa ci offre i metodi tipo l’ <code>.upperCase</code> che sono molto generali e adatti a trattare il testo in quanto tale), gli oggetti di tipo <strong><code>Path</code></strong> e <strong><code>PathBuf</code></strong> ci offrono invece dei metodi che sono funzionali a navigare nelle cartelle.</p>
<p>Quindi:</p>
<ul>
<li><strong><code>Path</code></strong>, analogamente a <code>&amp;str</code>, è un oggetto <em><strong>unsized:</strong></em> quindi di cui noi possediamo uno slice sostanzialmente e lo possiamo vedere solo in lettura</li>
<li><strong><code>PathBuf</code></strong> invece possediamo il contenuto e lo possiamo in qualche modo modificare.</li>
</ul>
<p>Un oggetto di tipo file si distingue da una stringa anche per il fatto che noi concateniamo elementi in modo differente in base al sistema operativo: cioè col back slash piuttosto che col forward slash.</p>
<p>All'interno sono conservati una serie di metadati che di nuovo dipendono in qualche misura dal sistema operativo: tra i metadati importanti c'è l'<em><strong>owner</strong></em>, c'è la <em><strong>data di creazione</strong></em> ed <em><strong>ultima modifica.</strong></em></p>
<p>Questi ultimi due fattori sono molto interessanti nel contesto soprattutto della <em><strong>system integration</strong></em> cioè quando noi ci troviamo ad avere un pezzo di software che già esiste (che ha scritto qualcun altro e che fa delle cose) e abbiamo bisogno di fare in modo che <em>inter-operi</em> in qualche modo con un altro pezzo di software che ha scritto qualcun altro ancora che ha delle sue caratteristiche.</p>
<aside>
💡 Spesso e volentieri i file sono un modo plausibile di ottenere una forma di system integration, perché se abbiamo, ad esempio, Word che crea i file .docx — io non so manipolare i file .docx, non so come word li generi eccetera.. però posso immaginare che mi metto a osservare una certa cartella e tutte le volte che vedo comparire un nuovo file .docx all'interno potrei decidere che quel file potrebbe magari servirmi da un'altra parte.
Quindi magari scrivo un programmino che me lo prende e lo copia su un disco, una cosa che sembra una cartella locale ma in realtà è google drive e quindi che ne so ho fatto l'archiviazione automatica dei miei file .docx.
<p>Chiaramente in questo genere di operazioni sapere quando quel file è stato creato e quando è stato modificato è molto interessante perché pur non capendo niente della logica di come word aggiorna il file .docx, ma limitandomi a guardare l'oggetto file e monitorare la data di ultima modifica posso cercare di capire se quel file lì lo devo anche ricopiare da un'altra parte perché voglio farne il backup automatico oppure no.</p>
</aside>
<p>Posso sapere anche che tipo di file ho in questione: un <em><strong>file semplice</strong></em> (cioè è associato ad un array di bytes di qualche genere), o se c'è un nome che rappresenta una <em><strong>cartella</strong></em> quindi un raggruppamento di altri file, o se è un <em><strong>collegamento simbolico</strong></em> (ovvero è un nome che in realtà è un alias di un file che è però da un'altra parte) etc…</p>
<h1 id="3-navigare-il-file-system"><a class="header" href="#3-navigare-il-file-system">3. Navigare il file system</a></h1>
<p><img src="images/file_io/Untitled%202.png" alt="Untitled" /></p>
<p><em>Come facciamo a usare il sistema il file system?</em></p>
<p>Ci sono una serie di funzioni base che ci vengono esposte all'interno del crate <code>std::fs</code> che ci consentono di fare la maggior parte delle operazioni.</p>
<ul>
<li><strong><code>read_dir</code></strong>
Accetta un riferimento a <code>Path</code>, e ci restituisce un iteratore a tutti file contenuti in una certa cartella. Siccome noi passiamo un <code>Path</code> e quel <code>Path</code> potrebbe anche non corrispondere a nulla (magari passiamo il percorso di una cartella che non esiste), la funzione non ci restituisce direttamente l’iteratore, ma ci restituisce un <strong><code>Result</code></strong> di un iteratore (in particolare un <code>io::Result</code>, una cosa che ci può dire <em>“Path not found”</em>).</li>
<li><strong><code>create_dir</code></strong>
Cerca di creare una nuova cartella nel Path che gli specifichiamo, e ritorna anche lei un <code>Result</code>.</li>
<li><strong><code>remove_dir</code></strong>
Cerca di eliminare una cartella tramite il <code>Path</code> che gli specifichiamo, e ritorna anche lei un <code>Result</code>.</li>
</ul>
<p>Per poter eliminare una cartella, questa deve essere vuota e in più dobbiamo avere i diritti necessari, cioè dovremo essere noi gli <strong>owner</strong> della cartella stessa o avere i diritti di scrittura sulla cartella, altrimenti la funzione fallisce.
Lo stesso vale per la creazione e anche per la lettura: la cartella potrebbe benissimo esistere ma noi non abbiamo i diritti di leggerla.</p>
<h1 id="4-manipolare-i-file-nel-file-system"><a class="header" href="#4-manipolare-i-file-nel-file-system">4. Manipolare i file nel file system</a></h1>
<p><img src="images/file_io/Untitled%203.png" alt="Untitled" /></p>
<p>Ci sono poi altre funzioni che facilitano proprio i concetti di system integration, in particolare la funzione <strong><code>copy</code></strong> che ci permette di copiare il file da un certo path ad un altro, se ci riesce ci dice quanti byte sono stati fisicamente copiati.</p>
<p>La funzione <strong><code>rename</code></strong> viceversa sposta un file da una posizione a un'altra — a seconda dei sistemi operativi questo concetto di spostamento varia dal semplice <em>“Modifico alcune informazioni in una cartella”</em> al <em>“Lo copio fisicamente”.</em></p>
<p>In particolare, quando operiamo all'interno dello stesso file system, nella maggior parte dei casi viene semplicemente eliminata l'entry del file dalla cartella di partenza (ma il file rimane nella sua posizione con il suo inode e tutte le informazioni associate) e viene creata una nuova entry nella cartella di destinazione. Per questo motivo, l'operazione di <em><strong>rename</strong></em> all'interno dello stesso file system ha un costo computazionale molto basso.</p>
<p>Analogamente, se io lo rinomino nella stessa cartella, e da <code>/alpha/beta</code> lo voglio chiamare <code>/alpha/gamma</code> devo semplicemente cambiare la entry nella cartella <code>alpha</code> e cambiare da <code>beta</code> a <code>gamma</code>.</p>
<p>Se invece io volessi spostare da <code>C:/alfa/beta</code> in <code>D:/gamma</code>, siccome <code>C:</code> e <code>D:</code> sono fisicamente due volumi disgiunti, è vero che faccio un rename ma quello equivale alla copia e poi alla cancellazione.</p>
<p>La funzione <code>remove_file</code> cerca di eliminare il file specificato tramite il path passato come parametro.</p>
<p><img src="images/file_io/Untitled%204.png" alt="Untitled" /></p>
<p><em>Come facciamo a leggere e manipolare dei file?</em>
Nel momento in cui siamo interessati al contenuto del file (quindi non al file in quanto contenitore di byte generico che vogliamo spostare da una parte all'altra ma concentrandoci su un singolo file siamo interessati al contenuto) abbiamo vari meccanismi che ci consentono di accedere al contenuto del file o di cambiare il contenuto del file.</p>
<p>Di base c'è una struct che si chiama <strong><code>File</code></strong> che ci offre due metodi per essere istanziato:</p>
<ul>
<li><strong><code>open</code></strong> che prende un path in ingresso e restituisce un’istanza della struct <code>File</code> che corrisponde a un file che deve essere già presente all'interno del file system. Quindi serve fondamentalmente in quelle situazioni in cui noi vogliamo accedere a un file che esiste (prevalentemente per leggerlo ma in alcuni casi per scriverlo o per appendere)</li>
<li><strong><code>create</code></strong> che viceversa assume che quel file non ci sia e prova a crearne uno di dimensione zero, anche in questo caso con l'obiettivo di scriverlo. Se il file già esiste <code>create</code> butta via tutto quello che c'era dentro e quindi inizia con una <em>truncate</em>, quindi riporta il suo size a zero e da lì in avanti ci lascia operare</li>
</ul>
<p>Di solito <strong><code>open</code></strong> ci dà la possibilità di aprire <strong>in lettura</strong>, ma possiamo cambiare queste cose attraverso la struct <strong><code>OpenOption</code></strong> che ci dà la possibilità di definire quale path vogliamo e quale modalità vogliamo usare.</p>
<p><img src="images/file_io/Untitled%205.png" alt="Untitled" /></p>
<p>Creare la struct <code>File</code> ci serve in quelle situazioni in cui pensiamo di dover lavorare col contenuto del file non <em>“tutto d'un colpo”</em> ma <em>“a pezzi”.</em>
Ad esempio, se questo file è molto grosso devo immaginare di poter aprirlo e leggerne un po’, farci delle cose, poi leggerne un altro po’, farci delle cose ecc..</p>
<p>Quando il file è piccolo (es. 100MB in un sistema desktop, non embedded dove già 100MB è “pesante”), allora magari è di una dimensione compatibile con lo spazio che posso allocare all'interno del mio processo.
In questo caso ho due funzioni che mi fanno la vita molto comoda:</p>
<ul>
<li><strong><code>read_to_string</code></strong> prende il file e mi restituisce il suo contenuto sotto forma di stringa</li>
<li><strong><code>write</code></strong> prende uno slice di byte (<code>&amp;u8</code>) e lo scrive dentro il file, quindi quello che c'era nel file va perduto e viene sostituito dal blocco che io gli passo</li>
</ul>
<p>Quindi in quelle situazioni in cui io so a priori che le cose che devo trattare stanno probabilmente nel mio spazio indirizzamento, con questi due metodi ho tutto quello che mi serve ed è molto più agile poi lavorare direttamente su una stringa o su uno slice di byte piuttosto che operare a pezzi su blocchi che devo capire come li segmento, come li congiungo e così via…</p>
<aside>
💡 Nell’esempio in slide, vediamo che **`read_to_string`** prende come argomento una variabile **`filename`** , che deve essere di tipo `&Path`.
Noi potremmo passarvi anche una stringa, ad esempio **`"C:/alpha/beta"`** perchè i `&str` (slice di caratteri) sono riconducibili ad un `Path`, perchè implementano il tratto **`From`** e quindi possiamo convertirli in automatico.
</aside>
<p><img src="images/file_io/Untitled%206.png" alt="Untitled" /></p>
<p>Nelle situazioni invece in cui vogliamo scriverlo pian piano, posso popolare questo file in vari modi.</p>
<p>In questo esempio parto da un nome di un file <code>path = "lines.txt"</code>.
Questo è un <code>&amp;str</code> normalissimo. Lo passo alla funzione <code>file::create</code>.</p>
<p>La funzione <code>file_create</code> mi restituisce un file aperto <strong>in scrittura</strong>. L'oggetto <code>output</code> è di tipo <code>File</code>, ed è <code>mut</code> perché devo avere la possibilità di modificarne il contenuto.</p>
<p><em>Come faccio a scrivere dentro questo file?</em>
Io posso scrivere, ad esempio, con la macro <code>write!</code>.</p>
<p><code>write!</code> è molto simile a <code>println!</code>, ha un parametro in più iniziale, che è l'oggetto <code>File</code> su cui devo fare la scrittura. Quindi <code>write!(output, ...)</code>, e poi ci metto una stringa, che potrebbe contenere delle graffe, con gli indicatori e dei parametri ulteriori, proprio come farei con la <code>println!</code>.</p>
<p>Fatto così, ho creato un file che ha esattamente quel contenuto. Ci sono anche altri modi di fare questa cosa.</p>
<p>Se io lo volessi leggere a questo punto, probabilmente potrei usare la <code>read_to_string</code>, oppure posso cercare di leggerlo a pezzettini.</p>
<p>Un modo per leggerlo a pezzettini è usare un <code>BufReader</code>.
<code>BufReader</code> è un particolare oggetto, un tipo di struttura, che mi permette di leggere un file <strong>riga per riga</strong>.</p>
<p>In questo caso apro il file in lettura con <strong><code>File::open(path)?;</code></strong> (punto interrogativo perché quell'operazione potrebbe fallire), e a partire da questo oggetto <code>File</code> creo l'oggetto <code>BufReader</code> che è specializzato nel leggere da un file che gli passo al lato della costruzione e mi offre meccanismi per andarci all'interno.</p>
<p>Tra i meccanismi che mi offre c'è l’iteratore <strong><code>.lines()</code></strong>, metodo che mi dà le singole righe presenti all'interno e a questo punto, avendo <strong><code>for line in bufferd.lines()</code>,</strong> per ciascuna riga presente all'interno faccio la stampa.</p>
<p>Va detto che la lettura della singola riga potrebbe sempre fallire così come anche l’iteratore che che mi fa vedere tutti file della cartella che gli ho specificato e cose del genere — sono tutti iteratori che ritornano un <code>Result</code>.</p>
<p>Siccome <strong><code>File</code></strong> implementa la strategia RAII <em>(Resource Acquisition Is Initialization)</em> automaticamente, quando la variabile esce di scope il file viene chiuso e quindi non mi devo occupare di chiudere il file esplicitamente.</p>
<p>Se ho bisogno posso anticipare la sua uscita di scope facendo in modo esplicito il <code>drop</code> del mio oggetto file così che il suo distruttore viene invocato.</p>
<h1 id="5-i-tratti-relativi-a-io"><a class="header" href="#5-i-tratti-relativi-a-io">5. I tratti relativi a I/O</a></h1>
<p><img src="images/file_io/Untitled%207.png" alt="Untitled" /></p>
<p>Esistono alcuni tratti fondamentali che semplificano l'implementazione e consentono di gestire le operazioni di I/O in modo analogo alle operazioni sulla memoria normale.
Quattro tratti in particolare sono essenziali: il tratto <code>Read</code>, il tratto <code>BufRead</code>, il tratto <code>Write</code> e il tratto <code>Seek</code>.</p>
<p>Questi tratti fanno parte del <strong>preludio</strong>, ma non del preludio standard completo. Di conseguenza, sono disponibili automaticamente se includiamo il preludio, altrimenti dobbiamo importarli separatamente.</p>
<p>In tutti i vari casi le operazioni che questi 4 tratti fanno restituiscono dei <code>Result</code>, che se sono positivi contengono di volta in volta un numero (quanti byte ho fisicamente letto/scritto piuttosto che un <code>void()</code> per dirmi che non c'era nessun risultato particolare o altro) nel caso di errore mi arriva un errore che è definito dalla struct <strong><code>ErrorKind</code></strong> .</p>
<p>Alcuni degli errori presenti in <strong><code>ErrorKind</code></strong> sono ingestibili, cioè posso solo arrendermi (es. il file non esiste). Ce n'è uno in particolare che è <strong><code>Interrupted</code></strong> che invece denota una situazione <em><strong>transitoria,</strong></em> cioè se il risultato è <code>Interrupted</code> potrebbe valer la pena metter in atto la strategia di riprovarci dopo un po’.</p>
<p>Va detto che nella maggior parte delle situazioni la strategia di riprovarci è un bagno di sangue perché devo capire cosa devo riprovare e come lo riprovo, quindi anche se in linea di principio sarebbe gestibile, nella maggior parte delle situazioni non si gestisce e si preferisce lasciar perdere.</p>
<p><img src="images/file_io/Untitled%208.png" alt="Untitled" /></p>
<p><em>Chi è che implementa il tratto</em> <strong><code>Read</code></strong> <em>?</em>
Il tratto <code>Read</code> è implementato da tre cose che sono molto diverse tra di loro: <strong><code>File</code></strong> implementa il tratto <code>Read</code> (posso leggere un blocco binario di dati da un file, ma anche dei caratteri, o delle stringhe etc...).</p>
<p><code>Read</code> è implementato anche dalla struttura che si chiama <strong><code>Stdin</code></strong> che rappresenta il <strong>flusso di default di ingresso</strong> di un processo. Normalmente se noi non facciamo niente di particolare quel flusso di ingresso corrisponde con la tastiera e quindi quello che l'utente può digitare. Noi sappiamo però che quando attiviamo un processo possiamo ridirigere il suo standard input usando i comandi che la shell ci offre quindi con <code>&gt;</code> con <code>|</code> o cose del genere per fargli entrare in ingresso altre cose.</p>
<p>Un altro oggetto che implementa lo stesso tratto <code>Read</code> è l'oggetto <strong><code>TcpStream</code></strong> che rappresenta invece una connessione di tipo TCP con un host. Notiamo che <code>TcpStream</code> rappresenta uno dei due endpoint — non sta dicendo nè che siamo server nè che siamo client perché una volta che la connessione TCP è stata stabilita, non c'è più nessuna differenza tra il server e client: la connessione è completamente bidirezionale. L'oggetto <code>TcpStream</code> rappresenta una connessione che è stata messa in piedi e a questo punto su questa connessione io posso leggere.</p>
<p>La lettura qua è una lettura che va a fare una system call (quindi interpella il sistema operativo) ogni volta che gli chiedo qualcosa; questo in alcuni casi va benissimo, in alcuni casi è un grosso problema: se ricordate in precedenza abbiamo parlato di come funzionano le cose abbiamo detto che io chiamo l'API del sistema operativo attraverso una funzione particolare (la system call) che mi innalza di privilegio e che in generale è un'operazione costosa — es. su un x86 la call normale costa 5 cicli macchina, mentre la system call ne costa 500.
Allora se io leggo un byte alla volta (perché sto leggendo tipo da tastiera), la lettura di quel byte mi costa 500. Ma io potrei piuttosto dire <em>“Leggimene all'ingrosso 500 e tieniteli lì in pancia, poi te li chiedo uno alla volta”.</em> In questo modo l'interazione col sistema operativo avviene molto più raramente: tutte le volte il sistema operativo dice <em>“Dammi i prossimi 500 byte se ce li hai, me li porto in pancia e poi al mio client (cioè il pezzo di sotto che ne ha bisogno) ne dò quelli che mi sta chiedendo”.</em>
Questo è fatto dal tratto <strong><code>BufRead</code></strong>, che dice <em>“Tra i dati che tu mi chiedi e quelli che io mia volta chiedo al sistema operativo interpongo un buffer”.</em></p>
<p><em>Quali sono le struct che implementano il tratto <strong><code>BufRead</code></strong> ?</em>
La struct <strong><code>BufReader</code></strong> è specializzata nel leggere da un file a <strong>chunk grossi</strong> dando poi i dati uno alla volta per come sono, perché vedete che <strong><code>BufRead</code></strong> è una specializzazione di <strong><code>Read</code></strong>, quindi ha <strong>tutti i metodi</strong> di <code>Read</code> e ci aggiunge i propri.</p>
<p><code>BufReader</code> offre funzionalità aggiuntive oltre ai metodi generali, come l'iteratore <code>.lines()</code>. Poiché carica molti dati in memoria in un colpo solo, può implementare efficacemente questo iteratore scorrendo il suo buffer interno. Quando trova un carattere di fine riga, restituisce la riga completa immediatamente. Alla richiesta successiva di <code>next()</code>, continuerà la ricerca dal punto in cui si era fermato. Se esaurisce i dati nel buffer, richiederà automaticamente altri dati al sistema operativo per riempire nuovamente il buffer.</p>
<p>C'è anche un altro oggetto che implementa <code>BufRead</code>: è <strong><code>Cursor</code></strong>, un oggetto un po’ particolare che mi permette di muovermi all'interno di uno slice di byte, che può essere fatto in vari modi.</p>
<p>E poi c'è <strong><code>StdinLock</code>.</strong>
Da <code>Stdin</code> normale io leggo un byte alla volta i singoli caratteri che digito (<em>c i a o</em>) e se se fossimo in due a leggere io magari leggo (<em>c i</em>) e l'altro legge (<em>a o</em>) della parola <em>ciao,</em> perché nel momento in cui io chiedo il prossimo disponibile, questo viene <strong>consumato.</strong> Se io volessi leggere una sequenza devo prendere possesso di <code>Stdin</code>, e quindi <strong><code>StdinLock</code></strong> serve proprio a dire <em>“Ho preso in modo esclusivo l'accesso a standard input e adesso posso leggere, ce l'ho a blocchi e quindi posso fare read line”.</em></p>
<p>Poi c'è invece il tratto <strong><code>Write</code></strong> che è implementato da tutta una serie di altre struct: la struct <strong><code>Stdout</code></strong> rappresenta il flusso di uscita standard di un processo (questo di solito coincide col terminale nell'applicazione basata su terminali ma può essere ridiretto verso un file, verso un altro processo e così via).
<strong><code>Stderr</code></strong> rappresenta il flusso di errore di un file.
Anche la struct <strong><code>File</code></strong> implementa <code>Write</code> proprio perché io ho la possibilità di mandare un byte o un chunk di byte verso un file.
Anche la struct <strong><code>TcpStream</code></strong> implementa <code>Write</code>, perché <code>TcpStream</code> è bidirezionale (posso leggere e posso scriverci).
Anche <strong><code>Vec&lt;u8&gt;</code></strong> implementa <code>Write</code>: posso trattare un vettore come il destinatario di un file — come tratterei un file in scrittura, cioè posso buttare lì dentro esclusivamente un vettore di byte.
Infine <strong><code>BufWriter</code></strong> è una specializzazione del tratto <code>Write</code> e mi aggiunge la capacità di dire che <em>“i singoli byte che mi dai non li passo subito al sistema operativo come fanno normalmente tutti gli altri, ma me li tengo in pancia finché non ne ho abbastanza e quando ne ho abbastanza te li scrivo”</em> così da far sì che questa barriera tra il codice utente e il codice del kernel sia attraversata ogni tanto e non per ogni byte o cose del genere, che altrimenti diventa costosissimo.</p>
<h2 id="51-il-tratto-read"><a class="header" href="#51-il-tratto-read">5.1 Il tratto <code>Read</code></a></h2>
<p><img src="images/file_io/Untitled%209.png" alt="Untitled" /></p>
<p>Il tratto <code>Read</code> è implementato da tutti coloro i quali permettono di leggere, un byte alla volta o un chunk di byte alla volta. Di base l'operazione elementare che il tratto <code>Read</code> offre è il metodo <strong><code>read()</code></strong> che accetta un <code>&amp;mut [u8]</code> (cioè un riferimento mutabile ad uno slice di byte) e mi dà la possibilità di leggere al suo interno sapendo che se quel buffer che ho passato contiene 100 byte lui proverà a leggerne 100 ma potrebbe riuscire a leggerene solo 32, o 27, o anche 0, e quindi come risultato mi dà un <code>Result</code> che contiene nel caso di <code>Ok</code> il numero di byte che ha effettivamente letto.</p>
<p>All'interno del tratto <code>Read</code> ci sono tanti altri metodi che sono definiti tutti quanti con una implementazione di default, e l'implementazione di default che è fornita di questi altri metodi è basata sul metodo <code>read()</code>, quindi se noi avessimo bisogno di implementare il tratto <code>Read</code> per una nostra struttura particolare l'unico vero bisogno che abbiamo è implementare il metodo <code>read()</code>.</p>
<p>Poi ovviamente potremmo decidere di implementare anche qualche altro metodo, se avessimo per il nostro caso particolare delle ottimizzazioni possibili rispetto alla funzione di default, ma in termini strettamente funzionali non sarebbe necessario.</p>
<p>In generale, il metodo <code>read()</code> restituisce un risultato che, se negativo, contiene la descrizione dell'errore. Se positivo, il valore varia tra 0 e la lunghezza massima del buffer.</p>
<p>È importante capire che quando leggiamo e otteniamo <strong><code>Ok(0)</code></strong>, questo può verificarsi in due situazioni:</p>
<ul>
<li>La più frequente è quando raggiungiamo l'<strong>end of file</strong>.
Questo accade solo se il buffer ha dimensione maggiore di 0.</li>
<li>Quando il buffer passato ha dimensione 0.</li>
</ul>
<aside>
💡
<p><strong>Nota</strong>
Se passiamo uno slice di size 0 (cosa possibile), otterremo necessariamente <code>Ok(0)</code>, semplicemente perché non c'è spazio per leggere: in pratica ci dice <em>"ho letto 0 byte".</em></p>
</aside>
<p>Ogni volta che chiamiamo <code>read()</code>, viene effettuata una system call che comporta un cambio di contesto (questo accade nella maggior parte dei casi). Questa system call è costosa, richiedendo 500 cicli macchina.</p>
<p><img src="images/file_io/Untitled%2010.png" alt="Untitled" /></p>
<p><em>Quali sono tutti gli altri metodi che il tratto</em> <code>Read</code> <em>mi offre (e che di conseguenza trovo dentro</em> <code>File</code>, **<code>Stdin</code><em>,</em> <code>TcpStream</code> <em>etc...)?</em> ****</p>
<p><strong><code>read_to_end</code></strong> → gli passo un <code>Vec&lt;u8&gt;</code> e lui mi riempie questo vettore col contenuto di tutto il file; chiaramente questo lo devo fare facendo attenzione che la dimensione del file sia compatibile con la memoria allocabile del vettore: se quel file lì è 200 giga non è detto che io riesca allocare 200 giga nel mio spazio di indirizzamento.</p>
<p><strong><code>read_to_string</code></strong> → metodo che in questo caso prende come parametro un variabile tipo <code>String</code> e fa il medesimo giro con un controllo in più: mentre nella <code>read_to_end</code> i byte così come sono vanno bene (qualunque questi byte fossero), nel caso di <code>read_to_string</code> viene fatto il controllo che quei byte formino una stringa utf-8 ben formata e quindi nel caso in cui ci fossero sequenze impossibili mi generano un errore.</p>
<p><strong><code>read_exact</code></strong> → molto simile a <code>read()</code> ma prova a leggere esattamente quel numero di byte di cui abbiamo passato il buffer; quindi io ho passato un buffer da 100 byte e lui cerca di riempirmeli tutti quanti; se non riesce a riempirmeli tutti quanti mi dà errore <em><strong>“Unexpected end of file”</strong></em>.</p>
<p><strong><code>bytes</code></strong> → mi restituisce un iteratore che mi permette di tirare fuori i byte uno alla volta; questi byte mi escono non come singoli byte ma come <code>Result</code> dove in <code>Ok</code> ho un byte e nel caso contrario ho un <strong><code>io::Error</code></strong> di un qualche tipo.</p>
<p><strong><code>chain</code></strong> → interessante perché mi permette di attaccare un <code>Read</code> a un altro <code>Read</code>, ad esempio io so che ho spaccato un file grosso in tre pezzi e ho messo l'inizio in file 1 la metà in file 2 e il resto in file 3 e quindi posso creare un oggetto <code>Read</code>, quindi apro per esempio un file col metodo <code>open</code> , su quel file li faccio <strong><code>.chain(file2).chain(file3)</code></strong> e a questo punto ho creato una struttura che è la concatenazione di tutto. Quando comincerò a farmi dare dei contenuti questi verranno prelevati da file 1 finché ce n'è, quando arrivo al fondo di file 1 verranno presi da file 2 finché ce n'è, e poi verranno presi da file 3 finché ce n’è.</p>
<p><strong><code>take</code></strong> → mi dà un iteratore che prende al massimo il numero di byte che io gli dico, quindi mi permette di porre un limite a priori sulla quantità di byte che voglio andare a prendere.</p>
<h2 id="52-il-tratto-bufread"><a class="header" href="#52-il-tratto-bufread">5.2 Il tratto BufRead</a></h2>
<p><img src="images/file_io/Untitled%2011.png" alt="Untitled" /></p>
<p><em>Cosa mi aggiunge <strong><code>BufRead</code></strong>?</em></p>
<p>Gli oggetti che implementano il tratto <code>BufRead</code> (quindi <code>BufReader</code> oppure <code>StdinLock</code> ecc..) mi danno alcuni metodi ulteriori: in generale internamente si basa su due metodi fondamentali che sono <strong><code>fill_buf</code></strong> e <strong><code>consume</code></strong> .
Sono metodi che lui usa per implementare gli altri metodi, e che noi di solito non chiamiamo in modo esplicito, perché ci interessano molto di più tutti gli altri che offre tra i quali c'è <strong><code>read_line</code></strong> che legge una singola riga di testo fino allo <code>/n</code>, o <strong><code>lines</code></strong> che ci dà l’iteratore che ci permette di prendere le righe una alla volta.</p>
<h3 id="521-esempio"><a class="header" href="#521-esempio">5.2.1 Esempio</a></h3>
<p><img src="images/file_io/Untitled%2012.png" alt="Untitled" /></p>
<p>Qui vediamo un esempio d'uso: prendo uno stdin, faccio <code>stdin.lock</code> e a questo punto trasforma il mio oggetto <code>stdin</code> che potrebbe essere usato da altri in contemporanea in un oggetto che appartiene solo a me e su cui ho il tratto <strong><code>BufRead</code></strong> . A questo punto posso usarlo per farci delle cose.
Con <strong><code>handle.fill_buf().unwrap();</code></strong> stiamo chiedendo di prendere tutto quello che riesce all'interno del buffer che internamente lui si è allocato, lo stampo, mi chiedo anche quanto è grande e a questo punto quello l’ho consumato. Questo è il meccanismo che internamente i vari metodi implementati da <code>BufRead</code> usano per gestirsi le cose. Noi di solito queste chiamate però non le facciamo così perché è una seccatura; noi quando creiamo gli oggetti <code>BufRead</code> chiamiamo <strong><code>read_line()</code></strong> piuttosto che <strong><code>lines()</code></strong> che è molto più comodo.</p>
<h2 id="53-il-metodo-write"><a class="header" href="#53-il-metodo-write">5.3 Il metodo <code>Write</code></a></h2>
<p><img src="images/file_io/Untitled%2013.png" alt="Untitled" /></p>
<p>Il tratto <strong><code>Write</code></strong> è implementato da varie strutture (<code>File</code>, <code>Stdout</code>, <code>Stder</code> e così via..) e all'interno contiene due metodi:</p>
<ul>
<li><strong><code>write()</code></strong> che affida al sistema operativo un blocco e il sistema operativo saprà che dovrà recapitarlo al dispositivo di io corrispondente, ma non è obbligato a farlo subito</li>
<li><strong><code>flush()</code></strong> che viceversa è responsabile di garantire che il sistema operativo prende tutto quello che ha tenuto e fisicamente lo trasferisca fino in fondo così che se qualcuno va ad accedere sul device ci trova esattamente quello che io penso di averci messo</li>
</ul>
<p>Oltre a questi due metodi ce ne sono altri qui che vale la pena di citare: <strong><code>write_all</code></strong> si prende uno slice come argomento, e garantisce che lo trasferisce per intero. Essenzialmente fa <code>write</code> e <code>flush</code> in un colpo solo.</p>
<h2 id="54-il-tratto-seek"><a class="header" href="#54-il-tratto-seek">5.4 Il tratto <code>Seek</code></a></h2>
<p><img src="images/file_io/Untitled%2014.png" alt="Untitled" /></p>
<p>Fino ad adesso abbiamo visto i file come oggetti di tipo <em><strong>stream</strong></em>, cioè oggetti in cui scriviamo aggiungendo sempre alla fine o da cui leggiamo i contenuti nell'ordine in cui sono stati scritti, dal primo all'ultimo byte. In questo modo manteniamo l'ordine sequenziale sia in scrittura che in lettura.</p>
<p>Ma in realtà un file è semplicemente un array di byte, e nulla ci impedisce di muoverci liberamente al suo interno. Questo funziona in modo diverso a seconda del tipo di file: su disco, dove il file è effettivamente un array di byte, ha senso spostarsi in modo casuale e dire <em>"alla posizione 32 scrivo questo, poi torno alla posizione 0 e scrivo quest'altro, poi vado alla posizione 150 e scrivo quest'altro"</em>.</p>
<p>Il file inteso come <em><strong>porta seriale</strong></em>, invece, non può essere trattato in questo modo: anche se ci appare come un file, non è <em>seekable</em>. Questo perché la porta seriale è, come dice il nome, seriale, e i byte che vi inseriamo <em>"vanno a casa di qualcun altro"</em>. Non possiamo dire <em>"no scusa, torno indietro"</em>: il tempo scorre in una sola direzione.</p>
<p>Quindi di tutte quelle cose che a noi sembrano files, alcune sono <em><strong>seekable</strong></em>, altre non lo sono.
Per quelle che sono seekable però abbiamo la possibilità di farci delle operazioni abbastanza interessanti: abbiamo la possibilità di dire che noi leggiamo i contenuti di questo grosso byte array che il file modella, in un qualche ordine che possiamo andare a definire — di base l'operazione <code>read</code> o l'operazione <code>write</code> avviene su quella che è la <em><strong>posizione corrente del file.</strong></em></p>
<p>La posizione corrente è stabilita al lato dell'apertura: quando apriamo un file nella modalità read o nella modalità write, la posizione iniziale è zero e quindi <code>read</code> legge il primo, secondo, il terzo o quarto byte, nel <code>write</code> scrivo il primo, il secondo, il terzo o quarto byte. Quando apriamo un file nella modalità <strong>append</strong> la posizione iniziale è al fondo, e quindi <code>append</code> è una modalità di scrittura dove invece di sovrascrivere quello che c'è aggiungo dei pezzi.</p>
<p>Noi però possiamo muoverci anche tornando indietro ecc.. il tratto <strong><code>Seek</code></strong> ci consente fondamentalmente di muoverci dall'inizio, dalla fine o dalla posizione corrente di un certo <em><strong>delta</strong></em>.</p>
<p>Quindi ad esempio <strong><code>SeekFrom::Start</code></strong> diciamo <em>“a partire dalla posizione zero del file porta la posizione corrente avanti di tot posti”,</em> oppure dall'end invece <strong><code>SeekFrom::End</code></strong> partendo dal fondo del file torna indietro di tanti altri oppure <strong><code>SeekFrom::Current</code></strong> dice <em>“da dove sei adesso vai avanti o indietro di una certa quantità”.</em></p>
<p>Notate che <code>SeekFrom::End</code> prende un numero <strong>con segno</strong> perché io potrei cercare di tornare indietro oppure potrei voler andare comunque avanti per allungare il file. <strong><code>SeekFrom::Start</code></strong> prende un <code>u64</code> perché dall'inizio non posso andare a “prima dell’inizio del file”.</p>
<p>Ci sono tre metodi fondamentali che chi implementa il tratto <strong><code>Seek</code></strong> ci mette a disposizione: il metodo <strong><code>seek()</code></strong> stesso che mi permette di cambiare qual è la produzione corrente da cui vado a fare le letture o su cui vado a fare le scritture, <strong><code>rewind()</code></strong> che mi permette fondamentalmente di ritornare all'inizio del flusso (quindi equivale a <strong><code>SeekFrom::Start(0)</code></strong>) e infine c'è il metodo <strong><code>stream_position()</code></strong> che mi ritornà qual è l'attuale posizione di questo file.</p>
<p><img src="images/file_io/Untitled%2015.png" alt="Untitled" /></p>
<p><em>Come facciamo a leggere dei dati binari di qualche tipo?</em></p>
<p>Supponiamo volessimo aprire un <strong>pdf</strong>, che è un file che ha un formato binario al suo interno: certo ci sono anche delle parti stringa, ma ci sono anche <em>immagini</em>, <em>codici di formattazione</em>, <em>cose strane</em> etc.</p>
<p>Per cui di per sé non abbiamo la garanzia che contenga dell'<code>utf-8</code> quindi dobbiamo leggere come array di byte. Qua proviamo a farlo: nell'esempio in realtà leggo (nel caso di Linux) dal device che si chiama <em><strong>urandom</strong></em>, un particolare device che viene montato. È un finto file (infatti sta nella cartella <code>/dev</code>) che quando lo leggo mi genera dei byte a caso appoggiandosi a una qualche periferica che, attraverso un fenomeno fisico di qualche genere, prova a generare dei numeri che siano robustamente casuali.</p>
<aside>
💡 Un modo per generare dei numeri robustamente casuali è fare lavorare un diodo zener in corrispondenza del punto di gomito della sua curva tensione corrente, che è una zona di grande aleatorietà dove, tenendo in quella posizione li, a volte leggo uno a volte leggo zero in un modo non controllabile. Siccome è un fenomeno fisico che dipende da tutta una serie di faccende varie, quella è una buona sorgente di variabilità e di conseguenza può essere messo all'interno della nostra CPU un chip che internamente fa questo mestiere, e quando leggiamo da ***urandom*** in realtà andiamo a interrogare questo chip che ci genera dei byte a caso.
<p>In altre situazioni si usano dei sensori (dei muoni piuttosto che di altre particelle che ci arrivano dai raggi cosmici sostanzialmente) che di nuovo sono abbastanza impredicibili e tra l'altro sono rilevabili anche negli ambienti interni perché attraversano una serie di situazioni e quindi questi sono tutti fenomeni difficilmente caratterizzabili.</p>
<p>Perché è importante essere difficilmente caratterizzabile?
I numeri random noi li possiamo usare per scopi molto diversi: li possiamo usare banalmente per pseudo simulazioni — fate un giochino, c'è il mostriciattolo che vi insegue che a volte gira destra e a volte gira a sinistra, va bene chi se ne frega.
Ma se invece di fare il giochino o la simulazione di qualcos'altro stiamo facendo la crittografia per proteggere una transazione bancaria, se l’algoritmo non è un vero random ma è uno pseudo random (che di fatto è assolutamente predicibile: qualcuno potrebbe aver studiato un po’ di bit precedenti e fare un <em><strong>educated guess</strong></em> su quali saranno i bit a venire) questo sarebbe rischiosissimo. Per questo motivo ci serve avere un generatore di numeri casuali che sia legato a fenomeni fuori dal controllo.</p>
</aside>
<p>In questo caso qui apriamo il device che si chiama <code>dev/urandom</code> e in questo caso noi sappiamo che questo ci dà un 32 bit, quindi prepariamo un buffer di 4 byte <code>let mut buff = [0;4]</code> — quello lì è un buff di 4 byte inizialmente tutti i posti a 0. E poi chiamiamo <code>f.read_exact(&amp;mut buff)</code> , cioè riempimi questi 4 byte con il contenuto del file urandom. Se qualcosa va storto ritorna l'errore, dopo di che se invece non è un errore all'interno dell’array buff ho i 4 byte completamente random e quindi vado a vedere cosa succede e vedo: se in questo caso ne trovo uno tutto a 0 la pianto lì subito dicendo ok altrimenti provo a trasformare questo numero in un intero 32 bit e ci faccio qualcosa in questo caso lo stampo.</p>
<p><img src="images/file_io/Untitled%2016.png" alt="Untitled" /></p>
<p>Altre volte, invece di leggere brutalmente un blocco di byte così com’è nel disco o code del genere, io ho bisogno di leggere dei dati che so essere strutturati: ad esempio un file csv che contiene qualche milionata di numeri.
Posso farmi questa lettura a mano: faccio open, ci creo un BufReader sopra, a questo punto punto con .lines ho la linea, quella linea lì la devo spezzettare, faccio .split sulla virgola ottengo i singoli chunk, devo ricordarmi che il primo vuol dire una certa cosa, il secondo vuol dire un’altra cosa etc..</p>
<p>Si può fare, però è una seccatura: il giorno che quelli che hanno generato il .csv cambiano il formato e mi dicono devo mettermi lì e paccioccare ed essere sicuro di farlo bene.
Mi farebbe molto più comodo poter descrivere quelli che sono i campi e poi mi farebbe piacere avere qualcosa che me li trasforma per i fatti suoi, e qui ci viene in aiuto un crate che possiamo includere all'interno delle nostre progetti che si chiama <strong><code>Serde</code></strong> .</p>
<p><em><strong>Serde</strong></em> sta per <em><strong>serialization e deserialization</strong></em>.
Serialization è l'operazione di trasformare il dato dal formato interno di Rust a un formato esterno, e deserialization è l'operazione di trasformare dal formato esterno in quello interno di Rust.</p>
<p>In realtà di formati esterni ce ne sono 20 mila possibili, .csv è solo uno di questi. Serde è un crate che definisce un framework generale e poi ha una serie di sottocrates che ne specializzano il comportamento in un modo o nell'altro.
Di suo Serde ci offre due tratti: <strong><code>Serialize</code></strong> e <strong><code>Deserialize</code></strong>.
Perchè sia utile, possiamo includere la macro derive che ci dà la possibilità di creare in automatico le funzioni serialize e deserialize per le strutture dati che andiamo a definire per i fatti nostri.</p>
<h1 id="6-il-framework-serde"><a class="header" href="#6-il-framework-serde">6. Il framework <code>Serde</code></a></h1>
<p><img src="images/file_io/Untitled%2017.png" alt="Untitled" /></p>
<p><img src="images/file_io/Untitled%2018.png" alt="Untitled" /></p>
<p>Includendo serde nel Cargo.toml abbiamo ora disponibili il framework serde e la macro derive. Ma il framework serde è un framework di serializzazione generico: sa serializzare, ma cosa ci serve serializzare?
Allora dobbiamo includere le “specializzazioni”, dunque includiamo anche <code>serde_json</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="13-collezioni_di_dati.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="15-smart_pointer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="13-collezioni_di_dati.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="15-smart_pointer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
