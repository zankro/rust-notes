<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Keep in Mind</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-things-to-keep-in-mind"><a class="header" href="#-things-to-keep-in-mind">üìù¬†Things to keep in mind</a></h1>
<blockquote>
<p>üí° <strong>Costruttore variabili globali</strong></p>
<p>In C++, se ho costruito delle variabili globali di tipo classe, queste possono avere un costruttore.
Il costruttore delle variabili globali viene invocato prima che il main parta.
Il distruttore delle variabili globali viene invocato dopo che il main √® terminato.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Puntatori e possesso + Smart Pointers</strong></p>
<ul>
<li><code>&amp;</code> ‚Üí Puntatore in sola lettura, senza possesso.</li>
<li><code>&amp;mut</code> ‚Üí Puntatore con accesso in scrittura, senza possesso.</li>
<li><code>Box&lt;T&gt;</code> ‚Üí Puntatore che <strong>possiede</strong> il dato.
<ul>
<li>Non pu√≤ essere copiato</li>
<li>Pu√≤ essere <em>mosso</em></li>
</ul>
</li>
<li><code>Rc&lt;T&gt;</code> ‚Üí <strong>Accesso condiviso (immutabile)</strong> al dato (&amp;T)
<ul>
<li><strong>La propriet√† √® condivisa</strong></li>
<li>Il dato √® posseduto collettivamente da tutti gli <code>Rc</code> che lo puntano</li>
<li>Contatori <strong>strong</strong> e <strong>weak</strong> ‚Üí Utile per strutture cicliche</li>
<li>Il blocco <code>dato+contatori</code> sta sullo heap</li>
</ul>
</li>
<li><code>Arc&lt;T&gt;</code> ‚Üí Equivalente <strong>thread-safe</strong> di <code>Rc&lt;T&gt;</code>
<ul>
<li>Accesso <strong>immutabile (&amp;T)</strong> condiviso tra pi√π thread</li>
<li>Usa <strong>atomic increment e decrement</strong></li>
<li>Usato con <code>Mutex&lt;T&gt;</code> o <code>RwLock&lt;T&gt;</code> per la mutabilit√†</li>
</ul>
</li>
<li><code>Cell&lt;T&gt;</code> ‚Üí Contenitore con¬†interior mutability per tipi¬†Copy
<ul>
<li>Permette di <strong>modificare il dato anche da un riferimento immutabile</strong></li>
<li>Il contenuto pu√≤ essere <strong>letto solo per copia</strong> (Copy), <strong>non per reference</strong></li>
</ul>
</li>
<li><code>RefCell&lt;T&gt;</code> ‚Üí Contenitore con <em>interior mutability</em> per <strong>tipi non Copy</strong>
<ul>
<li>Permette accesso <strong>in lettura (<code>borrow()</code>)</strong> e <strong>scrittura (<code>borrow_mut()</code>)</strong> anche da <code>&amp;self</code></li>
<li>Verifica le regole di borrowing <strong>a runtime</strong> (panic se violate)</li>
<li>Utile per dati mutabili condivisi in ambienti <strong>single-threaded</strong></li>
</ul>
</li>
<li><code>Mutex&lt;T&gt;</code> ‚Üí <strong>Protegge un dato con un lock esclusivo per accesso concorrente</strong>
<ul>
<li>Solo un thread per volta pu√≤ accedere in scrittura (via <code>.lock()</code>)</li>
<li>Interior mutability</li>
<li>Tipicamente usato con <code>Arc&lt;T&gt;</code> per <strong>mutabilit√† condivisa tra thread</strong></li>
</ul>
</li>
<li><code>Cow&lt;'a, B&gt;</code> ‚Üí <em>‚ÄúClone-On-Write‚Äù</em> ‚Üí wrapper che pu√≤ essere <strong>borrowed o owned</strong>
<ul>
<li>Se non mutato si comporta come <code>&amp;‚Äôa B</code></li>
<li>Se mutato effettua un <strong>clone</strong> del dato</li>
<li>Esempio: <code>Cow&lt;str&gt;</code> pu√≤ contenere <code>&amp;‚Äôa str</code> oppure <code>String</code></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>üí° <strong>Riferimenti, espressioni e valori immediati</strong></p>
<p>Scrivere <code>let r1 = &amp;75</code> √® assolutamente lecito: Rust scrive 75 dentro lo stack, come se avessimo creato una variabile temporanea, prende l‚Äôindirizzo di quella variabile e lo salva dentro <code>r1</code> e ci lascia fare delle cose.</p>
<p>Posso scrivere anche <code>let r1 = &amp;(i*5/4)</code> ‚Äî calcola il risultato, lo mette in un temporaneo sempre sullo stack, prende il puntatore e mi manda avanti.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Modificare l‚Äôarea puntata dai puntatori</strong></p>
<p>In Rust, generalmente questo non √® possibile.
L‚Äôunico modo per modificare manualmente un puntatore, per cambiare manualmente l‚Äôindirizzo cui sta puntando (tipo con aritmetica dei puntatori), √® usare i raw pointers (i puntatori nativi del C) in blocchi unsafe.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Create an array of i32 values
    let arr = [1, 2, 3, 4, 5];

    // Create a raw pointer to the first element of the array
    let mut r_ptr: *const i32 = arr.as_ptr();

    // Print the initial value pointed to by r_ptr
    println!("Initial value: {} @ {:p}", unsafe { *r_ptr }, r_ptr); // Output: Initial value: 1

    // Perform pointer arithmetic to move the pointer to the next element
    unsafe {
        r_ptr = r_ptr.add(1);
    }

    // Print the new value pointed to by r_ptr
    println!("New value: {} @ {:p}", unsafe { *r_ptr }, r_ptr); // Output: New value: 2

    // Perform pointer arithmetic to move the pointer to the third element
    unsafe {
        r_ptr = r_ptr.add(1);
    }

    // Print the new value pointed to by r_ptr
    println!("New value: {} @ {:p}", unsafe { *r_ptr }, r_ptr); // Output: New value: 3
}

/*  
		OUTPUT:
		Initial value: 1 @ 0x7fffbb6b8fa4
		New value: 2 @ 0x7fffbb6b8fa8
		New value: 3 @ 0x7fffbb6b8fac
*/
</code></pre></pre>
</blockquote>
<blockquote>
<p>üí° <strong>Le struct stanno sullo stack, SEMPRE (a meno che non sono boxate)</strong></p>
<p><img src="images/images/keep_in_mind/image.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%201.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Struct sullo stack vs struct sullo heap (Box<Struct>)</strong></p>
<p><img src="images/keep_in_mind/image%202.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%203.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%204.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Copia vs Movimento</strong></p>
<p>La <strong>copia</strong> √® una <strong>duplicazione</strong>: il nuovo valore √® indipendente dall‚Äôoriginale.
Tipi come gli interi (i32, u8, ecc.) vengono copiati quando vengono assegnati o passati a una funzione: si crea una nuova copia del dato, e l‚Äôoriginale resta valido.</p>
<p>Invece, per tipi come Box<T>, l‚Äôassegnazione comporta un <em><strong>movimento</strong></em> (move): il valore viene <em>spostato</em>, e l‚Äôoriginale non pu√≤ pi√π essere usato.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine: */
/* i32 implements Copy */
fn main() {
    let x1 = 5;
    let x2 = x1; // Copy
    
    println!("x1: {}", x1);
    println!("x2: {}", x2);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">/* This doesn't compile */
/* Box doesn't implement Copy */
fn main() {
    let b1 = Box::new(5);
    let b2 = b1; // Movement
    
    println!("b1: {}", b1);     // this should thrown an error
    println!("b2: {}", b2);
}</code></pre></pre>
<p>L‚Äôesempio a destra non funziona perch√®, dato che i dati posseduti da <code>b1</code> vengono <em>spostati</em> in <code>b2</code> (che ne diventa il nuovo proprietario), quando proviamo a stampare <code>b1</code> dopo il movimento, il compilatore ci blocca.
Ci suggerisce anche un modo per risolvere, qualora proprio volessimo tenere sia <code>b1</code> che <code>b2</code>: clonare <code>b1</code>.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn main() {
    let b1 = Box::new(5);
    let b2 = b1.clone();
    
    println!("b1: {}", b1);
    println!("b2: {}", b2);
}</code></pre></pre>
</blockquote>
<blockquote>
<p>üí° <strong>Copy vs Clone ‚Äî Part 1</strong></p>
<p><img src="images/keep_in_mind/image%205.png" alt="image.png" /></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec1.clone();    // vec2 is a deep copy of vec1
    let vec3 = vec2;            // vec2 data is moved to vec3
    
    println!("{:?}", vec1);     // OK
    println!("{:?}", vec2);     // ERROR!!!
}</code></pre></pre>
<p>Nell‚Äôesempio sopra, vediamo che possiamo clonare o spostare un Vec, ma non possiamo semplicemente copiarlo.
Questo √® vero per Vec, ma anche per qualsiasi tipo complesso come ad esempio delle struct custom con campi complessi all‚Äôinterno, e in generale per tutti quei tipi che necessitano di una gestione della memoria dinamica, e che dunque devono implementare il tratto <code>Drop</code>.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Copy vs Clone ‚Äî Part 2</strong></p>
<p><img src="images/keep_in_mind/image%206.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%207.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Mutabilit√†</strong></p>
<p>La mutabilit√† √® una caratteristica del <em>possessore</em>, non del <em>dato</em>.
Dunque se ad esempio avessi una funzione che crea un Box, e inizialmente questo √® immutabile, e poi restituisco questo Box al chiamante, che lo memorizza in una variabile, questa sarebbe il nuovo possessore del Box, che pu√≤ quindi decidere di mutarlo.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn makeBox(a: i32) -&gt; Box&lt;(i32, i32)&gt; {
    let r = Box::new( (a, 1) );
    return r;
}

fn main() {
    let mut b = makeBox(5); // OK
    b.0 = b.0 + 1;
    
    println!("{:?}", b);
}</code></pre></pre>
</blockquote>
<blockquote>
<p>üí° <strong>Movimento, stack ed heap</strong></p>
<p>Il movimento provoca una copia bit a bit di ci√≤ che c‚Äô√® sullo stack.
Quello che sta sullo heap non √® coinvolto nell‚Äôoperazione di movimento.</p>
<p><img src="images/keep_in_mind/image%208.png" alt="image.png" /></p>
<p>Ad esempio, supponiamo si avere un <code>Vec</code> che punta sullo heap a quella sequenza di interi. Se scrivessi <code>let v2 = v;</code>, sullo stack si creerebbe <code>v2</code>, cio√® un nuovo <code>Vec</code>, al cui interno troveremmo: nel primo campo <strong>lo stesso puntatore</strong> alla sequenza di interi, nel secondo campo <strong>la stessa capacity 8</strong>, e nel terzo campo <strong>la stessa size 5</strong>.</p>
<p>A questo punto il Vec originale <code>v</code> <strong>√® ancora presente sullo stack</strong>, ma √® ora inaccessibile: ha perso diritti e doveri sullo spazio allocato sull‚Äôheap.</p>
<p>Una volta usciti dallo scope sintattico, sia <code>v</code> che <code>v2</code> verranno egettate dallo stack, ma con una importante differenza: <code>v2</code> si occuper√† di rilasciare lo spazio sull‚Äôheap, mentre <code>v</code> non deve fare niente (questo meccanismo ‚Äî il fatto che v2 deve rilasciare, mentre v no ‚Äî lo gestisce il compilatore).</p>
</blockquote>
<blockquote>
<p>üí° <strong>Valori temporanei e riferimenti</strong></p>
<p><img src="images/keep_in_mind/image%209.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2010.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Spostare un puntatore in Rust</strong></p>
<p><img src="images/keep_in_mind/image%2011.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2012.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2013.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2014.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2015.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2016.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2017.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>I riferimenti implementano Copy</strong></p>
<p><img src="images/keep_in_mind/image%2018.png" alt="image.png" /></p>
<p>Output:</p>
<p><img src="images/keep_in_mind/image%2019.png" alt="image.png" /></p>
<p>Vediamo che <code>pt1</code> e <code>pt2</code> sono due puntatori distinti: puntano allo stesso indirizzo di memoria (l‚Äôindirizzo dove √® contenuto <code>x</code>), ma hanno indirizzi diversi. Dunque nel momento in cui abbiamo fatto <code>let pt2 = pt1</code>, abbiamo creato un nuovo reference ex novo, senza movimento.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Rc ‚Äî downgrade &amp; upgrade</strong></p>
<p><img src="images/keep_in_mind/image%2020.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2021.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2022.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Cell<T></strong></p>
<p><img src="images/keep_in_mind/image%2023.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2024.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Polimorfismo: <em>tipi generici</em> vs <em>oggetti tratto</em></strong></p>
<p><img src="images/keep_in_mind/image%2025.png" alt="image.png" /></p>
<p><strong>Tipi generici e Monomorfizzazione</strong>
Quando scriviamo del codice con tipi generici, al momento della compilazione Rust applica un processo di <em><strong>monomorfizzazione</strong></em>: una volta che il compilatore comprende qual √® il tipo concreto su cui deve eseguire il codice scritto con le metavariabili, genera il codice ottimizzato per quel tipo concreto. Quindi, se ad esempio abbiamo scritto una funzione con parametri generici, e poi la richiamiamo una volta su degli interi, e una volta su delle stringhe, a compile time verranno generate due versioni della stessa funzione: una ottimizzata per gli interi, l‚Äôaltra ottimizzata per le stringhe.</p>
<p>In ogni caso, √® possibile applicare dei vincoli su quali possano essere questi tipi concreti che andranno a sostituirsi alle metavariabili, specificando su queste quali sono i tratti che il tipo concreto deve implementare (<em><strong>Trait Bound</strong></em>).</p>
<p>Ad esempio <code>struct MyStruct&lt;T: Copy&gt; {copy_data: T, ... }</code> indica che questa struct accetta tra i suoi campi una variabile generica <code>copy_data</code>, il cui tipo deve implementare il tratto <code>Copy</code>.</p>
<ul>
<li><strong>Vantaggi</strong>:
<ul>
<li>Performance a runtime</li>
<li>Ottimizzazione del codice generato per la funzione</li>
<li><em>Code inlining</em> per limitare l‚Äôimpatto delle chiamate a funzione</li>
<li>Consente di esprimere vincoli pi√π complessi sui tratti</li>
</ul>
</li>
<li><strong>Svantaggi</strong>: codice generato dal compilatore di dimensioni maggiori (di fatto generiamo una versione della stessa funzione per ogni tipo concreto su cui la invochiamo).</li>
</ul>
<p><strong>Oggetti tratto</strong>
Gli oggetti tratto, d‚Äôaltro canto, consentono di rimandare a runtime la determinazione della funzione da chiamare, invece di doverla determinare a compile time. Infatti, attraverso la vtable del tipo concreto passato a runtime viene chiamata l‚Äôimplementazione di quella funzione offerta dal tipo concreto, specificata nella sua vtable.
Alla funzione viene dunque passato un oggetto tratto: un fat pointer che √® composto dal puntatore al dato concreto, e un puntatore alla vtable del tipo concreto.</p>
<ul>
<li><strong>Vantaggi:</strong>
<ul>
<li><strong>Codice pi√π compatto</strong>: quando scriviamo una funzione che usa oggetti tratto, siamo sicuri che il codice della funzione generato dal compilatore √® unico, ed √® proprio quello l√¨ che abbiamo scritto, a prescindere dal tipo concreto che verr√† passato alla funzione</li>
<li><strong>Un oggetto tratto √® un fat pointer, che pu√≤ puntare a dati di tipo diverso</strong>, e dunque di dimensione diversa. Per√≤ alla funzione/struttura passiamo sempre e solo un fat pointer da 16 byte (per architettura 64bit).</li>
<li><strong>Utile quando dobbiamo memorizzare in una collezione</strong> <strong>tipi diversi</strong>, ma che implementano un tratto comune.
Questo viene facile perch√® appunto memorizziamo semplicemente dei riferimenti a degli oggetti che implementano quel tratto l√¨, mentre nella programmazione generica avremmo dovuto usare una metavariabile <code>T: Some_trait</code>, che avrebbe implicato che <em><strong>tutti</strong></em> gli oggetti della collezione devono essere dello stesso tipo <code>T</code></li>
</ul>
</li>
<li><strong>Svantaggi:</strong>
<ul>
<li>Non tutti i tratti permettono di definire oggetti tratto (occorre che nessun metodo del tratto non si usi <code>self</code> come parametro o tipo di ritorno, ma solo <code>&amp;self</code> e <code>&amp;mut self</code>)</li>
<li>Non √® possibile definire un oggetto tratto legato a pi√π tratti disgiunti (invece con i tipi generici possiamo vincolarli a pi√π tratti!)</li>
<li>Chiamata del metodo pi√π dispendiosa e lenta: passa attaverso la vtable</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>üí° <strong>Puntatori e gestione della memoria in Rust</strong></p>
<p>I puntatori consentono di fare tantissime cose, ad esempio quando dobbiamo passare una struttura dati ad una funzione, possiamo passare un puntatore alla struttura, piuttosto che copiare la struttura intera. In pratica, ci d√† un modo efficiente per avere dei riferimenti a dei dati.</p>
<p>Tuttavia, un uso sbagliato dei puntatori (in linguaggi che ne consentono la manipolazione senza espliciti meccanismi che ne rendano sicuro l‚Äôutilizzo) pu√≤ portare a dei comportamenti indesiderati: gli undefined behaviours.</p>
<p>Tra questi troviamo:</p>
<ul>
<li><strong>Wild pointer</strong>
Se non inizializziamo un puntatore con un indirizzo valido, ma piuttosto lo usiamo cos√¨ com‚Äô√®, potremmo leggere o scrivere in un indirizzo qualsiasi: dipende da cosa c‚Äôera scritto nello stack al momento in cui abbiamo dichiarato il puntatore, senza inizializzarlo.</li>
<li><strong>Dangling pointer</strong>
Puntatore che punta ad una zona di memoria che per√≤ era stata rilasciata: ad esempio l‚Äôindirizzo di una variabile uscita di scope. Il puntatore dunque non √® pi√π valido, perch√® la variabile √® stata rilasciata, l‚Äôinformazione quindi non √® pi√π valida e la zona puntata ora potrebbe contenere qualsiasi altra cosa.</li>
<li><strong>Memory leakage</strong>
Se acquisiamo della memoria dinamica, e otteniamo il puntatore al blocco di memoria dinamica, ma poi non lo rilasciamo pi√π, nel momento in cui il puntatore esce di scope non solo non avremo rilasciato la memoria, ma perderemo anche l‚Äôinformazione di <em>dove</em> era quel blocco di memoria acquisito.
In pratica, quel blocco non pu√≤ essere rilasciato: abbiamo creato un buco nella memoria.</li>
<li><strong>Double free</strong>
Se abbiamo ad esempio due puntatori che puntano allo stesso blocco di memoria, e proviamo a fare un doppio rilascio, provochiamo danni nelle strutture dati che mantengono l‚Äôorganizzazione della memoria.</li>
</ul>
<p>Inoltre, in linguaggi come C i puntatori non hanno informazioni che rendano esplicito se chi li usa √® anche responsabile del rilascio della memoria puntata: insomma, il possesso del dato puntato non √® chiaro.</p>
<p>Per risolvere questi problemi, Rust combina due cose: da un lato l‚Äôutilizzo di svariati tipi di puntatori, ciascuno con un determinato scopo e determinate caratteristiche (abbiamo puntatori che posseggono, puntatori che non posseggono, puntatori che possono solo leggere, oppure puntatori che possono leggere e scrivere ma nel frattempo non possono esserci altri riferimenti allo stesso dato, oppure ancora puntatori che consentono un possesso condiviso, tenendo all‚Äôinterno del puntatore stesso le informazioni di in quanti conoscono quel dato etc‚Ä¶), dall‚Äôaltro l‚Äôutilizzo di un modulo del compilatore chiamato <strong>Borrow Checker</strong>, che facendo un‚Äôanalisi formale e logica del codice garantisce che non esista alcuna possibilit√† che le regole sul possesso e sui prestiti siano violate.</p>
<p>Rust implementa il paradigma RAII: <em>Resource Acquisition Is Initialization</em>, che in pratica stabilisce che chi acquisisce un dato diventa responsabile della sua inizializzazione, e anche della sua distruzione (e quindi del rilascio di memoria dinamica, laddove previsto).
In pratica, il dato √® posseduto da una e una sola variabile, e quando ad esempio proviamo ad assegnare una variabile ad un‚Äôaltra solo due sono le possibilit√†:</p>
<ul>
<li>Il dato viene <strong><em>moss</em>o</strong> nella nuova variabile, e quella vecchia diventa inaccessibile</li>
<li>Il dato viene <em><strong>copiato</strong></em>, generando una copia totalmente separata dal dato originale</li>
</ul>
<p>Oppure, il dato pu√≤ essere <em><strong>clonato</strong></em> (se non pu√≤ essere copiato, ma solo mosso), ma questa operazione deve essere resa esplicita dal programmatore.</p>
<p>Quando la variabile che possiede il dato arriva alla fine del suo ciclo di vita, questa dovr√† occuparsi del rilascio del dato posseduto: in Rust questo viene fatto attraverso l‚Äôimplementazione del tratto <code>Drop</code>, infatti i tipi di dati che necessitano particolari operazioni di rilascio (rilascio di blocco di memoria, chiusura di un file, chiusura di un socket etc‚Ä¶) devono implementare questo tratto.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Borrow Checker</strong></p>
<p>Il <strong>Borrow Checker</strong> √® uno dei meccanismi centrali del compilatore Rust, e ha il compito di <strong>verificare che il codice rispetti le regole di possesso (ownership) e prestito (borrowing)</strong> dei dati. Questo sistema consente di scrivere <strong>codice sicuro in modo automatico, senza bisogno di garbage collector o analisi a runtime</strong>.</p>
<p>Il Borrow Checker analizza il codice <strong>durante la compilazione</strong> per assicurarsi che:</p>
<ul>
<li><strong>Ogni valore abbia un solo proprietario (owner)</strong>, che √® responsabile della sua validit√† e distruzione.
Controlla chi √® che possiede un certo dato, se, quando e a chi questo venga ceduto, rendendo impossibile l‚Äôaccesso alla variabile che lo deteneva in origine etc‚Ä¶</li>
<li><strong>Esistano regole chiare per il ‚Äúprestito‚Äù del dato</strong>:
<ul>
<li>√à possibile avere <strong>pi√π prestiti immutabili</strong> (&amp;T) <strong>oppure uno solo mutabile</strong> (&amp;mut T), <strong>mai entrambi contemporaneamente</strong>.</li>
<li>Un riferimento (prestito) <strong>non pu√≤ sopravvivere pi√π a lungo del dato originale</strong>.#</li>
</ul>
</li>
</ul>
<p><em>Perch√® √® utile?</em>
Con il Borrow Checker, Rust <strong>garantisce a compile-time</strong> che non esister√† mai un riferimento non valido. Questo:</p>
<ul>
<li>Elimina la necessit√† di una raccolta automatica della memoria (GC),</li>
<li>Garantisce sicurezza nella concorrenza (thread-safe by default),</li>
<li>Migliora le performance, perch√© evita runtime overhead.</li>
</ul>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="18-processi_parte_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="18-processi_parte_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
