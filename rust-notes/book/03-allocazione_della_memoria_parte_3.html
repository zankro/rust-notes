<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Allocazione della Memoria (Parte 3)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="allocazione-della-memoria---malnati-3"><a class="header" href="#allocazione-della-memoria---malnati-3">Allocazione della memoria - Malnati 3 <!-- omit in toc --></a></h1>
<h1 id="indice"><a class="header" href="#indice">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="#1-ciclo-di-vita-delle-variabili">1. Ciclo di vita delle variabili</a>
<ul>
<li><a href="#11-esempio-costruttore-e-distruttore">1.1 Esempio costruttore e distruttore</a></li>
</ul>
</li>
<li><a href="#2-allocazione-della-memoria">2. Allocazione della memoria</a></li>
<li><a href="#3-rilascio-della-memoria">3. Rilascio della memoria</a></li>
<li><a href="#4-puntatori">4. Puntatori</a>
<ul>
<li><a href="#41-indirizzo-valido">4.1 Indirizzo valido?</a></li>
<li><a href="#42-quanto-%C3%A8-grosso-il-blocco-puntato">4.2 Quanto √® grosso il blocco puntato?</a></li>
<li><a href="#43-fino-a-quando-%C3%A8-garantito-laccesso">4.3 Fino a quando √® garantito l‚Äôaccesso?</a></li>
<li><a href="#44-se-ne-pu%C3%B2-modificare-il-contenuto">4.4 Se ne pu√≤ modificare il contenuto?</a></li>
<li><a href="#45-occorre-rilasciarlo">4.5 Occorre rilasciarlo?</a></li>
<li><a href="#46-lo-si-pu%C3%B2-rilasciare-o-altri-conoscono-lo-stesso-indirizzo">4.6 Lo si pu√≤ rilasciare o altri conoscono lo stesso indirizzo?</a></li>
<li><a href="#47-viene-usato-come-modo-per-esprimere-lopzionalit%C3%A0-del-dato">4.7 Viene usato come modo per esprimere l‚Äôopzionalit√† del dato?</a></li>
</ul>
</li>
<li><a href="#5-rischi">5. Rischi</a>
<ul>
<li><a href="#51-esempi">5.1 Esempi</a>
<ul>
<li><a href="#511-dangling-pointer">5.1.1 Dangling Pointer</a></li>
<li><a href="#512-memory-leakage">5.1.2 Memory Leakage</a></li>
<li><a href="#513-double-free">5.1.3 Double free</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-gestire-i-puntatori">6. Gestire i puntatori</a></li>
</ul>
<h1 id="1-ciclo-di-vita-delle-variabili"><a class="header" href="#1-ciclo-di-vita-delle-variabili">1. Ciclo di vita delle variabili</a></h1>
<p><img src="images/allocazione_della_memoria_3/image.png" alt="image.png" /></p>
<p>Abbiamo cominciato a vedere la divisione tra stack e heap e abbiamo visto sostanzialmente come le variabili locali esistono nel contesto del blocco in cui sono definite.</p>
<p>Quando entro all'interno di un blocco e incontro la definizione di una variabile globale, questa comincia a esistere, viene allocata sullo stack, quando arrivo alla parentesi graffa corrispondente alla chiusura del blocco la variabile viene buttata via, perdendo il dato che aveva al suo interno.</p>
<p>In generale, adesso vogliamo focalizzarci sul controllo del ciclo di vita che ciascuna di variabili ha e di come noi andiamo a intervenire.</p>
<p>Allora, le variabili globali esistono da sempre, <strong>quindi prima che parta il main e cessano di esistere dopo che il main √® finito</strong>.
Sono accessibili in ogni momento e in generale se contengono del codice di inizializzazione, questo viene eseguito prima che il main parta.
Se contengono del codice di finalizzazione, questo viene eseguito dopo l'uscita del main.</p>
<p>L'altra caratteristica delle variabili globali √® che hanno un <strong>indirizzo assoluto</strong>, il compilatore sa gi√† dove le mette e quindi pu√≤, tutte le volte che incontra una variabile globale, scrivere gi√† <em>‚Äúquella l√¨ sta all'indirizzo 3b7f5942‚Äù</em>.</p>
<p>Le variabili locali, viceversa, incominciano a esistere quando si arriva alla loro definizione, cio√® alla riga dove compare quella variabile locale l√¨, int i=5, in quel momento comincia a esistere, cessano di esistere quando arrivo alla chiusura graffa corrispondente e hanno un indirizzo che √® <strong>relativo alla cima dello stack</strong>.</p>
<p>Quindi quando il compilatore genera il codice, per riferirsi a quella variabile locale l√¨, tendenzialmente dice <code>base_ptr+27</code>, <code>base_ptr+32</code>, qualcosa del genere, dove <code>base_ptr</code> √® un registro ausiliario, nel caso dell'x86, che serve a contenere una copia dell‚Äôindirizzo dello stack all'inizio della funzione stessa, in modo da poter definire questo ‚Äúoffset‚Äù relativo da cui partire.</p>
<p><img src="images/allocazione_della_memoria_3/image%201.png" alt="image.png" /></p>
<p>Le variabili locali hanno un valore iniziale casuale.
Se io dichiaro solo <code>int i</code> e non gli assegno direttamente un valore di inizializzazione, lo stack si abbassa di 4 byte e cosa c'√® in quello spazio nello stack? Quello che c‚Äô√®.</p>
<p>Non sono in grado di prevedere il suo contenuto.</p>
<p><img src="images/allocazione_della_memoria_3/image%202.png" alt="image.png" /></p>
<p>Poi abbiamo le variabili dinamiche, cio√® sono quelle che contengono un dato e che noi possiamo referenziare solo tramite puntatori.
Tocca al programmatore controllare nel ciclo di vita.</p>
<p>Una variabile dinamica comincia a esistere nel momento in cui io esplicitamente la alloco, e cessa di esistere quando la rilascio.</p>
<p>Come si fanno allocazione e rilascio?
Dipende dal linguaggio.</p>
<p>Se sto scrivendo del codice in C, l'allocazione si fa con <code>malloc</code>, o le sue funzioni parenti <code>calloc</code>, <code>realloc</code>, e il rilascio si fa con <code>free</code>.</p>
<p>Se sto lavorando in C++, che mi d√† un supporto pi√π avanzato alla gestione dei tipi, l'allocazione dinamica si fa con l'operatore <code>new</code> e il rilascio si fa con l'operatore <code>delete</code>.
Se ho una classe di tipo <code>automobile</code>, che rappresenta un veicolo, posso dire, la mia variabile <code>auto* a = new auto;</code>.</p>
<p>L'effetto di scrivere new auto √® duplice.
Viene cercato sullo heap un blocco di memoria grande quanto serve a contenere un'automobile. Quanto ne serve dipende da come √® definita quella classe, da quanti campi internamente avr√†.</p>
<p>Subito dopo, trovato questo blocco, viene invocato il <strong>costruttore della classe</strong>, che si occupa di riempire quel blocco con i dati iniziali.</p>
<p>Esattamente come in Java, in C++ le classi hanno dei costruttori che ci permettono di garantire che la memoria sia inizializzata correttamente.</p>
<p><em>Come rilasciamo i blocchi di memoria che allochiamo dinamicamente?</em>
Li rilascio con <code>delete</code>.</p>
<p><em>Cosa succede quando chiamo delete?</em>
Anche qui due cose.</p>
<p>Prima di tutto <strong>viene chiamato il <em>distruttore</em></strong>.
<em>Cos'√® il distruttore?</em>
√à un particolare metodo che il C++ ci mette a disposizione, all'interno del quale noi possiamo scrivere cosa fare nel momento in cui la variabile cessa di esistere.
Il distruttore ci √® utile quando una classe contiene, all'interno dei propri campi, delle risorse che devono essere lasciate.</p>
<p>Ad esempio, io potrei avere una classe che gestisce un file, il costruttore potrebbe essere responsabile di aprire il file, il distruttore √® responsabile di chiudere il file.</p>
<p>Cos√¨ sono tranquillo che quando quell'oggetto cessa di esistere, il file sar√† chiuso.</p>
<p>Il costruttore lo chiamate <em><strong>voi</strong></em> esplicitamente nel momento in cui fate <code>new</code> o semplicemente dichiarate una variabile di quel tipo, il distruttore viene chiamato esclusivamente dal <em><strong>compilatore</strong></em>.</p>
<p>Viene chiamato, in qualche modo, sotto il vostro diretto controllo quando fate <code>delete</code>, per cui lui distrugge e poi rilascia la memoria, cio√® notifica che quel gruppo di byte pu√≤ essere riusato per altro.
Nel caso delle variabili locali viene chiamato nel momento in cui la variabile viene egettata.</p>
<h2 id="11-esempio-costruttore-e-distruttore"><a class="header" href="#11-esempio-costruttore-e-distruttore">1.1 Esempio costruttore e distruttore</a></h2>
<p>Facciamo una prova velocissima per renderci conto di questa cosa qua.</p>
<p><img src="images/allocazione_della_memoria_3/image%203.png" alt="image.png" /></p>
<p>Vediamo che il programma parte, mi stampa ‚Äúmain()‚Äù.
Subito dopo aver chiamato main, e subito dopo aver fatto la stampa, dichiara la variabile <code>t</code> di tipo <code>Test</code>, che quindi viene automaticamente costruita, e qui mi dice <em>‚Äúl‚Äôho costruito all‚Äôindirizzo 16db8353b‚Äù</em>, poi va avanti, stampa ‚Äúfine main()‚Äù, e poi esegue return 0, chiusa graffa.</p>
<p>In corrispondenza di quella chiusa graffa l√¨, lui dice ‚Äú<em>devo pulire lo stack</em>‚Äù<em>.</em>
Cosa c‚Äôera nello stack?
Avevo un oggetto <code>Test</code>, quindi automaticamente invoca il distruttore, e vediamo ‚Äúdistrutto Test‚Äù, proprio a quell‚Äôindirizzo l√¨.</p>
<p><img src="images/allocazione_della_memoria_3/image%204.png" alt="image.png" /></p>
<p><em>Cosa succede se facciamo cos√¨?</em></p>
<p>Parte dal main, inizia il ciclo for, all‚Äôinterno del ciclo for dichiaro la variabile <code>t</code>, che viene costruita, viene costruita dove?</p>
<p>Abbassando leggermente lo stack, e quindi sta all‚Äôindirizzo 37, quello che finisce con 37.
Poi subito dopo stampa iterazione numero 0, e arriva la chiusa graffa, dove test finisce, e quindi che cosa fa? Distrugge l‚Äôoggetto <code>t</code>.</p>
<p>E chiaramente l‚Äôha costruito all‚Äôindirizzo 37, e lo distrugge all‚Äôindirizzo 37, quindi lo stack risale un po‚Äô, poi torna a fare l‚Äôiterazione successiva.</p>
<p>Dice ‚Äú<em>ah, ho bisogno di un Test</em>‚Äù, riabbassa lo stack, stampa iterazione numero 1, rialza lo stack, e lo fa tre volte.</p>
<p>Poi arriva al fondo, stampa ‚Äúfine del main‚Äù, chiusa.</p>
<p>Quindi, vediamo che, dichiarata dentro un ciclo for, la variabile viene creata tante volte quante sono le iterazioni del ciclo, e viene distrutta al termine dell‚Äôiterazione del ciclo.</p>
<p><img src="images/allocazione_della_memoria_3/image%205.png" alt="image.png" /></p>
<p>Se io dichiarassi anche una variabile globale, <code>Test t1</code>, vedete che questa volta dice <em>‚Äúho costruito un Test all‚Äôindirizzo 1000a8000‚Äù</em>, prima ancora di chiamare main.</p>
<p>Perch√©? Perch√© il costruttore delle variabili globali parte prima che inizi il main!</p>
<p>Fa tutte le sue cose, mi dir√† ‚Äúfine main‚Äù, e poi mi distrugge quella parte l√¨.</p>
<p>Qui non riusciamo bene a distinguere che cosa avviene dove e quando, perch√© anche prima ci stampava ‚Äúdistrutto‚Äù dopo aver scritto ‚Äúfine del main‚Äù, perch√© noi la scritta ‚Äúfine del main‚Äù non la possiamo mettere in corrispondenza del chiusa graffa, possiamo solo metterla in corrispondenza subito prima del chiusa graffa, quindi la vera distruzione avviene tra la stampa e il chiusa graffa, se fosse locale.</p>
<p>Quella globale avviene dopo il chiusa graffa.</p>
<p>Comunque, sostanzialmente le cose sono fatte cos√¨.</p>
<p>Tutte queste sono variabili che hanno un ciclo di vita ben definito.</p>
<p><img src="images/allocazione_della_memoria_3/image%206.png" alt="image.png" /></p>
<p><em>Cosa succede se noi invece allocassimo delle cose dinamicamente?</em></p>
<p>Scritto in questo modo, <code>new Test()</code> dice <em>‚Äúquesta variabile non deve stare nello stack, deve stare nello heap e la voglio tenere fin quando mi viene comoda‚Äù</em>.</p>
<p>Ad esempio, dentro il ciclo for potrei dire <code>if i==1 delete pt</code>.
Quindi invece di far coincidere la vita di questa variabile con un blocco, la creo prima del for e la distruggo a met√† delle iterazioni del for.</p>
<p>Quindi avr√≤ delle iterazioni del for in cui quella variabile l√¨ non √® pi√π valida.</p>
<p>Parte, √® sempre costruita la variabile globale t1 che questa volta parte all‚Äôindirizzo 1049d8000, poi viene stampato ‚Äúmain()‚Äù, e poi viene stampato <code>Costruito Test @ 0x600000744040</code>, e notiamo che l‚Äôindirizzo √® totalmente diverso: 60000744040.</p>
<p>Questo perch√© vive in una zona totalmente distinta, nell‚Äôheap!</p>
<p>Poi c‚Äô√® l‚Äôiterazione numero 0, poi dovrebbe arrivare nell‚Äôiterazione numero 1 e in effetti ci entra ma subito prima della stampa viene eseguita la delete.</p>
<p>Poi fa l‚Äôiterazione numero 2, il ciclo for finisce, finisce il main, ma c‚Äô√® ancora una variabile globale, che quindi viene buttata via invocando il distruttore.</p>
<p>Quindi le variabili possono avere un codice di inizializzazione, lo chiamiamo <strong>costruttore</strong>, possono avere un codice di rilascio, che chiamiamo <strong>distruttore</strong>.</p>
<p>Il costruttore implicitamente lo andiamo a chiamare nel momento in cui mettiamo in gioco la variabile, il distruttore √® sempre solo chiamato dal compilatore: noi non abbiamo nessuna chiamata <code>~Test()</code>.</p>
<p>E viene chiamato nel momento giusto, quando quella variabile cessa di esistere.</p>
<p><img src="images/allocazione_della_memoria_3/image%207.png" alt="image.png" /></p>
<p>Quindi le variabili dinamiche hanno un indirizzo che √® assoluto.
Peccato che non si pu√≤ sapere a compile time, solo a run time me lo verr√† detto, quando io invoco <code>new *qualcosa*</code>, in quel momento verr√† cercato un posto grande a sufficienza per far stare la mia variabile.</p>
<p>E accedo alle variabili dinamiche solo tramite puntatori, mentre alle altre accedo con variabili che hanno un nome.</p>
<p>Il fatto che sia inizializzato o meno il valore iniziale dipende da cosa ho scritto nel costruttore, dipende anche dal linguaggio.
Se faccio <code>malloc</code>, malloc non mi d√† garanzie di inizializzazione, mi prende un blocco grande quanto gli chiedo, ad esempio 84, e lui mi cerca 84 byte, ma non √® che li pulisce, mi d√† il puntatore al primo di 84 byte e basta, dentro ci pu√≤ essere qualunque cosa.</p>
<p>Quando faccio in C++ <code>new</code>, new passa attraverso il costruttore che di solito si prende la briga di inizializzare le cose.</p>
<p>Chiaramente perch√© possano funzionare le variabili dinamiche ci vuole un sistema di supporto, quando io chiamo <code>malloc</code> o <code>new</code>, come fa l‚Äôimplementazione di <code>malloc</code> o <code>new</code> a darmi un indirizzo?</p>
<p>Deve cercare!
Vuol dire che internamente <code>malloc</code> e <code>new</code> sono in realt√† delle funzioni sofisticate che si appoggiano a una loro rappresentazione della memoria, sanno che per esempio all‚Äôinizio lo heap va dall‚Äôindirizzo 60000 all‚Äôindirizzo 70000, prendiamo dei numeri a caso, ed √® tutto libero, quindi alla domanda <em>‚Äúdammene un pezzo‚Äù</em> magari vi danno l‚Äôinizio, poi dopo un po‚Äô chiedo un altro pezzo, mi danno quello che viene subito dopo, poi magari gli rilascio il pezzo iniziale e a questo punto l‚Äôheap che prima era tutto bello compatto √® diventato con un buchino.</p>
<p>Quando gli chieder√≤ un‚Äôaltra cosa, probabilmente cercheranno se tra i rotti c‚Äô√® un pezzo piccolo dove ci sta gi√† quello che io gli chiedo, perch√©?</p>
<p>Perch√© vale il principio che se posso uso gli sfridi, non vado a intaccare il pezzo grosso.</p>
<p>Chiaramente andare a cercare qual √® il punto pi√π conveniente pu√≤ essere lento, perch√© io ho tante alternative, potrei accontentarmi della prima ma non √® detto che la prima sia la pi√π furba.</p>
<p>Probabilmente <code>malloc</code> e <code>new</code> possono tenersi i loro pezzettini organizzati in tanti modi, il modo pi√π becero √® una lista, per√≤ se √® una lista per sapere quale pezzettino pi√π adatto la devo visitare tutta, e quella lista pu√≤ essere molto lunga, ci mette un mucchio a saperlo, oppure posso tenerla organizzata ad albero, √® molto pi√π articolata, tengo un albero dove parto da un punto medio, a destra metto i pezzi piccoli, a sinistra metto i pezzi grandi e cos√¨ via, quella potrebbe essere un‚Äôaltra strategia.</p>
<p>L‚Äôunico problema √® che quando io seguo un pezzo devo ribilanciarmi l‚Äôalbero, perch√© adesso mi sono trovato un pezzettino, uno sfridino piccolo che deve andare da qualche parte e devo andare a spostare, oppure quando qualcuno mi restituisce se riesco a compattare devo fare un pezzo grosso.</p>
<p>Quindi le operazioni di allocazione e rilascio sono potenzialmente operazioni lente e complesse, che richiedono di tenere allineate un mucchio di cose, consumano.</p>
<p>Se <code>malloc</code> deve farsi l‚Äôalbero vuol dire che una parte della memoria che globalmente ha a disposizione la usa per se stesso e non la potr√† mai dare al programma ‚Äî pi√π √® sofisticata quella struttura l√¨ fatta di puntatori, mappe, tabelle e schifezze di ogni tipo, meno sar√† la memoria per il programma.
Probabilmente sar√† pi√π efficiente nel comportamento, ma c‚Äô√® un bilanciamento da trovare.</p>
<p><em>Cosa succede quando il programmatore chiama</em> <code>free</code> <em>piuttosto che</em> <code>delete</code><em>?</em>
Restituisce quel pezzettino che aveva ricevuto.</p>
<p>Che cosa se ne fa la funzione <code>free</code> o la funzione <code>delete</code>?
Va a vedere nell‚Äôalbero, nella lista, in generale nella struttura dati se questo pezzettino A √® suo o meno, perch√© io potrei fare il furbo ‚Äî ad esempio se <code>malloc</code> mi dava gli indirizzi da 60.000 a 70.000 e io gli d√≤ un indirizzo che √® 1.000, ma lui mi dir√† che non √® mio.</p>
<p>Supponendo che sia suo va a cercare se quel pezzettino l√¨ gli risultava come occupato e lo deve marcare come libero e possibilmente lo deve accorpare ad altri pezzi liberi e adiacenti, in modo da fare un pezzo pi√π grosso.</p>
<p>Cosa succede se gli restituisco un pezzo, e poi senza averglielo chiesto, glielo restituisco di nuovo?
Cio√® se io nel programma che ho scritto, l√† dove ho messo <code>delete</code>, mettessi <code>delete</code> due volte?
La prima volta tutto bene, prende quel pezzo e lo mette a suo posto.</p>
<p>La seconda volta dipende come √® implementata.
Un‚Äôimplementazione di <code>delete</code> molto lenta ma attenta potrebbe rigettarmelo dicendo <em>‚Äúche √® sta roba? No, non va bene‚Äù</em>.
Un‚Äôimplementazione un po‚Äô pi√π veloce, che magari √® pi√π desiderabile perch√© io ho bisogno di fare tante <code>new</code> e tante <code>delete</code> nell‚Äôarco della vita del mio programma, potrebbe prendere per buono che quell‚Äôindirizzo che gli passo sia effettivamente indirizzo in uso e aggiornare le sue strutture dati.</p>
<p>Peccato che le strutture erano gi√† aggiornate, e quindi si spacca tutto.
E a quel punto l√¨ alle prossime richieste a <code>new</code> non ci capisce niente.</p>
<p>Se io non rilascio, resta il buco.
Se io rilascio due volte, spacco.</p>
<p>Se poi rilasci una cosa sbagliata, supponiamo, gli ho chiesto un indirizzo e lui mi ha dato 6.300, io gli restituisco 6.500, che √® solo un pezzo. Potrebbe non accorgersene, ma a quel punto fa casino totale. Qui la grande responsabilit√† del programmatore √® di fare le operazioni giuste.</p>
<h1 id="2-allocazione-della-memoria"><a class="header" href="#2-allocazione-della-memoria">2. Allocazione della memoria</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%208.png" alt="image.png" /></p>
<p>In C abbiamo <strong><code>malloc</code></strong> che ci restituisce un void asterisco, cio√® un puntatore opaco, un puntatore ad una cosa qualunque. Prende come parametro un numero di byte e ci restituisce, se pu√≤, un puntatore valido.</p>
<p><strong><code>Calloc</code></strong> che prende in ingresso un numero di byte e un moltiplicatore.
Serve per fare gli array. Ad esempio, ho bisogno di un array di 25 automobili. Fornisco quanti elementi voglio, e quanto √® grande un elemento di tipo auto, ad esempio 16 byte.
Quindi devo dare 25 x 16, 400 byte.</p>
<p><strong><code>Rialloc</code></strong> √® particolare, dice ‚Äú<em>cara malloc, tu mi avevi dato questo puntatore, guarda, adesso me serve uno un po‚Äô pi√π grande‚Äù</em>, oppure <em>‚Äúmi serve un po‚Äô pi√π piccolo‚Äù</em>.</p>
<p>Un po‚Äô pi√π grande, non √® detto sempre, un po‚Äô pi√π piccolo √® facile. Vuol dire che lei si segna che c‚Äô√® un pezzo in fondo che √® diventato libero.</p>
<p>Un po‚Äô pi√π grande √® pi√π complicato, perch√© non √® detto che al fondo ci sia ancora spazio. Quindi Rialloc non sempre funziona: se fallisce restituisce null.
Dice <em>‚Äúguarda, quello che avevi √® ancora buono, per√≤ non posso dartene di pi√π, non ce l‚Äôho o non ce l‚Äôho l√¨, devo spostarlo‚Äù</em>.</p>
<p><img src="images/allocazione_della_memoria_3/image%209.png" alt="image.png" /></p>
<p>In C++ invece abbiamo un <code>new</code> che prende il nome del tipo ed eventualmente tra parentesi gli argomenti.</p>
<p>Le parentesi nella versione vecchia del C++ erano sempre tonde, nella versione moderna del C++ sono graffe, perch√© questo semplifica, toglie delle ambiguit√† possibili.</p>
<p>Nel C++ potete fare <code>new</code> del tipo e basta, oppure <code>new[]</code>.
New con le quadre serve per gli array, pi√π o meno ha la stessa differenza che c‚Äô√® tra malloc e calloc in C.</p>
<p><img src="images/allocazione_della_memoria_3/image%2010.png" alt="image.png" /></p>
<p>Se allocate un array, specifichiamo quanti elementi vogliamo e lui inizializza tanti pezzi uno di fianco all‚Äôaltro.</p>
<h1 id="3-rilascio-della-memoria"><a class="header" href="#3-rilascio-della-memoria">3. Rilascio della memoria</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2011.png" alt="image.png" /></p>
<p>Se avete ottenuto il puntatore con una certa funzione, dovete rilasciarlo con la funzione <em><strong>duale</strong></em>.</p>
<p>Le cose create con <code>malloc</code>, <code>calloc</code>, <code>realloc</code> si rilasciano con <code>free</code>.</p>
<p>Le cose allocate con <code>new</code> si rilasciano con <code>delete</code>.
Le cose allocate con <code>new[n]</code> vengono rilasciate con <code>delete[]</code>.</p>
<p>√à necessario fare cos√¨, perch√© altrimenti il compilatore non capisce.</p>
<p>Se il blocco non viene rilasciato si crea una perdita di memoria, se invece viene rilasciato due volte si spacca tutto: si corrompono le strutture dati che internamente vengono usate e poi di l√¨ in avanti √® assolutamente impossibile dire cosa capita.</p>
<h1 id="4-puntatori"><a class="header" href="#4-puntatori">4. Puntatori</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2012.png" alt="image.png" /></p>
<p>L‚Äôidea del puntatore non √® solo collegato alla memoria dinamica.</p>
<p>Certo, non c‚Äô√® altro modo in C e C++ di avere accesso a memoria dinamica se non tramite puntatori, perch√© il linguaggio vi pone questo.</p>
<p>In realt√† i puntatori sono presenti in tantissimi altri linguaggi (li abbiamo anche in javascript, in java, in python e cos√¨ via..), ma semplicemente non lo sapete, perch√© la cosa viene tenuta in qualche modo nascosta.
Quei puntatori l√¨ sono essenziali per l‚Äôottimizzazione degli algoritmi.</p>
<p>Perch√©? Perch√© se io devo passarti un dato, se quel dato √® piccolo va bene, me lo passi ‚Äî un intero ad esempio non √® un grosso problema.
Ma se io devo passarti, ad esempio, un array che contiene mille elementi, mica te lo posso copiare.</p>
<p>S√¨, in alcuni casi te lo copier√≤ se ho davvero bisogno di mantenere due informazioni disgiunte. Ma altrimenti √® onerosissimo.
L‚Äôidea di poterti passare il puntatore mi d√† un mucchio di efficienza, √® comodo.</p>
<p>Quindi, il fatto che io abbia lo spazio dinamico (quindi che posso chiedere quando mi serve e rilasciare quando mi serve, che √® gi√† un grande vantaggio perch√© posso chiedere delle cose grandi a piacere senza saperlo a priori, posso tenerle a lungo per quanto mi serve etc‚Ä¶) abilita un mucchio di cose che altrimenti non riuscirei a fare.</p>
<p>Una linked list, ad esempio, se non avete la memoria dinamica, non la potete fare.
Perch√© la linked list, ogni volta che aggiungete un elemento, ha bisogno di prenderne un pezzo in pi√π e di metterlo al fondo.</p>
<p>Per√≤ vi pone il problema di gestire correttamente il rilascio.</p>
<p>I puntatori, al di l√† dell‚Äôuso della memoria dinamica, servono comunque tantissimo e abilitano tanti meccanismi che adesso vediamo nel dettaglio.</p>
<p>Per√≤, se li usiamo male √® un disastro, perch√© portano gli <em><strong>undefined behaviours</strong></em> che hanno conseguenze disastrose.</p>
<p><img src="images/allocazione_della_memoria_3/image%2013.png" alt="image.png" /></p>
<p>Vediamo l‚Äôuso tipico dei puntatori.</p>
<p>Il pezzo pi√π semplice dell‚Äôuso dei puntatori, che non necessitano direttamente la memoria dinamica, √® banalmente quando io devo dare l‚Äôaccesso a una variabile senza dover copiare la variabile.</p>
<p>Io ho la variabile <code>A</code>, che vale 10, e voglio permettere a qualcun altro di andarci a guardare dentro.
Recupero dalla variabile il suo puntatore e passo il puntatore a chi gli interessa.
Quest‚Äôaltro, dereferenziando il puntatore, potr√† leggere cosa c‚Äô√® scritto in quella variabile, potr√† scrivere cosa c‚Äô√® scritto in quella variabile.</p>
<p>Questo √® un uso comunissimo.</p>
<p>Oppure posso avere dei puntatori che sono allocati per uno scopo particolare.
L√¨ ho <code>int* pB = new int{24}</code>, voglio un intero dinamico che inizialmente vale 24 e che potr√≤ cancellare in un qualche momento.
Magari lo dar√≤ a qualcun altro per cancellarlo al posto mio o cose del genere.</p>
<p>I puntatori possono essere resi esplicitamente <strong>invalidi</strong>.
La convenzione che viene assunta in C √® che un puntatore √® invalido se contiene il numero 0.
Il puntatore dentro di s√© non √® nient‚Äôaltro che un numero, √® l‚Äôoffset nello spazio virtuale di indirizzamento. Se io gli scrivo 0, per convenzione quello √® un puntatore invalido.
Nel linguaggio C si usa di solito la macro NULL, che √® definita come <code>((void*)0)</code>.
Nel C++ si usa la parola chiave <code>nullptr</code>.</p>
<p><em>Perch√© questo √® utile?</em>
Perch√© in certe situazioni avere dei puntatori nulli mi permette di capire che certe cose non continuano oltre quel puntatore nullo.</p>
<p>Pensate a una lista collegata: ho il puntatore al primo elemento, che contiene il puntatore al secondo elemento, che contiene il puntatore al terzo elemento, che finalmente contiene null ‚Äî vuol dire che finisce l√¨ la lista.</p>
<p>Quindi avere una convenzione che mi dice quando un puntatore smette di essere buono √® utile.
Altrimenti non implementereste tantissime cose.</p>
<p><img src="images/allocazione_della_memoria_3/image%2014.png" alt="image.png" /></p>
<p>Il problema √® che ci sono tante responsabilit√†.</p>
<h2 id="41-indirizzo-valido"><a class="header" href="#41-indirizzo-valido">4.1 Indirizzo valido?</a></h2>
<p>Quando io ricevo una variabile di tipo puntatore e ci guardo dentro, leggo un numero, ad esempio <code>3b7f5944</code>‚Ä¶ <em>posso dire se quel numero √® <strong>valido</strong>?</em></p>
<p>Se ci leggo 0 posso sicuramente dire che <strong>non √® valido.</strong></p>
<p>Ma se c‚Äô√® scritto <code>3b7f5944</code> potrebbe <em>essere stato valido</em>, ma magari io l‚Äôho appena rilasciato, e se dopo averlo rilasciato ci vado a scrivere ancora, potrei fare dei danni (perch√® magari ora quel blocco apparterrebbe a qualcun altro).</p>
<p>Nell‚Äôesempio di codice che abbiamo visto prima, nel ciclo for alla seconda iterazione buttavamo via la variabile dinamica <code>pt</code>, ma nella variabile <code>pt</code> mi era rimasto l‚Äôindirizzo a quel blocco di memoria che abbiamo rilasciato nel for.
E se dopo che ho fatto <code>delete</code> ci andassi a scrivere sopra, farei del danno.</p>
<p>Per cui se io vedo un numero diverso da 0 <strong>non posso sapere direttamente se quello l√¨ √® mai stato buono, √® buono o √® ancora buono</strong>.</p>
<p>Questo √® il primo grossissimo problema che abbiamo con i puntatori.</p>
<h2 id="42-quanto-√®-grosso-il-blocco-puntato"><a class="header" href="#42-quanto-√®-grosso-il-blocco-puntato">4.2 Quanto √® grosso il blocco puntato?</a></h2>
<p>Secondo problema, quanto √® grosso il blocco puntato?
Un puntatore √® un singolo numero che rappresenta <strong>un solo byte</strong>.
Da cosa capisco <em>quanti byte posso andare a vedere, a partire da quello puntato?</em>
Potremmo pensare dal tipo: se quello l√¨ √® un puntatore a <code>int</code>, supponendo che l‚Äôint sia di 4 byte, so che posso andare a guardare da quella cella l√¨ fino alle tre successive, se fosse buono.</p>
<p>Ma se io avessi alloccato un <code>int[]</code> array? Non posso sapere quanti <code>int</code> ci sono in quell‚Äôarray, quindi non so fino a dove posso leggere lecitamente‚Ä¶
E l‚Äôidea di andare a contare finch√© non trovo lo 0 √® un‚Äôidea peregrinissima, perch√© potrebbe non esserci lo 0 e magari finisco a leggere in zone che non sono mie‚Ä¶</p>
<p>Dunque, il tipo non mi d√† queste informazioni.
Dire che quello l√¨ √® un <code>char*</code> mi dice s√¨ che se vado alla fine di questo puntatore trover√≤ un char, ma quanti char non lo so.</p>
<aside>
üí°
<p><strong>From ChatGPT</strong></p>
<p><img src="images/allocazione_della_memoria_3/image%2015.png" alt="image.png" /></p>
</aside>
<h2 id="43-fino-a-quando-√®-garantito-laccesso"><a class="header" href="#43-fino-a-quando-√®-garantito-laccesso">4.3 Fino a quando √® garantito l‚Äôaccesso?</a></h2>
<p><em>Fino a quando √® garantito l‚Äôaccesso?</em>
Non lo sappiamo.</p>
<p>Se quello l√¨ √® un puntatore ad una variabile locale, √® garantito fino a che il codice che l‚Äôha allocata non ha raggiunto la graffa finale.
Ma se io ho copiato questo puntatore in una struttura, quando andr√≤ a dare la struttura in giro, non posso sapere se quella variabile l√¨ era gi√† finita di vivere o meno.
<strong>Ho perduto questa informazione.</strong></p>
<h2 id="44-se-ne-pu√≤-modificare-il-contenuto"><a class="header" href="#44-se-ne-pu√≤-modificare-il-contenuto">4.4 Se ne pu√≤ modificare il contenuto?</a></h2>
<p>Posso modificare il contenuto?
Non lo sappiamo.</p>
<p>Teoricamente il tipo di puntatore potrebbe aiutarmi.</p>
<p>C e C++ distinguono il <code>const T*</code> dagli <code>T*</code> ‚Äî <code>char*</code> mi dice <em>‚Äúquello √® un puntatore a caratteri che puoi modificare‚Äù</em>, <code>const char*</code> mi dice <em>‚Äúquello √® un puntatore a caratteri che non puoi modificare, che devi solo leggere‚Äù</em>.</p>
<p>Ma √® un po‚Äô debole come cosa, perch√© io posso castare e far diventare un <code>const char*</code> un <code>char*</code> semplice. E a quel punto non ne so pi√π niente se quella era una cosa che non dovevo toccare...</p>
<h2 id="45-occorre-rilasciarlo"><a class="header" href="#45-occorre-rilasciarlo">4.5 Occorre rilasciarlo?</a></h2>
<p><em>Sono responsabile del suo rilascio?</em>
Non lo sappiamo.</p>
<p>Dipende come √® nato quel puntatore.</p>
<p>Se io mi sono procurato quel puntatore dalla variabile <code>l</code> tramite l‚Äôoperatore <code>&amp;</code>, non sono responsabile, perch√© la variabile <code>l</code> ha il suo ciclo di vita predefinito, e quando arriver√† al fondo del suo blocco verr√† buttata via.</p>
<p>Ma se io invece mi sono procurato il puntatore con <code>new</code>, sono responsabile io del suo rilascio.</p>
<p>Peccato che non c‚Äô√® modo di capirlo.
S√¨ √® vero, abbiamo visto nell‚Äôesempio di prima che l‚Äôindirizzo di una zona nell‚Äôheap √® diverso dall‚Äôindirizzo di una zona nello stack, ma non posso guardare quella cosa l√¨, perch√© ogni volta che lancio il programma lo spazio di indirizzamento √® randomizzato e posso avere delle cose a caso.</p>
<p>Quindi non posso basarmi su questa informazione qua.</p>
<p>E i linguaggi C e C++ non mi danno nessun suggerimento per distinguere quello che √® un puntatore dello heap, di cui qualcuno si deve occupare di rilasciare, da quello che √® un puntatore allo stack, dove √® il linguaggio che garantisce il rilascio.</p>
<h2 id="46-lo-si-pu√≤-rilasciare-o-altri-conoscono-lo-stesso-indirizzo"><a class="header" href="#46-lo-si-pu√≤-rilasciare-o-altri-conoscono-lo-stesso-indirizzo">4.6 Lo si pu√≤ rilasciare o altri conoscono lo stesso indirizzo?</a></h2>
<p>Supponendo che io possa per qualche via traversa sapere che sono responsabile del rilascio, lo posso rilasciare in questo momento? O c‚Äô√® una copia di questo stesso puntatore in giro in casa di qualcuno che potrebbe andarci a guardare dentro?
Non lo sappiamo.</p>
<h2 id="47-viene-usato-come-modo-per-esprimere-lopzionalit√†-del-dato"><a class="header" href="#47-viene-usato-come-modo-per-esprimere-lopzionalit√†-del-dato">4.7 Viene usato come modo per esprimere l‚Äôopzionalit√† del dato?</a></h2>
<p>√à difficile capire se questo puntatore viene usato per fornire un accesso efficiente ai dati oppure per esprimere il concetto di <em>opzionalit√†</em>.
Per esempio, una funzione che cerca un valore in un array potrebbe restituire un puntatore al valore se lo trova, oppure null se non lo trova.
Non abbiamo modo di saperlo.</p>
<p>Quello l√¨ √® un puntatore, non ha al suo interno altro tipo di informazioni per specificare cose di questo tipo.</p>
<p>Quindi il linguaggio, pur dandomi degli strumenti potenzialmente potenti per poter ottimizzare l‚Äôaccesso, mi lascia per√≤ con sette domande a cui non ho risposta.</p>
<p>E se da programmatore devo mettere le mani al codice, quella risposta l√¨ la devo dare io.</p>
<p><em>E come facciamo a darla?</em>
Andando a leggere tutto il codice, non solo un pezzettino, ma tutto.
Perch√© se di quel puntatore ce n‚Äô√® una copia sperduta da qualche parte, io non posso farci tante cose.</p>
<p>Il problema √® che <em>‚Äútutto quel codice‚Äù</em> comprende tutto il codice che scrivo io, tutto il codice che sta nelle librerie, e tutto il codice nascosto da qualche parte che in qualche modo interagisce con il mio.
E se non lo capisco, faccio delle assunzioni che possono essere sbagliate.</p>
<p>E ci√≤ pu√≤ causare problemi tutte le volte che provo poi a rieseguire il mio programma.
Il problema √® che buona parte di questi malfunzionamenti non sono ripetibili, ma nascono da combinazioni astrali, dal fatto che sono successe certe cose, che alcune sono successe pi√π in fretta di altre, e cose simili‚Ä¶ <strong>tutte cose che sono fuori dal nostro controllo.</strong></p>
<p>E quindi diventa complicatissimo sviluppare i programmi.</p>
<p>Per questi motivi, i programmi scritti in C e C++ sono un <em>florilegio</em> di bug.</p>
<p><img src="images/allocazione_della_memoria_3/image%2016.png" alt="image.png" /></p>
<p>In C e C++ usiamo i puntatori in tanti modi.</p>
<p>Il pi√π semplice √® quello per accedere, qua e ora, ad un dato valore.
Mi serve sostanzialmente per ottimizzare: evito di spostare una grossa struttura dati, e piuttosto ti passo il puntatore alla struttura.</p>
<p>Ti dico ‚Äú<em>Cara funzione, io te lo passo e tu lo usi adesso, per il tempo della tua chiamata. Ci guardi dentro, ci scrivi se devi scrivere, <strong>ma non te lo copi.</strong> Perch√© quando tu sarai tornata io non posso pi√π garantirti che questo dato rimanga valido, quindi lo devi usare solo adesso</em>‚Äù.</p>
<p>Il problema √® che non riesco a trasmettere in codice questa informazione.</p>
<p>Il meglio che posso fare √® scriverla in un commento, ma il commento lascia il tempo che trova, perch√© bisogna che qualcuno lo legga.
Bisogna prima che qualcuno l‚Äôabbia scritto, e poi bisogna che qualcuno lo legga e ne faccia uso.</p>
<p>Un puntatore lo posso usare per indicare a una funzione dove dovr√† mettermi le sue risposte.</p>
<p>√à il caso, ad esempio, della funzione <code>scanf</code>.
Quando in C usiamo <code>scanf</code> per leggere la tastiera, cosa facciamo?
Scriviamo <code>scanf(‚Äù%d‚Äù, &amp;i)</code>, cio√® passiamo il puntatore a una nostra variabile, dentro cui <code>scanf</code>, se trova un intero, ci scriver√† il valore che ha letto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2017.png" alt="image.png" /></p>
<p>Qua c‚Äô√® un esempio, ho una funzione ipotetica <code>read_data1</code>, che usa il valore di ritorno per dirmi se √® riuscita o meno a leggere i dati, e quindi mi d√† come valore di ritorno un booleano.</p>
<p>Nel caso in cui il booleano sia true, vuol dire <em>‚Äúho letto i dati‚Äù</em>, e il dato che legge me lo mette dentro il parametro.</p>
<p>Ovviamente siccome il parametro √® passato per copia, io non posso passargli un int, perch√© quell‚Äôint l√¨, quando la funzione ritorna ve l‚Äôavrebbe buttato via.
Io gli devo passare un puntatore, in modo tale che la funzione lo dereferenzia, ci scrive dentro e anche se poi il puntatore viene buttato via, siccome io ho l‚Äôoriginale, dall‚Äôoriginale prendo quello che mi serve.</p>
<p>E quindi, se qualcuno mi ha passato un risultato buono e ho dei dati disponibili, vado a prendermi i dati, li metto dentro il puntatore, <code>*result = get_some_data()</code> , quello che devo metterci. E in questo caso ritorno true.</p>
<p>Se non mi hai passato un puntatore buono, oppure non ho niente da dirti, ti rispondo false e lascio perdere.</p>
<p><img src="images/allocazione_della_memoria_3/image%2018.png" alt="image.png" /></p>
<p>Posso usare un puntatore per accedere a un blocco di dati.</p>
<p>Questo √® uno dei grossi casini del C, perch√© automaticamente quando voi dichiarate un array di n elementi, la vostra dichiarazione <code>int[10]</code>, quell‚Äôarray l√¨ si dimentica di essere un array <em>lungo 10 elementi</em>: viene <em><strong>demoted</strong></em>, ridotto a puntatore al primo elemento. Fine.</p>
<p>Ma quando io lo passo a qualcun altro, quell‚Äôaltro che ne sa che l√¨ ce ne sono davvero 10?Potrebbero essere solo 5.</p>
<p>Per questo in C++ c‚Äô√® un tipo apposito, l‚Äô<strong><code>std::array</code></strong>, che ha nella firma del tipo la dimensione e questo permette di capire quanto √® grande.</p>
<p><img src="images/allocazione_della_memoria_3/image%2019.png" alt="image.png" /></p>
<p>Posso usare il puntatore per farti accedere a una sequenza di dati pi√π o meno grande, non nota priori, √® il caso delle stringhe del C.</p>
<p>Le stringhe del C io ti passo il puntatore all‚Äôinizio e chi ha bisogno da quel puntatore va avanti a cercare quello che gli serve, fino a quando non incontra lo <code>/0</code>.</p>
<p>Tecnica pericolosissima, perch√© √® una di quelle pi√π facilmente hackerabile.</p>
<p><img src="images/allocazione_della_memoria_3/image%2020.png" alt="image.png" /></p>
<p>Posso usare i puntatori per accedere a dati dinamici, ed √® tutto quello che facciamo normalmente quando ci serve allocare delle mappe, delle liste, delle cose la cui dimensione non √® nota a priori.</p>
<p>Il problema √® che in questa situazione c‚Äô√® sicuramente la responsabilit√† del rilascio: in C++ se ho ottenuto il dato con una <code>new</code>, qualcuno lo dovr√† rilasciare con la <code>delete</code>, oppure se in C l‚Äôho ottenuto con la <code>malloc</code>, qualcuno lo dovr√† rilasciare con la <code>free</code>.</p>
<p>Di nuovo il C++ mi facilita perch√© mi mette a disposizione delle classi gi√† fatte che si occupano nel loro costruttore di prendere i pezzi di cui hanno bisogno e nel loro distruttore di buttare via tutto quello che avevano preso.</p>
<p>Rendendo quindi la vita del programmatore un pochino pi√π sicura, ma solo un po‚Äô.</p>
<p>E poi posso usare il puntatore come modo per esprimere l‚Äôopzionalit√† di un risultato, ovvero ti ritorno null se non ho trovato niente, o ti ritorno un puntatore valido se ho trovato qualcosa.
<strong>Ma non √® chiaro se quel puntatore valido va rilasciato o meno.</strong></p>
<p><img src="images/allocazione_della_memoria_3/image%2021.png" alt="image.png" /></p>
<p>Oppure posso usare il puntatore per fare delle strutture articolate come le liste, le mappe, etc...</p>
<p><img src="images/allocazione_della_memoria_3/image%2022.png" alt="image.png" /></p>
<p>Quindi, lavorando in C non c‚Äô√® salvezza.
Tutte quelle sette domande elencate prima non hanno nessuna risposta.
√à il programmatore che deve trovarsela.</p>
<p>C++ mi aiuta un po‚Äô di pi√π.
Mi aiuta un po‚Äô di pi√π perch√© mi d√† un supporto sintattico attraverso dei tipi pi√π elaborati, mediante i quali <em>alcune cose</em> mi vengono gestite.</p>
<p>Ad esempio, per i puntatori dinamici mi dice ‚Äú<em>guarda, io ti do una cosa che si chiama <strong>Smart Pointer</strong>, che √® fatta in modo tale per cui tu la crei e automaticamente quando questa cessa di essere visibile distrugge il dato a cui punta</em>‚Äù.</p>
<p>Anzi te ne do due.
Uno che si chiama <em><strong>Unique Pointer</strong></em>, che non pu√≤ essere copiato.
Un altro che si chiama <em><strong>Shared Pointer</strong></em>, che pu√≤ essere copiato.</p>
<p>Quello che pu√≤ essere copiato conta quante copie ci sono e quando l‚Äôultima copia muore, rilascia il dato, cos√¨ non c‚Äô√® rischio di perdere l‚Äôinformazione.</p>
<p>Lo Unique Pointer invece √® molto pi√π agile, ma non pu√≤ essere copiato.
Se cerchi di copiarlo ti dice <em>‚Äúno, al massimo lo <strong>cedi</strong>‚Äù</em>: il C++ introduce un concetto che si chiama <em><strong>movimento</strong></em>.</p>
<p><em>Cosa vuol dire ‚ÄúLo cedi‚Äù?</em>
Beh: lo dai a lui, per√≤ poi non √® pi√π tuo.</p>
<p><img src="images/allocazione_della_memoria_3/image%2023.png" alt="image.png" /></p>
<p>Il programmatore ha tutta una serie di responsabilit√†.</p>
<ul>
<li>Deve limitare gli accessi a un blocco <strong>nello spazio</strong>, cio√® non devo andare oltre la zona a cui quel puntatore lecitamente pu√≤ arrivare, e neanche prima, e <strong>nel tempo</strong>, cio√® devo accederci solo quando quel dato l√¨ effettivamente esiste.</li>
<li>Non devo assegnare ai puntatori valori che corrispondono agli accessi non mappati.
Se io dichiaro una variabile locale di tipo <code>int*</code> e non la inizializzo, non √® che dentro non c‚Äô√® scritto niente, c‚Äô√® scritto una schifezza qualunque che era presente sullo stack quando lo stack √® stato abbassato. Magari c‚Äô√® scritto <code>0</code>, se sono fortunato. Magari c‚Äô√® scritto <code>3b7f5962</code>. Ma non √® un vero indirizzo, √® semplicemente che sono dei byte a caso che c‚Äôerano scritti l√¨, e se io provo e vado ad accedere, chiss√† che succede.</li>
<li>Devo rilasciare tutta la memoria dinamica allocata una e una sola volta, usando la funzione duale di quella che √® servita per l‚Äôallocazione. Perch√© se io ho allocato con <code>new</code> non posso rilasciare con <code>free</code>. Perch√© <code>free</code> ha delle strutture dati diverse da quelle di <code>new</code>.</li>
</ul>
<h1 id="5-rischi"><a class="header" href="#5-rischi">5. Rischi</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2024.png" alt="image.png" /></p>
<p><em>Cosa succede se faccio casino?</em></p>
<ul>
<li>Allora, se accedo a un indirizzo, quando il corrispondente ciclo di vita del valore a cui quell‚Äôindirizzo punta √® terminato, andiamo incontro ad effetti impredicibili.
Quella situazione l√¨ si chiama <em><strong>dangling pointer</strong></em>.</li>
<li>Se io non rilascio tutta la memoria che ho allocato, faccio un <em><strong>memory leakage</strong></em>.
Memory leakage √® uno spreco in primis, ed √® un problema in secondis.
Nel momento in cui il mio programma vive abbastanza a lungo, specialmente se sto creando un server. Perch√© sul server se a ogni richiesta io mi perdo una manciata di byte, dopo un po‚Äô di richieste non ho pi√π.</li>
<li>Rilasciare la memoria pi√π volte corrompe le strutture dell‚Äôheap ed √® l‚Äôorigine del problema del <em><strong>Double Free</strong></em>.</li>
</ul>
<aside>
üí°
<p>Agli inizi della storia di Microsoft, Windows NT, aveva un mucchio di leakage e ti dicevano <em>‚ÄúSai che c‚Äô√®? Ogni notte lo spegni, e poi lo riaccendi‚Äù</em>.
Ma se hai una server farm con 500 macchine, non √® molto comodo ricordare di spegnerle tutte e riaccenderle, e inoltre nel tempo in cui Windows NT fa il bootstrap (e ci metteva un bel po‚Äô a farlo) sei completamente out of service.</p>
<p><em>E perch√© si doveva fare?</em>
Perch√© aveva cos√¨ tanto leakage che se lo facevi girare pi√π di 24 ore lui esauriva tutta la memoria.</p>
<p>Windows NT era comunque un sistema operativo fatto da zero e quindi ci sta che fosse complicato a realizzarlo, per√≤ era un problema reale che ha causato danni seri alle aziende che lo usavano, e a Microsoft stessa.</p>
</aside>
<p><img src="images/allocazione_della_memoria_3/image%2025.png" alt="image.png" /></p>
<p>Se assegno a un puntatore un indirizzo non mappato, o non gli assegno niente e quindi mi tengo un dato a caso che c‚Äô√® dentro, diventa un <em><strong>wild pointer</strong></em>: non so minimamente cosa possa essere.</p>
<h2 id="51-esempi"><a class="header" href="#51-esempi">5.1 Esempi</a></h2>
<h3 id="511-dangling-pointer"><a class="header" href="#511-dangling-pointer">5.1.1 Dangling Pointer</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2026.png" alt="image.png" /></p>
<p>Ho questo blocco, non ha importanza se √® parte di una funzione o di una cosa pi√π o meno complicata. Nello stack c‚Äô√® gi√† qualcosa, non mi interessa.</p>
<p><img src="images/allocazione_della_memoria_3/image%2027.png" alt="image.png" /></p>
<p>Arrivo a eseguire questa istruzione <code>char* ptr = null</code>: lo stack cresce di 8 byte (nel caso di sistema a 64 bit), devo farci stare un puntatore.</p>
<p>Cosa ci metto in questi 8 byte? NULL, ossia 0x0, perfetto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2028.png" alt="image.png" /></p>
<p>Aperta graffa vuol dire che inizia un nuovo <strong>scope sintattico</strong>: le variabili locali dichiarate qua dentro esisteranno fino alla chiusa graffa corrispondente.</p>
<p>Dopo l‚Äôaperta graffa c‚Äô√® <code>char ch = '!'</code>: lo stack si abbassa di 1 byte e in quel byte ci scrivo il codice esadecimale 21, che √® il punto esclamativo.
E subito dopo dico <em>‚Äúinizializza quel puntatore di prima che valeva</em> <code>NULL</code> <em>con l‚Äôindirizzo di</em> <code>ch</code><em>‚Äù</em>.</p>
<p>Vado a vedere quanto vale lo stack pointer che c‚Äô√® in questo momento (che in pratica √® l‚Äôindirizzo a cui troviamo il valore di ch), e lo scrivo l√† dentro.</p>
<p>Quindi il mio puntatore viene sostituito con l‚Äôindirizzo giusto di <code>ch</code>.</p>
<p><img src="images/allocazione_della_memoria_3/image%2029.png" alt="image.png" /></p>
<p>Chiusa graffa lo stack pointer sale di 1 byte.
Il puntatore che c‚Äôera scritto l√¨ continua a puntare dove non doveva!</p>
<p><img src="images/allocazione_della_memoria_3/image%2030.png" alt="image.png" /></p>
<p>A questo punto provo a chiamare <code>printf</code>.</p>
<p>Cosa fa la chiamata printf?
Eh, pusha sullo stack: comincia a metterci lo spazio per il valore di ritorno, l‚Äôindirizzo a cui chiamare <code>printf</code>, i suoi parametri etc...</p>
<p>Il mio puntatore a questo punto punta delle cose strampalate. Cerco di stampare e non so minimamente che cosa ottengo.</p>
<h3 id="512-memory-leakage"><a class="header" href="#512-memory-leakage">5.1.2 Memory Leakage</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2031.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2032.png" alt="image.png" /></p>
<p>Entro nel mio blocco, dichiaro un puntatore come prima, lo stack cresce di 8 byte, per fare spazio a questo puntatore nullo.</p>
<p><img src="images/allocazione_della_memoria_3/image%2033.png" alt="image.png" /></p>
<p>Alloco un blocco, nello heap da qualche parte cerco un pezzo grande quanto gli ho chiesto, 10 byte. Lo trovo e il mio puntatore punta dove deve.</p>
<p>Nel frattempo la struttura di malloc in questo caso si organizza e si segna che quel segmentino l√¨ adesso √® in uso e quindi si segna che deve saltarne un pezzo perch√© quella memoria non pu√≤ essere usata in quanto l‚Äôha data in prestito a chi gliel‚Äôha chiesta.</p>
<p><img src="images/allocazione_della_memoria_3/image%2034.png" alt="image.png" /></p>
<p>Dentro quella stringa ci scrivo quello che voglio, non ha importanza, la uso come mi pare.</p>
<p><img src="images/allocazione_della_memoria_3/image%2035.png" alt="image.png" /></p>
<p>La stampo, va tutto bene.</p>
<p><img src="images/allocazione_della_memoria_3/image%2036.png" alt="image.png" /></p>
<p>E ritorno.</p>
<p>A questo punto il mio puntatore viene egettato, non lo posso pi√π restituire perch√© dove stava questa stringa non lo so pi√π, √® perduto per sempre.</p>
<p>La <code>malloc</code> √® fatta apposta per dare della memoria che potrebbe essere usata per un po‚Äô di tempo e quindi dice <em>‚Äúvabb√®, non me l‚Äôha restituita adesso, me la dar√† dopo..‚Äù</em>, ma noi ‚Äúdopo‚Äù non possiamo pi√π dargliela perch√© non si sa pi√π dov‚Äô√®.</p>
<p>Abbiamo fatto del memory leakage.</p>
<h3 id="513-double-free"><a class="header" href="#513-double-free">5.1.3 Double free</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2037.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2038.png" alt="image.png" /></p>
<p>Alloco un primo puntatore, ne alloco un secondo che metto uguale al primo.
Adesso ne ho due che puntano l√¨.</p>
<p>Di per s√© non √® una tragedia averne due che puntano l√¨, posso avere dei motivi validi per farlo: pensate a una double linked list, in cui ciascun blocco √® puntato dall‚Äôelemento precedente e dall‚Äôelemento successivo.</p>
<p>Quindi non √® un problema di per s√© il fatto che ci sono due puntatori.
Il problema √® che devo rilasciare una volta sola.</p>
<p><img src="images/allocazione_della_memoria_3/image%2039.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2040.png" alt="image.png" /></p>
<p>Qui cosa succede?</p>
<p>Uso questa struttura in qualche modo, chiamo la <code>free</code> su uno dei due (non importa quale) e a questo punto le strutture di <code>malloc</code> prendono il possesso di nuovo di quel blocchettino che avevano segnato prima essere in uso e fin qui va tutto bene.</p>
<p><img src="images/allocazione_della_memoria_3/image%2041.png" alt="image.png" /></p>
<p>Poi faccio la seconda free e a questo punto non capisce pi√π niente, si spacca.</p>
<h1 id="6-gestire-i-puntatori"><a class="header" href="#6-gestire-i-puntatori">6. Gestire i puntatori</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2042.png" alt="image.png" /></p>
<p>Chi alloca un puntatore √® responsabile quindi di mettere in atto un meccanismo che mi garantisca il suo <strong>rilascio</strong>.</p>
<p>Colui che √® responsabile del rilascio del blocco viene chiamato <em><strong>il possessore</strong></em>.
<strong>Possedere un blocco vuol dire essere responsabile del rilascio.</strong></p>
<p>Il possesso non √® un diritto, √® un dovere.
Certo, ti d√† diritto ad accedere al blocco. Ma ti d√† anche <strong>il dovere di rilasciarlo.</strong></p>
<p>Se io questo puntatore che possiede il blocco lo duplico, e quindi a questo punto ho due puntatori che conoscono il blocco, chi √® il possessore dei due? Boh.</p>
<p>I linguaggi come Java, i linguaggi <em>managed</em>, dicono che il possesso √® <em>equidistribuito</em>: fin tanto che c‚Äô√® almeno uno che conosce quel blocco, il blocco non √® rilasciabile.
Quando non ci sar√† pi√π nessuno che conosce quel blocco, il blocco √® rilasciabile perch√© non √® pi√π posseduto.
Piccolo problema: non viene rilasciato subito, √® solo segnato come rilasciabile.</p>
<p>Quella memoria diventer√† utilizzabile al primo ciclo di garbage collection, che potrebbe avvenire tra un bel po‚Äô e questo potrebbe essere un problema perch√© io a forza di prendere pezzi di memoria potrei trovarmi in difficolt√†.</p>
<p>Quindi in qualche modo se io copio un puntatore che possiede l‚Äôindirizzo, cio√® √® responsabile del rilascio di quella cosa l√¨, il secondo puntatore si trova malgrado a diventare possessore anche lui, partecipa al ciclo di vita e questo ci fa casino, rende ad esempio scrivere l‚Äôalgoritmo della linked list non cos√¨ banale: chi √® che rilascia? I puntatori in avanti o i puntatori all‚Äôindietro?</p>
<p>Quindi bisogna introdurre un meccanismo che gestisca efficacemente la semantica del puntatore e per questo motivo in Rust i puntatori sono svariati: ci sono i puntatori che posseggono e i puntatori che non posseggono, i puntatori che possono scrivere e i puntatori che possono leggere.</p>
<p><strong>Rendiamo esplicito nel tipo che cosa puoi fare</strong>, e qui il compilatore ti aiuta perch√© usa le informazioni che noi gli diamo per verificare che lo usiamo in modo giusto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2043.png" alt="image.png" /></p>
<p>Il vincolo di rilascio √® particolarmente problematico per via dell‚Äôambiguit√† dei puntatori.</p>
<p>In C e in C++ non ho niente che mi distingue un puntatore con possesso da un puntatore senza possesso. Si chiamano tutti <code>int*</code>.</p>
<p>Il fatto che uno possegga e l‚Äôaltro no √® solo nella testa del programmatore.</p>
<p>L‚Äôho ottenuto da una variabile locale o una variabile globale che gi√† esisteva, di cui non sono responsabile del rilascio perch√© lo √® il compilatore ‚Üí non posseggo.
L‚Äôho ottenuto con new o con malloc ‚Üí posseggo.</p>
<p>Solo che quando sto puntatore passa di mano, chi lo sa pi√π come √® nato.
Il tipo non mi dice niente.</p>
<p>Quindi chi √® possessore ha la responsabilit√† di liberarlo.</p>
<p>C++ fa un passo avanti: dice <em>‚Äúguarda io ho i puntatori standard come quelli del C, poi ho gli smart pointer‚Äù</em>.
Gli smart pointer posseggono. Anzi alcuni smart pointer posseggono, perch√© ce ne √® anche un terzo tipo che si chiama <strong><code>Weak</code></strong> che non possiede: partecipa al ciclo di vita senza possedere.</p>
<p><img src="images/allocazione_della_memoria_3/image%2044.png" alt="image.png" /></p>
<p>Non tutti i puntatori posseggono il blocco a cui puntano.
Se ad un puntatore viene assegnato l‚Äôindirizzo di un‚Äôaltra variabile, la propriet√† di quella memoria √® della libreria di esecuzione.</p>
<p>Quindi quando dico <code>int* ptr = &amp;i</code>, la propriet√† √® di <code>i</code>.</p>
<p><code>i</code> √® una variabile che √® allocata, √® stata allocata dal compilatore e viene rilasciata al compilatore.</p>
<p>Il puntatore √® solo un alias.
Pu√≤ guardarla ma non deve partecipare diversamente.</p>
<p>Tutto si complica se un puntatore che possiede il proprio blocco viene copiato.</p>
<p>Quale delle due copie √® responsabile del rilascio?
Tendenzialmente l‚Äôultima. Ma che ne so io qual √® l‚Äôultima?</p>
<p><img src="images/allocazione_della_memoria_3/image%2045.png" alt="image.png" /></p>
<p>Nel momento in cui io creo delle strutture dati complesse, come una linked list, come una mappa, come un oggetto pi√π sofisticato, spesso ho bisogno di crearmi qualcosa che punta a qualcos‚Äôaltro che punta qualcos‚Äôaltro per poter gestire la semantica di questa faccenda qua.</p>
<p>Ad esempio gli oggetti vector (sono quelli che in Java si chiamano array lists), hanno dentro di s√© un puntatore a un blocco dinamico.</p>
<p>Inizialmente piccolo, poi se voi ci mettete dentro delle cose, se per un po‚Äô vengono aggiunti, quando non ci stanno pi√π, quel blocco dinamico viene riallocato grosso il doppio, i vecchi elementi vengono copiati nel blocco nuovo, il blocco vecchio viene rilasciato e faccio spazio per aggiungere cose e quindi piano piano posso ospitare tanti elementi.</p>
<p>Nel momento in cui quel vector viene distrutto, raggiunge la fine del suo ciclo di vita, deve ricordarsi di buttare via tutto.</p>
<p>In qualche modo questo blocco √® una dipendenza del vector, quindi la struttura vector ha dentro di s√© delle appendici come fosse un grappolo d‚Äôuva che dal tralcio si dipana con tanti pezzettini e quando quella cosa l√¨ viene distrutta deve prendersi la briga di buttare via tutti i suoi pezzettini in modo congruo.</p>
<p>Non ci sono solo le dipendenze legate alla memoria, possono esserci dipendenze legate ad altri risorse del sistema operativo.</p>
<p>Se io ho un oggetto che ha aperto un file, quando questo oggetto finisce di vivere quel file deve garantirmi che √® chiuso, altrimenti il sistema operativo penser√† che quel file l√¨ sia ancora in uso.
Se io ho creato un socket per ricevere dalla rete, analogamente il socket lo devo chiudere.
Se ho creato un thread devo garantire che questo thread abbia finito di vivere e cos√¨ via.</p>
<p>Quindi questo insieme di cose, di risorse ulteriori, la memoria, i file, i socket, altri pezzi del sistema operativo, che hanno un ciclo di vita che deve essere riportato al ciclo di vita dell‚Äôoggetto, prendono il nome di <em><strong>dipendenze</strong></em>.</p>
<p><img src="images/allocazione_della_memoria_3/image%2046.png" alt="image.png" /></p>
<p>C non d√† nessun supporto per la gestione delle dipendenze.</p>
<p>C++ ci mette a disposizione il concetto di costruttore e distruttore.
Nel costruttore inizializzo le mie dipendenze, nel distruttore mi libero delle mie dipendenze.</p>
<p><img src="images/allocazione_della_memoria_3/image%2047.png" alt="image.png" /></p>
<p>Innanzitutto, raramente i programmi sono scritti da una persona sola.
Ognuno di tanti che scrive lo fa con le sue convenzioni, con i suoi assunti, con un proprio schema mentale.</p>
<p>Non √® detto che i suoi compagni o colleghi li conoscano, non √® detto manco che si conoscano reciprocamente, perch√© io sono subentrato in un‚Äôazienda dove ho trovato del software che ha scritto qualcun altro che se ne √® gi√† andato da tempo.</p>
<p>Al crescere delle dimensioni del programma la quantit√† di particolari a cui bisogna badare esplode.</p>
<p>Finch√© voi avete un puntatore vi prendete la briga di seguirlo, ma quando avete un milione di puntatori che hanno storie diverse, non li seguite manco per idea.</p>
<p>Il 70% delle vulnerabilit√† elevate all‚Äôinterno di Windows sono dovute a problemi di gestione della memoria. Non √® che Microsoft assume gli imbecilli, ma nonostante ci siano dei professionisti, la possibilit√† di sbagliare √® altissima.</p>
<p><img src="images/allocazione_della_memoria_3/image%2048.png" alt="image.png" /></p>
<p>Nella maggior parte dei linguaggi di alto livello il problema non si pone.</p>
<p>Perch√© non siete mai stati abbastanza stressati con tutte queste cose?
Eh perch√© fin tanto che scrivete in Python va tutto bene.</p>
<p>Piccolo problema.
√à vero che questi hanno dentro di s√© il concetto di puntatore, ma non vi lasciano controllare quando quella memoria viene veramente rilasciata.</p>
<p>E quindi certe cose in Python, in C#, in Java non le potete fare.</p>
<p>In questo corso vogliamo occuparci di quella zona in cui con quei linguaggi l√¨ non si pu√≤ lavorare, perch√© abbiamo bisogno di stare pi√π vicini all‚Äôhardware.</p>
<p>Il fatto che ci sia il garbage collector libera completamente il programmatore dalla responsabilit√† del rilascio, ma in compenso ci fa perdere il controllo sul quando e come il rilascio avvenga.</p>
<p>E quindi in generale c‚Äô√® un bisogno di risorse molto pi√π grande.</p>
<p>La maggior parte di questi linguaggi usa gli algoritmi di <em><strong>Mark and Sweep</strong></em>, che sono quelli che fondamentalmente permettono di identificare quali zone sono ancora referenziate, vengono marcate, e tutto ci√≤ che non viene marcato viene <em>Sweeped</em>, scopato via, tolto insieme alla polvere.</p>
<p>Sono algoritmi belli, interessanti, per√≤ sono anche estremamente dispendiosi.
Quando parte la garbage collection il programma si deve arrestare.</p>
<p><img src="images/allocazione_della_memoria_3/image%2049.png" alt="image.png" /></p>
<p>Cosa succede tra C/C++, linguaggi che ci danno controllo a basso livello, e Java, piuttosto che C#, piuttosto che Python.</p>
<p>Allora in C++ noi abbiamo un controllo manuale del rilascio. Dobbiamo ricordarci noi di chiamare <code>delete</code> o <code>free</code> o quello che sia.</p>
<p>Di l√† ce ne freghiamo attentamente, lo fa il garbage collector.</p>
<p>Il problema √® che in C/C++ noi possiamo controllare quando rilasciare.
Di l√†, siccome lo fa il garbage collector, la memoria √® rilasciata al piacere del garbage collector.</p>
<p>In C++ gli oggetti dispongono di un distruttore, che permette di gestire le dipendenze, di fare il rilascio esplicito delle dipendenze.</p>
<p>In tutti gli altri linguaggi, tranne Java, che ha un finalizer, che per√≤ ora √® stato deprecato, non c‚Äô√® il concetto di distruttore.
Non ce n‚Äô√® bisogno.</p>
<p>In C/C++ il rilascio non comporta dei tempi supplementari di attesa.
Non devo fare una ricerca, perch√© io ho gi√† la mia ricetta nel distruttore che mi dice cosa devo fare.
Di l√†, in realt√†, il rilascio comporta delle pause, pause che possono essere molto lunghe e che in contesto di realt√† sono semplicemente inaccettabili.
Per√≤ in C e in C++ possono verificarsi doppi rilasci, memory leakage, dangling pointer, wild pointer e tutte queste serie di cose che abbiamo visto prima.
Di l√† no. Motivo per cui, per i programmi applicativi, la strada √® quella l√†.
Per i programmi di sistema, la strada passa di qua.</p>
<p><img src="images/allocazione_della_memoria_3/image%2050.png" alt="image.png" /></p>
<p><em>Come sopravviviamo?</em></p>
<p>Certamente usando dei programmi che ci aiutano a diagnosticare l‚Äôuso della memoria nei processi, come Valgrind, se siamo in Linux, Dr.Memory se siamo su Windows.</p>
<p>Certamente usando dei tipi pi√π sofisticati, invece che <code>int*</code>, o cose del genere, cio√® il puntatore nativo del C++, le versioni moderne di C++ ci offrono una serie di classi che ci facilitano la vita.</p>
<p>I vari tipi di smart pointer, le tuple, gli iteratori, gli span, gli optional e cos√¨ via, sono tutti tipi pi√π sofisticati che evitano di dover usare i puntatori, pur dandoci delle strutture che sintatticamente sembrano puntatori e che quindi hanno tante caratteristiche che gli assomigliano, ma sono tracciate per la loro semantica.</p>
<p>Terza strada, ed √® quella che seguiremo nel corso, usiamo dei linguaggi che sono intrinsecamente Memory Safe: Rust.</p>
<p><img src="images/allocazione_della_memoria_3/image%2051.png" alt="image.png" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="02-allocazione_della_memoria_parte_2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="04-introduzione_al_linguaggio.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="02-allocazione_della_memoria_parte_2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="04-introduzione_al_linguaggio.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
