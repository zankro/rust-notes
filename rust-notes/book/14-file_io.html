<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>File I/O</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="file-e-io---malnati-19"><a class="header" href="#file-e-io---malnati-19">File e I/O - Malnati 19 <!-- omit in toc --></a></h1>
<h1 id="indice"><a class="header" href="#indice">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="#1-introduzione">1. Introduzione</a></li>
<li><a href="#2-percorsi--path-e-pathbuf">2. Percorsi ‚Äî <code>Path</code> e <code>PathBuf</code></a></li>
<li><a href="#3-navigare-il-file-system">3. Navigare il file system</a></li>
<li><a href="#4-manipolare-i-file-nel-file-system">4. Manipolare i file nel file system</a></li>
<li><a href="#5-i-tratti-relativi-a-io">5. I tratti relativi a I/O</a>
<ul>
<li><a href="#51-il-tratto-read">5.1 Il tratto <code>Read</code></a></li>
<li><a href="#52-il-tratto-bufread">5.2 Il tratto BufRead</a>
<ul>
<li><a href="#521-esempio">5.2.1 Esempio</a></li>
</ul>
</li>
<li><a href="#53-il-metodo-write">5.3 Il metodo <code>Write</code></a></li>
<li><a href="#54-il-tratto-seek">5.4 Il tratto <code>Seek</code></a></li>
</ul>
</li>
<li><a href="#6-il-framework-serde">6. Il framework <code>Serde</code></a></li>
</ul>
<h1 id="1-introduzione"><a class="header" href="#1-introduzione">1. Introduzione</a></h1>
<p>Spessissimo le nostre applicazioni hanno l'<strong>esigenza di mantenere nel tempo</strong> delle informazioni.</p>
<p>Il modo base con cui i sistemi operativi offrono l'approccio alla persistenza √® tramite il <strong>concetto di file</strong> e <strong>Rust</strong>, di conseguenza, attraverso la sua libreria standard, ci offre meccanismi per poter accedere ai file system.</p>
<p>Sapendo che i file system, pur concettualmente essendo presenti in <em>tutti i sistemi operativi</em>, sono praticamente diversi nelle loro varie installazioni.</p>
<p>Per cui, ad esempio, nel mondo <strong>Windows</strong> esistono molteplici file system che convivono parallelamente, per cui voi avete per ciascun volume in realt√† una cartella radice che rappresenta quel disco, quindi i due punti, i due punti, ecc. ‚Äî Sono in qualche modo separati.</p>
<p>Nel mondo <strong>Unix</strong>, viceversa, l'intero file system viene ricondotto a un'unica radice su cui eventualmente sono montati all'interno di particolari cartelle degli altri volumi, che per√≤ diventano parte di un'unica gerarchia.</p>
<p>Le notazioni usate nei file system sono simili ma diverse, banalmente i separatori di cartella nel mondo Unix sono basati sullo <code>/</code> (slash), in avanti nel mondo Windows sono basati sul <code>\</code> (backslash).</p>
<p>La natura dei nomi dei file nel tempo ha avuto delle manifestazioni.</p>
<p>Questi sono gli elementi <em>macroscopici</em> del file system, poi ci sono tutta una serie di dettagli ulteriori.</p>
<p>I singoli file all'interno del file system dispongono di <strong>metadati</strong>.</p>
<p>Esiste un <strong>owner</strong> di quel file l√¨, cio√® quell'utente che √® possessore del file stesso e che pu√≤ avere, in quanto owner, certi <em>diritti di lettura, di scrittura, di esecuzione.</em></p>
<p>Nel mondo Unix si aggiunge il concetto di <em><strong>gruppo</strong></em>.
Quell'unico file l√¨ appartiene anche a un certo gruppo, e di conseguenza tutti gli utenti che fanno parte del medesimo gruppo possono avere permessi dettagliati.</p>
<p>Poi ci sono tutti gli utenti che non sono n√© owner, n√© quelli che appartengono al gruppo di cui √® dichiarato appartenere il file. Questi sono genericamente gli <em><strong>others</strong></em>, che hanno ulteriori caratteristiche.</p>
<p><em>Nel mondo Windows questa distinzione √® molto pi√π complessa, perch√©?</em>
Sebbene ci sia ancora l‚Äôowner, i privilegi di accesso ai file sono molto pi√π complessi in quanto io posso aggiungere regole ad hoc che dicono <em>"Questo file lo vedono tutti tranne tizio"</em> oppure tranne quelli che hanno <em>certe caratteristiche</em>.
Quindi andando a dare delle espressioni molto pi√π articolate rispetto a quelle del sistema Unix e Unix-like.</p>
<p>Poi ci sono i <em>finti file</em>, ovvero delle cose che <em>appaiono</em> come elementi del file system, ma in realt√† non sono dei veri file che risiedono sul disco, ma vengono fatti apparire come tali.
Ad esempio se avete una mattina Linux avete una cartella che si chiama <code>/proc</code>. Le cartelle presenti all'interno di <code>/proc</code> non sono veri file. I loro nomi sono numeri e corrispondono agli id dei processi in questo momento in funzione.</p>
<p>Per cui <code>/proc/3274</code> contiene degli altri finti file che danno informazioni ulteriori circa quello che sta facendo il processo 3274. Quindi ci trovate la mappa ad esempio della sua memoria, ci trovate i consumi che vengono fatti della CPU, tutta una serie di informazioni...
Se andiamo a guardare dentro il disco non c'√® quella cartella, nel momento in cui il processo 3274 finisce, quella cartella svanisce.</p>
<p>Ci sono poi i file speciali. Di nuovo, il mondo Unix √® pieno di queste cose qua:</p>
<ul>
<li>Alcuni file sono quelli presenti nella cartella <code>/dev</code>, ad esempio <code>/dev/tty</code> per esempio sembra un file ma in realt√† mappa sulla porta seriale 1. Fisicamente se voi scrivete dei byte l√¨ sopra e collegaste un dispositivo alla porta seriale vedreste i bit che salgono e scendono in concomitanza delle vostre scritture. Al contrario se cercate di leggere da quel file, leggete solo se qualcuno sta mandando dei byte a quella porta seriale altrimenti non ci leggete niente</li>
<li>Poi ci sono i symbolic link, ovvero io posso dire che c'√® nella cartella <code>alfa/beta</code> il file <code>gamma</code> che in realt√† non √® lui ma √® un symbolic link al file che sta nella cartella <code>omega/zeta</code> e quindi tutte le volte che apro <code>alfa/beta/gamma</code> in realt√† sto aprendo <code>omega/zeta</code>, questo per√≤ permette in certe situazioni di far sembrare una cosa che in realt√† √® un'altra</li>
</ul>
<p>Questo ci d√† l'idea che il concetto di file system e l'accesso alla persistenza √® qualcosa di molto pi√π elaborato di quanto normalmente possiamo pensare.</p>
<p><em>Allora, Rust come ci d√† accesso a queste cose qua?</em></p>
<p><img src="images/file_io/Untitled.png" alt="Untitled" /></p>
<p>Di base l'idea di file √® una pura astrazione che i sistemi operativi ci mettono a disposizione dicendo <em>"Io posso associare a un nome, pi√π o meno articolato, un insieme di byte".</em></p>
<p><em>Questo insieme di byte non rimane fisso nel tempo: ti fornisco degli strumenti per modificarlo in vari modi ‚Äî sostituendolo completamente, aggiungendo contenuto alla fine, o modificando parti specifiche al suo interno.</em> E ti permetto anche di leggere questo insieme di byte</p>
<p>Quindi il file system sostanzialmente ci d√† l'astrazione per poter, dato un nome articolato (lo chiamiamo path) che ci permette di riconoscere la sua posizione, accedere a questo blocco di byte che pu√≤ avere una dimensione arbitraria molto pi√π grande della massima quantit√† di spazio allocabile all'interno del processo ‚Äî ci√≤ che caratterizza i file √® che tendenzialmente sono strutturati per poter contenere una quantit√† grande di informazione, che vuol dire che spesso e volentieri il nostro accesso al file avviene in una modalit√† di <em><strong>streaming,</strong></em> ovvero ne leggiamo un pezzo per volta e piano piano ne elaboriamo il contenuto.</p>
<p>Concettualmente i sistemi operativi ci permettono di raggruppare i file in cartelle e alle cartelle danno un meccanismo di accesso per cui io posso creare dei cammini per accedere a tali files, con alcune convenzioni che sono abbastanza standard.</p>
<p>Ad ogni file sono associati i vincoli di sicurezza che dicono <em>‚ÄúNon tutti gli utenti della macchina possono accedere a questo file ma solo alcuni‚Äù</em> ‚Äî <em>come?</em> I dettagli qua differiscono molto..</p>
<p>Tendenzialmente l'accesso al file system √® uno di quelle zone che per prima ha avuto, nei vari linguaggi di programmazione, un meccanismo standardizzato multi piattaforma, per cui se voi in C dovete aprire un file usate la funzione <code>fopen</code> , se voi lo dovete fare in Java create un oggetto di tipo <code>FileInputStream</code> se lo leggete o <code>FileOutputStream</code> se lo volete scrivere e cos√¨ via..</p>
<p>Ogni linguaggio ha trovato delle astrazioni che sono ragionevolmente indipendenti della piattaforma.
Anche Rust l‚Äôha fatto e ci ha messo a disposizione sostanzialmente tutto un create che √® <code>std::fs</code>.</p>
<p>All‚Äôinterno di <code>std::fs</code> ci sono alcune astrazioni principali: una delle principali astrazioni che troviamo √® l'astrazione che si chiama <strong><code>std::fs::File</code></strong> , che modella il concetto di file presente sul disco nel suo accesso sia in lettura che in scrittura.</p>
<p>Notate che mentre il singolo file √® una cosa che standard lo √® stata fin dall'inizio, il concetto di cartella e di accesso alla cartella <em>manco per idea.</em>
Nel caso del C non c'√® un bel niente: <em>come faccio a sapere quali file sono presenti in una cartella?</em>
Il C non mi da nessuna funzione sua standard della libreria per poterlo sapere, perch√© in Windows io devo cominciare a fare <code>FindFirstFile</code> e poi <code>FindFirstNext</code> tante altre volte finch√© non mi dice non ce ne sono altri, in Unix ho un altra api e cos√¨ via‚Ä¶ quindi i singoli stream operativi hanno delle funzioni che permettono di enumerare i file ma queste nel caso del C non sono state portate nella libreria standard.</p>
<p>Nel caso del C++ sono entrati nella libreria standard a partire dalla versione 17, quindi pochi anni fa. Viceversa, altrove fortunatamente, in Java ad esempio la classe <code>File</code> del package <code>java.utils</code> fin dalla versione 1.0 di Java aveva permesso di lavorare decentemente con le cartelle, per cui in Java la classe <code>java.utils.File</code> non modella i dati del file, ma modella l'entit√† file col suo nome e ci offre metodi come <strong><code>exists</code></strong> (per sapere se a quel nome ha associato o meno un file), ci offre il metodo <strong><code>erase</code></strong> (che ci consente di cancellarlo), ci permette di usare il metodo <strong><code>mkdir</code></strong> (che ci consente, se quel file non esiste gi√†, di creare una cartella nella posizione indicata dal file con quel particolare nome) e cos√¨ via..</p>
<p>Nel caso di di Rust noi abbiamo tutta una serie di classi che fanno parte di <strong><code>std::fs</code></strong> che ci aiutano.</p>
<h1 id="2-percorsi--path-e-pathbuf"><a class="header" href="#2-percorsi--path-e-pathbuf">2. Percorsi ‚Äî <code>Path</code> e <code>PathBuf</code></a></h1>
<p><img src="images/file_io/Untitled%201.png" alt="Untitled" /></p>
<p>Siccome Rust pone tanta attenzione sulla <strong>indipendenza dalla piattaforma</strong> introduce un paio di classi che si chiamano <strong><code>Path</code></strong> e <strong><code>PathBuf</code></strong> che sono sostanzialmente analoghi per tante caratteristiche a <code>&amp;str</code> (uno slice di caratteri) e un oggetto <code>String</code>.
L'oggetto <code>Path</code> rappresenta un cammino all'interno del file system che √® accessibile in sola lettura, perch√© non lo possediamo.
Viceversa l'oggetto <code>PathBuf</code>, come <code>String</code>, rappresenta un cammino di cui abbiamo il possesso come contenuto e quindi lo possiamo modificare.</p>
<p><em>Perch√© allora non sono stati usati</em> <code>&amp;str</code> <em>e</em> <code>String</code><em>?</em>
Sostanzialmente perch√© rispetto ad una stringa, che ha certe caratteristiche (una stringa ci offre i metodi tipo l‚Äô <code>.upperCase</code> che sono molto generali e adatti a trattare il testo in quanto tale), gli oggetti di tipo <strong><code>Path</code></strong> e <strong><code>PathBuf</code></strong> ci offrono invece dei metodi che sono funzionali a navigare nelle cartelle.</p>
<p>Quindi:</p>
<ul>
<li><strong><code>Path</code></strong>, analogamente a <code>&amp;str</code>, √® un oggetto <em><strong>unsized:</strong></em> quindi di cui noi possediamo uno slice sostanzialmente e lo possiamo vedere solo in lettura</li>
<li><strong><code>PathBuf</code></strong> invece possediamo il contenuto e lo possiamo in qualche modo modificare.</li>
</ul>
<p>Un oggetto di tipo file si distingue da una stringa anche per il fatto che noi concateniamo elementi in modo differente in base al sistema operativo: cio√® col back slash piuttosto che col forward slash.</p>
<p>All'interno sono conservati una serie di metadati che di nuovo dipendono in qualche misura dal sistema operativo: tra i metadati importanti c'√® l'<em><strong>owner</strong></em>, c'√® la <em><strong>data di creazione</strong></em> ed <em><strong>ultima modifica.</strong></em></p>
<p>Questi ultimi due fattori sono molto interessanti nel contesto soprattutto della <em><strong>system integration</strong></em> cio√® quando noi ci troviamo ad avere un pezzo di software che gi√† esiste (che ha scritto qualcun altro e che fa delle cose) e abbiamo bisogno di fare in modo che <em>inter-operi</em> in qualche modo con un altro pezzo di software che ha scritto qualcun altro ancora che ha delle sue caratteristiche.</p>
<aside>
üí° Spesso e volentieri i file sono un modo plausibile di ottenere una forma di system integration, perch√© se abbiamo, ad esempio, Word che crea i file .docx ‚Äî io non so manipolare i file .docx, non so come word li generi eccetera.. per√≤ posso immaginare che mi metto a osservare una certa cartella e tutte le volte che vedo comparire un nuovo file .docx all'interno potrei decidere che quel file potrebbe magari servirmi da un'altra parte.
Quindi magari scrivo un programmino che me lo prende e lo copia su un disco, una cosa che sembra una cartella locale ma in realt√† √® google drive e quindi che ne so ho fatto l'archiviazione automatica dei miei file .docx.
<p>Chiaramente in questo genere di operazioni sapere quando quel file √® stato creato e quando √® stato modificato √® molto interessante perch√© pur non capendo niente della logica di come word aggiorna il file .docx, ma limitandomi a guardare l'oggetto file e monitorare la data di ultima modifica posso cercare di capire se quel file l√¨ lo devo anche ricopiare da un'altra parte perch√© voglio farne il backup automatico oppure no.</p>
</aside>
<p>Posso sapere anche che tipo di file ho in questione: un <em><strong>file semplice</strong></em> (cio√® √® associato ad un array di bytes di qualche genere), o se c'√® un nome che rappresenta una <em><strong>cartella</strong></em> quindi un raggruppamento di altri file, o se √® un <em><strong>collegamento simbolico</strong></em> (ovvero √® un nome che in realt√† √® un alias di un file che √® per√≤ da un'altra parte) etc‚Ä¶</p>
<h1 id="3-navigare-il-file-system"><a class="header" href="#3-navigare-il-file-system">3. Navigare il file system</a></h1>
<p><img src="images/file_io/Untitled%202.png" alt="Untitled" /></p>
<p><em>Come facciamo a usare il sistema il file system?</em></p>
<p>Ci sono una serie di funzioni base che ci vengono esposte all'interno del crate <code>std::fs</code> che ci consentono di fare la maggior parte delle operazioni.</p>
<ul>
<li><strong><code>read_dir</code></strong>
Accetta un riferimento a <code>Path</code>, e ci restituisce un iteratore a tutti file contenuti in una certa cartella. Siccome noi passiamo un <code>Path</code> e quel <code>Path</code> potrebbe anche non corrispondere a nulla (magari passiamo il percorso di una cartella che non esiste), la funzione non ci restituisce direttamente l‚Äôiteratore, ma ci restituisce un <strong><code>Result</code></strong> di un iteratore (in particolare un <code>io::Result</code>, una cosa che ci pu√≤ dire <em>‚ÄúPath not found‚Äù</em>).</li>
<li><strong><code>create_dir</code></strong>
Cerca di creare una nuova cartella nel Path che gli specifichiamo, e ritorna anche lei un <code>Result</code>.</li>
<li><strong><code>remove_dir</code></strong>
Cerca di eliminare una cartella tramite il <code>Path</code> che gli specifichiamo, e ritorna anche lei un <code>Result</code>.</li>
</ul>
<p>Per poter eliminare una cartella, questa deve essere vuota e in pi√π dobbiamo avere i diritti necessari, cio√® dovremo essere noi gli <strong>owner</strong> della cartella stessa o avere i diritti di scrittura sulla cartella, altrimenti la funzione fallisce.
Lo stesso vale per la creazione e anche per la lettura: la cartella potrebbe benissimo esistere ma noi non abbiamo i diritti di leggerla.</p>
<h1 id="4-manipolare-i-file-nel-file-system"><a class="header" href="#4-manipolare-i-file-nel-file-system">4. Manipolare i file nel file system</a></h1>
<p><img src="images/file_io/Untitled%203.png" alt="Untitled" /></p>
<p>Ci sono poi altre funzioni che facilitano proprio i concetti di system integration, in particolare la funzione <strong><code>copy</code></strong> che ci permette di copiare il file da un certo path ad un altro, se ci riesce ci dice quanti byte sono stati fisicamente copiati.</p>
<p>La funzione <strong><code>rename</code></strong> viceversa sposta un file da una posizione a un'altra ‚Äî a seconda dei sistemi operativi questo concetto di spostamento varia dal semplice <em>‚ÄúModifico alcune informazioni in una cartella‚Äù</em> al <em>‚ÄúLo copio fisicamente‚Äù.</em></p>
<p>In particolare, quando operiamo all'interno dello stesso file system, nella maggior parte dei casi viene semplicemente eliminata l'entry del file dalla cartella di partenza (ma il file rimane nella sua posizione con il suo inode e tutte le informazioni associate) e viene creata una nuova entry nella cartella di destinazione. Per questo motivo, l'operazione di <em><strong>rename</strong></em> all'interno dello stesso file system ha un costo computazionale molto basso.</p>
<p>Analogamente, se io lo rinomino nella stessa cartella, e da <code>/alpha/beta</code> lo voglio chiamare <code>/alpha/gamma</code> devo semplicemente cambiare la entry nella cartella <code>alpha</code> e cambiare da <code>beta</code> a <code>gamma</code>.</p>
<p>Se invece io volessi spostare da <code>C:/alfa/beta</code> in <code>D:/gamma</code>, siccome <code>C:</code> e <code>D:</code> sono fisicamente due volumi disgiunti, √® vero che faccio un rename ma quello equivale alla copia e poi alla cancellazione.</p>
<p>La funzione <code>remove_file</code> cerca di eliminare il file specificato tramite il path passato come parametro.</p>
<p><img src="images/file_io/Untitled%204.png" alt="Untitled" /></p>
<p><em>Come facciamo a leggere e manipolare dei file?</em>
Nel momento in cui siamo interessati al contenuto del file (quindi non al file in quanto contenitore di byte generico che vogliamo spostare da una parte all'altra ma concentrandoci su un singolo file siamo interessati al contenuto) abbiamo vari meccanismi che ci consentono di accedere al contenuto del file o di cambiare il contenuto del file.</p>
<p>Di base c'√® una struct che si chiama <strong><code>File</code></strong> che ci offre due metodi per essere istanziato:</p>
<ul>
<li><strong><code>open</code></strong> che prende un path in ingresso e restituisce un‚Äôistanza della struct <code>File</code> che corrisponde a un file che deve essere gi√† presente all'interno del file system. Quindi serve fondamentalmente in quelle situazioni in cui noi vogliamo accedere a un file che esiste (prevalentemente per leggerlo ma in alcuni casi per scriverlo o per appendere)</li>
<li><strong><code>create</code></strong> che viceversa assume che quel file non ci sia e prova a crearne uno di dimensione zero, anche in questo caso con l'obiettivo di scriverlo. Se il file gi√† esiste <code>create</code> butta via tutto quello che c'era dentro e quindi inizia con una <em>truncate</em>, quindi riporta il suo size a zero e da l√¨ in avanti ci lascia operare</li>
</ul>
<p>Di solito <strong><code>open</code></strong> ci d√† la possibilit√† di aprire <strong>in lettura</strong>, ma possiamo cambiare queste cose attraverso la struct <strong><code>OpenOption</code></strong> che ci d√† la possibilit√† di definire quale path vogliamo e quale modalit√† vogliamo usare.</p>
<p><img src="images/file_io/Untitled%205.png" alt="Untitled" /></p>
<p>Creare la struct <code>File</code> ci serve in quelle situazioni in cui pensiamo di dover lavorare col contenuto del file non <em>‚Äútutto d'un colpo‚Äù</em> ma <em>‚Äúa pezzi‚Äù.</em>
Ad esempio, se questo file √® molto grosso devo immaginare di poter aprirlo e leggerne un po‚Äô, farci delle cose, poi leggerne un altro po‚Äô, farci delle cose ecc..</p>
<p>Quando il file √® piccolo (es. 100MB in un sistema desktop, non embedded dove gi√† 100MB √® ‚Äúpesante‚Äù), allora magari √® di una dimensione compatibile con lo spazio che posso allocare all'interno del mio processo.
In questo caso ho due funzioni che mi fanno la vita molto comoda:</p>
<ul>
<li><strong><code>read_to_string</code></strong> prende il file e mi restituisce il suo contenuto sotto forma di stringa</li>
<li><strong><code>write</code></strong> prende uno slice di byte (<code>&amp;u8</code>) e lo scrive dentro il file, quindi quello che c'era nel file va perduto e viene sostituito dal blocco che io gli passo</li>
</ul>
<p>Quindi in quelle situazioni in cui io so a priori che le cose che devo trattare stanno probabilmente nel mio spazio indirizzamento, con questi due metodi ho tutto quello che mi serve ed √® molto pi√π agile poi lavorare direttamente su una stringa o su uno slice di byte piuttosto che operare a pezzi su blocchi che devo capire come li segmento, come li congiungo e cos√¨ via‚Ä¶</p>
<aside>
üí° Nell‚Äôesempio in slide, vediamo che **`read_to_string`** prende come argomento una variabile **`filename`** , che deve essere di tipo `&Path`.
Noi potremmo passarvi anche una stringa, ad esempio **`"C:/alpha/beta"`** perch√® i `&str` (slice di caratteri) sono riconducibili ad un `Path`, perch√® implementano il tratto **`From`** e quindi possiamo convertirli in automatico.
</aside>
<p><img src="images/file_io/Untitled%206.png" alt="Untitled" /></p>
<p>Nelle situazioni invece in cui vogliamo scriverlo pian piano, posso popolare questo file in vari modi.</p>
<p>In questo esempio parto da un nome di un file <code>path = "lines.txt"</code>.
Questo √® un <code>&amp;str</code> normalissimo. Lo passo alla funzione <code>file::create</code>.</p>
<p>La funzione <code>file_create</code> mi restituisce un file aperto <strong>in scrittura</strong>. L'oggetto <code>output</code> √® di tipo <code>File</code>, ed √® <code>mut</code> perch√© devo avere la possibilit√† di modificarne il contenuto.</p>
<p><em>Come faccio a scrivere dentro questo file?</em>
Io posso scrivere, ad esempio, con la macro <code>write!</code>.</p>
<p><code>write!</code> √® molto simile a <code>println!</code>, ha un parametro in pi√π iniziale, che √® l'oggetto <code>File</code> su cui devo fare la scrittura. Quindi <code>write!(output, ...)</code>, e poi ci metto una stringa, che potrebbe contenere delle graffe, con gli indicatori e dei parametri ulteriori, proprio come farei con la <code>println!</code>.</p>
<p>Fatto cos√¨, ho creato un file che ha esattamente quel contenuto. Ci sono anche altri modi di fare questa cosa.</p>
<p>Se io lo volessi leggere a questo punto, probabilmente potrei usare la <code>read_to_string</code>, oppure posso cercare di leggerlo a pezzettini.</p>
<p>Un modo per leggerlo a pezzettini √® usare un <code>BufReader</code>.
<code>BufReader</code> √® un particolare oggetto, un tipo di struttura, che mi permette di leggere un file <strong>riga per riga</strong>.</p>
<p>In questo caso apro il file in lettura con <strong><code>File::open(path)?;</code></strong> (punto interrogativo perch√© quell'operazione potrebbe fallire), e a partire da questo oggetto <code>File</code> creo l'oggetto <code>BufReader</code> che √® specializzato nel leggere da un file che gli passo al lato della costruzione e mi offre meccanismi per andarci all'interno.</p>
<p>Tra i meccanismi che mi offre c'√® l‚Äôiteratore <strong><code>.lines()</code></strong>, metodo che mi d√† le singole righe presenti all'interno e a questo punto, avendo <strong><code>for line in bufferd.lines()</code>,</strong> per ciascuna riga presente all'interno faccio la stampa.</p>
<p>Va detto che la lettura della singola riga potrebbe sempre fallire cos√¨ come anche l‚Äôiteratore che che mi fa vedere tutti file della cartella che gli ho specificato e cose del genere ‚Äî sono tutti iteratori che ritornano un <code>Result</code>.</p>
<p>Siccome <strong><code>File</code></strong> implementa la strategia RAII <em>(Resource Acquisition Is Initialization)</em> automaticamente, quando la variabile esce di scope il file viene chiuso e quindi non mi devo occupare di chiudere il file esplicitamente.</p>
<p>Se ho bisogno posso anticipare la sua uscita di scope facendo in modo esplicito il <code>drop</code> del mio oggetto file cos√¨ che il suo distruttore viene invocato.</p>
<h1 id="5-i-tratti-relativi-a-io"><a class="header" href="#5-i-tratti-relativi-a-io">5. I tratti relativi a I/O</a></h1>
<p><img src="images/file_io/Untitled%207.png" alt="Untitled" /></p>
<p>Esistono alcuni tratti fondamentali che semplificano l'implementazione e consentono di gestire le operazioni di I/O in modo analogo alle operazioni sulla memoria normale.
Quattro tratti in particolare sono essenziali: il tratto <code>Read</code>, il tratto <code>BufRead</code>, il tratto <code>Write</code> e il tratto <code>Seek</code>.</p>
<p>Questi tratti fanno parte del <strong>preludio</strong>, ma non del preludio standard completo. Di conseguenza, sono disponibili automaticamente se includiamo il preludio, altrimenti dobbiamo importarli separatamente.</p>
<p>In tutti i vari casi le operazioni che questi 4 tratti fanno restituiscono dei <code>Result</code>, che se sono positivi contengono di volta in volta un numero (quanti byte ho fisicamente letto/scritto piuttosto che un <code>void()</code> per dirmi che non c'era nessun risultato particolare o altro) nel caso di errore mi arriva un errore che √® definito dalla struct <strong><code>ErrorKind</code></strong> .</p>
<p>Alcuni degli errori presenti in <strong><code>ErrorKind</code></strong> sono ingestibili, cio√® posso solo arrendermi (es. il file non esiste). Ce n'√® uno in particolare che √® <strong><code>Interrupted</code></strong> che invece denota una situazione <em><strong>transitoria,</strong></em> cio√® se il risultato √® <code>Interrupted</code> potrebbe valer la pena metter in atto la strategia di riprovarci dopo un po‚Äô.</p>
<p>Va detto che nella maggior parte delle situazioni la strategia di riprovarci √® un bagno di sangue perch√© devo capire cosa devo riprovare e come lo riprovo, quindi anche se in linea di principio sarebbe gestibile, nella maggior parte delle situazioni non si gestisce e si preferisce lasciar perdere.</p>
<p><img src="images/file_io/Untitled%208.png" alt="Untitled" /></p>
<p><em>Chi √® che implementa il tratto</em> <strong><code>Read</code></strong> <em>?</em>
Il tratto <code>Read</code> √® implementato da tre cose che sono molto diverse tra di loro: <strong><code>File</code></strong> implementa il tratto <code>Read</code> (posso leggere un blocco binario di dati da un file, ma anche dei caratteri, o delle stringhe etc...).</p>
<p><code>Read</code> √® implementato anche dalla struttura che si chiama <strong><code>Stdin</code></strong> che rappresenta il <strong>flusso di default di ingresso</strong> di un processo. Normalmente se noi non facciamo niente di particolare quel flusso di ingresso corrisponde con la tastiera e quindi quello che l'utente pu√≤ digitare. Noi sappiamo per√≤ che quando attiviamo un processo possiamo ridirigere il suo standard input usando i comandi che la shell ci offre quindi con <code>&gt;</code> con <code>|</code> o cose del genere per fargli entrare in ingresso altre cose.</p>
<p>Un altro oggetto che implementa lo stesso tratto <code>Read</code> √® l'oggetto <strong><code>TcpStream</code></strong> che rappresenta invece una connessione di tipo TCP con un host. Notiamo che <code>TcpStream</code> rappresenta uno dei due endpoint ‚Äî non sta dicendo n√® che siamo server n√® che siamo client perch√© una volta che la connessione TCP √® stata stabilita, non c'√® pi√π nessuna differenza tra il server e client: la connessione √® completamente bidirezionale. L'oggetto <code>TcpStream</code> rappresenta una connessione che √® stata messa in piedi e a questo punto su questa connessione io posso leggere.</p>
<p>La lettura qua √® una lettura che va a fare una system call (quindi interpella il sistema operativo) ogni volta che gli chiedo qualcosa; questo in alcuni casi va benissimo, in alcuni casi √® un grosso problema: se ricordate in precedenza abbiamo parlato di come funzionano le cose abbiamo detto che io chiamo l'API del sistema operativo attraverso una funzione particolare (la system call) che mi innalza di privilegio e che in generale √® un'operazione costosa ‚Äî es. su un x86 la call normale costa 5 cicli macchina, mentre la system call ne costa 500.
Allora se io leggo un byte alla volta (perch√© sto leggendo tipo da tastiera), la lettura di quel byte mi costa 500. Ma io potrei piuttosto dire <em>‚ÄúLeggimene all'ingrosso 500 e tieniteli l√¨ in pancia, poi te li chiedo uno alla volta‚Äù.</em> In questo modo l'interazione col sistema operativo avviene molto pi√π raramente: tutte le volte il sistema operativo dice <em>‚ÄúDammi i prossimi 500 byte se ce li hai, me li porto in pancia e poi al mio client (cio√® il pezzo di sotto che ne ha bisogno) ne d√≤ quelli che mi sta chiedendo‚Äù.</em>
Questo √® fatto dal tratto <strong><code>BufRead</code></strong>, che dice <em>‚ÄúTra i dati che tu mi chiedi e quelli che io mia volta chiedo al sistema operativo interpongo un buffer‚Äù.</em></p>
<p><em>Quali sono le struct che implementano il tratto <strong><code>BufRead</code></strong> ?</em>
La struct <strong><code>BufReader</code></strong> √® specializzata nel leggere da un file a <strong>chunk grossi</strong> dando poi i dati uno alla volta per come sono, perch√© vedete che <strong><code>BufRead</code></strong> √® una specializzazione di <strong><code>Read</code></strong>, quindi ha <strong>tutti i metodi</strong> di <code>Read</code> e ci aggiunge i propri.</p>
<p><code>BufReader</code> offre funzionalit√† aggiuntive oltre ai metodi generali, come l'iteratore <code>.lines()</code>. Poich√© carica molti dati in memoria in un colpo solo, pu√≤ implementare efficacemente questo iteratore scorrendo il suo buffer interno. Quando trova un carattere di fine riga, restituisce la riga completa immediatamente. Alla richiesta successiva di <code>next()</code>, continuer√† la ricerca dal punto in cui si era fermato. Se esaurisce i dati nel buffer, richieder√† automaticamente altri dati al sistema operativo per riempire nuovamente il buffer.</p>
<p>C'√® anche un altro oggetto che implementa <code>BufRead</code>: √® <strong><code>Cursor</code></strong>, un oggetto un po‚Äô particolare che mi permette di muovermi all'interno di uno slice di byte, che pu√≤ essere fatto in vari modi.</p>
<p>E poi c'√® <strong><code>StdinLock</code>.</strong>
Da <code>Stdin</code> normale io leggo un byte alla volta i singoli caratteri che digito (<em>c i a o</em>) e se se fossimo in due a leggere io magari leggo (<em>c i</em>) e l'altro legge (<em>a o</em>) della parola <em>ciao,</em> perch√© nel momento in cui io chiedo il prossimo disponibile, questo viene <strong>consumato.</strong> Se io volessi leggere una sequenza devo prendere possesso di <code>Stdin</code>, e quindi <strong><code>StdinLock</code></strong> serve proprio a dire <em>‚ÄúHo preso in modo esclusivo l'accesso a standard input e adesso posso leggere, ce l'ho a blocchi e quindi posso fare read line‚Äù.</em></p>
<p>Poi c'√® invece il tratto <strong><code>Write</code></strong> che √® implementato da tutta una serie di altre struct: la struct <strong><code>Stdout</code></strong> rappresenta il flusso di uscita standard di un processo (questo di solito coincide col terminale nell'applicazione basata su terminali ma pu√≤ essere ridiretto verso un file, verso un altro processo e cos√¨ via).
<strong><code>Stderr</code></strong> rappresenta il flusso di errore di un file.
Anche la struct <strong><code>File</code></strong> implementa <code>Write</code> proprio perch√© io ho la possibilit√† di mandare un byte o un chunk di byte verso un file.
Anche la struct <strong><code>TcpStream</code></strong> implementa <code>Write</code>, perch√© <code>TcpStream</code> √® bidirezionale (posso leggere e posso scriverci).
Anche <strong><code>Vec&lt;u8&gt;</code></strong> implementa <code>Write</code>: posso trattare un vettore come il destinatario di un file ‚Äî come tratterei un file in scrittura, cio√® posso buttare l√¨ dentro esclusivamente un vettore di byte.
Infine <strong><code>BufWriter</code></strong> √® una specializzazione del tratto <code>Write</code> e mi aggiunge la capacit√† di dire che <em>‚Äúi singoli byte che mi dai non li passo subito al sistema operativo come fanno normalmente tutti gli altri, ma me li tengo in pancia finch√© non ne ho abbastanza e quando ne ho abbastanza te li scrivo‚Äù</em> cos√¨ da far s√¨ che questa barriera tra il codice utente e il codice del kernel sia attraversata ogni tanto e non per ogni byte o cose del genere, che altrimenti diventa costosissimo.</p>
<h2 id="51-il-tratto-read"><a class="header" href="#51-il-tratto-read">5.1 Il tratto <code>Read</code></a></h2>
<p><img src="images/file_io/Untitled%209.png" alt="Untitled" /></p>
<p>Il tratto <code>Read</code> √® implementato da tutti coloro i quali permettono di leggere, un byte alla volta o un chunk di byte alla volta. Di base l'operazione elementare che il tratto <code>Read</code> offre √® il metodo <strong><code>read()</code></strong> che accetta un <code>&amp;mut [u8]</code> (cio√® un riferimento mutabile ad uno slice di byte) e mi d√† la possibilit√† di leggere al suo interno sapendo che se quel buffer che ho passato contiene 100 byte lui prover√† a leggerne 100 ma potrebbe riuscire a leggerene solo 32, o 27, o anche 0, e quindi come risultato mi d√† un <code>Result</code> che contiene nel caso di <code>Ok</code> il numero di byte che ha effettivamente letto.</p>
<p>All'interno del tratto <code>Read</code> ci sono tanti altri metodi che sono definiti tutti quanti con una implementazione di default, e l'implementazione di default che √® fornita di questi altri metodi √® basata sul metodo <code>read()</code>, quindi se noi avessimo bisogno di implementare il tratto <code>Read</code> per una nostra struttura particolare l'unico vero bisogno che abbiamo √® implementare il metodo <code>read()</code>.</p>
<p>Poi ovviamente potremmo decidere di implementare anche qualche altro metodo, se avessimo per il nostro caso particolare delle ottimizzazioni possibili rispetto alla funzione di default, ma in termini strettamente funzionali non sarebbe necessario.</p>
<p>In generale, il metodo <code>read()</code> restituisce un risultato che, se negativo, contiene la descrizione dell'errore. Se positivo, il valore varia tra 0 e la lunghezza massima del buffer.</p>
<p>√à importante capire che quando leggiamo e otteniamo <strong><code>Ok(0)</code></strong>, questo pu√≤ verificarsi in due situazioni:</p>
<ul>
<li>La pi√π frequente √® quando raggiungiamo l'<strong>end of file</strong>.
Questo accade solo se il buffer ha dimensione maggiore di 0.</li>
<li>Quando il buffer passato ha dimensione 0.</li>
</ul>
<aside>
üí°
<p><strong>Nota</strong>
Se passiamo uno slice di size 0 (cosa possibile), otterremo necessariamente <code>Ok(0)</code>, semplicemente perch√© non c'√® spazio per leggere: in pratica ci dice <em>"ho letto 0 byte".</em></p>
</aside>
<p>Ogni volta che chiamiamo <code>read()</code>, viene effettuata una system call che comporta un cambio di contesto (questo accade nella maggior parte dei casi). Questa system call √® costosa, richiedendo 500 cicli macchina.</p>
<p><img src="images/file_io/Untitled%2010.png" alt="Untitled" /></p>
<p><em>Quali sono tutti gli altri metodi che il tratto</em> <code>Read</code> <em>mi offre (e che di conseguenza trovo dentro</em> <code>File</code>, **<code>Stdin</code><em>,</em> <code>TcpStream</code> <em>etc...)?</em> ****</p>
<p><strong><code>read_to_end</code></strong> ‚Üí gli passo un <code>Vec&lt;u8&gt;</code> e lui mi riempie questo vettore col contenuto di tutto il file; chiaramente questo lo devo fare facendo attenzione che la dimensione del file sia compatibile con la memoria allocabile del vettore: se quel file l√¨ √® 200 giga non √® detto che io riesca allocare 200 giga nel mio spazio di indirizzamento.</p>
<p><strong><code>read_to_string</code></strong> ‚Üí metodo che in questo caso prende come parametro un variabile tipo <code>String</code> e fa il medesimo giro con un controllo in pi√π: mentre nella <code>read_to_end</code> i byte cos√¨ come sono vanno bene (qualunque questi byte fossero), nel caso di <code>read_to_string</code> viene fatto il controllo che quei byte formino una stringa utf-8 ben formata e quindi nel caso in cui ci fossero sequenze impossibili mi generano un errore.</p>
<p><strong><code>read_exact</code></strong> ‚Üí molto simile a <code>read()</code> ma prova a leggere esattamente quel numero di byte di cui abbiamo passato il buffer; quindi io ho passato un buffer da 100 byte e lui cerca di riempirmeli tutti quanti; se non riesce a riempirmeli tutti quanti mi d√† errore <em><strong>‚ÄúUnexpected end of file‚Äù</strong></em>.</p>
<p><strong><code>bytes</code></strong> ‚Üí mi restituisce un iteratore che mi permette di tirare fuori i byte uno alla volta; questi byte mi escono non come singoli byte ma come <code>Result</code> dove in <code>Ok</code> ho un byte e nel caso contrario ho un <strong><code>io::Error</code></strong> di un qualche tipo.</p>
<p><strong><code>chain</code></strong> ‚Üí interessante perch√© mi permette di attaccare un <code>Read</code> a un altro <code>Read</code>, ad esempio io so che ho spaccato un file grosso in tre pezzi e ho messo l'inizio in file 1 la met√† in file 2 e il resto in file 3 e quindi posso creare un oggetto <code>Read</code>, quindi apro per esempio un file col metodo <code>open</code> , su quel file li faccio <strong><code>.chain(file2).chain(file3)</code></strong> e a questo punto ho creato una struttura che √® la concatenazione di tutto. Quando comincer√≤ a farmi dare dei contenuti questi verranno prelevati da file 1 finch√© ce n'√®, quando arrivo al fondo di file 1 verranno presi da file 2 finch√© ce n'√®, e poi verranno presi da file 3 finch√© ce n‚Äô√®.</p>
<p><strong><code>take</code></strong> ‚Üí mi d√† un iteratore che prende al massimo il numero di byte che io gli dico, quindi mi permette di porre un limite a priori sulla quantit√† di byte che voglio andare a prendere.</p>
<h2 id="52-il-tratto-bufread"><a class="header" href="#52-il-tratto-bufread">5.2 Il tratto BufRead</a></h2>
<p><img src="images/file_io/Untitled%2011.png" alt="Untitled" /></p>
<p><em>Cosa mi aggiunge <strong><code>BufRead</code></strong>?</em></p>
<p>Gli oggetti che implementano il tratto <code>BufRead</code> (quindi <code>BufReader</code> oppure <code>StdinLock</code> ecc..) mi danno alcuni metodi ulteriori: in generale internamente si basa su due metodi fondamentali che sono <strong><code>fill_buf</code></strong> e <strong><code>consume</code></strong> .
Sono metodi che lui usa per implementare gli altri metodi, e che noi di solito non chiamiamo in modo esplicito, perch√© ci interessano molto di pi√π tutti gli altri che offre tra i quali c'√® <strong><code>read_line</code></strong> che legge una singola riga di testo fino allo <code>/n</code>, o <strong><code>lines</code></strong> che ci d√† l‚Äôiteratore che ci permette di prendere le righe una alla volta.</p>
<h3 id="521-esempio"><a class="header" href="#521-esempio">5.2.1 Esempio</a></h3>
<p><img src="images/file_io/Untitled%2012.png" alt="Untitled" /></p>
<p>Qui vediamo un esempio d'uso: prendo uno stdin, faccio <code>stdin.lock</code> e a questo punto trasforma il mio oggetto <code>stdin</code> che potrebbe essere usato da altri in contemporanea in un oggetto che appartiene solo a me e su cui ho il tratto <strong><code>BufRead</code></strong> . A questo punto posso usarlo per farci delle cose.
Con <strong><code>handle.fill_buf().unwrap();</code></strong> stiamo chiedendo di prendere tutto quello che riesce all'interno del buffer che internamente lui si √® allocato, lo stampo, mi chiedo anche quanto √® grande e a questo punto quello l‚Äôho consumato. Questo √® il meccanismo che internamente i vari metodi implementati da <code>BufRead</code> usano per gestirsi le cose. Noi di solito queste chiamate per√≤ non le facciamo cos√¨ perch√© √® una seccatura; noi quando creiamo gli oggetti <code>BufRead</code> chiamiamo <strong><code>read_line()</code></strong> piuttosto che <strong><code>lines()</code></strong> che √® molto pi√π comodo.</p>
<h2 id="53-il-metodo-write"><a class="header" href="#53-il-metodo-write">5.3 Il metodo <code>Write</code></a></h2>
<p><img src="images/file_io/Untitled%2013.png" alt="Untitled" /></p>
<p>Il tratto <strong><code>Write</code></strong> √® implementato da varie strutture (<code>File</code>, <code>Stdout</code>, <code>Stder</code> e cos√¨ via..) e all'interno contiene due metodi:</p>
<ul>
<li><strong><code>write()</code></strong> che affida al sistema operativo un blocco e il sistema operativo sapr√† che dovr√† recapitarlo al dispositivo di io corrispondente, ma non √® obbligato a farlo subito</li>
<li><strong><code>flush()</code></strong> che viceversa √® responsabile di garantire che il sistema operativo prende tutto quello che ha tenuto e fisicamente lo trasferisca fino in fondo cos√¨ che se qualcuno va ad accedere sul device ci trova esattamente quello che io penso di averci messo</li>
</ul>
<p>Oltre a questi due metodi ce ne sono altri qui che vale la pena di citare: <strong><code>write_all</code></strong> si prende uno slice come argomento, e garantisce che lo trasferisce per intero. Essenzialmente fa <code>write</code> e <code>flush</code> in un colpo solo.</p>
<h2 id="54-il-tratto-seek"><a class="header" href="#54-il-tratto-seek">5.4 Il tratto <code>Seek</code></a></h2>
<p><img src="images/file_io/Untitled%2014.png" alt="Untitled" /></p>
<p>Fino ad adesso abbiamo visto i file come oggetti di tipo <em><strong>stream</strong></em>, cio√® oggetti in cui scriviamo aggiungendo sempre alla fine o da cui leggiamo i contenuti nell'ordine in cui sono stati scritti, dal primo all'ultimo byte. In questo modo manteniamo l'ordine sequenziale sia in scrittura che in lettura.</p>
<p>Ma in realt√† un file √® semplicemente un array di byte, e nulla ci impedisce di muoverci liberamente al suo interno. Questo funziona in modo diverso a seconda del tipo di file: su disco, dove il file √® effettivamente un array di byte, ha senso spostarsi in modo casuale e dire <em>"alla posizione 32 scrivo questo, poi torno alla posizione 0 e scrivo quest'altro, poi vado alla posizione 150 e scrivo quest'altro"</em>.</p>
<p>Il file inteso come <em><strong>porta seriale</strong></em>, invece, non pu√≤ essere trattato in questo modo: anche se ci appare come un file, non √® <em>seekable</em>. Questo perch√© la porta seriale √®, come dice il nome, seriale, e i byte che vi inseriamo <em>"vanno a casa di qualcun altro"</em>. Non possiamo dire <em>"no scusa, torno indietro"</em>: il tempo scorre in una sola direzione.</p>
<p>Quindi di tutte quelle cose che a noi sembrano files, alcune sono <em><strong>seekable</strong></em>, altre non lo sono.
Per quelle che sono seekable per√≤ abbiamo la possibilit√† di farci delle operazioni abbastanza interessanti: abbiamo la possibilit√† di dire che noi leggiamo i contenuti di questo grosso byte array che il file modella, in un qualche ordine che possiamo andare a definire ‚Äî di base l'operazione <code>read</code> o l'operazione <code>write</code> avviene su quella che √® la <em><strong>posizione corrente del file.</strong></em></p>
<p>La posizione corrente √® stabilita al lato dell'apertura: quando apriamo un file nella modalit√† read o nella modalit√† write, la posizione iniziale √® zero e quindi <code>read</code> legge il primo, secondo, il terzo o quarto byte, nel <code>write</code> scrivo il primo, il secondo, il terzo o quarto byte. Quando apriamo un file nella modalit√† <strong>append</strong> la posizione iniziale √® al fondo, e quindi <code>append</code> √® una modalit√† di scrittura dove invece di sovrascrivere quello che c'√® aggiungo dei pezzi.</p>
<p>Noi per√≤ possiamo muoverci anche tornando indietro ecc.. il tratto <strong><code>Seek</code></strong> ci consente fondamentalmente di muoverci dall'inizio, dalla fine o dalla posizione corrente di un certo <em><strong>delta</strong></em>.</p>
<p>Quindi ad esempio <strong><code>SeekFrom::Start</code></strong> diciamo <em>‚Äúa partire dalla posizione zero del file porta la posizione corrente avanti di tot posti‚Äù,</em> oppure dall'end invece <strong><code>SeekFrom::End</code></strong> partendo dal fondo del file torna indietro di tanti altri oppure <strong><code>SeekFrom::Current</code></strong> dice <em>‚Äúda dove sei adesso vai avanti o indietro di una certa quantit√†‚Äù.</em></p>
<p>Notate che <code>SeekFrom::End</code> prende un numero <strong>con segno</strong> perch√© io potrei cercare di tornare indietro oppure potrei voler andare comunque avanti per allungare il file. <strong><code>SeekFrom::Start</code></strong> prende un <code>u64</code> perch√© dall'inizio non posso andare a ‚Äúprima dell‚Äôinizio del file‚Äù.</p>
<p>Ci sono tre metodi fondamentali che chi implementa il tratto <strong><code>Seek</code></strong> ci mette a disposizione: il metodo <strong><code>seek()</code></strong> stesso che mi permette di cambiare qual √® la produzione corrente da cui vado a fare le letture o su cui vado a fare le scritture, <strong><code>rewind()</code></strong> che mi permette fondamentalmente di ritornare all'inizio del flusso (quindi equivale a <strong><code>SeekFrom::Start(0)</code></strong>) e infine c'√® il metodo <strong><code>stream_position()</code></strong> che mi ritorn√† qual √® l'attuale posizione di questo file.</p>
<p><img src="images/file_io/Untitled%2015.png" alt="Untitled" /></p>
<p><em>Come facciamo a leggere dei dati binari di qualche tipo?</em></p>
<p>Supponiamo volessimo aprire un <strong>pdf</strong>, che √® un file che ha un formato binario al suo interno: certo ci sono anche delle parti stringa, ma ci sono anche <em>immagini</em>, <em>codici di formattazione</em>, <em>cose strane</em> etc.</p>
<p>Per cui di per s√© non abbiamo la garanzia che contenga dell'<code>utf-8</code> quindi dobbiamo leggere come array di byte. Qua proviamo a farlo: nell'esempio in realt√† leggo (nel caso di Linux) dal device che si chiama <em><strong>urandom</strong></em>, un particolare device che viene montato. √à un finto file (infatti sta nella cartella <code>/dev</code>) che quando lo leggo mi genera dei byte a caso appoggiandosi a una qualche periferica che, attraverso un fenomeno fisico di qualche genere, prova a generare dei numeri che siano robustamente casuali.</p>
<aside>
üí° Un modo per generare dei numeri robustamente casuali √® fare lavorare un diodo zener in corrispondenza del punto di gomito della sua curva tensione corrente, che √® una zona di grande aleatoriet√† dove, tenendo in quella posizione li, a volte leggo uno a volte leggo zero in un modo non controllabile. Siccome √® un fenomeno fisico che dipende da tutta una serie di faccende varie, quella √® una buona sorgente di variabilit√† e di conseguenza pu√≤ essere messo all'interno della nostra CPU un chip che internamente fa questo mestiere, e quando leggiamo da ***urandom*** in realt√† andiamo a interrogare questo chip che ci genera dei byte a caso.
<p>In altre situazioni si usano dei sensori (dei muoni piuttosto che di altre particelle che ci arrivano dai raggi cosmici sostanzialmente) che di nuovo sono abbastanza impredicibili e tra l'altro sono rilevabili anche negli ambienti interni perch√© attraversano una serie di situazioni e quindi questi sono tutti fenomeni difficilmente caratterizzabili.</p>
<p>Perch√© √® importante essere difficilmente caratterizzabile?
I numeri random noi li possiamo usare per scopi molto diversi: li possiamo usare banalmente per pseudo simulazioni ‚Äî fate un giochino, c'√® il mostriciattolo che vi insegue che a volte gira destra e a volte gira a sinistra, va bene chi se ne frega.
Ma se invece di fare il giochino o la simulazione di qualcos'altro stiamo facendo la crittografia per proteggere una transazione bancaria, se l‚Äôalgoritmo non √® un vero random ma √® uno pseudo random (che di fatto √® assolutamente predicibile: qualcuno potrebbe aver studiato un po‚Äô di bit precedenti e fare un <em><strong>educated guess</strong></em> su quali saranno i bit a venire) questo sarebbe rischiosissimo. Per questo motivo ci serve avere un generatore di numeri casuali che sia legato a fenomeni fuori dal controllo.</p>
</aside>
<p>In questo caso qui apriamo il device che si chiama <code>dev/urandom</code> e in questo caso noi sappiamo che questo ci d√† un 32 bit, quindi prepariamo un buffer di 4 byte <code>let mut buff = [0;4]</code> ‚Äî quello l√¨ √® un buff di 4 byte inizialmente tutti i posti a 0. E poi chiamiamo <code>f.read_exact(&amp;mut buff)</code> , cio√® riempimi questi 4 byte con il contenuto del file urandom. Se qualcosa va storto ritorna l'errore, dopo di che se invece non √® un errore all'interno dell‚Äôarray buff ho i 4 byte completamente random e quindi vado a vedere cosa succede e vedo: se in questo caso ne trovo uno tutto a 0 la pianto l√¨ subito dicendo ok altrimenti provo a trasformare questo numero in un intero 32 bit e ci faccio qualcosa in questo caso lo stampo.</p>
<p><img src="images/file_io/Untitled%2016.png" alt="Untitled" /></p>
<p>Altre volte, invece di leggere brutalmente un blocco di byte cos√¨ com‚Äô√® nel disco o code del genere, io ho bisogno di leggere dei dati che so essere strutturati: ad esempio un file csv che contiene qualche milionata di numeri.
Posso farmi questa lettura a mano: faccio open, ci creo un BufReader sopra, a questo punto punto con .lines ho la linea, quella linea l√¨ la devo spezzettare, faccio .split sulla virgola ottengo i singoli chunk, devo ricordarmi che il primo vuol dire una certa cosa, il secondo vuol dire un‚Äôaltra cosa etc..</p>
<p>Si pu√≤ fare, per√≤ √® una seccatura: il giorno che quelli che hanno generato il .csv cambiano il formato e mi dicono devo mettermi l√¨ e paccioccare ed essere sicuro di farlo bene.
Mi farebbe molto pi√π comodo poter descrivere quelli che sono i campi e poi mi farebbe piacere avere qualcosa che me li trasforma per i fatti suoi, e qui ci viene in aiuto un crate che possiamo includere all'interno delle nostre progetti che si chiama <strong><code>Serde</code></strong> .</p>
<p><em><strong>Serde</strong></em> sta per <em><strong>serialization e deserialization</strong></em>.
Serialization √® l'operazione di trasformare il dato dal formato interno di Rust a un formato esterno, e deserialization √® l'operazione di trasformare dal formato esterno in quello interno di Rust.</p>
<p>In realt√† di formati esterni ce ne sono 20 mila possibili, .csv √® solo uno di questi. Serde √® un crate che definisce un framework generale e poi ha una serie di sottocrates che ne specializzano il comportamento in un modo o nell'altro.
Di suo Serde ci offre due tratti: <strong><code>Serialize</code></strong> e <strong><code>Deserialize</code></strong>.
Perch√® sia utile, possiamo includere la macro derive che ci d√† la possibilit√† di creare in automatico le funzioni serialize e deserialize per le strutture dati che andiamo a definire per i fatti nostri.</p>
<h1 id="6-il-framework-serde"><a class="header" href="#6-il-framework-serde">6. Il framework <code>Serde</code></a></h1>
<p><img src="images/file_io/Untitled%2017.png" alt="Untitled" /></p>
<p><img src="images/file_io/Untitled%2018.png" alt="Untitled" /></p>
<p>Includendo serde nel Cargo.toml abbiamo ora disponibili il framework serde e la macro derive. Ma il framework serde √® un framework di serializzazione generico: sa serializzare, ma cosa ci serve serializzare?
Allora dobbiamo includere le ‚Äúspecializzazioni‚Äù, dunque includiamo anche <code>serde_json</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="13-collezioni_di_dati.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="15-smart_pointer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="13-collezioni_di_dati.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="15-smart_pointer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
