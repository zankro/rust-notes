<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduzione"><a class="header" href="#introduzione">Introduzione</a></h1>
<p>Questi appunti derivano dalle sbobinature del corso di <strong>Rust</strong> tenuto dal Prof. <em>Giovanni Malnati</em> durante l‚Äôanno accademico <strong>2023/2024</strong> al <em>Politecnico di Torino</em>.</p>
<p>Ho cercato di riportare le spiegazioni del professore nel modo pi√π fedele possibile, senza alterarne i contenuti, ma riorganizzandole in una forma pi√π leggibile e strutturata. Lo stile orale delle lezioni √® stato quindi adattato a un registro pi√π adatto alla lettura e allo studio.</p>
<p>Dove ho ritenuto che alcuni concetti potessero risultare poco chiari, ho inserito degli <strong>approfondimenti</strong> personali, basati su ricerche online o chiarimenti ottenuti con l‚Äôaiuto di strumenti come <em>ChatGPT</em>. In ogni caso, ho fatto del mio meglio per garantire l‚Äôaccuratezza e la correttezza delle informazioni riportate.</p>
<p>Ogni capitolo contiene nel titolo un riferimento al numero della lezione video corrispondente, cos√¨ da facilitarne l‚Äôeventuale consultazione.</p>
<hr />
<h3 id="-a-chi-consiglio-questa-lettura"><a class="header" href="#-a-chi-consiglio-questa-lettura">üìå A chi consiglio questa lettura?</a></h3>
<p>Questi appunti possono essere considerati come una <strong>dispensa</strong> del corso, utile a chi desidera un supporto per lo studio ‚Äî soprattutto se non ha potuto prendere appunti durante le lezioni.</p>
<p>Grazie all'indice presente in ogni capitolo, √® possibile anche utilizzarli per consultazioni puntuali su specifici argomenti.</p>
<hr />
<p>üí° <strong>Ogni contributo o suggerimento √® benvenuto.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocazione-della-memoria---malnati-1"><a class="header" href="#allocazione-della-memoria---malnati-1">Allocazione della memoria - Malnati 1</a></h1>
<p><img src="images/allocazione_della_memoria_1/image.png" alt="image.png" /></p>
<p>Un programma eseguibile non √® nient‚Äôaltro che un insieme di istruzioni macchina mescolate con dei dati mescolate con dei valori di configurazione e controllo tutti codificati sotto forma di sequenze di byte.</p>
<p>Il significato di questi byte √® legato alla tipologia di informazione che mettiamo dentro ‚Äî per la parte di istruzioni il significato √® <strong>cablato</strong> dentro il processore.
Sui processori 8080 che venivano usati nel PC IBM originale, il byte 3E serviva a rappresentare l‚Äôistruzione <code>MOV A</code>, dove A era l‚Äôaccumulatore (il registro principale della CPU): 3E 7B voleva dire <em>carica nel registro accumulatore il valore binario 7B</em>.</p>
<p>Quindi l√¨ e nei processori moderni ci sono codifiche analoghe, quindi a ogni byte corrisponde una e una sola interpretazione come istruzione macchina.
Cambiando processore chiaramente cambiano le istruzioni e quindi bisogna generare delle sequenze diverse.</p>
<p>La presentazione dei dati o delle informazioni di controllo in parte √® desunta dalle istruzioni macchine.
Io ho scritto un programma che legge una stringa e la trasforma in numero. La stringa √® impiantata insieme al mio codice, mischiata l√¨ dentro. L‚Äôinterpretazione della stringa per trasformarla in un numero sta nelle istruzioni che ho generato.
La parte dell‚Äôinformazione di controllo √® in realt√† invece governata dal sistema operativo: il fatto che il mio programma inizia con una certa sequenza binaria, che il particolare sistema operativo riconosce e trasforma in qualcosa, dipende dal sistema operativo stesso.</p>
<p>Il programma normalmente vive dentro il disco, in un file. Tipicamente su una macchina Windows abbiamo i file .exe che rappresentano i binari eseguibili. Per poter essere eseguito in realt√† occorre che questo file sia trasferito all‚Äôinterno della RAM, dove il processore √® in grado poi di andare a prendere le singole istruzioni.</p>
<p>Come avviene questa cosa qua?
Nei sistemi pi√π banali, come l‚ÄôArduino, il disco neanche c‚Äô√®, il programma √® cablato dentro la flash e banalmente il modo per portarselo nella flash √® grazie a un hardware specifico che fa da programmatore (mi d√† la possibilit√† di andarci a scrivere dentro) e in qualche modo lo posso andare a pescare per essere eseguito.
Nei sistemi pi√π grandi, in realt√†, c‚Äô√® un componente specifico del sistema operativo, il <strong>loader</strong>, che √® responsabile di trasferire dal disco alla RAM per permettere l‚Äôesecuzione.</p>
<p><img src="images/allocazione_della_memoria_1/image%201.png" alt="image.png" /></p>
<p>Una volta che il programma √® in memoria, pu√≤ essere eseguito.</p>
<p>Come avviene l‚Äôesecuzione?
Banalmente c‚Äô√® un ciclare continuo.
Il processore preleva un‚Äôistruzione da una certa cella di memoria indirizzata da uno specifico registro contenuto al suo interno, negli x86 si chiama IP, instruction pointer, preleva il dato presente a quell‚Äôindirizzo, se lo porta in pancia, lo capisce e fa quello che c‚Äô√® scritto l√¨ dentro.
Poi ne prende un altro, poi ne prende un altro..
Questo alternarsi √® chiamato il ciclo fetch, decode, execute ‚Äî prelevo, capisco, faccio.</p>
<p><img src="images/allocazione_della_memoria_1/image%202.png" alt="image.png" /></p>
<p>Il processore fa riferimento alla specifica cella in cui sta un‚Äôistruzione indicandone l‚Äôindirizzo.
L‚Äôindirizzo √® l‚Äôoffset all‚Äôinterno della memoria del calcolatore dove quell‚Äôistruzione √® memorizzata.</p>
<p>Il <em><strong>program counter</strong></em> (l‚Äôinstruction pointer) √® un registro che, a seguito dell‚Äôoperazione fetch, viene automaticamente incrementato, in modo tale che la prossima volta che prelever√† un‚Äôaltra istruzione la prende dalla cella successiva. E se quella √® un‚Äôistruzione multibyte l‚Äôinstruction pointer viene incrementato di un offset corrispondente cos√¨ da poter andare avanti a prelevare istruzioni successive.</p>
<p>Non solo l‚Äôinstruction pointer ricorda qual √® la prossima cella da cui prelevare un‚Äôistruzione, altri registri dedicati ricordano altri tipi di informazioni.
Ad esempio lo <em><strong>stack pointer</strong></em> √® un altro registro presente nella maggior parte dei processori che si ricorda dove certi dati temporanei devono essere messi o da dove devono essere prelevati.</p>
<p><img src="images/allocazione_della_memoria_1/image%203.png" alt="image.png" /></p>
<p>L‚Äôesecuzione del programma avviene nel contesto del suo spazio di indirizzamento.
Che cos‚Äô√® lo <strong>spazio di indirizzamento</strong>?</p>
<p>Noi sappiamo che il nostro sistema di elaborazione ha un processore e della RAM.
Ma al singolo programma non viene data visibilit√† dell‚Äôintera RAM, ma di una piccola porzione che costituisce lo spazio di indirizzamento di quel particolare processo.</p>
<p>Tutto quello che noi abbiamo nel nostro file EXE finisce dentro questa piccola porzione della RAM totalmente disponibile.
Noi possiamo immaginare il nostro spazio di indirizzamento come fosse un array di byte consecutivi che parte da zero e va fino a un qualche livello.</p>
<p>Questo spazio di indirizzamento √® composto da celle che a secondo del livello di parallelismo del processore sono lette un byte alla volta, due byte alla volta, quattro byte alla volta, otto byte alla volta.
Il numero di celle potenzialmente presenti nello spazio di indirizzamento dipende dal processore.</p>
<p>Nel caso dell‚Äôx86, nelle versioni a 64 bit, lo spazio di indirizzamento √® limitato a 48 bit.
Quindi, di fatto, un x64 pu√≤ indirizzare al massimo due alla 48 celle.
Altri tipi di processore fanno altre cose. Un ARM pu√≤ estendersi su 64 bit o cose simili.
Nominalmente, quindi, i nostri programmi potrebbero accedere a qualunque indirizzo compreso tra zero e due alla qualcosa meno uno.
Con l‚Äôx86 due alla 48 meno uno. Sul processore a 32 bit, lo spazio di indirizzamento varier√† da zero a due alla 32 meno uno.</p>
<p>Nominalmente! Ma gli spazi di indirizzamento <strong>non sono completi n√© contigui</strong>.
Cio√®, all‚Äôinterno dello spazio di indirizzamento, solo una piccola porzione di indirizzi √® effettivamente presente.
Il nostro programma ha l‚Äôillusione di averceli tutti, ma non √® vero: ne ha alcuni.
Se prova a leggere o scrivere fuori dal seminato, fuori di quelle piccole zone che gli sono date, il sistema operativo interviene e lo uccide.
Quest‚Äôoperazione si chiama <em><strong>segmentation fault</strong></em>. Sei uscito dal tuo segmento.</p>
<p>Questo non si vede nell‚Äôastrazione del linguaggio di programmazione.
Quando voi in C, in Java, in quello che volete, scrivete un programma, non avete la percezione che gli indirizzi possono solo stare in certi pezzi. Un indirizzo √® un indirizzo, √® un numero.
Ma in realt√†, per il sistema operativo, non tutti i numeri vanno bene. Solo alcuni.</p>
<p><img src="images/allocazione_della_memoria_1/image%204.png" alt="image.png" /></p>
<p>Non solo.
Gli indirizzi che il programma maneggia, quelli cio√® che voi scrivete fisicamente dentro il vostro programma, che potete vedere se li stampate a video o cose del genere, non corrispondono al posto in cui il processore va a leggere o a scrivere. Cio√®, gli indirizzi che voi maneggiate prendono il nome di <strong>indirizzi virtuali</strong>. E nominalmente possono assumere un range tra 0 e 2 alla n-1.
Nella realt√†, se noi attaccassimo un analizzatore di stati logici al bus di sistema per vedere nel momento in cui viene eseguita un‚Äôoperazione di lettura dove vado a leggere, mi accorgerei che, anche se il programma era stato costruito per dire ‚Äúvai a leggere alla cella al cui indirizzo √® 3b7f‚Äù, attaccandomi al bus hardware, vedo che lui va a leggere alla cella 59472657.
Tutto un‚Äôaltra parte.</p>
<p>Questa discrasia tra dove io gli dico di andare e dove lui va √® ci√≤ che permette ai sistemi operativi di avere pi√π programmi che pensano di essere loro proprietari dell‚Äôintero sistema e non darsi fastidio.
√à reso possibile del fatto che dentro le CPU moderne c‚Äô√® un blocco che si chiama <strong>MMU</strong>, <em><strong>Memory Management Unit</strong></em>, che ha il compito di tradurre gli indirizzi virtuali che il programma usa in indirizzi fisici, in quelli in cui effettivamente avviene la scrittura e la lettura.</p>
<p>√à un po‚Äô come se qualcuno mi dicesse ‚Äú<em>metti questa tastiera nel terzo cassetto</em>‚Äù e io invece di infilarlo nel terzo cassetto lo infilassi nel cinquantaseiesimo.
Fintanto che io mi ricordo che quando lui mi parla del terzo cassetto devo andare nel cinquantaseiesimo, non fa nessuna differenza.
Questo permette a uno di dirmi ‚Äú<em>mettilo nel terzo cassetto</em>‚Äù e io lo infilo qua, e a un altro di dirmi ‚Äú<em>metti questo microfono, sempre nel terzo cassetto</em>‚Äù e io posso ricordarmi che per quell‚Äôaltro il terzo cassetto invece √® il tredicesimo.</p>
<p>Tutti e loro sono contenti perch√© mi hanno detto il terzo cassetto quando loro mi chiedono il terzo cassetto all‚Äôuno dove ho la tastiera e all‚Äôaltro dove ho il microfono ma in realt√† i cassetti sono distinti e non si impicciano.</p>
<p>Quindi il sistema operativo al proprio interno sostanzialmente mantiene per ciascun processo in esecuzione questa tabella delle corrispondenze.
Questo fa s√¨ ad esempio che io posso avere due notepad aperti ciascuno dei quali √® convinto di andare a leggere all‚Äôindirizzo 7F793950000, ad esempio, ma in realt√† vanno in posti diversi della RAM fisica.</p>
<p>Nella parte centrale dell‚Äôillustrazione sono riportati gli indirizzi fisici, quelli in cui effettivamente avvengono le scritture.
Nei due estremi ci sono le viste che ciascuna delle due istanze in funzione di notepad hanno della memoria.
Tutti e due sono convinti di andare a leggere in un certo posto ma il sistema operativo li devia e li fa andare tutti da un‚Äôaltra parte.</p>
<p>Questo fa s√¨ che un unico programma notepad possa essere instanziato 100 volte senza avere casino.</p>
<p>Senn√≤ dovrei cambiare ogni volta il contenuto del programma per dire ‚Äú<em>no ma tu sei un po‚Äô pi√π in qua, tu sei un po‚Äô pi√π in l√†</em>‚Äù invece loro sono tranquilli, sanno che in certi posti trovano certe cose e di fatto le trovano ma fisicamente quelle cose l√¨ sono altrove di dove loro pensano.</p>
<p>La traduzione quindi garantisce che programmi diversi, o istanze diverse di uno stesso programma, mentre sono in esecuzione non possano interferire ‚Äî non si danno fastidio perch√© il sistema operativo me li tiene lontani, e non ha bisogno di farmi sapere dove fisicamente li ha messi, basta che sia coerente: quando parla con uno gestisca le informazioni dell‚Äôuno e quando parla con l‚Äôaltro gestisca le informazioni dell‚Äôaltro.</p>
<p>Questo mapping tra l‚Äôindirizzo virtuale (che √® l‚Äôunico che il nostro programma vede) e quello fisico √® soggetto ad alcune annotazioni. Non solo il sistema operativo, attraverso l‚Äôopportuna configurazione del blocco MMU, mi mappa gli indirizzi da logico a fisico ma mi segna anche a quali vincoli quel mapping √® soggetto: mi dice ‚Äúguarda qui l‚Äôindirizzo 7F793950000 va l√† quando leggi e quando scrivi, ma se lui ti chiede invece di fare la fetch, bloccalo! Perch√© questa √® un‚Äôarea in lettura e scrittura, ma non in esecuzione‚Äù. O al contrario mi pu√≤ dire ‚Äúquesta √® un‚Äôarea per l‚Äôesecuzione ma non pu√≤ essere scritta‚Äù.</p>
<p>Questo √® prezioso perch√© vi para un po‚Äô dai virus: il fatto che un programma sia mappato in una zona che √® read and execute only impedisce a un virus di andare a cambiare le istruzioni e di far fare al vostro programma qualcosa di diverso. Protegge anche da voi stessi perch√© a volte quando usiamo i puntatori male uno potrebbe sporcare la propria area di memoria.</p>
<p>C‚Äô√® un fatto in pi√π: l‚Äôesistenza di questa corrispondenza tra la memoria virtuale e la memoria fisica fa si che un programma possa allocare una quantit√† di memoria che pu√≤ essere molto superiore alla memoria fisica effettivamente presente. E come?</p>
<p>Ci verrebbe da dire che, per via di questa partizione, ogni volta che un programma parte si mangia un po‚Äô di memoria fisica e quindi io al massimo accedo a un ennesimo della quantit√† di memoria.</p>
<p><img src="images/allocazione_della_memoria_1/image%205.png" alt="image.png" /></p>
<p>In realt√† il sistema operativo interviene in tanti modi.
La riga sopra √® l‚Äôimmagine dello spazio di indirizzamento virtuale che un programma in esecuzione ha. Il programma lanciato pensa di poter accedere dalla cella numero 0 fino alla cella 2^n-1 ‚Äî questa √® la sua idea potenziale: siccome i puntatori sono grandi 64 bit io immagino di poter andare da 0 a 2^64-1. Questo √® il mio spazio potenziale.</p>
<p>In questo spazio potenziale alcuni blocchi sono quelli effettivamente presenti: sono evidenziati in un verde un pochino pi√π scuro e mappano da qualche parte sulla memoria fisica, che invece √® riportata sotto. Notate che questo mapping avviene a pagine, non a singolo byte (che sarebbe ingestibile) ‚Äî si prende un blocco di 4096 byte piuttosto che 65.536 byte o comunque una potenza del 2 e si dice ‚Äú<em>tutto questo blocco finisce in questa zona della memoria fisica‚Äù</em> cos√¨ da rendere le tabelle un pochino pi√π piccole.</p>
<p>Sono mappate con le loro relazioni: alcune sono mappate xr che vuol dire execute and read (posso leggere cosa c‚Äô√® scritto l√¨ e posso fare il fetch di quell‚Äôistruzione, ma non posso scrivere).
Ma ci sono anche delle zone che non sono mappate sulla memoria fisica, ma <strong>sono mappate sul disco</strong> ‚Äî i sistemi operativi diversi fanno cose leggermente diverse: su windows c‚Äô√® il file page.sys (√® un file nascosto che vive tipicamente in C:) dentro il quale vengono presi dei blocchi da 4k in cui temporaneamente tenere dei dati che il programma vuole poter usare ma che non mi stanno fisicamente nella ram fisica perch√® in questo momento non ho nessuna pagina libera. Fin tanto che il programma non ha bisogno di andare a leggere adesso va benissimo che stiano l√¨.</p>
<p>Siccome il vostro programma non legge contemporaneamente tutto, ma mentre guarda questa variabile qui non guarda quella l√¨, pu√≤ lavorare in questo modo, dice ‚Äú<em>guarda tu hai bisogno di tanta roba ok, un po‚Äô te la do fisica, mentre quella che non riesco a darti fisica, te la salvo nel disco. Una volta che hai bisogno di andare a leggere quella cosa che √® nel disco vado a vedere se c‚Äô√® una pagina fisica libera, se c‚Äô√® te la carico l√¨. Se non avessi nessuna pagina fisica libera ne prendo una delle tue occupate, la scarico sul disco e a questo punto quella √® diventata una pagina libera e quindi prendo quella che vuoi leggere e te la piazzo l√¨</em>‚Äù.</p>
<p>Questo permette a un programma potenzialmente di manipolare una memoria virtuale molto pi√π grande di quella fisica.
Con le stesse prestazioni? Ma manco per idea!
Ovvero, fin tanto che voi accedete alle pagine che sono mappate in memoria la lettura e la scrittura √® bella veloce, ma nel momento in cui accedete a una pagina che sta sul disco, c‚Äô√® da aspettare.. se per caso quella cosa che √® finita sul disco √® un pezzo di programma vuol dire che l‚Äôesecuzione del vostro programma, ad esempio chiama la funzione f che √® finita sul disco, l√¨ ha un salto!
Perch√© mentre cerca di andare a prendere la funzione f, la funzione f non c‚Äô√® aspetta, deve essere recuperata dal disco..</p>
<p>Le zone grigie dello spazio virtuale sono non accessibili: se il vostro programma prova ad andare a leggere, a scrivere o ad eseguire in una qualunque zona grigia, viene ucciso.</p>
<p><img src="images/allocazione_della_memoria_1/image%206.png" alt="image.png" /></p>
<p>Le cose sono ancora pi√π complicate.. perch√© nei sistemi non elementari (cio√® non nell‚Äôarduino, ma gi√† sul raspberry) il processore non legge direttamente dalla ram, perch√© se leggesse direttamente dalla ram andrebbe a manovella perch√© la ram √® lenta. Tra il processore e la ram √® interposta la memoria cache. La memoria cache che pu√≤ essere a un livello, a due livelli a tre livelli.</p>
<p><em>A cosa serve la memoria cache?</em>
A velocizzare l‚Äôaccesso alle informazioni contenute nella ram.</p>
<p><em>E come fa a velocizzarlo?</em>
Con l‚Äôidea che in qualche modo io posso anticipare il bisogno di quell‚Äôaltra</p>
<p><em>E sulla base di cosa?</em>
L‚Äôidea √® che c‚Äô√® un principio molto importante che √® il principio di localit√†.</p>
<p>Quando leggo la cella 100 mi conviene portarmi pi√π vicino al processore, in un posto che leggo pi√π agilmente, non solo la 100 ma anche la 101 e la 102 cos√¨ le ho gi√† l√¨ pronte. La memoria cache si basa sull‚Äôuso di dispositivi che hanno poca capacit√† di memoria ma tempi di eccesso molto pi√π rapidi della ram tradizionale.</p>
<p><img src="images/allocazione_della_memoria_1/image%207.png" alt="image.png" /></p>
<p>La memoria cache √® spesso organizzata su livelli, che sono via via pi√π capaci ma anche pi√π lenti. Qui √® schematizzata una CPU moderna con 4 core.
I core sono queste unit√† di elaborazioni individuali che permettono di eseguire delle istruzioni; nascono dal fatto che non √® possibile pi√π di tanto velocizzare il clock, o non √® conveniente velocizzare il clock perch√© questo porta a delle rese termodinamiche bassissime e il processore si scalda troppo e alla fine non dissipa a sufficienza, e quindi conviene usare la capacit√† di fare del silicio piccolo per far stare i transistor in spazi microscopici e permettere tante unit√† di elaborazione che possono svolgersi in parallelo cos√¨ da avere pi√π flussi di elaborazione.</p>
<p>Il singolo core legge e scrive direttamente da una quantit√† di memoria piccolissima: la cache di livello 1, che per√≤ √® molto veloce.
Se occorre riempire la cache di livello 1, la si va a riempire dalla cache di livello 2 che √® un po‚Äô pi√π grande e anche un po‚Äô pi√π lenta.
A sua volta, se occorre riempire la cache di livello 2 la si va a prendere dalla cache di livello 3 che √® ancora pi√π grande e ancora pi√π lenta, e infine la cache di livello 3 prende i suoi dati dalla RAM.</p>
<p>Normalmente tutto questo voi non lo vedete: quando scrivete il vostro programmino hello world, non c‚Äô√® scritto da nessuna parte che c‚Äô√® la cache, ma c‚Äô√®!
E il sistema operativo e l‚Äôhardware si occupano di nascondere tutto questo ‚Äî voi non lo vedete!
Quasi, in realt√†.. perch√® incontrando la programmazione concorrente saremo obbligati a vederlo.</p>
<p>Perch√©?
Perch√© se il core 0 sta incrementando una variabile, e quindi ha preso la variabile i e ha fatto i++ per farla diventare il valore successivo, beh, quell‚Äôi++ √® finito scritto nella cache di livello 1 del core 0, ma se il core 3 anche lui volesse incrementare quella variabile non vedrebbe mica il valore incrementato perch√© quello che l‚Äôaltro ha gi√† scritto nel suo core 0 non √® ancora risalito al livello 2, non √® ancora risalito al livello 3 e non √® ancora risalito nella RAM per permettere all‚Äôaltro di vederlo!
E quindi c‚Äô√® un momento in cui uno ha gi√† fatto una cosa e l‚Äôaltro ancora non lo sa, e siccome non lo sa dice ‚Äúallora lo faccio io‚Äù, e a quel punto l‚Äôhanno fatto in due ed √® un disastro.</p>
<p>Questo simpatico giochetto che normalmente ci fa andare solo veloce e ci piace tanto dobbiamo vederlo e gestirlo..
Se un dato condiviso viene scritto da un core, e un altro core lo vuole leggere, devo prima invalidare la sua cache e dire ‚Äú<em>vattelo a prendere dalla RAM</em>‚Äù oppure se lo vuole scrivere devo dirgli ‚Äú<em>non fermarti l√¨ dove ti fermeresti normalmente, propaga la scrittura fino alla RAM</em>‚Äù.</p>
<p>Quelle operazioni l√¨ diventano molto pi√π costose ma necessarie per garantirmi la correttezza. Quindi programmare a livello di sistema vuol dire guardare questi fatti e rendersi conto che le cose avvengono in questa maniera.</p>
<p><img src="images/allocazione_della_memoria_1/image%208.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_1/image%209.png" alt="image.png" /></p>
<p>Usando i programmi di alto livello tutte queste cose che abbiamo raccontate sono invisibili ‚Äî non emergono assolutamente, ma ci sono!
E quindi i programmi di alto livello sono obbligati a introdurre delle sovrastrutture che permettono di nasconderli.
L‚Äôeffetto che il programmatore trova √® che √® molto pi√π facile scrivere il suo codice. Pari menti √® che quel codice l√¨ va a singhiozzo: si ferma ogni tanto.
Possiamo prenderci la briga di garantire che se quello √® il codice dell‚ÄôABS non ci schiantiamo?
No, perch√© avvengono delle cose che sono fuori dal nostro controllo.
In pi√π la presenza di queste varie sovrastrutture introducono una serie di vincoli e restrizioni di cui dobbiamo essere pienamente coscienti, ad esempio la restrizione del garbage collector che dice ‚Äú<em>la memoria la libero io quando ho voglia</em>‚Äù.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocazione-della-memoria---malnati-2"><a class="header" href="#allocazione-della-memoria---malnati-2">Allocazione della memoria - Malnati 2 <!-- omit in toc --></a></h1>
<h1 id="indice"><a class="header" href="#indice">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="02-allocazione_della_memoria_parte_2.html#1-modello-di-esecuzione">1. Modello di esecuzione</a></li>
<li><a href="02-allocazione_della_memoria_parte_2.html#2-stack">2. Stack</a>
<ul>
<li><a href="02-allocazione_della_memoria_parte_2.html#21-esempio-limite-stack">2.1 Esempio limite stack</a></li>
</ul>
</li>
<li><a href="02-allocazione_della_memoria_parte_2.html#3-heap">3. Heap</a>
<ul>
<li><a href="02-allocazione_della_memoria_parte_2.html#31-esempio-heap">3.1 Esempio heap</a></li>
</ul>
</li>
<li><a href="02-allocazione_della_memoria_parte_2.html#4-organizzazione-dello-spazio-di-indirizzamento">4. Organizzazione dello spazio di indirizzamento</a></li>
</ul>
<h1 id="1-modello-di-esecuzione"><a class="header" href="#1-modello-di-esecuzione">1. Modello di esecuzione</a></h1>
<p><img src="images/allocazione_della_memoria_2/image.png" alt="image.png" /></p>
<p>Ogni linguaggio di programmazione ha un proprio modello specifico di esecuzione, pi√π o meno articolato.</p>
<p><em>Che cos‚Äô√® il <strong>modello di esecuzione</strong>?</em>
√à quell‚Äôinsieme di comportamenti che l‚Äôelaboratore attua a fronte dei costrutti di alto livello che il linguaggio propone.
Ci sono linguaggi un po‚Äô esoterici che hanno modelli di esecuzione particolari.
Ad esempio il linguaggio Prolog √® basato sul concetto di <strong>unificazione</strong> e di <strong>ricerca della prova</strong>, che lo pone a esplorare la sua base di conoscenza usando una serie di regole di produzione, facendo delle cose completamente diverse da quello che fa qualunque altro linguaggio standard che voi conoscete.</p>
<p>Il JavaScript, ad esempio, assume che il programma sia costituito in parte dalle istruzioni immediate che vengono fornite, che possono determinare delle invocazioni di funzioni, che possono avere degli effetti sul futuro, per cui mantiene al suo interno una coda degli eventi nella quale vengono pubblicate le cose che succederanno.
E attinge da questa coda per fare le proprie operazioni.
Questo tipo di comportamento non si ritrova altrove, se non adottando delle librerie che lo vadano a emulare, mentre nel JavaScript √® intrinseco nel linguaggio stesso.</p>
<p>E cos√¨ via.</p>
<p>Il modello che ciascun linguaggio propone, in generale, non corrisponde neanche un po‚Äô al dispositivo reale.
Il compilatore si prende la briga di trasformare le istruzioni scritte nel linguaggio di alto livello X in comportamenti tipici di un particolare processore.
Questa trasformazione in parte √® legata alla sequenza di istruzioni che vengono generate per ciascun costrutto di alto livello (quando qui scrivo for, cosa genero? Quando qui scrivo if, cosa genero? Eccetera..).</p>
<p>In parte √® dovuta al fatto che inframezzate a queste istruzioni, che sono la traduzione diretta dei costrutti di alto livello del linguaggio, vengono messe chiamate a libreria, che servono a garantire che certe cose avvengano come debbono avvenire.
Questi pezzi di chiamate a libreria, che sono inserite automaticamente dal compilatore, servono a generare questa astrazione, a fare in modo che l‚Äôastrazione funzioni.
La libreria prende il nome di <em><strong>RTL</strong></em>, <em>Runtime Support Library</em>, o <em>Runtime Library</em> semplicemente, e dipende dai diversi linguaggi.</p>
<p><img src="images/allocazione_della_memoria_2/image%201.png" alt="image.png" /></p>
<p>Quindi quello che succede √® che la compilazione trasforma il programma sorgente che noi abbiamo scritto in un nuovo programma, che ha un modello di esecuzione pi√π semplice, e che √® associato a una libreria di esecuzione scritta specificatamente per quel particolare sottosistema.</p>
<p>Notate che il livello pi√π semplice pu√≤ voler dire cose molto diverse.</p>
<p>Pu√≤ voler dire, ad esempio, che √® direttamente eseguibile da un particolare elaboratore, oppure che pu√≤ essere eseguito attraverso l‚Äôintervento di un programma ulteriore che lo abbassa di livello.</p>
<p>Nel caso di Java, voi compilate il vostro programma in bytecode, e poi la JVM, la Java Virtual Machine, traduce questo bytecode, just in time, in codice eseguibile per l‚Äôelaboratore concreto.</p>
<p>Che poi va in esecuzione.</p>
<p>Va in esecuzione su una macchina fisica? Forse.
A volte va in esecuzione su una macchina virtuale.</p>
<p>A volte c‚Äô√® un ulteriore livello.
Ad esempio, sui Mac che montano l‚ÄôARM, c‚Äô√® un software chiamato Rosetta, che trasforma dei programmi eseguibili x86 in ARM.
E quindi, ignorando tutto il resto, guarda ‚ÄúAh, questa qui √® l‚Äôistruzione <em>LOAD SP qualcosa</em>. Magnifico!‚Äù. Qual √® il corrispondente ARM? Non c‚Äô√®, e allora simulo: diventa queste altre tre istruzioncine.
Per√≤ d√† la possibilit√† di poter lanciare qua un programma scritto per la versione macOS x86, pur avendo un processore completamente diverso.</p>
<p>A volte questa trasformazione √® fatta nel contesto di una virtual machine, perch√© avete lanciato, che ne so, VirtualBox o qualcosa di simile, Docker, e cos√¨ via.
Contesti che ulteriormente trasformano di livello in livello.</p>
<p><img src="images/allocazione_della_memoria_2/image%202.png" alt="image.png" /></p>
<p>Cosa c‚Äô√® nelle librerie di esecuzione?
Beh, ci sono quei meccanismi di base che permettono ai programmi di alto livello di funzionare come ci aspettiamo che funzionino.
Da un lato supportano le astrazioni che quel particolare linguaggio vuole offrire, dall‚Äôaltro si prendono la briga di interfacciarsi col sistema operativo nascondendo le differenze.</p>
<p>Per cui se voi dovete aprire un file, in C, scrivete sempre <code>fopen</code>, non preoccupandovi del fatto che su Windows quella <code>fopen</code> in alcuni casi diventa <code>Create File</code>, e invece su Linux quella <code>fopen</code> diventa una <code>Open</code>, System Call di livello 2.</p>
<p>Perch√© questo livello di dettaglio il linguaggio ve lo nasconde, almeno in parte.</p>
<p>All‚Äôinterno delle librerie di esecuzione troviamo due tipologie di funzioni.
Alcune sono completamente invisibili al programmatore, vengono inserite automaticamente dal compilatore per supportare l‚Äôesecuzione.
Ad esempio, tutte le volte che voi chiamate una funzione, nella chiamata c‚Äô√® anche un pezzo di codice che va a vedere ‚Äú<em>sto mica facendo traboccare lo stack?‚Äù</em>, perch√© se trabocca lo stack perdo dei dati e quindi il programma deve interrompersi.</p>
<p>Oppure, ce ne sono altre per cui quando assegnate a una struttura un‚Äôaltra struttura, l√¨ bisogna fare una memcpy, e viene fatta in automatico: voi scrivete a=b, vi perdete il dettaglio che a sono 200 byte e b anche, e che lui li deve copiare sopra.
Ci pensa il compilatore a generare questo pezzo di operazione.</p>
<p>Altre sono invece evidenti al programmatore, come la <code>fopen</code>, per cui il linguaggio vi espone un‚Äôastrazione di alto livello, e si prende poi lui la briga di tradurla nel dettaglio che serve per il sistema operativo X, o cose del genere. Fopen, malloc, e cos√¨ via.</p>
<p><img src="images/allocazione_della_memoria_2/image%203.png" alt="image.png" /></p>
<p>Nel linguaggio C e C++, l‚Äôastrazione che viene offerta al programmatore √® quella che il programma si presenta come se fosse l‚Äôesecutore, l‚Äôutilizzatore unico dell‚Äôintero sistema, che si immagina completamente dedicato al programma stesso.</p>
<p>Quindi il programma crede di aver accesso all‚Äôintero spazio di indirizzamento, i puntatori vi lasciano scrivere un numero qualunque tra 0 e 2 alla n-1, potete immaginare di allocare quanta memoria vi pare, potete pensare di avere tutto il tempo che volete.</p>
<p>Il fatto che poi fisicamente voi non possiate impicciare gli altri √® garantito dal sistema operativo che, adottando il meccanismo della memoria virtuale, confina l‚Äôesecuzione del singolo programma nel suo spazietto e impedisce che questo interferisca con altri.</p>
<p>Il fatto che i puntatori potenzialmente possono contenere qualunque numero compreso tra 0 e 2 alla n-1 d√† l‚Äôimpressione che sia lecito andare a cedere a qualunque locazione.
Ma sappiamo che non √® cos√¨.</p>
<p>I limiti, gli indirizzi effettivamente accessibili sono molti molti di meno e sono uno spazio sparso, proprio come disegnato prima nella slide, a pezzettini.
Tra l‚Äôaltro ogni volta in posti leggermente diversi.</p>
<p>Perch√© in posti leggermente diversi?
E‚Äô sempre per difendersi dai virus. Inizialmente non era cos√¨. I sistemi operativi allocavano a un indirizzo specifico il punto di partenza del programma. E i virus l√¨ ci si buttavano a capofitto.</p>
<p>E allora i programmi, i sistemi operativi, hanno introdotto la randomizzazione per cui il programma inizia a una certa cella pi√π o meno delta, dove delta √® random. Questo sposta un po‚Äô le cose e rende pi√π difficile la vita ai virus.</p>
<p><img src="images/allocazione_della_memoria_2/image%204.png" alt="image.png" /></p>
<p>Il C, mi presenta un‚Äôastrazione tipica in cui io scrivo delle istruzioni di alto livello che posso immaginare essere eseguite una per volta nell‚Äôordine indicato dal programmatore.</p>
<p>Quindi se ho scritto:</p>
<pre><code class="language-c">if A &gt; B {
	printf(...);
else {
	// etc..
}
</code></pre>
<p>immagino che le cose vanno esattamente nell‚Äôordine in cui le ho scritte.</p>
<p>Non √® detto che succeda quello.
Perch√© <strong>il compilatore</strong> pu√≤ decidere che certe cose, fin tanto che nessuno se ne accorge, le pu√≤ scambiare.</p>
<p><strong>Il processore</strong> pu√≤ decidere che, fin tanto che nessuno se ne accorge, pu√≤ fare delle cose diverse (varie tecniche di ottimizzazione: dei branch, esecuzione speculativa, etc..).</p>
<p>Non √® detto che se scrivo <code>i=25</code>, 25 venga scritto dentro i.</p>
<p>Perch√© il processore o il compilatore hanno la facolt√†, fin tanto che non rompono l‚Äôastrazione sequenziale, di riordinare i pezzi l√¨ dentro.</p>
<p>Se tu mi dici, prima scrivi qui e poi scrivi l√¨, e qui e l√¨ sono due cose distinte, beh, chi se ne frega, le posso scambiare. Tanto che differenza fa?
Fin tanto che il programma √® costituito da un unico flusso di elaborazione, non fa nessuna differenza.</p>
<p>Ma se il programma √® costituito da due flussi di elaborazione, e i due flussi possono <em>osservarsi</em>, cio√® io posso vedere cosa tu stai facendo, il fatto che tu prima abbia scritto in un posto e poi nell‚Äôaltro mi cambia la vita.</p>
<p>Non ci sono limiti sul numero di istruzioni da eseguire, sul tempo richiesto all‚Äôesecuzione, n√© sulla memoria necessaria: io scrivo il mio programma cos√¨ com‚Äô√®, il linguaggio non mi d√† evidenza. Ma i limiti esistono.
E il programmatore deve capire, perch√© se io devo garantire che quella roba l√¨ mi gestisce l‚ÄôABS, per stare nell‚Äôesempio di prima, deve gestirmi l‚ÄôABS, sempre.</p>
<p>All‚Äôinterno del flusso principale di esecuzione possiamo abilitare degli ulteriori flussi di esecuzione secondari, chiamati <strong>thread</strong>.
Questi permettono di fare pi√π cose quasi contemporaneamente.
Davvero in parallelo se la CPU √® multicore, o alternando un po‚Äô l‚Äôuna e un po‚Äô l‚Äôaltra cosa se la CPU non √® multicore.
E, come abbiamo gi√† avuto modo di dire prima, introducono un ordine di grandezza nella complessit√† del programma, creando delle situazioni completamente inattese.</p>
<p><img src="images/allocazione_della_memoria_2/image%205.png" alt="image.png" /></p>
<p>Il singolo flusso di esecuzione standard di un programma C o C++ √® costituito da una computazione che si dipana dalla funzione main.
Noi abbiamo l‚Äôimpressione che il nostro programma incominci invocando il main e termini nel momento in cui il main finisce.</p>
<p>Non √® cos√¨.
Ci possono essere delle parti che vengono eseguite prima, anzi ce ne sono sicuramente parti che vengono eseguite prima, sia di sistema sia aggiunte da noi.
Ci sono delle parti che vengono eseguite dopo, sia di sistema sia da noi.</p>
<p>Ad esempio, se sono in C++ e ho costruito delle variabili globali di tipo classe, queste possono avere un costruttore.
Il costruttore delle variabili globali viene invocato prima che il main parta.
Il distruttore delle variabili globali viene invocato dopo che il main √® terminato.</p>
<p>Quindi gi√† questo mi cambia un po‚Äô le carte in tavola.</p>
<p>Ma prima che il costruttore venga chiamato parte la funzione di setup del sistema operativo che mi prepara l‚Äôambiente di esecuzione e fa cose.</p>
<p>In pi√π, il C e il C++ assumono l‚Äôesistenza di due strutture dati ausiliarie.</p>
<ul>
<li>Una a forma di pila, chiamata lo <strong>stack</strong>, che serve a gestire le chiamate, la storia delle chiamate (e quindi dei punti di ritorno), e le variabili locali.
In C++, all‚Äôinterno dello stack, √® anche gestita la parte, la gestione strutturata delle eccezioni.</li>
<li>E una seconda struttura ausiliaria, lo <strong>heap</strong>, che serve a usare la memoria dinamica.</li>
</ul>
<p>Queste due strutture crescono e si contraggono via via che il programma va in esecuzione.
Mentre lo stack √® fortemente prevedibile e, a fisarmonica, si allarga e comprime, in modo compatto, lo heap evolve in modo non compatto, sotto il controllo del programmatore. Che quindi diventa responsabile della sua gestione.</p>
<h1 id="2-stack"><a class="header" href="#2-stack">2. Stack</a></h1>
<p><img src="images/allocazione_della_memoria_2/image%206.png" alt="image.png" /></p>
<p>Lo stack √® un blocco che viene allocato automaticamente all‚Äôavvio del programma.</p>
<p>L√¨ dentro c‚Äô√® la storia delle chiamate a funzione, degli argomenti passati a ciascuna funzione, dei valori di ritorno, delle variabili locali e cos√¨ via.
Viene utilizzato a partire da un estremo, si espande verso il basso e si contrae quando le funzioni ritornano.</p>
<p>Poich√© la dimensione √® finita, limita la profondit√† della ricorsione.
Cos√¨ anche come la dimensione delle variabili che possono essere allocate come variabili locali.</p>
<h2 id="21-esempio-limite-stack"><a class="header" href="#21-esempio-limite-stack">2.1 Esempio limite stack</a></h2>
<p><img src="images/allocazione_della_memoria_2/image%207.png" alt="image.png" /></p>
<p>Questa funzione f alloca una variabile locale. Supponiamo <code>uint_8t</code>, un intero a 8 bit, quindi un byte, e lo chiamiamo <code>buffer</code>, di 1024 per 1024. √à un array di un mega.</p>
<p>Quando io chiamo f di 1, quello che succede √® che verr√† chiamato, entro dentro f, alloco questa cosa. Poi stampo quanto vale i. Poi mi chiamo ricorsivamente f con <code>i+1</code>.</p>
<p>Questo cosa vuol dire?
Che io ho invocato f nel main, che ha preso il suo simpatico buffer da un mega, mi stampa 1 e poi si richiama.</p>
<p>Cosa succede richiamandosi?
Che alloca un altro buffer da un mega, stampa 2 e poi si richiama. E alloca un altro buffer da un mega.</p>
<p>Quando si romper√† questa ricorsione?
Alla settima chiamata.</p>
<p><code>Program finished with the exit code 139 (interrupted by signal 11: SIGSEGV)</code> ‚Üí <em><strong>Segment violation</strong></em>.</p>
<p>Ho messo 7 blocchi da un mega e mentre cercavo di mettere l‚Äôottavo ho gi√† traboccato.</p>
<p>Perch√© in realt√† lo stack, sulla macchina su cui stiamo eseguendo l‚Äôesempio, √® esattamente 8MB, ma ad ogni array da 1MB che allochiamo si aggiungono qualche byte in cui c‚Äô√® l‚Äôindirizzo di ritorno, perch√© via via che mi chiamo la funzione f devo scrivere dove devo tornare, poi c‚Äô√® lo spazio per la variabile i che devo passare, quindi si mangia una decina di byte in pi√π a giro, e quindi in realt√† l‚Äôottavo non ci sta, perch√© quando cerco di allocarlo, vado fuori.</p>
<p>Questo ci dice che noi sullo stack pi√π di 8MB non mettiamo.</p>
<p><img src="images/allocazione_della_memoria_2/image%208.png" alt="image.png" /></p>
<p>Chiaramente se invece di mettere 1024 per 1024 mettiamo di meno, qui arriva.
Non arriva a 8 mila, si ferma prima a 7800.</p>
<p>Perch√©?
Perch√© adesso i 12 byte in realt√† di overhead che io ho, 8 per il ritorno pi√π 4 dell‚Äôintero, a ogni giro, pesano di pi√π.
Perch√© sono 12 su 1024. Prima erano 12 su 1 mega, quindi erano una frazione piccola.</p>
<p><img src="images/allocazione_della_memoria_2/image%209.png" alt="image.png" /></p>
<p>Adesso se addirittura abbatto e qui scendo a 1, e quindi ho messo un singolo byte, non arrivo a 8 milioni. Arrivo molto prima.</p>
<p>Questo ci dice che lo stack √® limitato. Non possiamo permetterci di ricorrere pi√π di tanto. Non possiamo allocare sullo stack cose grosse. O perlomeno se lo facciamo dobbiamo farlo un po‚Äô con cautela, altrimenti si spacca.</p>
<p><img src="images/allocazione_della_memoria_2/image%2010.png" alt="image.png" /></p>
<p>Questo tipo di situazione si chiama stack overflow: lo stack trabocca.</p>
<p><img src="images/allocazione_della_memoria_2/image%2011.png" alt="image.png" /></p>
<p>Quando il nostro programma parte, lo stack <strong>non √® vuoto</strong>.
C‚Äô√® gi√† l‚Äôindirizzo a cui la funzione main dovr√† ritornare, perch√© la funzione main non √® l‚Äôinizio del nostro programma.</p>
<p>L‚Äôinizio del nostro programma √® un pezzo di funzione che dipende dal sistema operativo, che pu√≤ chiamarsi <em>CRT startup</em> (CRT ‚Üí C Runtime) o qualcosa del genere, che serve a preparare lo stack, lo heap, insomma a costruire tutti i pezzi che servono e poi dopo che ha fatto tutto, chiama il main.</p>
<p>Quindi quando il main arriva, sullo stack gi√† c‚Äô√® l‚Äôindirizzo a cui dovr√† tornare, perch√© il main finisce con una <code>return 0</code>.
E dopo che il main √® ritornato, quello 0 servir√† per far sapere come finisce il nostro processo: diventer√† l‚Äôexit code del processo.</p>
<p>Comunque, il main parte e sullo stack gi√† c‚Äô√® qualcosa.</p>
<p><img src="images/allocazione_della_memoria_2/image%2012.png" alt="image.png" /></p>
<p>Poi qui, la prima cosa che succede, viene dichiarato una variabile locale, int v=9. Lo stack cresce. Si allunga e l√¨ ci infilo v, che vale 9.</p>
<p><img src="images/allocazione_della_memoria_2/image%2013.png" alt="image.png" /></p>
<p>Poi dico <code>v = f(v)</code>.</p>
<p>Per poter chiamare f(v) devo fare un po‚Äô di pezzi. Siccome f(v) restituir√† qualcosa, mi dar√† un valore di ritorno, devo prima di tutto fare uno spazio dove questo valore di ritorno verr√† scritto. Ci sono quei tre puntini chiamati <code>res</code>: √® il posto dove l√¨ depositer√≤ il mio risultato. Cio√® il risultato che f avr√†. Io devo prepararlo prima lo spazio.</p>
<p>Poi siccome a f passo un parametro, devo metterglielo. Devo metterglielo perch√© io potrei passargli v, ma potrei passargli v+1, potrei passargli v per 5 diviso 54.
Quindi di per s√© quella roba l√¨ √® un‚Äôespressione.
Quindi valuter√≤ l‚Äôespressione, metter√≤ il risultato dell‚Äôespressione sullo stack.</p>
<p>f ancora non l‚Äôho chiamata, ma ho gi√† preparato i pezzi perch√© possa essere eseguita.</p>
<p><img src="images/allocazione_della_memoria_2/image%2014.png" alt="image.png" /></p>
<p>Dopo che ho fatto spazio per il posto di ritorno, ho messo tutti i parametri di cui la mia funzione f ha bisogno, posso effettivamente eseguire l‚Äôistruzione assembler <code>call</code>.</p>
<p>L‚Äôistruzione assembler call fa s√¨ che nello stack venga aggiunto il valore dell‚Äôinstruction pointer aggiornato, cio√® la prossima istruzione che dovr√≤ eseguire quando f sar√† finita.</p>
<p>Quindi lo stack √® cresciuto ulteriormente.
Mi √® entrato dentro l‚Äôindirizzo di ritorno che punta a quello che dovr√≤ fare, prendere il valore che f restituisce e metterlo dentro v, e l‚Äôinstruction pointer si √® trasferito all‚Äôinizio di f.</p>
<p><img src="images/allocazione_della_memoria_2/image%2015.png" alt="image.png" /></p>
<p>Entrando dentro f, f dice ‚Äú<em>a me serve una variabile i</em>‚Äù.
Notate che f, il suo parametro (che per l‚Äôaltro era il risultato dell‚Äôespressione v nell‚Äôinvocazione della funzione) l‚Äôha chiamato a. Ma sono la stessa cosa.</p>
<p>Quindi quel 9 che c‚Äô√® l√¨ prima del return address, nel contesto di f, si chiama a.
f dice ‚Äú<em>a me serve una variabile locale, che chiamo i</em>‚Äù.
Lo stack cresce ancora. Lo piazzo l√¨.</p>
<p><img src="images/allocazione_della_memoria_2/image%2016.png" alt="image.png" /></p>
<p>Poi c‚Äô√® un if: <code>a</code> √® maggiore di 0 (vale 9), quindi salta direttamente al blocco then, e dice ‚Äú<em>return a+i</em>‚Äù.</p>
<p>Aspetta, a+i: calcoliamo questa espressione ‚Äî <code>a</code> vale 9, <code>i</code> vale 5, <code>a+i</code> vale 14.</p>
<p><em>Dove lo scrivo sto 14?</em>
Al posto dei tre puntini, l√† dove gi√† avevo lo spazio.</p>
<p>Sono tutti indirizzi relativi alla cima dello stack.
Altrimenti ritornerei un‚Äôaltra cosa.</p>
<p>Ma return non solo dice il valore, quindi prende a+i, 14, e lo scrive nello spazio dei tre puntini.
Ma dice anche ‚Äúpiantala l√¨‚Äù.</p>
<p>Piantala l√¨ cosa vuol dire? Vuol dire che lo stack deve contrarsi.
Nel tornare al livello, i viene egettata, sparisce.
L‚Äôindirizzo di ritorno viene preso e messo nell‚Äôinstruction pointer.</p>
<p>In modo tale che lui vada a eseguire quell‚Äôistruzione l√¨, al ciclo prossimo.</p>
<p><img src="images/allocazione_della_memoria_2/image%2017.png" alt="image.png" /></p>
<p>Torno all‚Äôaltezza dell‚Äôuguale. All‚Äôaltezza dell‚Äôuguale vengono fatte due operazioni.
Si prende quello che c‚Äôera nei tre puntini e lo si deposita, in questo caso, dentro <code>v</code>.
E si tira via quello che, quel pezzo di incastellatura che era stata fatta per poter chiamare f.</p>
<p>Quando ho chiamato f, ho preparato lo spazio per il valore di ritorno, ho preparato lo spazio del suo parametro, e poi ho chiamato fisicamente f.</p>
<p>Quando f ritorna, tiro via automaticamente l‚Äôindirizzo di ritorno, perch√© quello √® l‚Äôesecuzione dell‚Äôistruzione assembler ret, return, che mi fa tornare al mio posto, ma nel posto in cui atterro, cos√¨ come prima erano stati messi delle istruzioni assembler che mi dicevano ‚Äúinfila questo, infila quello‚Äù sullo stack, subito prima di poter fare le altre cose, ora fa ‚Äútogli questo, togli quello‚Äù e mi ripulisce la situazione.</p>
<p>Quindi al termine della chiamata di f io vedo lo stack come era prima che la facessi.</p>
<p><img src="images/allocazione_della_memoria_2/image%2018.png" alt="image.png" /></p>
<p>Dopodich√© qui ho finito questa cosa, <code>return 0</code>, lo zero viene messo nello spazio dove lui pu√≤ gi√† tornare, che era stato preallocato dal chiamante, la CRT Startup.</p>
<p><img src="images/allocazione_della_memoria_2/image%2019.png" alt="image.png" /></p>
<p>E infine lo stack si contrae, lasciando spazio in questo caso solo allo zero, perch√© lo zero me l‚Äôaveva messo il chiamante e lo deve trovare lui ancora, perch√© poi lo toglier√† lui.</p>
<p>Questa √® la storia dello stack.</p>
<p>Quindi lo stack si allunga ogni volta che dichiaro una variabile locale, si contrae quando la variabile locale non si vede pi√π.</p>
<p>Attenzione: se la variabile locale √® definita in un blocco, quindi</p>
<pre><code class="language-c">if (somecondition) {
	int i
} // finisce di vivere qui
</code></pre>
<p>quella <code>i</code> inizia a esistere mentre entro dentro il then dell‚Äôif, e finisce di esistere quando arrivo alla chiusa graffa corrispondente.
Quindi <strong>non tutte le variabili locali durano quanto l‚Äôintera funzione.</strong>
Le variabili che sono definite in un blocco durano quanto il blocco.
Appena l‚Äôesecuzione raggiunge la chiusa graffa del blocco, quelle variabili vengono espulse.</p>
<p>Se ho una variabile locale dentro un for, k viene creata e distrutta dieci volte.</p>
<pre><code class="language-c">for i=0, i&lt;10, i++ {
	int k = something // k creata e distrutta ad ogni iterazione del for
}
</code></pre>
<p>Quindi quello stack per dieci volte fa, si allunga, si accorcia, si allunga un po‚Äô di cose e si accorcia, eccetera, e va avanti cos√¨.</p>
<p>Quindi la durata in vita delle variabili locali √® circondata, cio√® √® delimitata dal tempo in cui il programma sta nel blocco in cui sono definite.</p>
<p>Chiaramente, in questo caso, la variabile <code>v</code> che inizia all‚Äôinizio del main ragionevolmente dura fino a che non raggiungo la fine del main. √à una variabile che ha una vita pi√π lunga.</p>
<p>La variabile <code>i</code> che √® nella funzione f esiste soltanto mentre √® in corso una chiamata f. Una volta che la chiamata f √® finita, la variabile <code>i</code> non esiste pi√π.</p>
<p>Questo ci fa intravedere qualche possibile problema.
Se la funzione f, invece di ritornare un intero, ritornasse un puntatore e scegliesse per qualche motivo di ritornare come puntatore l‚Äôindirizzo della variabile <code>i</code>, sarebbe un problema.</p>
<p><em>Perch√©?</em>
Certamente mentre la funzione f √® in esecuzione, la variabile <code>i</code> esiste e ha un suo indirizzo. Non sappiamo qual √®, ma fa lo stesso. Nel momento in cui va in esecuzione lo sapr√†.</p>
<p>Piccolo problema: lo pu√≤ ritornare quel puntatore, √® un numero, quindi come ritorno 5 ritorno anche un‚Äôaltra cosa. Ma quel numero l√¨ appena f ritorna, non rappresenta pi√π una locazione lecita, perch√© in quello spazio l√¨ io potrei farci altro, dipende da cosa c‚Äô√® scritto dopo.</p>
<p>Quindi questo ci pone il problema di dire: <em>ma i puntatori come funzionano?</em></p>
<p><img src="images/allocazione_della_memoria_2/image%2020.png" alt="image.png" /></p>
<p>Quindi, il fatto che lo stack cresca a fisarmonica fa s√¨ che allocazione e rilascio siano due operazioni efficientissime.</p>
<p>Perch√©?
Perch√© se io ho bisogno di spazio devo solo incrementare lo stack pointer (o decrementarlo, visto che in realt√† vado verso il basso).</p>
<p>Lo stack pointer parte da 7FFFFFFF e scende verso il basso.
Quindi farmi spazio sullo stack pointer equivale a sottrarre dallo stack pointer il delta di cui ho bisogno.
Liberare memoria vuol dire sommare allo stack pointer per farlo tornare verso l‚Äôalto.</p>
<p>Per√≤ ho un vincolo. I dati che sono nello stack durano solo, al massimo, quanto l‚Äôintera funzione in cui sono definiti. In realt√† durano quanto il blocco in cui sono definiti, che pu√≤ essere molto meno della funzione.</p>
<p>Quindi se io ho bisogno di salvarmi un‚Äôinformazione che dura pi√π a lungo, ecco l√¨ me la perdo.
Per questo motivo il valore di ritorno √® <strong>preallocato dal chiamante</strong>. Cos√¨ quel dato l√¨ mi rimane.</p>
<p>E il chiamante usa quello spazio per poi metterci quello che √®, per prendere poi il risultato e poi lo libera.</p>
<p>Inoltre, poich√© lo spazio totale dello stack √® definito a priori, il sistema operativo quando il programma parte stabilisce quanto √® grande lo stack, abbiamo visto sulla macchina dell‚Äôesempio di prima sono 8MB, quello l√¨ √® il dato pi√π grande che ci posso mettere.</p>
<p>Se avessi bisogno, che ne so, perch√© sto facendo un film e ho bisogno di tenerci 64GB, o sto facendo un modello LLM, che ne so, qualunque cosa che ha bisogno di memoria, sullo stack non ce lo metto.</p>
<h1 id="3-heap"><a class="header" href="#3-heap">3. Heap</a></h1>
<p><img src="images/allocazione_della_memoria_2/image%2021.png" alt="image.png" /></p>
<p>C‚Äô√® una seconda struttura per√≤ che ci interessa tantissimo, si chiama lo heap.</p>
<p>Heap vuol dire il mucchio, dove le cose sono buttate cos√¨, una a fianco all‚Äôaltra, come capita.</p>
<p>Tutte le volte in cui un dato ha un ciclo di vita che non √® collegato alla funzione in cui quel dato nasce, oppure, pur essendo legato a quella funzione, √® grosso e quindi potenzialmente mi potrebbe provocare uno stack overflow, oppure ha una dimensione che al momento della compilazione non √® nota (e quindi ho bisogno di allocare un certo numero di byte, ma quanti esattamente lo sapr√≤ solo a run time, deducendolo da uno dei parametri), quella cosa l√¨ non pu√≤ stare sullo stack, perch√© il compilatore non ha abbastanza informazioni per poterla fare.
Se non √® nota la size, io non so di quanto abbassare lo stack e quindi non ce lo posso mettere l√¨ dentro, oppure, se me lo pu√≤ mandare in overflow, non ce lo devo mettere perch√© se no mi spacca tutto, oppure, se il suo tempo di vita non √® collegato all‚Äôesecuzione della funzione, devo metterlo da un‚Äôaltra parte dove abbia un tempo di vita possibilmente pi√π lungo, o a volte pi√π breve, perch√© magari mi serve solo all‚Äôinizio della mia funzione, ma non esattamente in questo blocco, in una zona un po‚Äô pi√π indefinita che non coincide proprio con un blocco.</p>
<p>Quindi lo devo tenere altrove.</p>
<p>Nel caso di C, C++ e Rust, questa zona a parte si chiama heap, o anche in alcuni libri √® chiamato free store, sono la stessa cosa.</p>
<p>L√¨ dentro si ottiene un blocco di memoria che rimane disponibile fino a che esplicitamente non gli diciamo ‚Äú<em>basta, non mi serve pi√π</em>‚Äù.</p>
<p>Lo heap ha pi√π spazio dello stack.</p>
<p>Quanto di pi√π? Dipende.
In generale noi sappiamo che √® pi√π grande. Le cose grosse devono andare nello heap.</p>
<p>Ci sta qualunque cosa, dipende dal sistema operativo.</p>
<p>Se faccio le prove qua su macOS posso provare ad allocare 1000 giga, un tera. Mi dice ‚Äúyes‚Äù, me le fa allocare. Poi quando vado dentro a un certo punto si rompe, ma allocare me le lascia allocare.</p>
<p>A differenza di quanto avviene per lo stack, dove le singole aree hanno un nome, ed √® il nome della variabile che abbiamo messo, per cui quella cosa l√¨ noi la chiamiamo i, j, k, l etc.. come i nomi che gli abbiamo dato, e lui internamente le fa diventare bp+4, bp+8, cose del genere, le zone sullo heap <strong>non hanno un nome</strong>, sono <strong>solo accessibili tramite dei puntatori</strong>.</p>
<p>Io chiedo di avere un blocco grande 64 byte, mi viene restituito il puntatore all‚Äôinizio di questo blocco. Lo devo memorizzare in una variabile di tipo <code>qualcosa *</code> : <code>int *</code>, <code>uint8 *</code> etc.. ma una variabile di tipo puntatore.</p>
<p>Per accedere al suo contenuto dovr√≤ <em><strong>dereferenziare</strong></em> il puntatore.</p>
<p>Se la mia variabile di tipo int* si chiama <code>ptr</code>, per sapere cosa c‚Äô√® scritto dentro o per scriverci qualcosa dentro, devo mettere <code>*ptr</code>, cio√® devo dereferenziarlo, dire ‚Äú<em>prendi quel numero l√¨, consideralo indice nello spazio di indirizzamento e vai a vedere</em>‚Äù.</p>
<p>Questo √® il primo problema, quindi necessariamente se devo manipolare dati grossi che hanno durata diversa da quella di una funzione o hanno dimensione non nota in fase di compilazione, devo avere dei puntatori tra le mani.</p>
<p>Secondo problema, questi puntatori inizialmente devo richiederne l‚Äôuso allocando in modo esplicito la memoria, invocando la funzione che va a cercare un posto e mi restituisce l‚Äôindirizzo del punto d‚Äôinizio.</p>
<p>E ho la responsabilit√† prima o poi di rilasciarli, cio√® di dire ‚Äú<em>runtime execution environment, sappi che questa zona non mi serve pi√π, te la restituisco, potrebbe servire a qualcun altro‚Äù.</em></p>
<p>Notate che il riciclo √® il principio fondamentale, sullo stack il riciclo √® frequentissimo, io chiamo la funzione f, usa lo stack per farci delle cose allungandolo, la funzione f ritorna, lo stack si ricontrae, e poi dopo aver chiamato la funzione f chiamo la funzione g, lo stack si riespande e va a occupare gli stessi spazi che prima usava la funzione f, ma ormai la funzione f √® ritornata, chi se ne frega, va benissimo, quindi quella zona l√¨ √® usata pi√π e pi√π volte, ed √® il motivo per cui √® pericolosissimo lasciare dei puntatori sparsi nello stack, perch√© io ti lascio adesso questo dato, che vale una certa cosa, ma poi io torno, √® rimasto un puntatore farlocco, parte qualcun altro che in quella zona scrive altre cose, quindi quel puntatore non so pi√π che cosa contiene.</p>
<p>Sullo heap anche, solo che mentre sullo stack io non devo fare nulla per causare questo riciclo, sullo heap il riciclo lo devo provocare io dicendo ‚Äú<em>tu mi hai dato questa zona, io l‚Äôho usata, adesso non mi serve pi√π, te la restituisco</em>‚Äù, e questo permetter√†, dopo che io ho restituito un blocco di memoria, se da qualche altra parte del mio programma servir√† dell‚Äôaltra memoria, di poterla eventualmente riusare.</p>
<p>Se io non rilascio la memoria, cosa succede?
Beh, il sistema operativo dice ‚Äú<em>ne hai bisogno ancora? tienila, non c‚Äô√® problema</em>‚Äù.</p>
<p>Piccolo problema, se io ne chiedo un pezzo, ok, ne chiedo un altro, ok, ne chiedo un altro, eccetera, lo heap √® esattamente come lo stack: ha dimensione, <strong>finita</strong>.</p>
<p>E‚Äô molto pi√π grande dello stack, ma √® finito, e dopo un po‚Äô si esaurisce.
Esaurendosi, verr√† il momento in cui gli chiedo ancora un pezzo, ma non ne ha pi√π.</p>
<p>E a quel punto il programma si rompe, proprio come si rompe con lo stack overflow.</p>
<p>C‚Äô√® una responsabilit√† in pi√π: io lo devo rilasciare <strong>una e una sola volta</strong>.
Non meno- <a href="02-allocazione_della_memoria_parte_2.html#allocazione-della-memoria---malnati-2">Allocazione della memoria - Malnati 2</a></p>
<ul>
<li><a href="02-allocazione_della_memoria_parte_2.html#1-modello-di-esecuzione">1. Modello di esecuzione</a></li>
<li><a href="02-allocazione_della_memoria_parte_2.html#2-stack">2. Stack</a>
<ul>
<li><a href="02-allocazione_della_memoria_parte_2.html#21-esempio-limite-stack">2.1 Esempio limite stack</a></li>
</ul>
</li>
<li><a href="02-allocazione_della_memoria_parte_2.html#3-heap">3. Heap</a>
<ul>
<li><a href="02-allocazione_della_memoria_parte_2.html#31-esempio-heap">3.1 Esempio heap</a></li>
</ul>
</li>
<li><a href="02-allocazione_della_memoria_parte_2.html#4-organizzazione-dello-spazio-di-indirizzamento">4. Organizzazione dello spazio di indirizzamento</a></li>
</ul>
<p>E vengono dei mostri. Per cui il programma compila, e poi quando esegue capitano cose a caso. Questi sono gli <strong>undefined behavior</strong>.</p>
<h2 id="31-esempio-heap"><a class="header" href="#31-esempio-heap">3.1 Esempio heap</a></h2>
<p><img src="images/allocazione_della_memoria_2/image%2022.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_2/image%2023.png" alt="image.png" /></p>
<p>Vediamo la storia dello heap.</p>
<p>Ripartiamo con la nostra, con il nostro main.</p>
<p>Parto al solito con lo spazio per valore di ritorno, alloco la variabile locale V, sta nello stack esattamente come prima.</p>
<p><img src="images/allocazione_della_memoria_2/image%2024.png" alt="image.png" /></p>
<p>Poi chiamo, introduco la variabile <code>buf</code> che √® di tipo int*.
Quindi lo stack cresce per avere spazio per la variabile buf.</p>
<p>E a quanto inizializzo la variabile buf? La inizializzo con il valore di ritorno di f di V.
Dunque devo chiamare f e passargli V. E mi serve un valore di ritorno.</p>
<p>Quindi non solo sullo stack ho messo buf, ma faccio anche spazio per <code>res</code>, il posto dove verr√† messo il ritorno, e faccio anche lo spazio per il parametro di f, che in questo caso √® il risultato dell‚Äôespressione <code>v</code>, che vale 2.</p>
<p>E quindi preparo questi tre pezzi.</p>
<p><img src="images/allocazione_della_memoria_2/image%2025.png" alt="image.png" /></p>
<p>E poi fisicamente chiamo f. Quindi lo stack cresce ancora e ci metto l‚Äôindirizzo di ritorno.
Adesso che ho fatto tutte queste simpatiche cose, vedo cosa succede dentro f.</p>
<p><img src="images/allocazione_della_memoria_2/image%2026.png" alt="image.png" /></p>
<p>Che fa f?
Guarda al solito se A √® maggiore di 0 e chiede di allocare un blocco di memoria.</p>
<p>Qui lo faccio con la sintassi del C++: <code>new int[a];</code>
Quel new vuol dire ‚Äú<em>lo alloco nello heap</em>‚Äù.</p>
<p>Che cosa alloco? Un array di interi.</p>
<p>Quanti interi? Eh non lo so. A differenza dell‚Äôesempio che vi ho fatto vedere prima con lo stack overflow, dove scrivevo <code>uint8_t[1024x1024]</code>, lo sapevo in compilazione, faceva un milione qualcosa, qui √® int di a.</p>
<p>A runtime lo sapr√≤, in questo caso √® 2. In un altro caso potrebbe essere 27, o 2500 etc...</p>
<p>Questa scrittura mi permette di andare a cercare sullo heap da qualche parte dove c‚Äô√® un blocco con almeno due interi vicini disponibile.</p>
<p>Quindi <code>new int[a]</code> trova sullo heap uno spazio sufficiente per tenermi due interi, in questo caso.
Prende il puntatore al primo, al byte iniziale del primo intero, e me lo restituisce.</p>
<p>Cosa me ne faccio di questo valore restituito?
Lo passo al return, che quindi lo deposita nell‚Äôapposita casellina che il chiamante mi ha preparato per mettere il risultato.</p>
<p>E quindi ci mette dentro questo.</p>
<p><img src="images/allocazione_della_memoria_2/image%2027.png" alt="image.png" /></p>
<p>E poi contrae tutto.</p>
<p>Quindi contrae tutto, torno al chiamante, cosa succede?
Il chiamante prende il valore che era stato restituito e lo deposita, in questo caso dentro buff.</p>
<p>Quindi adesso mi ritrovo che buff punta da qualche parte nella memoria, dove ci sono due interi, quello che gli ho chiesto.</p>
<p>Bene. Che faccio?
Quello che voglio, lo uso, f √® tornata ma buf √® ancora l√¨, tranquillo.</p>
<p>Quindi ho in questo caso sia una variabile la cui dimensione √® nota solo a run time, sia la cui durata √® pi√π lunga della funzione in cui √® nata.</p>
<p>La memoria puntata da buf nasce nella funzione f ma rimane in vita, accessibile, dopo che la funzione f √® finita.</p>
<p>Faccio tutto quello che devo all‚Äôinterno di quella memoria, quando non mi serve pi√π ho la responsabilit√† di rilasciarla.</p>
<p><img src="images/allocazione_della_memoria_2/image%2028.png" alt="image.png" /></p>
<p>Come la rilascio? L‚Äôho creato con new, lo rilascio con <code>delete</code>.</p>
<p>Delete vuol dire ‚Äú<em>quell‚Äôarray l√¨ non mi serve, buttalo via</em>‚Äù. Il sistema operativo prende atto e rilascia la memoria, si segna che non √® pi√π in uso, e la pu√≤ dare a un altro se ne avesse bisogno.</p>
<p><strong>Attenzione</strong>: dentro buf per√≤ √® rimasto il numerino che c‚Äôera prima, non √® che √® sparito, dentro buf supponiamo che la new avesse trovato uno spazio all‚Äôindirizzo 3b7f59: quello √® scritto dentro buf.</p>
<p>Se non ci sto attento, io vedo che dentro buf c‚Äô√® un valore lecito, e potrei cercare di guardare dove punta, ma adesso punta a casa di altri!</p>
<p><img src="images/allocazione_della_memoria_2/image%2029.png" alt="image.png" /></p>
<p>Qui va tutto bene perch√© scrivo return 0, quindi metto 0 nella celletta che mi √® stata preparata per il valore di ritorno, contraggo lo stack e ho finito.</p>
<h1 id="4-organizzazione-dello-spazio-di-indirizzamento"><a class="header" href="#4-organizzazione-dello-spazio-di-indirizzamento">4. Organizzazione dello spazio di indirizzamento</a></h1>
<p><img src="images/allocazione_della_memoria_2/image%2030.png" alt="image.png" /></p>
<p>Cosa ci trovo nello spazio di indirizzamento?</p>
<p>Un po‚Äô di cose:</p>
<ul>
<li>il <strong>codice eseguibile</strong>, tutte le istruzioni che sono state generate tipicamente sono scritte in modo compatto, vicino una all‚Äôaltra per convenienza, tipicamente questa zona qui ha un accesso che √® in lettura e in esecuzione, ma non in scrittura.</li>
<li>l‚Äô<strong>area delle costanti</strong>, che √® un blocco, se io nel programma ho dichiarato una serie di costanti (es. <code>const float p=3.14</code>), ecco, quella zona l√¨ √® una zona di nuovo che viene compattata insieme, e che viene marcata come read only, in modo da non rischiare di sporcarla.</li>
<li>una zona dentro cui ci sono le <strong>variabili globali</strong>, ammesso di averne scritta qualcuna, che √® una zona in lettura e scrittura.</li>
<li>lo <strong>stack</strong>, che √® una zona accessibile in lettura e scrittura preallocata di una certa dimensione.</li>
<li>lo <strong>heap</strong>, che √® una zona disponibile in lettura e scrittura, di per s√© molto grande, ma in cui non ho diritto di scrivere e leggere dove cavolo voglio. Perch√© √® soggetta ai limiti del fatto che il sistema, la runtime library, me le d√† lui o lei che sia, quei pezzettini, che io gli vado a chiedere chiamando <code>new</code> e rilascio con <code>delete</code>, oppure se sono in C, che chiedo con <code>malloc</code> e rilascio con <code>free</code>. Quindi devo farci un po‚Äô di attenzione.</li>
</ul>
<p><img src="images/allocazione_della_memoria_2/image%2031.png" alt="image.png" /></p>
<p>Come sono messe queste aree?
Ogni sistema operativo le sceglie a modo proprio. In Linux √® molto facile vederle.</p>
<p>Se voi prendete un processo qualunque di quelli esistenti, in una macchina Linux o una macchina virtuale, andate a guardare nel file system, trovate che nel file system c‚Äô√® una cartella che si chiama /proc. /proc contiene degli pseudo directory, cui nome √® un numero, 27521760.</p>
<p>Quei numerini l√¨ sono semplicemente i process ID dei processi attualmente in funzione.
√à una cartella fittizia, non corrisponde a un vero dato sul disco, √® il modo con cui il sistema operativo permette l‚Äôintrospezione, cio√® vi fa vedere com‚Äô√® fatto.</p>
<p>Se prendete un processo che esiste, qui io banalmente quando ho stampato sta cosa avevo in esecuzione un processo che si chiamava 4742, dentro questa pseudo cartella c‚Äô√® un altro file che si chiama /maps.</p>
<p>√à un file di testo, √® sempre un file virtuale che viene generato.
Dentro vi mette una per riga i blocchi dello spazio di indirizzamento in uso.</p>
<p>In questo caso cosa ci trovo?
C‚Äôerano un po‚Äô di cose, qui adesso condensate per stare nella slide, e ho messo in evidenza i tre pezzi che mi interessavano.</p>
<p>C‚Äô√® un blocco da 7F4E3161D000, che √® readable ed executable ma non writable (p ha semplicemente a che fare con il modo del mapping l√¨ sopra), dove c‚Äô√® una sequenza di 3538 byte che corrisponde all‚Äôeseguibile che stavo provando, home/user/testmem.</p>
<p>C‚Äô√® un‚Äôaltra area che √® l‚Äôarea dello heap, c‚Äô√® un‚Äôaltra area, un po‚Äô pi√π in su, che √® l‚Äôarea dello stack, e c‚Äô√® un‚Äôaltra area che in questo caso √® usata da un driver, un virtual driver del sistema operativo, e cos√¨ via.</p>
<p>Quindi avete la possibilit√† di andare a vedere, notate che lo spazio andrebbe da 0 a FFFFFFFF, ma solo dei pezzettini piccoli sono usati, tutto il resto √® inaccessibile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocazione-della-memoria---malnati-3"><a class="header" href="#allocazione-della-memoria---malnati-3">Allocazione della memoria - Malnati 3 <!-- omit in toc --></a></h1>
<h1 id="indice-1"><a class="header" href="#indice-1">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="03-allocazione_della_memoria_parte_3.html#1-ciclo-di-vita-delle-variabili">1. Ciclo di vita delle variabili</a>
<ul>
<li><a href="03-allocazione_della_memoria_parte_3.html#11-esempio-costruttore-e-distruttore">1.1 Esempio costruttore e distruttore</a></li>
</ul>
</li>
<li><a href="03-allocazione_della_memoria_parte_3.html#2-allocazione-della-memoria">2. Allocazione della memoria</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#3-rilascio-della-memoria">3. Rilascio della memoria</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#4-puntatori">4. Puntatori</a>
<ul>
<li><a href="03-allocazione_della_memoria_parte_3.html#41-indirizzo-valido">4.1 Indirizzo valido?</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#42-quanto-%C3%A8-grosso-il-blocco-puntato">4.2 Quanto √® grosso il blocco puntato?</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#43-fino-a-quando-%C3%A8-garantito-laccesso">4.3 Fino a quando √® garantito l‚Äôaccesso?</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#44-se-ne-pu%C3%B2-modificare-il-contenuto">4.4 Se ne pu√≤ modificare il contenuto?</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#45-occorre-rilasciarlo">4.5 Occorre rilasciarlo?</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#46-lo-si-pu%C3%B2-rilasciare-o-altri-conoscono-lo-stesso-indirizzo">4.6 Lo si pu√≤ rilasciare o altri conoscono lo stesso indirizzo?</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#47-viene-usato-come-modo-per-esprimere-lopzionalit%C3%A0-del-dato">4.7 Viene usato come modo per esprimere l‚Äôopzionalit√† del dato?</a></li>
</ul>
</li>
<li><a href="03-allocazione_della_memoria_parte_3.html#5-rischi">5. Rischi</a>
<ul>
<li><a href="03-allocazione_della_memoria_parte_3.html#51-esempi">5.1 Esempi</a>
<ul>
<li><a href="03-allocazione_della_memoria_parte_3.html#511-dangling-pointer">5.1.1 Dangling Pointer</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#512-memory-leakage">5.1.2 Memory Leakage</a></li>
<li><a href="03-allocazione_della_memoria_parte_3.html#513-double-free">5.1.3 Double free</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="03-allocazione_della_memoria_parte_3.html#6-gestire-i-puntatori">6. Gestire i puntatori</a></li>
</ul>
<h1 id="1-ciclo-di-vita-delle-variabili"><a class="header" href="#1-ciclo-di-vita-delle-variabili">1. Ciclo di vita delle variabili</a></h1>
<p><img src="images/allocazione_della_memoria_3/image.png" alt="image.png" /></p>
<p>Abbiamo cominciato a vedere la divisione tra stack e heap e abbiamo visto sostanzialmente come le variabili locali esistono nel contesto del blocco in cui sono definite.</p>
<p>Quando entro all'interno di un blocco e incontro la definizione di una variabile globale, questa comincia a esistere, viene allocata sullo stack, quando arrivo alla parentesi graffa corrispondente alla chiusura del blocco la variabile viene buttata via, perdendo il dato che aveva al suo interno.</p>
<p>In generale, adesso vogliamo focalizzarci sul controllo del ciclo di vita che ciascuna di variabili ha e di come noi andiamo a intervenire.</p>
<p>Allora, le variabili globali esistono da sempre, <strong>quindi prima che parta il main e cessano di esistere dopo che il main √® finito</strong>.
Sono accessibili in ogni momento e in generale se contengono del codice di inizializzazione, questo viene eseguito prima che il main parta.
Se contengono del codice di finalizzazione, questo viene eseguito dopo l'uscita del main.</p>
<p>L'altra caratteristica delle variabili globali √® che hanno un <strong>indirizzo assoluto</strong>, il compilatore sa gi√† dove le mette e quindi pu√≤, tutte le volte che incontra una variabile globale, scrivere gi√† <em>‚Äúquella l√¨ sta all'indirizzo 3b7f5942‚Äù</em>.</p>
<p>Le variabili locali, viceversa, incominciano a esistere quando si arriva alla loro definizione, cio√® alla riga dove compare quella variabile locale l√¨, int i=5, in quel momento comincia a esistere, cessano di esistere quando arrivo alla chiusura graffa corrispondente e hanno un indirizzo che √® <strong>relativo alla cima dello stack</strong>.</p>
<p>Quindi quando il compilatore genera il codice, per riferirsi a quella variabile locale l√¨, tendenzialmente dice <code>base_ptr+27</code>, <code>base_ptr+32</code>, qualcosa del genere, dove <code>base_ptr</code> √® un registro ausiliario, nel caso dell'x86, che serve a contenere una copia dell‚Äôindirizzo dello stack all'inizio della funzione stessa, in modo da poter definire questo ‚Äúoffset‚Äù relativo da cui partire.</p>
<p><img src="images/allocazione_della_memoria_3/image%201.png" alt="image.png" /></p>
<p>Le variabili locali hanno un valore iniziale casuale.
Se io dichiaro solo <code>int i</code> e non gli assegno direttamente un valore di inizializzazione, lo stack si abbassa di 4 byte e cosa c'√® in quello spazio nello stack? Quello che c‚Äô√®.</p>
<p>Non sono in grado di prevedere il suo contenuto.</p>
<p><img src="images/allocazione_della_memoria_3/image%202.png" alt="image.png" /></p>
<p>Poi abbiamo le variabili dinamiche, cio√® sono quelle che contengono un dato e che noi possiamo referenziare solo tramite puntatori.
Tocca al programmatore controllare nel ciclo di vita.</p>
<p>Una variabile dinamica comincia a esistere nel momento in cui io esplicitamente la alloco, e cessa di esistere quando la rilascio.</p>
<p>Come si fanno allocazione e rilascio?
Dipende dal linguaggio.</p>
<p>Se sto scrivendo del codice in C, l'allocazione si fa con <code>malloc</code>, o le sue funzioni parenti <code>calloc</code>, <code>realloc</code>, e il rilascio si fa con <code>free</code>.</p>
<p>Se sto lavorando in C++, che mi d√† un supporto pi√π avanzato alla gestione dei tipi, l'allocazione dinamica si fa con l'operatore <code>new</code> e il rilascio si fa con l'operatore <code>delete</code>.
Se ho una classe di tipo <code>automobile</code>, che rappresenta un veicolo, posso dire, la mia variabile <code>auto* a = new auto;</code>.</p>
<p>L'effetto di scrivere new auto √® duplice.
Viene cercato sullo heap un blocco di memoria grande quanto serve a contenere un'automobile. Quanto ne serve dipende da come √® definita quella classe, da quanti campi internamente avr√†.</p>
<p>Subito dopo, trovato questo blocco, viene invocato il <strong>costruttore della classe</strong>, che si occupa di riempire quel blocco con i dati iniziali.</p>
<p>Esattamente come in Java, in C++ le classi hanno dei costruttori che ci permettono di garantire che la memoria sia inizializzata correttamente.</p>
<p><em>Come rilasciamo i blocchi di memoria che allochiamo dinamicamente?</em>
Li rilascio con <code>delete</code>.</p>
<p><em>Cosa succede quando chiamo delete?</em>
Anche qui due cose.</p>
<p>Prima di tutto <strong>viene chiamato il <em>distruttore</em></strong>.
<em>Cos'√® il distruttore?</em>
√à un particolare metodo che il C++ ci mette a disposizione, all'interno del quale noi possiamo scrivere cosa fare nel momento in cui la variabile cessa di esistere.
Il distruttore ci √® utile quando una classe contiene, all'interno dei propri campi, delle risorse che devono essere lasciate.</p>
<p>Ad esempio, io potrei avere una classe che gestisce un file, il costruttore potrebbe essere responsabile di aprire il file, il distruttore √® responsabile di chiudere il file.</p>
<p>Cos√¨ sono tranquillo che quando quell'oggetto cessa di esistere, il file sar√† chiuso.</p>
<p>Il costruttore lo chiamate <em><strong>voi</strong></em> esplicitamente nel momento in cui fate <code>new</code> o semplicemente dichiarate una variabile di quel tipo, il distruttore viene chiamato esclusivamente dal <em><strong>compilatore</strong></em>.</p>
<p>Viene chiamato, in qualche modo, sotto il vostro diretto controllo quando fate <code>delete</code>, per cui lui distrugge e poi rilascia la memoria, cio√® notifica che quel gruppo di byte pu√≤ essere riusato per altro.
Nel caso delle variabili locali viene chiamato nel momento in cui la variabile viene egettata.</p>
<h2 id="11-esempio-costruttore-e-distruttore"><a class="header" href="#11-esempio-costruttore-e-distruttore">1.1 Esempio costruttore e distruttore</a></h2>
<p>Facciamo una prova velocissima per renderci conto di questa cosa qua.</p>
<p><img src="images/allocazione_della_memoria_3/image%203.png" alt="image.png" /></p>
<p>Vediamo che il programma parte, mi stampa ‚Äúmain()‚Äù.
Subito dopo aver chiamato main, e subito dopo aver fatto la stampa, dichiara la variabile <code>t</code> di tipo <code>Test</code>, che quindi viene automaticamente costruita, e qui mi dice <em>‚Äúl‚Äôho costruito all‚Äôindirizzo 16db8353b‚Äù</em>, poi va avanti, stampa ‚Äúfine main()‚Äù, e poi esegue return 0, chiusa graffa.</p>
<p>In corrispondenza di quella chiusa graffa l√¨, lui dice ‚Äú<em>devo pulire lo stack</em>‚Äù<em>.</em>
Cosa c‚Äôera nello stack?
Avevo un oggetto <code>Test</code>, quindi automaticamente invoca il distruttore, e vediamo ‚Äúdistrutto Test‚Äù, proprio a quell‚Äôindirizzo l√¨.</p>
<p><img src="images/allocazione_della_memoria_3/image%204.png" alt="image.png" /></p>
<p><em>Cosa succede se facciamo cos√¨?</em></p>
<p>Parte dal main, inizia il ciclo for, all‚Äôinterno del ciclo for dichiaro la variabile <code>t</code>, che viene costruita, viene costruita dove?</p>
<p>Abbassando leggermente lo stack, e quindi sta all‚Äôindirizzo 37, quello che finisce con 37.
Poi subito dopo stampa iterazione numero 0, e arriva la chiusa graffa, dove test finisce, e quindi che cosa fa? Distrugge l‚Äôoggetto <code>t</code>.</p>
<p>E chiaramente l‚Äôha costruito all‚Äôindirizzo 37, e lo distrugge all‚Äôindirizzo 37, quindi lo stack risale un po‚Äô, poi torna a fare l‚Äôiterazione successiva.</p>
<p>Dice ‚Äú<em>ah, ho bisogno di un Test</em>‚Äù, riabbassa lo stack, stampa iterazione numero 1, rialza lo stack, e lo fa tre volte.</p>
<p>Poi arriva al fondo, stampa ‚Äúfine del main‚Äù, chiusa.</p>
<p>Quindi, vediamo che, dichiarata dentro un ciclo for, la variabile viene creata tante volte quante sono le iterazioni del ciclo, e viene distrutta al termine dell‚Äôiterazione del ciclo.</p>
<p><img src="images/allocazione_della_memoria_3/image%205.png" alt="image.png" /></p>
<p>Se io dichiarassi anche una variabile globale, <code>Test t1</code>, vedete che questa volta dice <em>‚Äúho costruito un Test all‚Äôindirizzo 1000a8000‚Äù</em>, prima ancora di chiamare main.</p>
<p>Perch√©? Perch√© il costruttore delle variabili globali parte prima che inizi il main!</p>
<p>Fa tutte le sue cose, mi dir√† ‚Äúfine main‚Äù, e poi mi distrugge quella parte l√¨.</p>
<p>Qui non riusciamo bene a distinguere che cosa avviene dove e quando, perch√© anche prima ci stampava ‚Äúdistrutto‚Äù dopo aver scritto ‚Äúfine del main‚Äù, perch√© noi la scritta ‚Äúfine del main‚Äù non la possiamo mettere in corrispondenza del chiusa graffa, possiamo solo metterla in corrispondenza subito prima del chiusa graffa, quindi la vera distruzione avviene tra la stampa e il chiusa graffa, se fosse locale.</p>
<p>Quella globale avviene dopo il chiusa graffa.</p>
<p>Comunque, sostanzialmente le cose sono fatte cos√¨.</p>
<p>Tutte queste sono variabili che hanno un ciclo di vita ben definito.</p>
<p><img src="images/allocazione_della_memoria_3/image%206.png" alt="image.png" /></p>
<p><em>Cosa succede se noi invece allocassimo delle cose dinamicamente?</em></p>
<p>Scritto in questo modo, <code>new Test()</code> dice <em>‚Äúquesta variabile non deve stare nello stack, deve stare nello heap e la voglio tenere fin quando mi viene comoda‚Äù</em>.</p>
<p>Ad esempio, dentro il ciclo for potrei dire <code>if i==1 delete pt</code>.
Quindi invece di far coincidere la vita di questa variabile con un blocco, la creo prima del for e la distruggo a met√† delle iterazioni del for.</p>
<p>Quindi avr√≤ delle iterazioni del for in cui quella variabile l√¨ non √® pi√π valida.</p>
<p>Parte, √® sempre costruita la variabile globale t1 che questa volta parte all‚Äôindirizzo 1049d8000, poi viene stampato ‚Äúmain()‚Äù, e poi viene stampato <code>Costruito Test @ 0x600000744040</code>, e notiamo che l‚Äôindirizzo √® totalmente diverso: 60000744040.</p>
<p>Questo perch√© vive in una zona totalmente distinta, nell‚Äôheap!</p>
<p>Poi c‚Äô√® l‚Äôiterazione numero 0, poi dovrebbe arrivare nell‚Äôiterazione numero 1 e in effetti ci entra ma subito prima della stampa viene eseguita la delete.</p>
<p>Poi fa l‚Äôiterazione numero 2, il ciclo for finisce, finisce il main, ma c‚Äô√® ancora una variabile globale, che quindi viene buttata via invocando il distruttore.</p>
<p>Quindi le variabili possono avere un codice di inizializzazione, lo chiamiamo <strong>costruttore</strong>, possono avere un codice di rilascio, che chiamiamo <strong>distruttore</strong>.</p>
<p>Il costruttore implicitamente lo andiamo a chiamare nel momento in cui mettiamo in gioco la variabile, il distruttore √® sempre solo chiamato dal compilatore: noi non abbiamo nessuna chiamata <code>~Test()</code>.</p>
<p>E viene chiamato nel momento giusto, quando quella variabile cessa di esistere.</p>
<p><img src="images/allocazione_della_memoria_3/image%207.png" alt="image.png" /></p>
<p>Quindi le variabili dinamiche hanno un indirizzo che √® assoluto.
Peccato che non si pu√≤ sapere a compile time, solo a run time me lo verr√† detto, quando io invoco <code>new *qualcosa*</code>, in quel momento verr√† cercato un posto grande a sufficienza per far stare la mia variabile.</p>
<p>E accedo alle variabili dinamiche solo tramite puntatori, mentre alle altre accedo con variabili che hanno un nome.</p>
<p>Il fatto che sia inizializzato o meno il valore iniziale dipende da cosa ho scritto nel costruttore, dipende anche dal linguaggio.
Se faccio <code>malloc</code>, malloc non mi d√† garanzie di inizializzazione, mi prende un blocco grande quanto gli chiedo, ad esempio 84, e lui mi cerca 84 byte, ma non √® che li pulisce, mi d√† il puntatore al primo di 84 byte e basta, dentro ci pu√≤ essere qualunque cosa.</p>
<p>Quando faccio in C++ <code>new</code>, new passa attraverso il costruttore che di solito si prende la briga di inizializzare le cose.</p>
<p>Chiaramente perch√© possano funzionare le variabili dinamiche ci vuole un sistema di supporto, quando io chiamo <code>malloc</code> o <code>new</code>, come fa l‚Äôimplementazione di <code>malloc</code> o <code>new</code> a darmi un indirizzo?</p>
<p>Deve cercare!
Vuol dire che internamente <code>malloc</code> e <code>new</code> sono in realt√† delle funzioni sofisticate che si appoggiano a una loro rappresentazione della memoria, sanno che per esempio all‚Äôinizio lo heap va dall‚Äôindirizzo 60000 all‚Äôindirizzo 70000, prendiamo dei numeri a caso, ed √® tutto libero, quindi alla domanda <em>‚Äúdammene un pezzo‚Äù</em> magari vi danno l‚Äôinizio, poi dopo un po‚Äô chiedo un altro pezzo, mi danno quello che viene subito dopo, poi magari gli rilascio il pezzo iniziale e a questo punto l‚Äôheap che prima era tutto bello compatto √® diventato con un buchino.</p>
<p>Quando gli chieder√≤ un‚Äôaltra cosa, probabilmente cercheranno se tra i rotti c‚Äô√® un pezzo piccolo dove ci sta gi√† quello che io gli chiedo, perch√©?</p>
<p>Perch√© vale il principio che se posso uso gli sfridi, non vado a intaccare il pezzo grosso.</p>
<p>Chiaramente andare a cercare qual √® il punto pi√π conveniente pu√≤ essere lento, perch√© io ho tante alternative, potrei accontentarmi della prima ma non √® detto che la prima sia la pi√π furba.</p>
<p>Probabilmente <code>malloc</code> e <code>new</code> possono tenersi i loro pezzettini organizzati in tanti modi, il modo pi√π becero √® una lista, per√≤ se √® una lista per sapere quale pezzettino pi√π adatto la devo visitare tutta, e quella lista pu√≤ essere molto lunga, ci mette un mucchio a saperlo, oppure posso tenerla organizzata ad albero, √® molto pi√π articolata, tengo un albero dove parto da un punto medio, a destra metto i pezzi piccoli, a sinistra metto i pezzi grandi e cos√¨ via, quella potrebbe essere un‚Äôaltra strategia.</p>
<p>L‚Äôunico problema √® che quando io seguo un pezzo devo ribilanciarmi l‚Äôalbero, perch√© adesso mi sono trovato un pezzettino, uno sfridino piccolo che deve andare da qualche parte e devo andare a spostare, oppure quando qualcuno mi restituisce se riesco a compattare devo fare un pezzo grosso.</p>
<p>Quindi le operazioni di allocazione e rilascio sono potenzialmente operazioni lente e complesse, che richiedono di tenere allineate un mucchio di cose, consumano.</p>
<p>Se <code>malloc</code> deve farsi l‚Äôalbero vuol dire che una parte della memoria che globalmente ha a disposizione la usa per se stesso e non la potr√† mai dare al programma ‚Äî pi√π √® sofisticata quella struttura l√¨ fatta di puntatori, mappe, tabelle e schifezze di ogni tipo, meno sar√† la memoria per il programma.
Probabilmente sar√† pi√π efficiente nel comportamento, ma c‚Äô√® un bilanciamento da trovare.</p>
<p><em>Cosa succede quando il programmatore chiama</em> <code>free</code> <em>piuttosto che</em> <code>delete</code><em>?</em>
Restituisce quel pezzettino che aveva ricevuto.</p>
<p>Che cosa se ne fa la funzione <code>free</code> o la funzione <code>delete</code>?
Va a vedere nell‚Äôalbero, nella lista, in generale nella struttura dati se questo pezzettino A √® suo o meno, perch√© io potrei fare il furbo ‚Äî ad esempio se <code>malloc</code> mi dava gli indirizzi da 60.000 a 70.000 e io gli d√≤ un indirizzo che √® 1.000, ma lui mi dir√† che non √® mio.</p>
<p>Supponendo che sia suo va a cercare se quel pezzettino l√¨ gli risultava come occupato e lo deve marcare come libero e possibilmente lo deve accorpare ad altri pezzi liberi e adiacenti, in modo da fare un pezzo pi√π grosso.</p>
<p>Cosa succede se gli restituisco un pezzo, e poi senza averglielo chiesto, glielo restituisco di nuovo?
Cio√® se io nel programma che ho scritto, l√† dove ho messo <code>delete</code>, mettessi <code>delete</code> due volte?
La prima volta tutto bene, prende quel pezzo e lo mette a suo posto.</p>
<p>La seconda volta dipende come √® implementata.
Un‚Äôimplementazione di <code>delete</code> molto lenta ma attenta potrebbe rigettarmelo dicendo <em>‚Äúche √® sta roba? No, non va bene‚Äù</em>.
Un‚Äôimplementazione un po‚Äô pi√π veloce, che magari √® pi√π desiderabile perch√© io ho bisogno di fare tante <code>new</code> e tante <code>delete</code> nell‚Äôarco della vita del mio programma, potrebbe prendere per buono che quell‚Äôindirizzo che gli passo sia effettivamente indirizzo in uso e aggiornare le sue strutture dati.</p>
<p>Peccato che le strutture erano gi√† aggiornate, e quindi si spacca tutto.
E a quel punto l√¨ alle prossime richieste a <code>new</code> non ci capisce niente.</p>
<p>Se io non rilascio, resta il buco.
Se io rilascio due volte, spacco.</p>
<p>Se poi rilasci una cosa sbagliata, supponiamo, gli ho chiesto un indirizzo e lui mi ha dato 6.300, io gli restituisco 6.500, che √® solo un pezzo. Potrebbe non accorgersene, ma a quel punto fa casino totale. Qui la grande responsabilit√† del programmatore √® di fare le operazioni giuste.</p>
<h1 id="2-allocazione-della-memoria"><a class="header" href="#2-allocazione-della-memoria">2. Allocazione della memoria</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%208.png" alt="image.png" /></p>
<p>In C abbiamo <strong><code>malloc</code></strong> che ci restituisce un void asterisco, cio√® un puntatore opaco, un puntatore ad una cosa qualunque. Prende come parametro un numero di byte e ci restituisce, se pu√≤, un puntatore valido.</p>
<p><strong><code>Calloc</code></strong> che prende in ingresso un numero di byte e un moltiplicatore.
Serve per fare gli array. Ad esempio, ho bisogno di un array di 25 automobili. Fornisco quanti elementi voglio, e quanto √® grande un elemento di tipo auto, ad esempio 16 byte.
Quindi devo dare 25 x 16, 400 byte.</p>
<p><strong><code>Rialloc</code></strong> √® particolare, dice ‚Äú<em>cara malloc, tu mi avevi dato questo puntatore, guarda, adesso me serve uno un po‚Äô pi√π grande‚Äù</em>, oppure <em>‚Äúmi serve un po‚Äô pi√π piccolo‚Äù</em>.</p>
<p>Un po‚Äô pi√π grande, non √® detto sempre, un po‚Äô pi√π piccolo √® facile. Vuol dire che lei si segna che c‚Äô√® un pezzo in fondo che √® diventato libero.</p>
<p>Un po‚Äô pi√π grande √® pi√π complicato, perch√© non √® detto che al fondo ci sia ancora spazio. Quindi Rialloc non sempre funziona: se fallisce restituisce null.
Dice <em>‚Äúguarda, quello che avevi √® ancora buono, per√≤ non posso dartene di pi√π, non ce l‚Äôho o non ce l‚Äôho l√¨, devo spostarlo‚Äù</em>.</p>
<p><img src="images/allocazione_della_memoria_3/image%209.png" alt="image.png" /></p>
<p>In C++ invece abbiamo un <code>new</code> che prende il nome del tipo ed eventualmente tra parentesi gli argomenti.</p>
<p>Le parentesi nella versione vecchia del C++ erano sempre tonde, nella versione moderna del C++ sono graffe, perch√© questo semplifica, toglie delle ambiguit√† possibili.</p>
<p>Nel C++ potete fare <code>new</code> del tipo e basta, oppure <code>new[]</code>.
New con le quadre serve per gli array, pi√π o meno ha la stessa differenza che c‚Äô√® tra malloc e calloc in C.</p>
<p><img src="images/allocazione_della_memoria_3/image%2010.png" alt="image.png" /></p>
<p>Se allocate un array, specifichiamo quanti elementi vogliamo e lui inizializza tanti pezzi uno di fianco all‚Äôaltro.</p>
<h1 id="3-rilascio-della-memoria"><a class="header" href="#3-rilascio-della-memoria">3. Rilascio della memoria</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2011.png" alt="image.png" /></p>
<p>Se avete ottenuto il puntatore con una certa funzione, dovete rilasciarlo con la funzione <em><strong>duale</strong></em>.</p>
<p>Le cose create con <code>malloc</code>, <code>calloc</code>, <code>realloc</code> si rilasciano con <code>free</code>.</p>
<p>Le cose allocate con <code>new</code> si rilasciano con <code>delete</code>.
Le cose allocate con <code>new[n]</code> vengono rilasciate con <code>delete[]</code>.</p>
<p>√à necessario fare cos√¨, perch√© altrimenti il compilatore non capisce.</p>
<p>Se il blocco non viene rilasciato si crea una perdita di memoria, se invece viene rilasciato due volte si spacca tutto: si corrompono le strutture dati che internamente vengono usate e poi di l√¨ in avanti √® assolutamente impossibile dire cosa capita.</p>
<h1 id="4-puntatori"><a class="header" href="#4-puntatori">4. Puntatori</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2012.png" alt="image.png" /></p>
<p>L‚Äôidea del puntatore non √® solo collegato alla memoria dinamica.</p>
<p>Certo, non c‚Äô√® altro modo in C e C++ di avere accesso a memoria dinamica se non tramite puntatori, perch√© il linguaggio vi pone questo.</p>
<p>In realt√† i puntatori sono presenti in tantissimi altri linguaggi (li abbiamo anche in javascript, in java, in python e cos√¨ via..), ma semplicemente non lo sapete, perch√© la cosa viene tenuta in qualche modo nascosta.
Quei puntatori l√¨ sono essenziali per l‚Äôottimizzazione degli algoritmi.</p>
<p>Perch√©? Perch√© se io devo passarti un dato, se quel dato √® piccolo va bene, me lo passi ‚Äî un intero ad esempio non √® un grosso problema.
Ma se io devo passarti, ad esempio, un array che contiene mille elementi, mica te lo posso copiare.</p>
<p>S√¨, in alcuni casi te lo copier√≤ se ho davvero bisogno di mantenere due informazioni disgiunte. Ma altrimenti √® onerosissimo.
L‚Äôidea di poterti passare il puntatore mi d√† un mucchio di efficienza, √® comodo.</p>
<p>Quindi, il fatto che io abbia lo spazio dinamico (quindi che posso chiedere quando mi serve e rilasciare quando mi serve, che √® gi√† un grande vantaggio perch√© posso chiedere delle cose grandi a piacere senza saperlo a priori, posso tenerle a lungo per quanto mi serve etc‚Ä¶) abilita un mucchio di cose che altrimenti non riuscirei a fare.</p>
<p>Una linked list, ad esempio, se non avete la memoria dinamica, non la potete fare.
Perch√© la linked list, ogni volta che aggiungete un elemento, ha bisogno di prenderne un pezzo in pi√π e di metterlo al fondo.</p>
<p>Per√≤ vi pone il problema di gestire correttamente il rilascio.</p>
<p>I puntatori, al di l√† dell‚Äôuso della memoria dinamica, servono comunque tantissimo e abilitano tanti meccanismi che adesso vediamo nel dettaglio.</p>
<p>Per√≤, se li usiamo male √® un disastro, perch√© portano gli <em><strong>undefined behaviours</strong></em> che hanno conseguenze disastrose.</p>
<p><img src="images/allocazione_della_memoria_3/image%2013.png" alt="image.png" /></p>
<p>Vediamo l‚Äôuso tipico dei puntatori.</p>
<p>Il pezzo pi√π semplice dell‚Äôuso dei puntatori, che non necessitano direttamente la memoria dinamica, √® banalmente quando io devo dare l‚Äôaccesso a una variabile senza dover copiare la variabile.</p>
<p>Io ho la variabile <code>A</code>, che vale 10, e voglio permettere a qualcun altro di andarci a guardare dentro.
Recupero dalla variabile il suo puntatore e passo il puntatore a chi gli interessa.
Quest‚Äôaltro, dereferenziando il puntatore, potr√† leggere cosa c‚Äô√® scritto in quella variabile, potr√† scrivere cosa c‚Äô√® scritto in quella variabile.</p>
<p>Questo √® un uso comunissimo.</p>
<p>Oppure posso avere dei puntatori che sono allocati per uno scopo particolare.
L√¨ ho <code>int* pB = new int{24}</code>, voglio un intero dinamico che inizialmente vale 24 e che potr√≤ cancellare in un qualche momento.
Magari lo dar√≤ a qualcun altro per cancellarlo al posto mio o cose del genere.</p>
<p>I puntatori possono essere resi esplicitamente <strong>invalidi</strong>.
La convenzione che viene assunta in C √® che un puntatore √® invalido se contiene il numero 0.
Il puntatore dentro di s√© non √® nient‚Äôaltro che un numero, √® l‚Äôoffset nello spazio virtuale di indirizzamento. Se io gli scrivo 0, per convenzione quello √® un puntatore invalido.
Nel linguaggio C si usa di solito la macro NULL, che √® definita come <code>((void*)0)</code>.
Nel C++ si usa la parola chiave <code>nullptr</code>.</p>
<p><em>Perch√© questo √® utile?</em>
Perch√© in certe situazioni avere dei puntatori nulli mi permette di capire che certe cose non continuano oltre quel puntatore nullo.</p>
<p>Pensate a una lista collegata: ho il puntatore al primo elemento, che contiene il puntatore al secondo elemento, che contiene il puntatore al terzo elemento, che finalmente contiene null ‚Äî vuol dire che finisce l√¨ la lista.</p>
<p>Quindi avere una convenzione che mi dice quando un puntatore smette di essere buono √® utile.
Altrimenti non implementereste tantissime cose.</p>
<p><img src="images/allocazione_della_memoria_3/image%2014.png" alt="image.png" /></p>
<p>Il problema √® che ci sono tante responsabilit√†.</p>
<h2 id="41-indirizzo-valido"><a class="header" href="#41-indirizzo-valido">4.1 Indirizzo valido?</a></h2>
<p>Quando io ricevo una variabile di tipo puntatore e ci guardo dentro, leggo un numero, ad esempio <code>3b7f5944</code>‚Ä¶ <em>posso dire se quel numero √® <strong>valido</strong>?</em></p>
<p>Se ci leggo 0 posso sicuramente dire che <strong>non √® valido.</strong></p>
<p>Ma se c‚Äô√® scritto <code>3b7f5944</code> potrebbe <em>essere stato valido</em>, ma magari io l‚Äôho appena rilasciato, e se dopo averlo rilasciato ci vado a scrivere ancora, potrei fare dei danni (perch√® magari ora quel blocco apparterrebbe a qualcun altro).</p>
<p>Nell‚Äôesempio di codice che abbiamo visto prima, nel ciclo for alla seconda iterazione buttavamo via la variabile dinamica <code>pt</code>, ma nella variabile <code>pt</code> mi era rimasto l‚Äôindirizzo a quel blocco di memoria che abbiamo rilasciato nel for.
E se dopo che ho fatto <code>delete</code> ci andassi a scrivere sopra, farei del danno.</p>
<p>Per cui se io vedo un numero diverso da 0 <strong>non posso sapere direttamente se quello l√¨ √® mai stato buono, √® buono o √® ancora buono</strong>.</p>
<p>Questo √® il primo grossissimo problema che abbiamo con i puntatori.</p>
<h2 id="42-quanto-√®-grosso-il-blocco-puntato"><a class="header" href="#42-quanto-√®-grosso-il-blocco-puntato">4.2 Quanto √® grosso il blocco puntato?</a></h2>
<p>Secondo problema, quanto √® grosso il blocco puntato?
Un puntatore √® un singolo numero che rappresenta <strong>un solo byte</strong>.
Da cosa capisco <em>quanti byte posso andare a vedere, a partire da quello puntato?</em>
Potremmo pensare dal tipo: se quello l√¨ √® un puntatore a <code>int</code>, supponendo che l‚Äôint sia di 4 byte, so che posso andare a guardare da quella cella l√¨ fino alle tre successive, se fosse buono.</p>
<p>Ma se io avessi alloccato un <code>int[]</code> array? Non posso sapere quanti <code>int</code> ci sono in quell‚Äôarray, quindi non so fino a dove posso leggere lecitamente‚Ä¶
E l‚Äôidea di andare a contare finch√© non trovo lo 0 √® un‚Äôidea peregrinissima, perch√© potrebbe non esserci lo 0 e magari finisco a leggere in zone che non sono mie‚Ä¶</p>
<p>Dunque, il tipo non mi d√† queste informazioni.
Dire che quello l√¨ √® un <code>char*</code> mi dice s√¨ che se vado alla fine di questo puntatore trover√≤ un char, ma quanti char non lo so.</p>
<blockquote>
<p>üí° <strong>From ChatGPT</strong></p>
<p><img src="images/allocazione_della_memoria_3/image%2015.png" alt="image.png" /></p>
</blockquote>
<h2 id="43-fino-a-quando-√®-garantito-laccesso"><a class="header" href="#43-fino-a-quando-√®-garantito-laccesso">4.3 Fino a quando √® garantito l‚Äôaccesso?</a></h2>
<p><em>Fino a quando √® garantito l‚Äôaccesso?</em>
Non lo sappiamo.</p>
<p>Se quello l√¨ √® un puntatore ad una variabile locale, √® garantito fino a che il codice che l‚Äôha allocata non ha raggiunto la graffa finale.
Ma se io ho copiato questo puntatore in una struttura, quando andr√≤ a dare la struttura in giro, non posso sapere se quella variabile l√¨ era gi√† finita di vivere o meno.
<strong>Ho perduto questa informazione.</strong></p>
<h2 id="44-se-ne-pu√≤-modificare-il-contenuto"><a class="header" href="#44-se-ne-pu√≤-modificare-il-contenuto">4.4 Se ne pu√≤ modificare il contenuto?</a></h2>
<p>Posso modificare il contenuto?
Non lo sappiamo.</p>
<p>Teoricamente il tipo di puntatore potrebbe aiutarmi.</p>
<p>C e C++ distinguono il <code>const T*</code> dagli <code>T*</code> ‚Äî <code>char*</code> mi dice <em>‚Äúquello √® un puntatore a caratteri che puoi modificare‚Äù</em>, <code>const char*</code> mi dice <em>‚Äúquello √® un puntatore a caratteri che non puoi modificare, che devi solo leggere‚Äù</em>.</p>
<p>Ma √® un po‚Äô debole come cosa, perch√© io posso castare e far diventare un <code>const char*</code> un <code>char*</code> semplice. E a quel punto non ne so pi√π niente se quella era una cosa che non dovevo toccare...</p>
<h2 id="45-occorre-rilasciarlo"><a class="header" href="#45-occorre-rilasciarlo">4.5 Occorre rilasciarlo?</a></h2>
<p><em>Sono responsabile del suo rilascio?</em>
Non lo sappiamo.</p>
<p>Dipende come √® nato quel puntatore.</p>
<p>Se io mi sono procurato quel puntatore dalla variabile <code>l</code> tramite l‚Äôoperatore <code>&amp;</code>, non sono responsabile, perch√© la variabile <code>l</code> ha il suo ciclo di vita predefinito, e quando arriver√† al fondo del suo blocco verr√† buttata via.</p>
<p>Ma se io invece mi sono procurato il puntatore con <code>new</code>, sono responsabile io del suo rilascio.</p>
<p>Peccato che non c‚Äô√® modo di capirlo.
S√¨ √® vero, abbiamo visto nell‚Äôesempio di prima che l‚Äôindirizzo di una zona nell‚Äôheap √® diverso dall‚Äôindirizzo di una zona nello stack, ma non posso guardare quella cosa l√¨, perch√© ogni volta che lancio il programma lo spazio di indirizzamento √® randomizzato e posso avere delle cose a caso.</p>
<p>Quindi non posso basarmi su questa informazione qua.</p>
<p>E i linguaggi C e C++ non mi danno nessun suggerimento per distinguere quello che √® un puntatore dello heap, di cui qualcuno si deve occupare di rilasciare, da quello che √® un puntatore allo stack, dove √® il linguaggio che garantisce il rilascio.</p>
<h2 id="46-lo-si-pu√≤-rilasciare-o-altri-conoscono-lo-stesso-indirizzo"><a class="header" href="#46-lo-si-pu√≤-rilasciare-o-altri-conoscono-lo-stesso-indirizzo">4.6 Lo si pu√≤ rilasciare o altri conoscono lo stesso indirizzo?</a></h2>
<p>Supponendo che io possa per qualche via traversa sapere che sono responsabile del rilascio, lo posso rilasciare in questo momento? O c‚Äô√® una copia di questo stesso puntatore in giro in casa di qualcuno che potrebbe andarci a guardare dentro?
Non lo sappiamo.</p>
<h2 id="47-viene-usato-come-modo-per-esprimere-lopzionalit√†-del-dato"><a class="header" href="#47-viene-usato-come-modo-per-esprimere-lopzionalit√†-del-dato">4.7 Viene usato come modo per esprimere l‚Äôopzionalit√† del dato?</a></h2>
<p>√à difficile capire se questo puntatore viene usato per fornire un accesso efficiente ai dati oppure per esprimere il concetto di <em>opzionalit√†</em>.
Per esempio, una funzione che cerca un valore in un array potrebbe restituire un puntatore al valore se lo trova, oppure null se non lo trova.
Non abbiamo modo di saperlo.</p>
<p>Quello l√¨ √® un puntatore, non ha al suo interno altro tipo di informazioni per specificare cose di questo tipo.</p>
<p>Quindi il linguaggio, pur dandomi degli strumenti potenzialmente potenti per poter ottimizzare l‚Äôaccesso, mi lascia per√≤ con sette domande a cui non ho risposta.</p>
<p>E se da programmatore devo mettere le mani al codice, quella risposta l√¨ la devo dare io.</p>
<p><em>E come facciamo a darla?</em>
Andando a leggere tutto il codice, non solo un pezzettino, ma tutto.
Perch√© se di quel puntatore ce n‚Äô√® una copia sperduta da qualche parte, io non posso farci tante cose.</p>
<p>Il problema √® che <em>‚Äútutto quel codice‚Äù</em> comprende tutto il codice che scrivo io, tutto il codice che sta nelle librerie, e tutto il codice nascosto da qualche parte che in qualche modo interagisce con il mio.
E se non lo capisco, faccio delle assunzioni che possono essere sbagliate.</p>
<p>E ci√≤ pu√≤ causare problemi tutte le volte che provo poi a rieseguire il mio programma.
Il problema √® che buona parte di questi malfunzionamenti non sono ripetibili, ma nascono da combinazioni astrali, dal fatto che sono successe certe cose, che alcune sono successe pi√π in fretta di altre, e cose simili‚Ä¶ <strong>tutte cose che sono fuori dal nostro controllo.</strong></p>
<p>E quindi diventa complicatissimo sviluppare i programmi.</p>
<p>Per questi motivi, i programmi scritti in C e C++ sono un <em>florilegio</em> di bug.</p>
<p><img src="images/allocazione_della_memoria_3/image%2016.png" alt="image.png" /></p>
<p>In C e C++ usiamo i puntatori in tanti modi.</p>
<p>Il pi√π semplice √® quello per accedere, qua e ora, ad un dato valore.
Mi serve sostanzialmente per ottimizzare: evito di spostare una grossa struttura dati, e piuttosto ti passo il puntatore alla struttura.</p>
<p>Ti dico ‚Äú<em>Cara funzione, io te lo passo e tu lo usi adesso, per il tempo della tua chiamata. Ci guardi dentro, ci scrivi se devi scrivere, <strong>ma non te lo copi.</strong> Perch√© quando tu sarai tornata io non posso pi√π garantirti che questo dato rimanga valido, quindi lo devi usare solo adesso</em>‚Äù.</p>
<p>Il problema √® che non riesco a trasmettere in codice questa informazione.</p>
<p>Il meglio che posso fare √® scriverla in un commento, ma il commento lascia il tempo che trova, perch√© bisogna che qualcuno lo legga.
Bisogna prima che qualcuno l‚Äôabbia scritto, e poi bisogna che qualcuno lo legga e ne faccia uso.</p>
<p>Un puntatore lo posso usare per indicare a una funzione dove dovr√† mettermi le sue risposte.</p>
<p>√à il caso, ad esempio, della funzione <code>scanf</code>.
Quando in C usiamo <code>scanf</code> per leggere la tastiera, cosa facciamo?
Scriviamo <code>scanf(‚Äù%d‚Äù, &amp;i)</code>, cio√® passiamo il puntatore a una nostra variabile, dentro cui <code>scanf</code>, se trova un intero, ci scriver√† il valore che ha letto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2017.png" alt="image.png" /></p>
<p>Qua c‚Äô√® un esempio, ho una funzione ipotetica <code>read_data1</code>, che usa il valore di ritorno per dirmi se √® riuscita o meno a leggere i dati, e quindi mi d√† come valore di ritorno un booleano.</p>
<p>Nel caso in cui il booleano sia true, vuol dire <em>‚Äúho letto i dati‚Äù</em>, e il dato che legge me lo mette dentro il parametro.</p>
<p>Ovviamente siccome il parametro √® passato per copia, io non posso passargli un int, perch√© quell‚Äôint l√¨, quando la funzione ritorna ve l‚Äôavrebbe buttato via.
Io gli devo passare un puntatore, in modo tale che la funzione lo dereferenzia, ci scrive dentro e anche se poi il puntatore viene buttato via, siccome io ho l‚Äôoriginale, dall‚Äôoriginale prendo quello che mi serve.</p>
<p>E quindi, se qualcuno mi ha passato un risultato buono e ho dei dati disponibili, vado a prendermi i dati, li metto dentro il puntatore, <code>*result = get_some_data()</code> , quello che devo metterci. E in questo caso ritorno true.</p>
<p>Se non mi hai passato un puntatore buono, oppure non ho niente da dirti, ti rispondo false e lascio perdere.</p>
<p><img src="images/allocazione_della_memoria_3/image%2018.png" alt="image.png" /></p>
<p>Posso usare un puntatore per accedere a un blocco di dati.</p>
<p>Questo √® uno dei grossi casini del C, perch√© automaticamente quando voi dichiarate un array di n elementi, la vostra dichiarazione <code>int[10]</code>, quell‚Äôarray l√¨ si dimentica di essere un array <em>lungo 10 elementi</em>: viene <em><strong>demoted</strong></em>, ridotto a puntatore al primo elemento. Fine.</p>
<p>Ma quando io lo passo a qualcun altro, quell‚Äôaltro che ne sa che l√¨ ce ne sono davvero 10?Potrebbero essere solo 5.</p>
<p>Per questo in C++ c‚Äô√® un tipo apposito, l‚Äô<strong><code>std::array</code></strong>, che ha nella firma del tipo la dimensione e questo permette di capire quanto √® grande.</p>
<p><img src="images/allocazione_della_memoria_3/image%2019.png" alt="image.png" /></p>
<p>Posso usare il puntatore per farti accedere a una sequenza di dati pi√π o meno grande, non nota priori, √® il caso delle stringhe del C.</p>
<p>Le stringhe del C io ti passo il puntatore all‚Äôinizio e chi ha bisogno da quel puntatore va avanti a cercare quello che gli serve, fino a quando non incontra lo <code>/0</code>.</p>
<p>Tecnica pericolosissima, perch√© √® una di quelle pi√π facilmente hackerabile.</p>
<p><img src="images/allocazione_della_memoria_3/image%2020.png" alt="image.png" /></p>
<p>Posso usare i puntatori per accedere a dati dinamici, ed √® tutto quello che facciamo normalmente quando ci serve allocare delle mappe, delle liste, delle cose la cui dimensione non √® nota a priori.</p>
<p>Il problema √® che in questa situazione c‚Äô√® sicuramente la responsabilit√† del rilascio: in C++ se ho ottenuto il dato con una <code>new</code>, qualcuno lo dovr√† rilasciare con la <code>delete</code>, oppure se in C l‚Äôho ottenuto con la <code>malloc</code>, qualcuno lo dovr√† rilasciare con la <code>free</code>.</p>
<p>Di nuovo il C++ mi facilita perch√© mi mette a disposizione delle classi gi√† fatte che si occupano nel loro costruttore di prendere i pezzi di cui hanno bisogno e nel loro distruttore di buttare via tutto quello che avevano preso.</p>
<p>Rendendo quindi la vita del programmatore un pochino pi√π sicura, ma solo un po‚Äô.</p>
<p>E poi posso usare il puntatore come modo per esprimere l‚Äôopzionalit√† di un risultato, ovvero ti ritorno null se non ho trovato niente, o ti ritorno un puntatore valido se ho trovato qualcosa.
<strong>Ma non √® chiaro se quel puntatore valido va rilasciato o meno.</strong></p>
<p><img src="images/allocazione_della_memoria_3/image%2021.png" alt="image.png" /></p>
<p>Oppure posso usare il puntatore per fare delle strutture articolate come le liste, le mappe, etc...</p>
<p><img src="images/allocazione_della_memoria_3/image%2022.png" alt="image.png" /></p>
<p>Quindi, lavorando in C non c‚Äô√® salvezza.
Tutte quelle sette domande elencate prima non hanno nessuna risposta.
√à il programmatore che deve trovarsela.</p>
<p>C++ mi aiuta un po‚Äô di pi√π.
Mi aiuta un po‚Äô di pi√π perch√© mi d√† un supporto sintattico attraverso dei tipi pi√π elaborati, mediante i quali <em>alcune cose</em> mi vengono gestite.</p>
<p>Ad esempio, per i puntatori dinamici mi dice ‚Äú<em>guarda, io ti do una cosa che si chiama <strong>Smart Pointer</strong>, che √® fatta in modo tale per cui tu la crei e automaticamente quando questa cessa di essere visibile distrugge il dato a cui punta</em>‚Äù.</p>
<p>Anzi te ne do due.
Uno che si chiama <em><strong>Unique Pointer</strong></em>, che non pu√≤ essere copiato.
Un altro che si chiama <em><strong>Shared Pointer</strong></em>, che pu√≤ essere copiato.</p>
<p>Quello che pu√≤ essere copiato conta quante copie ci sono e quando l‚Äôultima copia muore, rilascia il dato, cos√¨ non c‚Äô√® rischio di perdere l‚Äôinformazione.</p>
<p>Lo Unique Pointer invece √® molto pi√π agile, ma non pu√≤ essere copiato.
Se cerchi di copiarlo ti dice <em>‚Äúno, al massimo lo <strong>cedi</strong>‚Äù</em>: il C++ introduce un concetto che si chiama <em><strong>movimento</strong></em>.</p>
<p><em>Cosa vuol dire ‚ÄúLo cedi‚Äù?</em>
Beh: lo dai a lui, per√≤ poi non √® pi√π tuo.</p>
<p><img src="images/allocazione_della_memoria_3/image%2023.png" alt="image.png" /></p>
<p>Il programmatore ha tutta una serie di responsabilit√†.</p>
<ul>
<li>Deve limitare gli accessi a un blocco <strong>nello spazio</strong>, cio√® non devo andare oltre la zona a cui quel puntatore lecitamente pu√≤ arrivare, e neanche prima, e <strong>nel tempo</strong>, cio√® devo accederci solo quando quel dato l√¨ effettivamente esiste.</li>
<li>Non devo assegnare ai puntatori valori che corrispondono agli accessi non mappati.
Se io dichiaro una variabile locale di tipo <code>int*</code> e non la inizializzo, non √® che dentro non c‚Äô√® scritto niente, c‚Äô√® scritto una schifezza qualunque che era presente sullo stack quando lo stack √® stato abbassato. Magari c‚Äô√® scritto <code>0</code>, se sono fortunato. Magari c‚Äô√® scritto <code>3b7f5962</code>. Ma non √® un vero indirizzo, √® semplicemente che sono dei byte a caso che c‚Äôerano scritti l√¨, e se io provo e vado ad accedere, chiss√† che succede.</li>
<li>Devo rilasciare tutta la memoria dinamica allocata una e una sola volta, usando la funzione duale di quella che √® servita per l‚Äôallocazione. Perch√© se io ho allocato con <code>new</code> non posso rilasciare con <code>free</code>. Perch√© <code>free</code> ha delle strutture dati diverse da quelle di <code>new</code>.</li>
</ul>
<h1 id="5-rischi"><a class="header" href="#5-rischi">5. Rischi</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2024.png" alt="image.png" /></p>
<p><em>Cosa succede se faccio casino?</em></p>
<ul>
<li>Allora, se accedo a un indirizzo, quando il corrispondente ciclo di vita del valore a cui quell‚Äôindirizzo punta √® terminato, andiamo incontro ad effetti impredicibili.
Quella situazione l√¨ si chiama <em><strong>dangling pointer</strong></em>.</li>
<li>Se io non rilascio tutta la memoria che ho allocato, faccio un <em><strong>memory leakage</strong></em>.
Memory leakage √® uno spreco in primis, ed √® un problema in secondis.
Nel momento in cui il mio programma vive abbastanza a lungo, specialmente se sto creando un server. Perch√© sul server se a ogni richiesta io mi perdo una manciata di byte, dopo un po‚Äô di richieste non ho pi√π.</li>
<li>Rilasciare la memoria pi√π volte corrompe le strutture dell‚Äôheap ed √® l‚Äôorigine del problema del <em><strong>Double Free</strong></em>.</li>
</ul>
<blockquote>
<p>üí° <strong>Curiosit√†</strong></p>
<p>Agli inizi della storia di Microsoft, Windows NT, aveva un mucchio di leakage e ti dicevano <em>‚ÄúSai che c‚Äô√®? Ogni notte lo spegni, e poi lo riaccendi‚Äù</em>.
Ma se hai una server farm con 500 macchine, non √® molto comodo ricordare di spegnerle tutte e riaccenderle, e inoltre nel tempo in cui Windows NT fa il bootstrap (e ci metteva un bel po‚Äô a farlo) sei completamente out of service.</p>
<p><em>E perch√© si doveva fare?</em>
Perch√© aveva cos√¨ tanto leakage che se lo facevi girare pi√π di 24 ore lui esauriva tutta la memoria.</p>
<p>Windows NT era comunque un sistema operativo fatto da zero e quindi ci sta che fosse complicato a realizzarlo, per√≤ era un problema reale che ha causato danni seri alle aziende che lo usavano, e a Microsoft stessa.</p>
</blockquote>
<p><img src="images/allocazione_della_memoria_3/image%2025.png" alt="image.png" /></p>
<p>Se assegno a un puntatore un indirizzo non mappato, o non gli assegno niente e quindi mi tengo un dato a caso che c‚Äô√® dentro, diventa un <em><strong>wild pointer</strong></em>: non so minimamente cosa possa essere.</p>
<h2 id="51-esempi"><a class="header" href="#51-esempi">5.1 Esempi</a></h2>
<h3 id="511-dangling-pointer"><a class="header" href="#511-dangling-pointer">5.1.1 Dangling Pointer</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2026.png" alt="image.png" /></p>
<p>Ho questo blocco, non ha importanza se √® parte di una funzione o di una cosa pi√π o meno complicata. Nello stack c‚Äô√® gi√† qualcosa, non mi interessa.</p>
<p><img src="images/allocazione_della_memoria_3/image%2027.png" alt="image.png" /></p>
<p>Arrivo a eseguire questa istruzione <code>char* ptr = null</code>: lo stack cresce di 8 byte (nel caso di sistema a 64 bit), devo farci stare un puntatore.</p>
<p>Cosa ci metto in questi 8 byte? NULL, ossia 0x0, perfetto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2028.png" alt="image.png" /></p>
<p>Aperta graffa vuol dire che inizia un nuovo <strong>scope sintattico</strong>: le variabili locali dichiarate qua dentro esisteranno fino alla chiusa graffa corrispondente.</p>
<p>Dopo l‚Äôaperta graffa c‚Äô√® <code>char ch = '!'</code>: lo stack si abbassa di 1 byte e in quel byte ci scrivo il codice esadecimale 21, che √® il punto esclamativo.
E subito dopo dico <em>‚Äúinizializza quel puntatore di prima che valeva</em> <code>NULL</code> <em>con l‚Äôindirizzo di</em> <code>ch</code><em>‚Äù</em>.</p>
<p>Vado a vedere quanto vale lo stack pointer che c‚Äô√® in questo momento (che in pratica √® l‚Äôindirizzo a cui troviamo il valore di ch), e lo scrivo l√† dentro.</p>
<p>Quindi il mio puntatore viene sostituito con l‚Äôindirizzo giusto di <code>ch</code>.</p>
<p><img src="images/allocazione_della_memoria_3/image%2029.png" alt="image.png" /></p>
<p>Chiusa graffa lo stack pointer sale di 1 byte.
Il puntatore che c‚Äôera scritto l√¨ continua a puntare dove non doveva!</p>
<p><img src="images/allocazione_della_memoria_3/image%2030.png" alt="image.png" /></p>
<p>A questo punto provo a chiamare <code>printf</code>.</p>
<p>Cosa fa la chiamata printf?
Eh, pusha sullo stack: comincia a metterci lo spazio per il valore di ritorno, l‚Äôindirizzo a cui chiamare <code>printf</code>, i suoi parametri etc...</p>
<p>Il mio puntatore a questo punto punta delle cose strampalate. Cerco di stampare e non so minimamente che cosa ottengo.</p>
<h3 id="512-memory-leakage"><a class="header" href="#512-memory-leakage">5.1.2 Memory Leakage</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2031.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2032.png" alt="image.png" /></p>
<p>Entro nel mio blocco, dichiaro un puntatore come prima, lo stack cresce di 8 byte, per fare spazio a questo puntatore nullo.</p>
<p><img src="images/allocazione_della_memoria_3/image%2033.png" alt="image.png" /></p>
<p>Alloco un blocco, nello heap da qualche parte cerco un pezzo grande quanto gli ho chiesto, 10 byte. Lo trovo e il mio puntatore punta dove deve.</p>
<p>Nel frattempo la struttura di malloc in questo caso si organizza e si segna che quel segmentino l√¨ adesso √® in uso e quindi si segna che deve saltarne un pezzo perch√© quella memoria non pu√≤ essere usata in quanto l‚Äôha data in prestito a chi gliel‚Äôha chiesta.</p>
<p><img src="images/allocazione_della_memoria_3/image%2034.png" alt="image.png" /></p>
<p>Dentro quella stringa ci scrivo quello che voglio, non ha importanza, la uso come mi pare.</p>
<p><img src="images/allocazione_della_memoria_3/image%2035.png" alt="image.png" /></p>
<p>La stampo, va tutto bene.</p>
<p><img src="images/allocazione_della_memoria_3/image%2036.png" alt="image.png" /></p>
<p>E ritorno.</p>
<p>A questo punto il mio puntatore viene egettato, non lo posso pi√π restituire perch√© dove stava questa stringa non lo so pi√π, √® perduto per sempre.</p>
<p>La <code>malloc</code> √® fatta apposta per dare della memoria che potrebbe essere usata per un po‚Äô di tempo e quindi dice <em>‚Äúvabb√®, non me l‚Äôha restituita adesso, me la dar√† dopo..‚Äù</em>, ma noi ‚Äúdopo‚Äù non possiamo pi√π dargliela perch√© non si sa pi√π dov‚Äô√®.</p>
<p>Abbiamo fatto del memory leakage.</p>
<h3 id="513-double-free"><a class="header" href="#513-double-free">5.1.3 Double free</a></h3>
<p><img src="images/allocazione_della_memoria_3/image%2037.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2038.png" alt="image.png" /></p>
<p>Alloco un primo puntatore, ne alloco un secondo che metto uguale al primo.
Adesso ne ho due che puntano l√¨.</p>
<p>Di per s√© non √® una tragedia averne due che puntano l√¨, posso avere dei motivi validi per farlo: pensate a una double linked list, in cui ciascun blocco √® puntato dall‚Äôelemento precedente e dall‚Äôelemento successivo.</p>
<p>Quindi non √® un problema di per s√© il fatto che ci sono due puntatori.
Il problema √® che devo rilasciare una volta sola.</p>
<p><img src="images/allocazione_della_memoria_3/image%2039.png" alt="image.png" /></p>
<p><img src="images/allocazione_della_memoria_3/image%2040.png" alt="image.png" /></p>
<p>Qui cosa succede?</p>
<p>Uso questa struttura in qualche modo, chiamo la <code>free</code> su uno dei due (non importa quale) e a questo punto le strutture di <code>malloc</code> prendono il possesso di nuovo di quel blocchettino che avevano segnato prima essere in uso e fin qui va tutto bene.</p>
<p><img src="images/allocazione_della_memoria_3/image%2041.png" alt="image.png" /></p>
<p>Poi faccio la seconda free e a questo punto non capisce pi√π niente, si spacca.</p>
<h1 id="6-gestire-i-puntatori"><a class="header" href="#6-gestire-i-puntatori">6. Gestire i puntatori</a></h1>
<p><img src="images/allocazione_della_memoria_3/image%2042.png" alt="image.png" /></p>
<p>Chi alloca un puntatore √® responsabile quindi di mettere in atto un meccanismo che mi garantisca il suo <strong>rilascio</strong>.</p>
<p>Colui che √® responsabile del rilascio del blocco viene chiamato <em><strong>il possessore</strong></em>.
<strong>Possedere un blocco vuol dire essere responsabile del rilascio.</strong></p>
<p>Il possesso non √® un diritto, √® un dovere.
Certo, ti d√† diritto ad accedere al blocco. Ma ti d√† anche <strong>il dovere di rilasciarlo.</strong></p>
<p>Se io questo puntatore che possiede il blocco lo duplico, e quindi a questo punto ho due puntatori che conoscono il blocco, chi √® il possessore dei due? Boh.</p>
<p>I linguaggi come Java, i linguaggi <em>managed</em>, dicono che il possesso √® <em>equidistribuito</em>: fin tanto che c‚Äô√® almeno uno che conosce quel blocco, il blocco non √® rilasciabile.
Quando non ci sar√† pi√π nessuno che conosce quel blocco, il blocco √® rilasciabile perch√© non √® pi√π posseduto.
Piccolo problema: non viene rilasciato subito, √® solo segnato come rilasciabile.</p>
<p>Quella memoria diventer√† utilizzabile al primo ciclo di garbage collection, che potrebbe avvenire tra un bel po‚Äô e questo potrebbe essere un problema perch√© io a forza di prendere pezzi di memoria potrei trovarmi in difficolt√†.</p>
<p>Quindi in qualche modo se io copio un puntatore che possiede l‚Äôindirizzo, cio√® √® responsabile del rilascio di quella cosa l√¨, il secondo puntatore si trova malgrado a diventare possessore anche lui, partecipa al ciclo di vita e questo ci fa casino, rende ad esempio scrivere l‚Äôalgoritmo della linked list non cos√¨ banale: chi √® che rilascia? I puntatori in avanti o i puntatori all‚Äôindietro?</p>
<p>Quindi bisogna introdurre un meccanismo che gestisca efficacemente la semantica del puntatore e per questo motivo in Rust i puntatori sono svariati: ci sono i puntatori che posseggono e i puntatori che non posseggono, i puntatori che possono scrivere e i puntatori che possono leggere.</p>
<p><strong>Rendiamo esplicito nel tipo che cosa puoi fare</strong>, e qui il compilatore ti aiuta perch√© usa le informazioni che noi gli diamo per verificare che lo usiamo in modo giusto.</p>
<p><img src="images/allocazione_della_memoria_3/image%2043.png" alt="image.png" /></p>
<p>Il vincolo di rilascio √® particolarmente problematico per via dell‚Äôambiguit√† dei puntatori.</p>
<p>In C e in C++ non ho niente che mi distingue un puntatore con possesso da un puntatore senza possesso. Si chiamano tutti <code>int*</code>.</p>
<p>Il fatto che uno possegga e l‚Äôaltro no √® solo nella testa del programmatore.</p>
<p>L‚Äôho ottenuto da una variabile locale o una variabile globale che gi√† esisteva, di cui non sono responsabile del rilascio perch√© lo √® il compilatore ‚Üí non posseggo.
L‚Äôho ottenuto con new o con malloc ‚Üí posseggo.</p>
<p>Solo che quando sto puntatore passa di mano, chi lo sa pi√π come √® nato.
Il tipo non mi dice niente.</p>
<p>Quindi chi √® possessore ha la responsabilit√† di liberarlo.</p>
<p>C++ fa un passo avanti: dice <em>‚Äúguarda io ho i puntatori standard come quelli del C, poi ho gli smart pointer‚Äù</em>.
Gli smart pointer posseggono. Anzi alcuni smart pointer posseggono, perch√© ce ne √® anche un terzo tipo che si chiama <strong><code>Weak</code></strong> che non possiede: partecipa al ciclo di vita senza possedere.</p>
<p><img src="images/allocazione_della_memoria_3/image%2044.png" alt="image.png" /></p>
<p>Non tutti i puntatori posseggono il blocco a cui puntano.
Se ad un puntatore viene assegnato l‚Äôindirizzo di un‚Äôaltra variabile, la propriet√† di quella memoria √® della libreria di esecuzione.</p>
<p>Quindi quando dico <code>int* ptr = &amp;i</code>, la propriet√† √® di <code>i</code>.</p>
<p><code>i</code> √® una variabile che √® allocata, √® stata allocata dal compilatore e viene rilasciata al compilatore.</p>
<p>Il puntatore √® solo un alias.
Pu√≤ guardarla ma non deve partecipare diversamente.</p>
<p>Tutto si complica se un puntatore che possiede il proprio blocco viene copiato.</p>
<p>Quale delle due copie √® responsabile del rilascio?
Tendenzialmente l‚Äôultima. Ma che ne so io qual √® l‚Äôultima?</p>
<p><img src="images/allocazione_della_memoria_3/image%2045.png" alt="image.png" /></p>
<p>Nel momento in cui io creo delle strutture dati complesse, come una linked list, come una mappa, come un oggetto pi√π sofisticato, spesso ho bisogno di crearmi qualcosa che punta a qualcos‚Äôaltro che punta qualcos‚Äôaltro per poter gestire la semantica di questa faccenda qua.</p>
<p>Ad esempio gli oggetti vector (sono quelli che in Java si chiamano array lists), hanno dentro di s√© un puntatore a un blocco dinamico.</p>
<p>Inizialmente piccolo, poi se voi ci mettete dentro delle cose, se per un po‚Äô vengono aggiunti, quando non ci stanno pi√π, quel blocco dinamico viene riallocato grosso il doppio, i vecchi elementi vengono copiati nel blocco nuovo, il blocco vecchio viene rilasciato e faccio spazio per aggiungere cose e quindi piano piano posso ospitare tanti elementi.</p>
<p>Nel momento in cui quel vector viene distrutto, raggiunge la fine del suo ciclo di vita, deve ricordarsi di buttare via tutto.</p>
<p>In qualche modo questo blocco √® una dipendenza del vector, quindi la struttura vector ha dentro di s√© delle appendici come fosse un grappolo d‚Äôuva che dal tralcio si dipana con tanti pezzettini e quando quella cosa l√¨ viene distrutta deve prendersi la briga di buttare via tutti i suoi pezzettini in modo congruo.</p>
<p>Non ci sono solo le dipendenze legate alla memoria, possono esserci dipendenze legate ad altri risorse del sistema operativo.</p>
<p>Se io ho un oggetto che ha aperto un file, quando questo oggetto finisce di vivere quel file deve garantirmi che √® chiuso, altrimenti il sistema operativo penser√† che quel file l√¨ sia ancora in uso.
Se io ho creato un socket per ricevere dalla rete, analogamente il socket lo devo chiudere.
Se ho creato un thread devo garantire che questo thread abbia finito di vivere e cos√¨ via.</p>
<p>Quindi questo insieme di cose, di risorse ulteriori, la memoria, i file, i socket, altri pezzi del sistema operativo, che hanno un ciclo di vita che deve essere riportato al ciclo di vita dell‚Äôoggetto, prendono il nome di <em><strong>dipendenze</strong></em>.</p>
<p><img src="images/allocazione_della_memoria_3/image%2046.png" alt="image.png" /></p>
<p>C non d√† nessun supporto per la gestione delle dipendenze.</p>
<p>C++ ci mette a disposizione il concetto di costruttore e distruttore.
Nel costruttore inizializzo le mie dipendenze, nel distruttore mi libero delle mie dipendenze.</p>
<p><img src="images/allocazione_della_memoria_3/image%2047.png" alt="image.png" /></p>
<p>Innanzitutto, raramente i programmi sono scritti da una persona sola.
Ognuno di tanti che scrive lo fa con le sue convenzioni, con i suoi assunti, con un proprio schema mentale.</p>
<p>Non √® detto che i suoi compagni o colleghi li conoscano, non √® detto manco che si conoscano reciprocamente, perch√© io sono subentrato in un‚Äôazienda dove ho trovato del software che ha scritto qualcun altro che se ne √® gi√† andato da tempo.</p>
<p>Al crescere delle dimensioni del programma la quantit√† di particolari a cui bisogna badare esplode.</p>
<p>Finch√© voi avete un puntatore vi prendete la briga di seguirlo, ma quando avete un milione di puntatori che hanno storie diverse, non li seguite manco per idea.</p>
<p>Il 70% delle vulnerabilit√† elevate all‚Äôinterno di Windows sono dovute a problemi di gestione della memoria. Non √® che Microsoft assume gli imbecilli, ma nonostante ci siano dei professionisti, la possibilit√† di sbagliare √® altissima.</p>
<p><img src="images/allocazione_della_memoria_3/image%2048.png" alt="image.png" /></p>
<p>Nella maggior parte dei linguaggi di alto livello il problema non si pone.</p>
<p>Perch√© non siete mai stati abbastanza stressati con tutte queste cose?
Eh perch√© fin tanto che scrivete in Python va tutto bene.</p>
<p>Piccolo problema.
√à vero che questi hanno dentro di s√© il concetto di puntatore, ma non vi lasciano controllare quando quella memoria viene veramente rilasciata.</p>
<p>E quindi certe cose in Python, in C#, in Java non le potete fare.</p>
<p>In questo corso vogliamo occuparci di quella zona in cui con quei linguaggi l√¨ non si pu√≤ lavorare, perch√© abbiamo bisogno di stare pi√π vicini all‚Äôhardware.</p>
<p>Il fatto che ci sia il garbage collector libera completamente il programmatore dalla responsabilit√† del rilascio, ma in compenso ci fa perdere il controllo sul quando e come il rilascio avvenga.</p>
<p>E quindi in generale c‚Äô√® un bisogno di risorse molto pi√π grande.</p>
<p>La maggior parte di questi linguaggi usa gli algoritmi di <em><strong>Mark and Sweep</strong></em>, che sono quelli che fondamentalmente permettono di identificare quali zone sono ancora referenziate, vengono marcate, e tutto ci√≤ che non viene marcato viene <em>Sweeped</em>, scopato via, tolto insieme alla polvere.</p>
<p>Sono algoritmi belli, interessanti, per√≤ sono anche estremamente dispendiosi.
Quando parte la garbage collection il programma si deve arrestare.</p>
<p><img src="images/allocazione_della_memoria_3/image%2049.png" alt="image.png" /></p>
<p>Cosa succede tra C/C++, linguaggi che ci danno controllo a basso livello, e Java, piuttosto che C#, piuttosto che Python.</p>
<p>Allora in C++ noi abbiamo un controllo manuale del rilascio. Dobbiamo ricordarci noi di chiamare <code>delete</code> o <code>free</code> o quello che sia.</p>
<p>Di l√† ce ne freghiamo attentamente, lo fa il garbage collector.</p>
<p>Il problema √® che in C/C++ noi possiamo controllare quando rilasciare.
Di l√†, siccome lo fa il garbage collector, la memoria √® rilasciata al piacere del garbage collector.</p>
<p>In C++ gli oggetti dispongono di un distruttore, che permette di gestire le dipendenze, di fare il rilascio esplicito delle dipendenze.</p>
<p>In tutti gli altri linguaggi, tranne Java, che ha un finalizer, che per√≤ ora √® stato deprecato, non c‚Äô√® il concetto di distruttore.
Non ce n‚Äô√® bisogno.</p>
<p>In C/C++ il rilascio non comporta dei tempi supplementari di attesa.
Non devo fare una ricerca, perch√© io ho gi√† la mia ricetta nel distruttore che mi dice cosa devo fare.
Di l√†, in realt√†, il rilascio comporta delle pause, pause che possono essere molto lunghe e che in contesto di realt√† sono semplicemente inaccettabili.
Per√≤ in C e in C++ possono verificarsi doppi rilasci, memory leakage, dangling pointer, wild pointer e tutte queste serie di cose che abbiamo visto prima.
Di l√† no. Motivo per cui, per i programmi applicativi, la strada √® quella l√†.
Per i programmi di sistema, la strada passa di qua.</p>
<p><img src="images/allocazione_della_memoria_3/image%2050.png" alt="image.png" /></p>
<p><em>Come sopravviviamo?</em></p>
<p>Certamente usando dei programmi che ci aiutano a diagnosticare l‚Äôuso della memoria nei processi, come Valgrind, se siamo in Linux, Dr.Memory se siamo su Windows.</p>
<p>Certamente usando dei tipi pi√π sofisticati, invece che <code>int*</code>, o cose del genere, cio√® il puntatore nativo del C++, le versioni moderne di C++ ci offrono una serie di classi che ci facilitano la vita.</p>
<p>I vari tipi di smart pointer, le tuple, gli iteratori, gli span, gli optional e cos√¨ via, sono tutti tipi pi√π sofisticati che evitano di dover usare i puntatori, pur dandoci delle strutture che sintatticamente sembrano puntatori e che quindi hanno tante caratteristiche che gli assomigliano, ma sono tracciate per la loro semantica.</p>
<p>Terza strada, ed √® quella che seguiremo nel corso, usiamo dei linguaggi che sono intrinsecamente Memory Safe: Rust.</p>
<p><img src="images/allocazione_della_memoria_3/image%2051.png" alt="image.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduzione-al-linguaggio---malnati-4"><a class="header" href="#introduzione-al-linguaggio---malnati-4">Introduzione al linguaggio - Malnati 4 <!-- omit in toc --></a></h1>
<h1 id="indice-2"><a class="header" href="#indice-2">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="04-introduzione_al_linguaggio.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="04-introduzione_al_linguaggio.html#11-storia">1.1 Storia</a></li>
</ul>
</li>
<li><a href="04-introduzione_al_linguaggio.html#2-obiettivi-del-linguaggio">2. Obiettivi del linguaggio</a></li>
<li><a href="04-introduzione_al_linguaggio.html#3-confronto-con-altri-linguaggi">3. Confronto con altri linguaggi</a></li>
<li><a href="04-introduzione_al_linguaggio.html#4-caratteristiche">4. Caratteristiche</a>
<ul>
<li><a href="04-introduzione_al_linguaggio.html#41-sicurezza">4.1 Sicurezza</a></li>
<li><a href="04-introduzione_al_linguaggio.html#42-prestazioni">4.2 Prestazioni</a></li>
<li><a href="04-introduzione_al_linguaggio.html#43-linguaggio-moderno">4.3 Linguaggio moderno</a></li>
<li><a href="04-introduzione_al_linguaggio.html#44-sicuro-per-definizione">4.4 Sicuro per definizione</a></li>
<li><a href="04-introduzione_al_linguaggio.html#45-controllo-a-basso-livello">4.5 Controllo a basso livello</a></li>
</ul>
</li>
<li><a href="04-introduzione_al_linguaggio.html#5-installare-rust">5. Installare Rust</a></li>
<li><a href="04-introduzione_al_linguaggio.html#6-cargo">6. Cargo</a></li>
</ul>
<h1 id="1-introduzione"><a class="header" href="#1-introduzione">1. Introduzione</a></h1>
<p><img src="images/introduzione_al_linguaggio/image.png" alt="image.png" /></p>
<p>Rust parte con il principio di garantire la correttezza del programma e contemporaneamente la velocit√†, che sono due argomenti che vanno diametralmente opposti.</p>
<p>Vedremo con un confronto con gli altri linguaggi di programmazione, che noi abbiamo dei linguaggi molto veloci ad alte prestazioni come C e C++, che per√≤ fanno poco sulla correttezza, e dei linguaggi ad alta correttezza come Haskell che per√≤ sulla velocit√† sono molto limitati.</p>
<p>E poi una serie in mezzo lungo la diagonale che unisce questi due estremi, dove si collocano i vari C#, Java, Python, etc..</p>
<p>In questa distribuzione Rust sta lass√π in alto e contemporaneamente veloce e corretto.</p>
<p>E questo perch√© √® stato scelto attentamente garantendo che tutte le feature del linguaggio devono impedire la presenza di undefined behaviours.</p>
<p>E contemporaneamente √® costruito sul principio della <em><strong>zero cost abstraction</strong></em>, ovvero se tu una certa feature non la usi non la devi pagare.</p>
<p>In C++ esiste ad esempio il polimorfismo, il problema √® che il polimorfismo ti costa.
Ti costa il fatto che le tue chiamate diventano chiamate indirette, quindi tu non chiami pi√π la funzione. Accedi a una zona di memoria dentro cui c'√® un puntatore che punta alla tua funzione, e quindi devi fare due letture.</p>
<p>Lo devi fare sempre? Se dichiari un metodo virtual s√¨, per√≤ puoi anche non dichiararlo virtual.
In Java invece questa scelta non ce l'hai. Tutte le tue chiamate sono virtuali, che ti piaccia o no, che ti serva o che non ti serva, e quindi comunque tu hai sempre un costo pi√π alto, eccetera..
Ci sono n posti dove questo principio vale.</p>
<p>Rust nasce con l‚Äôobiettivo di mantenere al minimo le librerie di supporto in fase di esecuzione.
Abbiamo detto la volta scorsa che l‚Äôesecuzione di un programma √® data dal <strong>compilato</strong>, l‚Äôassembler che viene generato a partire da una istruzione, pi√π la <strong>RTL</strong>, la runtime library.</p>
<p>L‚Äôobiettivo di Rust √® tenere la runtime library microscopica, giusto quelle quattro funzioni minime che servono per copiare la memoria quando io ho bisogno di spostare un pezzo da una parte all‚Äôaltra, fare il check dello stack overflow, vedere che non sto traboccando, e poco altro.
E questo gli garantisce grande cose.</p>
<p>E lo fa garantendo che la memoria venga correttamente gestita, rilasciata nel momento in cui si deve rilasciare, senza far ricorso a un garbage collector.
E quindi evitando tutte quelle situazioni di cui abbiamo parlato, in cui nel momento in cui non mi basta pi√π la memoria che ho a disposizione, blocco tutto per fare spazio.</p>
<p>Questo rende un programma scritto in Rust adatto a funzionare in contesti molto eterogenei.</p>
<p>Da quelli molto piccoli, tipo compilare un programma in Rust per l‚ÄôArduino, a quelli molto grandi, magari su cloud, dove pensate di avere decine o centinaia di laboratori connessi insieme.</p>
<p>Va bene per fare il kernel del sistema operativo, Linux Torvald ci ha messo un po‚Äô, poi nel 2021, in qualche modo dopo essersi completamente sempre opposto all‚Äôuso del c++ per la scrittura dei moduli all‚Äôinterno del kernel di Linux, invece ha riconosciuto che va bene scrivere dei moduli in Rust.</p>
<p>Rust √® un linguaggio che √® staticamente e fortemente tipato.</p>
<p>Staticamente tipato vuol dire che le variabili nascono legate a un tipo.
A differenza di quello che succede in Python o in JavaScript, dove io posso scrivere let v = ‚Äúciao‚Äù e poi una riga dopo scrivere v = 23, e quindi in momenti diversi quella variabile contiene dati di tipo diverso, in Rust quando introduco una variabile la introduco legata a un tipo.</p>
<p>Questo tipo lo posso dichiarare esplicitamente oppure semplicemente lo lascio dedurre al compilatore alla luce del valore di inizializzazione.
Quando dico let i = 10, il compilatore deduce che verosimilmente i √® un i32, cio√® un intero a 32 bit consegno.</p>
<p>Va bene per la programmazione di sistema perch√© tutti i tipi sono noti in fase di compilazione.</p>
<p>Il fatto che questi tipi, che sono molto ricchi perch√© il sistema dei tipi √® un sistema di tipi generici, con i tratti, permette sostanzialmente al compilatore di dedurre tutto quello che esplicitamente non viene scritto nella maggior parte delle situazioni e di conseguenza poter intervenire e garantire che il codice che viene scritto sia sostanzialmente coerente.</p>
<p>La memoria √® completamente sotto il controllo del programmatore che deve scegliere come usarla.
E al programmatore sono dati gli strumenti potenti perch√© di puntatori ce ne sono un po‚Äô: ci sono i puntatori che possiedono, ci sono i puntatori che non possiedono, ci sono i puntatori mutabili (che permettono di andare a cambiare il dato che stanno puntando), e i puntatori a dati immutabili.
E queste informazioni il compilatore le usa e le propaga.</p>
<p>Ma vedremo che anche le stringhe sono una cosa ricchissima.
Se in C una stringa equivale a const char* e finisce l√¨, perch√© il linguaggio non ci d√† altri supporti, il C++ aggiunge std string e poi finisce l√¨, vediamo che in Rust abbiamo una sacco di stringhe diverse, ognuna <em>tailored</em>, ritagliata su un bisogno.
Per cui certamente c‚Äô√® il tipo <em><strong>std string</strong></em> che rappresenta una stringa generica mutabile, c‚Äô√® il tipo <em><strong>ref str</strong></em> che invece rappresenta una stringa immutabile, visibile soltanto.
C‚Äô√® il tipo <em><strong>os string</strong></em> che rappresenta una stringa cos√¨ come la rappresenta il sistema operativo, c‚Äô√® il tipo <em><strong>c string</strong></em> che rappresenta una stringa cos√¨ come la vorrebbe vedere un programma scritto in C per poterci fare l‚Äôinteroperabilit√† e altre..</p>
<p>E tocca al programmatore saper scegliere e destreggiarsi in questo mondo qua.</p>
<h2 id="11-storia"><a class="header" href="#11-storia">1.1 Storia</a></h2>
<p><img src="images/introduzione_al_linguaggio/image%201.png" alt="image.png" /></p>
<p>La versione 1.0 √® del maggio 2015. La versione corrente √® la 76, 1.76.0, uscita a febbraio.</p>
<p>Giusto per dare due cifre, all‚Äôinterno di Firefox ci sono circa 3 milioni di righe scritte in Rust, che rappresentano il 9% del contenuto di Firefox.
Dropbox usa Rust nel suo motore di sincronizzazione, Amazon Web Services usa abbondantemente Rust all‚Äôinterno di tutti i suoi motori di esecuzioni per le lambda function, per il database, eccetera.
Microsoft ha portato tutte le API di Windows all‚Äôinterno di Rust, per cui tutte le system call di Windows sono chiamabili direttamente da Rust.
Google predilige l‚Äôuso di Rust per lo sviluppo di codice nativo in Android.</p>
<p>Giusto la settimana scorsa √® uscito un annuncio della Casa Bianca ‚Äú<em>White House urges devs to switch to memory safe programming languages, such as Rust</em>‚Äù.</p>
<p><img src="images/introduzione_al_linguaggio/image%202.png" alt="image.png" /></p>
<p>Quando nasce Rust?
Dimenticando i primissimi anni che era un giocattolo, comincia a diventare significativo intorno al 2015, dove prende forma.</p>
<p>Allora, qui vi ho messo a confronto la crescita di progetti Rust all‚Äôinterno di GitHub, in particolare il numero di stelle che sono state conferite ai progetti Rust all‚Äôinterno di GitHub, confrontandole con quelli di Kotlin, che √® un linguaggio che nasce pi√π o meno negli stessi anni.</p>
<p>Vediamo che Kotlin ha un grosso impulso tra il 2017 e il 2018, quando Google decide che Kotlin diventa il linguaggio di Android, ed improvviso, boom, fa un salto.
Dopodich√© non √® che lo prende, continua a divergere. E Rust invece va su.</p>
<h1 id="2-obiettivi-del-linguaggio"><a class="header" href="#2-obiettivi-del-linguaggio">2. Obiettivi del linguaggio</a></h1>
<p><img src="images/introduzione_al_linguaggio/image%203.png" alt="image.png" /></p>
<p>Il linguaggio nasce per creare un linguaggio per la <strong>programmazione di sistema</strong>, quindi ad alte prestazioni, dove il programmatore abbia il controllo di quello che succede, ma privo di comportamenti non definiti.</p>
<p>Quindi esclude a priori, by design, tutte quelle situazioni nelle quali √® possibile creare un undefined behaviour, e quindi generare del comportamento non ripetibile.</p>
<p>E contemporaneamente con un <strong>supporto corretto all‚Äôesecuzione concorrente</strong>.</p>
<p>Insieme all‚Äôenorme mole di problemi che nascono dall‚Äôuso scorretto della memoria, di cui abbiamo avuto abbondantemente modo di raccontarci, che sono poi alla fine tre o quattro casi, che per√≤ sono cos√¨ frequenti da potersi mescolare ovunque, ci sono tutti i problemi che nascono dalla concorrenza.</p>
<p>L‚Äô<strong>accesso concorrente</strong> √® un grosso casino: se io scrivo qua e tu nel frattempo stai leggendo, potrebbe darsi che leggi sbagliato perch√© io nel frattempo ti ho cambiato le carte in tavola.
Quindi bisogna metterci d‚Äôaccordo, tu leggi quando io non scrivo, ma bisogna che ci parliamo perch√© questo succeda.
Bisogna concepire i programmi che avvengano in questo modo.</p>
<p>Rust nasce avendo sott‚Äôocchio che quella √® un‚Äôaltra fonte di guai grandissima, e ci d√† una serie di strumenti precisi per gestire questo genere di situazioni, by design.</p>
<p>Terza cosa: <strong>un linguaggio pratico</strong>.
L‚Äôobiettivo di Graydon non era fare l‚Äôennesimo linguaggio accademico, ce ne sono miliardi, inutile.
Include un compilatore robusto, che quando becca un errore ti spiega che errore ha preso.
Ma il compilatore √® solo un pezzo, un linter che a priori ti dice ‚Äú<em>guarda che qui c‚Äô√® una cosa che puzza, non capisco. Di solito chi fa cos√¨ sta scrivendo una schifezza</em>‚Äù.
Un <strong>supporto alle dipendenze</strong>: con Cargo, che √® un sistema ispirato a npm, che invece gestisce centralmente le librerie.
Faccio un programma e scrivo che dipendo della libreria <em>vattelapesca</em> e lui automaticamente se la scarica e me la mette a disposizione, la verifica, controlla la versione e cos√¨ via.</p>
<p>Mentre in C se volete includere una libreria, dovete andarvela a cercare, la scaricate. Che versione √® questa libreria? Boh, √® quella che ho sul disco, ma √® l‚Äôultima? Boh..</p>
<p>Offrire <strong>astrazioni a costo nullo</strong>.
Cio√® dire che il linguaggio pu√≤ darti un boost extra. Ma tu non sei obbligato a pagarlo.
Lo paghi solo se ne hai strettamente bisogno. E quindi se ne hai strettamente bisogno, vale la pena.Ma se non hai bisogno non lo paghi.</p>
<p>Sempre tornando all‚Äôesempio del polimorfismo, in C++ il polimorfismo noi lo otteniamo grazie al fatto che tutti gli oggetti si trovano in un campo nascosto, la Vtable, un puntatore alla Vtable che permette di gestire queste chiamate indirette.
Anche quando uso un oggetto che di per s√© potrebbe essere polimorfico, ma io lo uso in modo non polimorfico, pago il costo, che mi piaccia o meno.</p>
<p>In Rust questa cosa non c‚Äô√®, l‚Äôoggetto √® nudo.
Se tu hai bisogno di usare polimorfico, √® il tuo puntatore che diventa grasso: invece di avere un 64 bit come puntatore ne hai 128 perch√© diventa un doppio puntatore. Met√† punta all‚Äôoggetto, met√† punta alla Vtable.
Se tu invece hai bisogno di accedere in modo non polimorfico, ti resta il tuo puntatore slim.</p>
<p>Quindi offre al programmatore una pluralit√† di stili nel redigere i propri algoritmi.
Quindi supporta gli algoritmi iterativi, la ricorsione, le chiusure, supporta in generale il modello funzionale della programmazione, d√† supporto a delle idee dell‚ÄôObject Orientation senza essere un linguaggio ad oggetti.</p>
<p>Garantisce la generazione del miglior codice assembler possibile al momento in cui √® stato realizzato il compilatore, ma loro ogni sei settimane te ne danno uno nuovo un po‚Äô pi√π performante senza introdurre costi aggiuntivi per quello che non ti interessa.</p>
<p>L‚Äôobiettivo √® supportare la produttivit√† del programmatore offrendo contemporaneamente costrutti di alto livello e un ecosistema di compilazione fortemente integrato che contiene il compilatore, la gestione delle dipendenze, i test e cos√¨ via.</p>
<p>Tutto insieme facile da gestire.</p>
<p><img src="images/introduzione_al_linguaggio/image%204.png" alt="image.png" /></p>
<p>Nasce con alcune scelte precise.</p>
<p>Una delle prime cose √® stato dire ‚ÄúNo Byte Code‚Äù. L‚Äôesperienza di Java molto utile, interessante. Compile once, run everywhere. Qualcuno l‚Äôha tradotto ‚Äúcompile once, debug everywhere‚Äù.
Per√≤ non va bene perch√©? Perch√© l‚Äôuso del By Code mi allontana dal metallo. Byte Code √® una macchina astratta. Rust si chiama Rust perch√© vuol dire <em>ruggine</em> e la ruggine √® quello straterello sottile che si deposita sul metallo vivo.
L‚Äôidea √® che √® pensato per girare sul bare metal, non dentro una macchina astratta.
E quindi deve essere compilabile nel miglior modo possibile per processori completamente eterogenei.</p>
<p>Abbiamo gi√† detto che √® fortemente tipizzato in fase di compilazione.
Il compilatore usa questi tipi tantissimo per anticipare tutta una serie di cose. Di base usa uno stile imperativo ma √® fortemente influenzato dal modello funzionale e supporta completamente tutta una serie di comportamenti di alto livello.</p>
<p>Non dispone di garbage collector, non ha una runtime library specifica come pu√≤ avere C# o JavaScript o qualcosa del genere e il sistema dei tipi √® molto sofisticato.</p>
<h1 id="3-confronto-con-altri-linguaggi"><a class="header" href="#3-confronto-con-altri-linguaggi">3. Confronto con altri linguaggi</a></h1>
<p><img src="images/introduzione_al_linguaggio/image%205.png" alt="image.png" /></p>
<p>Questo era il disegno di parlavamo prima.</p>
<p>Sui due assi ci sono da un lato le prestazioni che equivalgono un po‚Äô al livello di controllo che il programmatore ha sul codice che viene generato. Siccome io ho un alto livello di controllo posso ottenere delle prestazioni alte.</p>
<p>C e C++ mi danno con un piccolo delta un alto livello sulle prestazioni, su un alto livello di controllo, un alto livello di prestazioni e mi danno una scarsissima sicurezza.
Altre linguaggi, Go, Java, Python eccetera si mettono l√¨ in mezzo.
Le prestazioni sono progressivamente pi√π basse, il livello di sicurezza √® progressivamente pi√π alto. Haskell mi d√† il massimo livello di sicurezza, prestazioni infime.</p>
<p>Rust √® lass√π. E‚Äô un po‚Äô meno del C. E se la gioca col C++.
Dipende quale aspetto guardate.
Su certe cosine il C++ va un po‚Äô meglio, su certe altre va un po‚Äô meglio il Rust.
On the average sono alla pari.</p>
<p><img src="images/introduzione_al_linguaggio/image%206.png" alt="image.png" /></p>
<p>Rispetto a Python √® decisamente pi√π <strong>veloce</strong>.
Per√≤ √® pensato proprio per obiettivi totalmente distinti. Consuma molto meno in termini di memoria. √à in grado di implementare il vero <strong>multithreading</strong>.</p>
<p>In Python a partire dalla versione 3.12 c‚Äô√® un multithreading un pochino pi√π vero, prima era proprio solo fake. Adesso √® parzialmente pi√π furbo.</p>
<p>Dispone dei <strong>tipi algebrici</strong>. Cos‚Äô√® un tipo algebrico?
Tipi algebrici sono i tipi somma e i tipi prodotto.
Una struct, ad esempio, √® un tipo prodotto ‚Äî immaginate di avere una struct che contiene un campo stringhe e un campo numero: il suo dominio √® fatto di tutte le coppie possibili tra stringhe e numero.
Quindi √® il prodotto della cardinalit√† delle stringhe per la cardinalit√† dei numeri.
Viceversa un enum √® un tipo somma perch√© √® l‚Äôinsieme delle cose che possono stare nel caso 1 unito all‚Äôinsieme delle cose che possono stare nel caso 2.</p>
<p>Supporta l‚Äô<strong>ereditariet√†</strong> in modo completamente differente. Cio√® Rust non supporta l‚Äôereditariet√† in quanto tale: non c‚Äô√® il concetto di classe e quindi non c‚Äô√® il concetto di ereditariet√†.
C‚Äô√® per√≤ il concetto di <em><strong>tratto</strong></em> e i tratti vivono tra loro in una relazione di dipendenza.</p>
<p>Dispone di un meccanismo sofisticato di <strong>pattern matching</strong>, che √® stato introdotto in Python nella versione 3.10 e rispetto a Python, Rust √® staticamente orientato ai tipi.
Cio√® il compilatore sa a priori che una certa variabile contiene solo valori di quel tipo l√¨, invece il compilatore Python non lo sa.
Questo fa s√¨ che ci siano molti meno arresti anomali in fase di esecuzione proprio perch√© il compilatore pu√≤ predire un mucchio di cose.</p>
<p><img src="images/introduzione_al_linguaggio/image%207.png" alt="image.png" /></p>
<p>Rispetto a Java non c‚Äô√® nessun overhead dovuto alla Java Virtual Machine e non ci sono le pause del garbage collector in quanto non c‚Äô√® il garbage collector.</p>
<p>Consuma molto di meno la memoria quindi otteniamo degli eseguibili che in termini di fabbisogno sono molto pi√π ridotti.</p>
<p>Non crea nessun costo di estrazione.</p>
<p>L‚Äôereditariet√† di nuovo √® completamente distinta.
Java √® un linguaggio basato sull‚Äôereditariet√† singola.</p>
<p>La programmazione generica √® totalmente diversa.
Java realizza la programmazione generica con una tecnica che si chiama Type Erasure.
Quando in Java scrivete list<String> state semplicemente dicendo che voi avete una lista di oggetti. Che il compilatore sa che casualmente sono stringhe. Ma lo sa solo il compilatore poi se lo dimentica. Il tipo viene cancellato perch√© l‚Äôoggetto list √® implementato per gli object.
Siccome tutto deriva da object, list di string √® semplicemente un caso particolare di list di object.
Siccome per√≤ poi se lo dimentica, a runtime non c‚Äô√® pi√π traccia di questo, non ci pu√≤ essere nessuna ottimizzazione che deriva dal fatto che io so che quelle sono proprio stringhe e che le stringhe sono grosse 20 byte e gli object sono grossi di un‚Äôaltra cosa.</p>
<p>In Rust invece si usa un approccio che non √® quello della Type Erasure ma √® quello della <strong>monomorfizzazione</strong>. Che vuol dire che lui quando incontra list di string dice ‚Äúah questo √® list di string‚Äù. Quindi fa una versione particolare del set di algoritmi di list tarata per le stringhe.
E quando dopo facciamo una la list di i32, che √® la lista dei numeri interi con segno, ne fa una versione diversa, ottimizzata per il fatto che quelli sono interi a 32 bit.
E‚Äô lo stesso approccio che segue anche il C++.</p>
<p>Questo permette ai tipi generici fatti in questo modo di essere molto pi√π performanti rispetto a quello che succede in Java.</p>
<p>Dispone del Pattern Matching che in Java √® stato introdotto solo parzialmente con la versione 21. C‚Äô√® un unico sistema di compilazione mentre in Java compilate con Java che poi avete la Just-in-Time Compilation nel momento in cui viene fatto loading, cio√® ci sono un po‚Äô di differenze.</p>
<p>E Java non ha nessun sistema di gestione delle dipendenze suo del linguaggio.
Potete usare Maven, potete usare Gradle, ma non sono del linguaggio, sono della comunit√† che li ha adottati.
E la comunit√† non √® sempre cos√¨ allineata sulle cose.</p>
<p><img src="images/introduzione_al_linguaggio/image%208.png" alt="image.png" /></p>
<p>Rispetto al C++ e al C non ci sono segmentation fault. Non ci sono segmentation fault perch√© non esiste il NULL. In C++ esiste NULL PTR, qua non c‚Äô√®.
I puntatori, almeno i puntatori safe, non possono semplicemente essere nulli perch√© non fa parte del linguaggio.</p>
<p>Non ci sono buffer overflow, non ci sono corse critiche dovute al fatto che in due cerchiamo in contemporanea di accedere alla stesso dato.</p>
<p>Il sistema dei tipi √® molto pi√π elaborato, l‚Äôeredit√† in Rust non c‚Äô√®, in C neanche, e in C++ invece c‚Äô√® un‚Äôereditariet√† multipla.</p>
<p>Il processo di costruzione √® unificato, e la gestione delle dipendenze √® integrata.</p>
<p><img src="images/introduzione_al_linguaggio/image%209.png" alt="image.png" /></p>
<p>Go √® un linguaggio che come Java adotta un bytecode intermedio, usa la memoria managed, e quindi abbiamo un garbage collector che comporta le pause.</p>
<p>In Go esistono i puntatori nulli e quindi possono esistere null pointer exception.</p>
<p>La gestione degli errori √® fatta in modo completamente diverso, Go usa il throw e di qua invece il concetto di throw e catch non c‚Äô√®, √® sostituito dall‚Äôidea che una funzione ritorna una monade, che √® un tipo algebrico, di result, che incapsula o il risultato o il fallimento.</p>
<p>E quindi non c‚Äô√® rischio di perderseli.</p>
<p>La programmazione concorrente √® sicura, Go ha questa idea delle goroutine, che √® una forma di implementare l‚Äôesecuzione asincrona in contesti multi-threaded, che per√≤ richiedono che il programmatore comprenda alcuni punti e si sforzi di mettere i costrutti di sincronizzazione l√† dove servono.</p>
<p>In Rust non potete fare una cosa non sincronizzata, il compilatore vi blocca.</p>
<p>L‚Äôapproccio all‚Äôereditariet√† √® diverso, non ci sono costi di estrazione e la gestione delle dipendenze √® diversa.</p>
<h1 id="4-caratteristiche"><a class="header" href="#4-caratteristiche">4. Caratteristiche</a></h1>
<h2 id="41-sicurezza"><a class="header" href="#41-sicurezza">4.1 Sicurezza</a></h2>
<p><img src="images/introduzione_al_linguaggio/image%2010.png" alt="image.png" /></p>
<p>Cosa non pu√≤ esserci in Rust?</p>
<p>Non ci possono essere dangling pointer.
A differenza di quello che succede in C e C++, una famiglia di puntatori di Rust si porta dietro il concetto di <strong>tempo di vita</strong>.
Il puntatore ha associato un tempo di vita, il compilatore conosce quel tempo di vita e usa l‚Äôinformazione del tempo di vita per poter dire se √® lecito o non √® lecito accedervi.</p>
<p>Ricordate quando abbiamo parlato quali sono i problemi dei puntatori in C? Dato un puntatore posso sapere se √® valido o meno? La risposta √® no.</p>
<p>Qui invece s√¨, perch√© io non posso assegnare a un puntatore null se non derivandolo da un dato esistente.
E in pi√π, questi puntatori si portano dietro l‚Äôetichetta del tempo di vita, che il compilatore valida, per cui non posso accedere n√© prima n√© dopo della loro validit√†.
Se provo a farlo il compilatore mi blocca. Non il runtime, il compilatore!</p>
<p>Non ci sono corse critiche, cio√® l‚Äôaccesso contemporaneo da parte di due thread a un certo dato.</p>
<p>Non ci sono buffer overflow, perch√© le strutture la cui dimensione √® variabile sono tutte rappresentate con dei <em><strong>fat pointer</strong></em>, ovvero dei puntatori che si portano insieme non solo l‚Äôinizio, come succede in C, ma anche la dimensione.
Questo mi costa un po‚Äô di pi√π, ma mi garantisce che nel momento in cui accedo io so che quello l√¨ in questo momento √® 32 byte, oppure 65, oppure 1900.</p>
<p>Uno dei grossi problemi, mentre io visito una lista, una struttura dati complessa e lo faccio guardando gli elementi uno per volta, √® che potrei trovarmi nella situazione che mentre osservo cosa c‚Äô√® l√¨ dentro, vorrei dire ‚Äúbutta via un pezzo‚Äù.
In Java hanno dovuto costruire un‚Äôastrazione un po‚Äô stramba per cui l‚Äôoggetto iterator vi d√† il metodo delete, ad esempio, per dire ‚Äúmentre scorri questa lista, questo buttalo via‚Äù.
In C++ non c‚Äô√® questa faccenda, quindi l‚Äôiterator funziona a modo suo. Se cancelli mentre iteri, il comportamento dell‚Äôiteratore √® ignoto.Pu√≤ capitare di tutto.
Qua non pu√≤ succedere.</p>
<p>C‚Äô√® il controllo dell‚Äôoverflow aritmetico per cui se fate 2 miliardi pi√π 2 miliardi il risultato non vi fa a meno 294 mila, come invece succede in C++.</p>
<p>In pi√π, viene favorito l‚Äôuso dell‚Äôimmutabilit√† per evitare di compromettere i dati.</p>
<h2 id="42-prestazioni"><a class="header" href="#42-prestazioni">4.2 Prestazioni</a></h2>
<p><img src="images/introduzione_al_linguaggio/image%2011.png" alt="image.png" /></p>
<p>Uno degli aspetti interessanti √® che il compilatore ottimizza in modo aggressivo sia la dimensione del codice che viene generato che la velocit√†.
Potreste non notarlo all‚Äôinizio perch√© quando compilate il vostro exe, lui si porta dentro tutto quello di cui ha bisogno a supportare poi la sua effettiva esecutiva, a differenza di quello che capita in C++ dove buona parte delle librerie sono caricate dinamicamente.
Quindi se voi guardate la dimensione dell‚Äôexe, vedete che l‚Äôhello world di C++ rischia di essere 50 byte, l‚Äôhello world di Rust rischia di essere 500 kilobyte.</p>
<p>Voi dite ‚Äúche schifo‚Äù. No, attenzione. Vai a vedere l‚Äôimpronta runtime.
Cosa c‚Äô√® nel processo mappato l√¨ dentro? C‚Äô√® il tuo hello world e una paccata di DLL.
Nel processo Rust c‚Äô√® tutto quello che c‚Äô√® scritto nel suo exe.
√à tanto, s√¨, ma intanto √® quella roba l√¨. La vedi tutta.</p>
<p>Quindi, fatto salvo questo che √® giusto metterlo in evidenza, le singole funzioni sono aggressivamente ottimizzate, cio√® cercando davvero di togliere tutto e di garantire il massimo livello della funzionalit√†.</p>
<p>Tutto √® stato pensato sapendo che l‚Äôarchitettura degli elaboratori √® basata sulla cache e quindi sono state scelte delle implementazioni che sono <em>cache aware</em>, che cercano di ridurre ad esempio il doppio salto, perch√© il doppio salto molto probabilmente provoca un cache miss.
Un cache miss, abbiamo visto nella tabellina dell‚Äôaltro giorno, che se il cache di primo livello costa due secondi, accedere alla RAM costa quattro minuti. √à un delta significativo.</p>
<p>La maggior parte delle invocazioni sono basate su <strong>indirizzi statici</strong> che permettono l‚Äôottimizzazione in line e quindi io il pi√π delle volte non chiamo una funzione.
Se quella funzione l√¨ √® piccola, il codice di quella funzione viene direttamente incastrato l√† dove c‚Äô√® la chiamata, perch√© mi costa di meno.
Il mio programma resta pulito lo stesso, non me ne accorgo, ma alla fine il compilatore pu√≤ scegliere di fare le cose in questo modo se lo ritiene opportuno.</p>
<p>La gestione di cargo, quindi il sistema per la gestione delle dipendenze, la suddivisione dei moduli, la presenza del sistema di test integrato e cos√¨ via, garantisce non solo la qualit√† di quello che stiamo facendo, ma anche l‚Äôaccesso a una vasta serie di librerie open source che il pi√π delle volte ci danno delle soluzioni veramente di alto livello per quello che abbiamo bisogno di fare.</p>
<h2 id="43-linguaggio-moderno"><a class="header" href="#43-linguaggio-moderno">4.3 Linguaggio moderno</a></h2>
<p><img src="images/introduzione_al_linguaggio/image%2012.png" alt="image.png" /></p>
<p>Quindi c‚Äô√® la gestione dei tipi generici basato sulla monomorfizzazione e non quella della Type Erasure di Java.</p>
<p>Supporta tipi algebrici e i pattern, quindi supporta sia le struct e le tuple sia le enum che sono invece tipi di somma.</p>
<p>Match √® una particolare istruzione che non ha nessun correlazione con altri linguaggi, l‚Äôunico che gli assomiglia molto lontanamente √® il when di Kotlin, che d√† la possibilit√† di esprimere in modo sintetico un branching dell‚Äôesecuzione tenendo conto che tutte le possibili alternative devono essere necessariamente rappresentate.</p>
<p>C‚Äô√® una strumentazione moderna associata al programma che ci consente di fare il linting, cio√® controllare che non ci siano code smell, di fare la formattazione in automatico in modo tale che il codice risulti scritto secondo un unico standard che facilita la lettura da parte delle persone, che facilita l‚Äôintegrazione con moduli esterni, la gestione delle dipendenze e cos√¨ via, la profilazione e altro.</p>
<h2 id="44-sicuro-per-definizione"><a class="header" href="#44-sicuro-per-definizione">4.4 Sicuro per definizione</a></h2>
<p><img src="images/introduzione_al_linguaggio/image%2013.png" alt="image.png" /></p>
<p>Il pezzo pi√π primo con cui andremo a scontrarci nel parlare di Rust √® il concetto di ‚Äú<em><strong>possesso</strong></em>‚Äù.</p>
<p>Abbiamo gi√† detto che alcuni puntatori ‚Äúposseggono‚Äù il loro valore, altri non posseggono il loro valore.
E quando abbiamo parlato di possesso, come l‚Äôabbiamo definito il possesso?
Il possesso √® un <em>diritto-dovere</em>.
√à il diritto di accedere al dato, √® il dovere di rilasciarlo alla fine della mia vita.</p>
<p>Questi per√≤, in C e C++, sono concetti che non sono espliciti e non sono neanche dati a tutti.</p>
<p>In Rust, viceversa, ogni valore √® posseduto da una e una sola variabile.
Quando quella variabile cessa di esistere, il valore viene rilasciato.</p>
<p>‚ÄúAh, ma allora non √® possibile passarsi delle cose?‚Äù
S√¨, √® possibile.</p>
<p>Perch√© Rust unisce al concetto di possesso il concetto di <em><strong>movimento</strong></em>.
Non solo un dato √® posseduto da una e una sola variabile, ma quando io, ad esempio, invoco una funzione e passo un dato come parametro, quello che sto facendo √® che sto cedendo quel dato alla funzione.</p>
<p>Quel dato l√¨ fisicamente perde il suo indirizzo, stava allocato a 3b7f, e viene ceduto e va nella locazione 7c49 o qualcosa altro. Si √® mosso.</p>
<p>‚ÄúEh, ma se c‚Äôera qualcuno che lo conosceva?‚Äù
E qui interviene il controllo dei tipi. Dice ‚ÄúTu puoi muoverlo se non c‚Äô√® nessuno che lo conosce. E se c‚Äô√® qualcuno che lo conosce invece non lo muovi, guarda un po‚Äô perch√©‚Ä¶‚Äù.
E ti obbliga a scrivere le giuste le cose.</p>
<p>I puntatori sono tutti controllati in fase di compilazione.</p>
<p>I thread possono essere, fanno parte del linguaggio, il linguaggio ha std sync thread come parte della libreria standard, quindi non √® stato aggiunto a posteriori, e soprattutto ha un insieme di tratti che determinano per ciascun tipo se √® lecito o meno che quel tipo l√¨ sia passabile da un thread all‚Äôaltro o se il puntatore a quel tipo l√¨ sia passabile da un thread all‚Äôaltro.</p>
<p>I tratti si chiamano sync e send e rispettivamente se un dato √® send quel dato pu√≤ essere ceduto a un altro thread, se non √® send non pu√≤ essere ceduto, ti blocca.
Al contrario, nel caso di un dato di tipo sync, l‚Äôindirizzo di quel dato l√¨ pu√≤ essere ceduto a un altro thread, altrimenti non pu√≤ essere ceduto.</p>
<p>Il compilatore verifica nel momento in cui scriviamo del codice multithread che cosa stiamo facendo conoscere da un thread all‚Äôaltro e ci blocca quando facciamo delle operazioni sbagliate.</p>
<p>Non ci sono stati nascosti.
Perch√© a differenza di quello che capita in C++, ad esempio con la gestione delle eccezioni, in C++ una funzione come in Java, come in JavaScript, come in altri linguaggi, potrebbe non arrivare al fondo, potrebbe lanciare un‚Äôeccezione: bloccarsi a met√†.
Cosa succede quando si lancia un‚Äôeccezione? Si lancia un‚Äôeccezione e quella funzione l√¨ ritorna.
Ma ritorna in un modo diverso dal ritorno normale, perch√© non atterra nel chiamante.
A meno che il chiamante non l‚Äôabbia racchiuso in un blocco try-catch.
Se il chiamante non c‚Äô√® al blocco try-catch il chiamante viene allegramente saltato, si torna al chiamante del chiamante, si torna al chiamante del chiamante, fino a che non si atterra in un blocco try-catch.</p>
<p>E quindi io mi trovo in situazioni dove so di aver iniziato una cosa ma non la posso finire.
Perch√© per via dell‚Äôeccezione che si √® verificata da qualche parte, in qualcuno che ho chiamato, che io non vedo, di cui non ho nessuna percezione, non sono arrivato al fondo.
E questo rende scrivere degli algoritmi coerenti molto complicato.</p>
<p>Oppure porta a scrivere degli algoritmi vomitevoli, cio√® pieni di try-catch, che per√≤ rendono illeggibile il codice.</p>
<p>Rust da questo punto di vista dice ‚Äúle eccezioni non ci sono‚Äù. Dopodich√© la computazione pu√≤ fallire. Non vuol dire che non ci sono fallimenti, ma non implementati col concetto di eccezione.</p>
<p>Le funzioni che possono fallire ritornano un tipo algebrico, <em><strong>result</strong></em>, che pu√≤ valere <em><strong>Ok</strong></em>, e se vale ok racchiude quello che vi pare, x, dove x √® di tipo che vi fa piacere, oppure <em><strong>error</strong></em>, e se vale error racchiude il tipo y, che √® la tipologia di dato che volete usare per rappresentare il vostro error. Pu√≤ essere una stringa, pu√≤ essere un‚Äôaltra cosa che vi fa capire che cosa √® successo.</p>
<p>Ma la funzione chiamata ritorna sempre.
E quindi il chiamante ha il compito poi di guardare cosa √® diventato dentro.</p>
<p>Quel tipo l√¨ √® una monade, ovvero √® una cosa che incapsula il suo contenuto e te lo fa vedere, non ti lascia accedere direttamente, ti obbliga a sbustarlo, e quindi richiede un‚Äôoperazione conscia al programmatore: <em>Che cosa mai mi √® tornato da sta roba qua?</em> If result is error ci faccio certe cose, if result is Ok ce ne faccio delle altre. Questo obbliga a essere consapevoli di quello che succede.
In pi√π ci sono una serie di syntactic sugar che rendono la scrittura del codice molto snella, nella maggior parte dei casi: <em>se √® un errore non posso farci niente</em> ‚Üí Questo viene risolto allegramente con una notazione sintattica che dice ‚Äúoh beh, ritorna questo stesso errore al chiamante che lo gestir√† lui‚Äù, ma lo faccio in modo esplicito.
Mentre in Java, o anche in C++, questo avviene implicitamente, senza che io me ne renda conto. E questo pu√≤ portare a delle situazioni molto brutte.</p>
<h2 id="45-controllo-a-basso-livello"><a class="header" href="#45-controllo-a-basso-livello">4.5 Controllo a basso livello</a></h2>
<p><img src="images/introduzione_al_linguaggio/image%2014.png" alt="image.png" /></p>
<p>C‚Äô√® un controllo a basso livello per cui la memoria viene rilasciata non appena una variabile esce di visibilit√†. Ogni valore √® posseduto da una variabile. Quando quella variabile l√¨ esce di visibilit√† il valore viene liberato, la memoria viene buttata via.</p>
<p>In alcuni casi questo vuol dire che lo stack si contrae, in altri casi vuol dire che lo heap riprende possesso di un buchino nel cui era stato allocato quel valore.</p>
<p>Questo fa s√¨ che non ci siano sprechi di memoria, dovuti al fatto che io ho montagne di cose che sono l√¨ pendenti in attesa che il garbage collection scatti e vada a raccogliere.</p>
<p>Posso chiamare direttamente le system call.
Tra le tante system call che posso chiamare ci sono quelle ad esempio per la creazione di nuovi processi come <em>fork</em>.
Nei linguaggi dove invece c‚Äô√® la garbage collection io non posso chiamare la fork perch√© il nuovo processo che si verrebbe a creare ha dei presupposti diversi da quello originale.</p>
<p>Pu√≤ essere eseguito su dispositivi senza sistema operativo, tanto che lo posso compilare per Arduino. Non ha bisogno dell‚Äôesistenza del sistema operativo.</p>
<p>E poi ha un sistema chiamato <em><strong>FFI</strong></em>, <em>foreign function interface</em>, che mi garantisce la chiamabilit√† di funzioni C. Per cui se ho bisogno, ho gi√† una libreria fatta, che so che funziona, che ha tutte le sue caratteristiche, la posso invocare.
E al contrario posso esporre un modulo Rust dicendo che √® il binding per il C, in modo tale che la mia libreria scritta in Rust sia chiamabile dal C o dal C++.</p>
<h1 id="5-installare-rust"><a class="header" href="#5-installare-rust">5. Installare Rust</a></h1>
<p><img src="images/introduzione_al_linguaggio/image%2015.png" alt="image.png" /></p>
<p><img src="images/introduzione_al_linguaggio/image%2016.png" alt="image.png" /></p>
<p>Se lo scaricate oggi √® verosimile che tra dieci giorni possiate fare la start update e lui si scarica automaticamente la versione nuova.</p>
<p>Ci sono una serie di toolchain differenti, alla fine il compilatore Rust √® distribuito, va compilato anche lui, e produce dei moduli eseguibili che devono essere linkabili con il resto del vostro sistema operativo per poter chiamare le system call.
Per farlo c‚Äô√® bisogno che sulla vostra macchina ci sia un linker opportuno e eventualmente un compilatore C opportuno.
Chi ha la macchina Windows pu√≤ scegliere se prendere la versione basata su MSWC, quindi Microsoft Visual C, senza bisogno di installarsi Visual C, scarica solo i compilatori, sono gratuiti, se lo fa lui per i fatti suoi.
Dovete solo scegliere se volete quella toolchain l√¨ o se volete quella su sigwin, che √® il porting di GCC su Windows. Normalmente quella di MSWC √® un po‚Äô pi√π performante.</p>
<p>Viceversa, se avete un Mac o un Linux, nel caso del Mac viene fatto per Clang e se avete un Linux il supporto √® quello di GCC all‚Äôultima versione.</p>
<p>Nel momento in cui scaricate, fate Rustup, non solo vi ritrovate il programma Rustc che √® il vero compilatore, ma vi ritrovate anche il programma Cargo che √® il gestore dei progetti.</p>
<p>Notate che Rustc probabilmente non lo chiamerete mai direttamente voi, perch√© √® molto pi√π semplice creare un progetto con Cargo, <em>Cargo init</em>, fa esattamente come npm init, vi crea una directory nuova dentro cui deporita un file Cargo.toml e ci mette all‚Äôinterno un primo main.rs che poi voi potete estendere con le vostre cose.</p>
<p>Quando avete una configurazione di quel genere il comando Cargo build automaticamente compila, linka le librerie che deve linkar, cio√® fa tutto quello di cui avete bisogno.
Cargo check viceversa vi esegue il linting e controlla che non ci siano schifezze e cos√¨ via.
Cargo profile vi fa il profiling del vostro programma.</p>
<h1 id="6-cargo"><a class="header" href="#6-cargo">6. Cargo</a></h1>
<p><img src="images/introduzione_al_linguaggio/image%2017.png" alt="image.png" /></p>
<p>Quindi Cargo √® realmente il vostro amico principale, lo usate per gestire il vostro progetto.
Rust usa una sua terminologia a cui bisogna un po‚Äô adattarsi.</p>
<p>Il progetto si chiama <strong>package</strong>, perch√© lo impacchettate.
All‚Äôinterno di questo del vostro package, tipicamente il package sta in una cartella all‚Äôinterno della quale ci mettete il file Cargo.toml, che √® un file di testo scritto o indentato in qualche modo con delle sezioni che descrive che versione di Rust usate, quali sono le dipendenze, se volete mettere un copyright, se volete mettere degli altri metadata associati etc...</p>
<p>E quando l‚Äôavete fatto potete compilare direttamente con Cargo build e Cargo run.</p>
<p><img src="images/introduzione_al_linguaggio/image%2018.png" alt="image.png" /></p>
<p>Eseguendo <code>cargo init rust1</code> ci pensa un po‚Äô e mi dice ‚Äú<em>created binary package</em>‚Äù.
Visto che non mi hai detto nient‚Äôaltro, penso che tu voglia fare un programma, un eseguibile, una cosa che puoi lanciare direttamente.</p>
<p>L‚Äôalternativa era dire Cargo init, nome del mio programma, - - library.
E allora lui mi creava lo scheletro di una libreria.</p>
<p>La differenza tra un programma e una libreria √® che il programma ha un main, la libreria non ce l‚Äôha.
Perch√© la libreria deve essere usata da qualcun altro.</p>
<p><img src="images/introduzione_al_linguaggio/image%2019.png" alt="image.png" /></p>
<p>Adesso faccio ls e vedo che mi ha creato una cartella che si chiama Rust 1. E dentro trovo il file Cargo.toml e un‚Äôaltra cartella che si chiama source.</p>
<p><img src="images/introduzione_al_linguaggio/image%2020.png" alt="image.png" /></p>
<p>All‚Äôinterno della cartella source al momento c‚Äô√® un unico file, main.rs.</p>
<p>Vediamo prima cosa c‚Äô√® dentro Cargo.toml:</p>
<p><img src="images/introduzione_al_linguaggio/image%2021.png" alt="image.png" /></p>
<p>Name Rust 1, il nome del progetto che ho creato. Lui ce l‚Äôha come metadato.
Versione 0.1.
Edizione 2021. L‚Äôedizione 2021 ha a che fare con quale versione del linguaggio Rust stiamo compilando.</p>
<p>Ci sono tre edizioni principali al momento: l‚Äôedizione 2015, la pi√π antica. L‚Äôedizione 2018. E qui abbiamo l‚Äôedizione 2021.
Ha a che fare con i costrutti del linguaggio che sono supportati.
Ogni tre anni c‚Äô√® un‚Äôedizione nuova.</p>
<p>Quindi tra un po‚Äô uscir√† l‚Äôedizione 2024 che aggiorner√† ulteriormente la sintassi. Semplificandola probabilmente.</p>
<p>Poi c‚Äô√® un commento.</p>
<p>Fin qua √® tutta la sesione [package], dove scrive tutte le cose che riguardano il progetto.</p>
<p>Poi, sotto, c‚Äô√® la sezione [dependencies], ma ora √® vuota quella sezione l√¨ perch√© non stiamo usando nessuna libreria esterna.</p>
<p>Se qui dentro noi ci aggiungessimo dei riferimenti a una libreria esterna, io magari gli scriverei che ne so, che dipendo dalla libreria Tokyo versione 1.37, dopo aver scritto quella cosa l√¨, se faccio Cargo Build lui dice ‚Äúah caspita ma tu mi hai detto questo, io non ce l‚Äôho ancora, aspetta, me la vado a scaricare, te la salvo in una cartella nascosta che √® la tua home/.cargo, non √® importante, da qualche parte, e poi te la compilo anche, dopodich√© ce l‚Äôhai nel tuo progetto‚Äù.</p>
<p>Andiamo a vedere cosa c‚Äô√® dentro src:</p>
<p><img src="images/introduzione_al_linguaggio/image%2022.png" alt="image.png" /></p>
<p>Il minimo che sia possibile scrivere.</p>
<p>Facciamo Cargo Build:</p>
<p><img src="images/introduzione_al_linguaggio/image%2023.png" alt="image.png" /></p>
<p>E‚Äô lenta la compilazione, per fare Low Word ci mette 2,28 secondi.
E‚Äô lenta perch√© in realt√† fa un mucchio di cose in compilazione. Vi salva un mucchio la vita, e quindi alla fine perlomeno debuggerete molto meno grazie al fatto che quella compilazione l√¨ √® lenta.</p>
<p><img src="images/introduzione_al_linguaggio/image%2024.png" alt="image.png" /></p>
<p>Se vado a vedere che cosa √® successo, vedo che sono cresciute le cose.</p>
<p>Lui automaticamente, quando ho fatto <code>cargo init</code>, ha gi√† fatto una cartella .git, c‚Äô√® gi√† un commit l√¨ sopra dell‚Äôinitial version.</p>
<p>Mi ha gi√† creato un git ignore, dicendo ‚ÄúGuarda che sono dei file che non servono, cio√® che non devi, se mai vai a mettere un origin remota, non devi salvarli dall‚Äôaltra parte, perch√© sono legati alla tua implementazione‚Äù.</p>
<p>Mi ha aggiunto, accanto al file Cargo.toml, il file Cargo.lock.</p>
<p>Che differenza c‚Äô√® tra il file Cargo.toml e il file Cargo.lock?</p>
<p>Come qualcuno di voi che ha un po‚Äô di conoscenze su JavaScript sa che i progetti JavaScript hanno del NPM la versione base e la versione con lock.</p>
<p>La versione con lock √® una versione verbosa della versione base che √® esplicita di tutte le dipendenze, √® la versione effettiva, mentre di solito nelle dipendenze raccontiamo la versione minima necessaria, che garantisce la riproducibilit√† del processo di compilazione in ambienti diversi.</p>
<p>Accanto alla cartella source √® comparsa la cartella target.</p>
<p><img src="images/introduzione_al_linguaggio/image%2025.png" alt="image.png" /></p>
<p>Se vado a vedere cosa c‚Äô√®, vedo che all‚Äôinterno √® comparsa un file CACHEDIR.TAG che serve a lui per ricordarsi a che versione della compilazione √® andata, c‚Äô√® un hash l√¨ dentro che gli serve.</p>
<p>E poi c‚Äô√® debug, cio√® la versione debug del nostro programma. Vediamo cosa c‚Äô√® dentro:</p>
<p><img src="images/introduzione_al_linguaggio/image%2026.png" alt="image.png" /></p>
<p>All‚Äôinterno ci trovo il risultato della compilazione, tra cui rust1 che √® il mio programma.</p>
<p>Vedete che √® vomitevole? 460k era quello che vi dicevo prima, perch√© dentro ha tutte le librerie che gli servono per l‚Äôesecuzione. Quella √® l‚Äôimmagine del processo.
Dentro ci troviamo delle altre cose che sono i vari pezzi di cui lui ha bisogno durante la compilazione.
Questa cartella qua √® tutta cancellabile, la potete pulire quando volete.</p>
<p><img src="images/introduzione_al_linguaggio/image%2027.png" alt="image.png" /></p>
<p>Se voi fate <code>cargo clean</code>, rimorsi i 27 file ha pulito un megabyte di schifezze.</p>
<p><img src="images/introduzione_al_linguaggio/image%2028.png" alt="image.png" /></p>
<p>Se io scrivessi cargo run, lui adesso si accorge ‚Äúcaspita ma mi ha appena cancellato l‚Äôeseguibile‚Äù. Lo rif√† e poi lo lancia.</p>
<p>Cargo check, checking. E‚Äô sufficientemente piccolo che non ci sono schifezze. Se no qua in mezzo ci avrebbe scritto ‚Äúalla riga 75 ho visto sta roba che non mi piace, alla riga 89 c‚Äô√® quest‚Äôaltro aggeggio un po‚Äô strano‚Äù e cos√¨ via.</p>
<p><img src="images/introduzione_al_linguaggio/image%2029.png" alt="image.png" /></p>
<p>Posso usare librerie, come?
Posso aggiungerci delle librerie nella sezione ‚Äúdependency‚Äù del Cargo.toml, o posso farlo automaticamente con ‚Äúcargo add‚Äù.</p>
<p>Va bene, qui ho citato un po‚Äô di ambienti che potete scaricarvi, vedete un po‚Äô, ‚Äúvs code‚Äù, ‚Äúrastrover‚Äù, che √® quello che uso io, potete fare con ‚Äúeclipse‚Äù, potete fare con ‚Äúsublime‚Äù, potete fare con ‚Äúatom‚Äù, potete fare ‚Äúneoveam‚Äù, un po‚Äô a piacimento.</p>
<p><img src="images/introduzione_al_linguaggio/image%2030.png" alt="image.png" /></p>
<p>Il <strong>package</strong> √® il progetto.</p>
<p>Il progetto contiene uno o pi√π ‚Äú<strong>crate</strong>‚Äù, che significa contenitore.
C‚Äô√® il ‚Äúcrate‚Äù principale, che √® il vostro main, e poi ci possono essere altri contenitori: sono le librerie di cui si serve.</p>
<p>Il vostro ‚Äúcrate‚Äù principale viene chiamato ‚Äúcrate root‚Äù, coincide col codice che √® scritto nel file ‚Äúmain.rs‚Äù o quello che √® presente nel file ‚Äúlib.rs‚Äù, se state facendo una libreria.</p>
<p>Notate che il punto di ingresso del vostro programma, a livello sorgente, si deve chiamare ‚Äúmain.rs‚Äù, se lo state facendo come eseguibile.</p>
<p>Rust ha il concetto di <strong>modulo</strong>.
Il modulo √® un blocco di funzioni e strutture dati tra loro coerente.
Il vostro programma pu√≤ essere suddiviso in molti moduli.</p>
<p>I moduli sono o blocchi dentro il file ‚Äúmain.rs‚Äù o file a parte.
In quel caso l√¨, se sono file a parte, si devono chiamare come il nome del modulo.</p>
<p>Se avete fatto il modulo ‚Äúpaghe_stipendi‚Äù, ecco, il modulo ‚Äúpaghe stipendi‚Äù sta nel file ‚Äúpaghe_stipendi.rs‚Äù.</p>
<p>Quindi c‚Äô√® una corrispondenza tra il nome del modulo e il file che lo contiene.</p>
<p>Oppure il modulo ‚Äúpaghe_stipendi‚Äù sta nella cartella ‚Äúpaghe_stipendi‚Äù e allora il suo codice principale si chiama ‚Äúmod.rs‚Äù.</p>
<p><img src="images/introduzione_al_linguaggio/image%2031.png" alt="image.png" /></p>
<p><img src="images/introduzione_al_linguaggio/image%2032.png" alt="image.png" /></p>
<p><img src="images/introduzione_al_linguaggio/image%2033.png" alt="image.png" /></p>
<p>Ma poi in realt√† non vale la pena dispenderci pi√π di tanto perch√© lo faremo concretamente e vedrete che vi viene abbastanza naturale fare delle cose.</p>
<p>Questo √® un esempio di un progetto che contiene un main che contiene dentro di s√© due diversi moduli.</p>
<p>Allora, contiene il modulo ‚Äúothermods.rs‚Äù e contiene un ‚Äúmain‚Äù module che a sua volta si suddivide a una parte principale o un sottomodulo chiamato ‚Äúinnermods.rs‚Äù.</p>
<p>Qui c‚Äô√® invece la struttura di una libreria che √® pi√π o meno simile e qui c‚Äô√® un esempio di un programma che ha pi√π eseguibili.</p>
<p><img src="images/introduzione_al_linguaggio/image%2034.png" alt="image.png" /></p>
<p>Per stampare si usa print o println con il punto esclamativo.</p>
<p>Perch√© col punto esclamativo?
Perch√© quella non √® una funzione, √® una <em><strong>macro</strong></em>.</p>
<p>Quella roba l√¨ viene scompattata in fase di compilazione e genera del codice ulteriore ottimizzato per quello che volete stampare.
E genera un‚Äôunica system call per tutta l‚Äôoperazione, invece di appiccicare dei pezzi.</p>
<p>Le variabili si introducono con la parola chiave ‚Äúlet‚Äù e le funzioni si introducono con la parola chiave ‚Äúfn‚Äù.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="il-linguaggio---malnati-5"><a class="header" href="#il-linguaggio---malnati-5">Il Linguaggio - Malnati 5 <!-- omit in toc --></a></h1>
<h1 id="indice-3"><a class="header" href="#indice-3">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="05-il_linguaggio_parte_1.html#1-variabili-e-tipi">1. Variabili e tipi</a></li>
<li><a href="05-il_linguaggio_parte_1.html#2-tipi-e-tratti">2. Tipi e tratti</a>
<ul>
<li><a href="05-il_linguaggio_parte_1.html#21-tuple">2.1 Tuple</a></li>
<li><a href="05-il_linguaggio_parte_1.html#22-puntatori">2.2 Puntatori</a>
<ul>
<li><a href="05-il_linguaggio_parte_1.html#221-ref">2.2.1 Ref</a></li>
<li><a href="05-il_linguaggio_parte_1.html#221-ref-mut">2.2.1 Ref mut</a></li>
<li><a href="05-il_linguaggio_parte_1.html#223-box">2.2.3 Box</a></li>
<li><a href="05-il_linguaggio_parte_1.html#224-puntatori-nativi-c">2.2.4 Puntatori nativi C</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_1.html#3-riferimenti">3. Riferimenti</a>
<ul>
<li><a href="05-il_linguaggio_parte_1.html#31-esempi">3.1 Esempi</a></li>
</ul>
</li>
</ul>
<h1 id="1-variabili-e-tipi"><a class="header" href="#1-variabili-e-tipi">1. Variabili e tipi</a></h1>
<p><img src="images/il_linguaggio/image.png" alt="image.png" /></p>
<p>Le variabili vengono introdotte dalla parola chiave let.
Let, da sola, vuol dire ‚Äúquello che segue √® il nome di una variabile che ha bisogno di avere un valore iniziale‚Äù <code>let i = 25;</code> questa cosa qua dice ‚Äúla variabile <code>i</code> contiene il valore 25‚Äù; siccome 25 √® un intero, verosimilmente √® un <em>intero a 32 bit con segno</em> perch√© √® la cosa pi√π probabile che sia.</p>
<p>Se non ti piace che quel 25 sia un intero a 32 bit con segno hai due possibilit√†:</p>
<ul>
<li>aggiungi un suffisso a 25 ‚Äî <code>let i = 25 u32</code> o <code>u64</code> (che vuol dire un unsigned a 32 bit o un unsigned a 64 bit) o anche <code>u8</code> (che vuol dire un unsigned a 8 bit, cio√® un byte)</li>
<li>dove metti <code>let i</code> prima di dargli il valore scrivi <code>let i:il_suo_tipo</code></li>
</ul>
<p>Quando io scrivo <code>let i = 25</code> sto introducendo una variabile <em><strong>immutabile</strong></em>, ******che vuol dire che non posso fare alla riga dopo <code>i = 26</code>, perch√© il compilatore non me lo consentirebbe.</p>
<p><code>let</code> introduce la variabile immutabile.
La maggior parte delle variabili che noi trattiamo di fatto sono immutabili anche se buona parte dei linguaggi a cui siamo abituati vedono l'immutabilit√† come un caso particolare.
Rust adotta esattamente l'approccio opposto: il caso normale √® l'immutabilit√†, e ogni tanto serve poter mutare.</p>
<p><em>Come faccio a creare una variabile mutabile?</em>
Devo usare la sintassi <code>let mut i = 25</code>, che scritta cos√¨ vuol dire che <code>i</code> √® una variabile intera a 32 bit che contiene 25 ed √® <em><strong>mutabile</strong></em>, cio√® nel tempo potrei assegnargli dei valori diversi.</p>
<p>Il concetto di immutabilit√† non √® solo legato al fatto che non posso riassegnarla, √® legato al fatto che eventuali operazioni che riguardano quella variabile l√¨, se fosse una cosa un pochino pi√π complessa invece di un semplice intero (che √® un numero e basta), ad esempio una lista, se io la introduco con let sto dicendo che non solo quella √® legata a quella lista particolare ma che in quella lista l√¨ non faccio nessun cambiamento ‚Äî non aggiungo e non tolgo.</p>
<p>Per poter fare un cambiamento devo metterci per forza la parola chiave <strong><code>mut</code></strong> in modo tale che il compilatore possa farsi i suoi conti e se lo ricordi. Quindi di base una variabile pu√≤ essere legata a un solo valore per tutta la sua esistenza in vita.
Posso dire che la variabile pu√≤ essere legata a valori successivi in futuro purch√© abbiano lo stesso tipo.</p>
<p><code>mut</code> suona bene come <em>mutabile</em>, ma in realt√† vuol dire <em><strong>mutuamente esclusivo</strong></em>: non solo pu√≤ cambiare le cose, ma mentre c'√® uno che cambia nessun altro cambia!
Non solo: mentre c'√® uno che cambia, gli altri neanche possono guardare perch√© se gli altri possono guardare mentre io cambio potrebbero leggere potrebbero vedere delle cose sbagliate.</p>
<p><em>Quindi il <strong>mut</strong>, il diritto di cambiare, me lo prendo solo quando mi serve in quei precisi momenti e per il resto osservo</em>.</p>
<p>Quest'idea che uno solo per volta ci mette le mani dentro per cambiare le cose √® essenziale alla coerenza e la correttezza del programma.
Ad ogni variabile √® associato staticamente, quindi per tutta l'esistenza in vita di quella variabile che va dal punto in cui la dichiaro fino al punto in cui c'√® la chiusa graffa corrispondente, resta legato quel tipo.</p>
<p>Quindi, se ad esempio ho dichiarato <code>i</code>  di tipo i32, a differenza di quello che succede in C, in C++, in Java e in tanti altri linguaggi, io posso, in due righe successive dello stesso blocco, ridefinire la variabile: posso scrivere <code>let i = 25</code> e sotto posso scrivere <code>let i = ‚Äúciao mamma‚Äù</code> ‚Äî notate il secondo let.
Che cosa fa il secondo let? Dice <em>‚Äúguarda, prima c'era una cosa che si chiamava</em> <code>i</code><em>, te la nascondo! Adesso te ne faccio un‚Äôaltra</em> <code>i</code><em>, e questa √® una stringa‚Äù.</em></p>
<p>La presenza del secondo automaticamente nasconde il primo, che non si vedr√† pi√π!
Questo in alcune situazioni √® comodissimo, perch√© io ricevo un valore e poi per non impazzire col mio codice lo ribattezzo in qualcos‚Äôaltro.</p>
<p><img src="images/il_linguaggio/image%201.png" alt="image.png" /></p>
<p>Quando io introduco let, non solo metto il nome della variabile ma posso anche aggiungere il tipo.</p>
<p><code>let v: i32 = 123</code> sto dicendo che <code>v</code> √® immutabile e vale 123, e spiego esplicitamente che √® un i32.
Quindi se scrivessi <code>v = -5</code> la riga dopo, senza nessun let davanti, lui dice <em>‚Äúno, sta roba non ha senso perch√® v √® immutabile‚Äù.</em></p>
<p>Se scrivo <code>let mut w = v</code> sto introducendo una nuova variabile.
Questa qui si, √® cambiabile, e inizialmente ha lo stesso valore di v, quindi 123.
Per il momento io sto <strong>copiando</strong> quel contenuto. <code>w</code> adesso lo posso cambiare: posso scrivere <code>w = -5</code> senza problemi. <code>v</code> √® rimasto quello che era perch√© me lo sono <strong>copiato</strong>.</p>
<p><code>let x = 1.3278</code> √® sempre immutabile ma √® un float questa volta, anzi un float 64 per default.</p>
<p><code>let y = 13278f32</code>  √® un float 32, cio√® un floating point a singola precisione.</p>
<p><code>let one_million = 1_000_000</code> √® semplicemente un intero, per√≤ nei numeri potete usare l‚Äôunderscore semplicemente come separatore della cifra.</p>
<p><img src="images/il_linguaggio/image%202.png" alt="image.png" /></p>
<p>A una variabile dobbiamo assegnare un valore iniziale.
Quel valore pu√≤ essere un <strong>valore immediato</strong>, cio√® derivato direttamente (tipo un numero, per esempio 27) o pu√≤ essere il risultato di un‚Äô<strong>espressione</strong>, come ad esempio <code>((3 * 5) + 9)</code>.</p>
<p>Tutte le espressioni <strong>producono un valore</strong> ‚Äî questo √® molto diverso da quello che succede in C e C++, in cui la maggior parte delle cose sono degli <em><strong>statement</strong></em> ovvero sono costrutti che non producono niente: in C <code>if</code> non produce niente, in Rust <code>if</code> produce o quello che c‚Äô√® nel then, se la condizione √® vera, oppure quello che c‚Äô√® nell‚Äôelse se la condizione √® falsa.
Quindi √® lecito scrivere <code>let max = if a&gt;b a else b</code> .</p>
<p>C‚Äô√® un‚Äôeccezione importante che √® l‚Äôassegnazione.
In C e in C++ l‚Äôassegnazione √® vista come una <strong>funzione</strong>: voi potete scrivere <code>int i = j = k = 0</code>  ‚Äî quella cosa l√¨ parte dal fondo, prende lo 0 e lo scrive dentro <code>k</code> , d√† come risultato 0 e lo scrive dentro j, d√† come risultato 0 e lo scrive dentro i.
In Rust questo non √® possibile, quindi non potete fare l‚Äôassegnazione multipla, se ne avete bisogno lo spezzate su pi√π righe.
Perch√© √® cos√¨? Perch√© in realt√† la presenza dell‚Äôassegnazione multipla mette in grossa difficolt√† il sistema di deduzione automatica e quindi va gestito in modo pi√π furbo perch√© vincola la validit√† del principio di transitivit√† tra tipi che non √® detto che esista.</p>
<h1 id="2-tipi-e-tratti"><a class="header" href="#2-tipi-e-tratti">2. Tipi e tratti</a></h1>
<p><img src="images/il_linguaggio/image%203.png" alt="image.png" /></p>
<p>Di base tutte le espressioni vengono valutate, producono un valore e il valore ha un tipo.
Ci sono tipi elementari, che sono quelli predefiniti nel linguaggio, come i numeri, che sono tanti e si dividono tendenzialmente in base alla loro dimensione e alla loro tipologia.</p>
<p>I tipi che iniziano con <code>i</code> sono gli interi con segno, i8, i16, i32, i64, i128‚Ä¶
Quelli che iniziano con <code>u</code> sono gli interi senza segno, u8, u16, u32 etc‚Ä¶
Gli <code>f32</code> sono floating point a singola precisione, gli <code>f64</code> floating point a doppia precisione etc..</p>
<p>Il programmatore pu√≤ aggiungere dei tipi attraverso tre costrutti:</p>
<ul>
<li>le <strong>tuple</strong></li>
<li>le <strong>struct</strong></li>
<li>le <strong>union</strong></li>
</ul>
<p>Questi tre tipi permettono di creare qualcosa di nuovo.
Tra i tipi predefiniti, oltre ai numeri, ci sono anche alcuni tipi di puntatori.
Ogni tipo di puntatore ha un uso particolare e ha dei vincoli legati al suo utilizzo.</p>
<p>A ogni tipo √® possibile associare zero o pi√π <em><strong>tratti</strong></em>.
Un tratto √® una <em>dichiarazione di impegno</em> a fornire un certo comportamento ‚Äî tradotto in altre parole, assomiglia molto a quello che in Java si chiama <strong>un‚Äôinterfaccia</strong>. Quando in Java create un‚Äôinterfaccia state dicendo non come si comporta un oggetto, ma state dicendo che <em>l‚Äôoggetto che implementer√† quell‚Äôinterfaccia si impegna a mettere il codice per il metodo x, y e z</em>.</p>
<p>Il tratto fa la stessa cosa dire: che il tipo <code>Int</code> gode del tratto <code>Copy</code> vuol dire che mette in atto il comportamento della <strong>copia a fronte dell‚Äôassegnazione</strong>, cio√® quando io lo assegno il dato di destra viene duplicato nel dato di sinistra.
Dire che il tipo <code>Int</code> gode del tratto <code>Eq</code> vuol dire che il tipo <code>Int</code> √® confrontabile con un altro intero e quindi posso chiedermi se sono uguali.
Dire che il tipo <code>Int</code> gode del tratto <code>Ord</code> significa che posso valutare la relazione d‚Äôordine cio√® posso chiedermi se un intero √® pi√π piccolo di un altro o √® pi√π grande di un altro o √® maggior uguale o cose del genere.</p>
<p><strong>Quindi il tratto esprime dei comportamenti</strong>.
Questo non ci stupisce troppo: in Java, ad esempio, io posso confrontare col minore due cose solo se queste implementano l‚Äôinterfaccia <em><strong>comparable</strong></em>.</p>
<p><strong>I</strong> <strong>tipi sono tutti indipendenti tra di loro</strong>: non c‚Äô√® una relazione di ereditariet√†, sono cose disgiunte.
Ogni tipo pu√≤ avere zero o pi√π tratti. Spesso ne ha tanti.</p>
<p><strong>I tratti invece sono legati tra di loro in una</strong> <strong>relazione di dipendenza</strong>.
****A volte in una dipendenza negativa: chi gode del tratto <code>Drop</code> non pu√≤ avere il tratto <code>Copy</code>, e viceversa.
Chi ha il tratto <code>Copy</code> deve avere il tratto <code>Clone</code>.
Serve a garantire la coerenza delle cose</p>
<p>Ci sono dei tratti che, come in Java, definiscono un gruppo di metodi.
Ad esempio in Java un‚Äôinterfaccia nota √® <code>runnable</code>, che contiene un unico metodo <code>void run()</code> senza argomenti. Ma in Java ci sono anche interfacce privi di metodi: l‚Äôinterfaccia <code>serializable</code> non contiene nessun metodo, √® un marker!
Un oggetto che implementa <code>serializable</code> dice ‚Äú<em>io posso essere serializzato</em>‚Äù, cio√® trasformato in una sequenza di byte <em>spostabile</em> in un altro processo.</p>
<p>Anche qua in Rust abbiamo dei tratti vuoti: sono i cosiddetti <em><strong>tratti marker</strong></em>.
I tratti della concorrenza <code>Sync</code> e <code>Send</code> sono tratti marker. La maggior parte degli oggetti sono sia <code>Sync</code> e <code>Send</code>, alcuni sono esplicitamente non <code>Sync</code> oppure non <code>Send</code> oppure n√© <code>Sync</code> n√© <code>Send</code>.</p>
<p>Quindi i tratti sono delle cose che si possono <em><strong>avere in positivo o avere in negativo</strong></em>, cio√® indicare che non mi pu√≤ appartenere o non avere del tutto.
Quindi il tratto serve a descrivere dei comportamenti che un certo tipo implementa.
Il compilatore si serve di questo fatto per capire come trattare le cose: ad esempio, quando vede <code>x &gt; y</code> va a cercare il tipo di x, va a cercare il tipo di y e si chiede innanzitutto ‚ÄúS<em>ono dello stesso tipo? Se sono dello stesso tipo, quel tipo l√¨ implementa il tratto Ord o implementa almeno il tratto PartialOrd?</em>‚Äù.
Se non √® nessuno dei due allora si blocca, se invece sono tipi diversi allora da vedere: ‚Äú<em>ma il tipo di sinistra implementa Ord del tipo di destra?</em>‚Äù, cio√® posso confrontare pere con mele? In alcuni casi s√¨, in altri no, e quindi si serve di questa informazione.</p>
<p>Qualunque tipo che sia predefinito o che sia custom (cio√® creato da voi) pu√≤ implementare zero o pi√π tratti.</p>
<p><img src="images/il_linguaggio/image%204.png" alt="image.png" /></p>
<p>Mentre i tipi sono <em>disgiunti</em>, i tratti sono <em>legati tra di loro</em>.
Ad esempio qui vediamo che il tratto <code>Copy</code> implica il tratto <code>Clone</code> ‚Äî un dato come i32 gode del tratto <code>Copy</code> e di conseguenza deve anche godere del tratto <code>Clone</code>, se non fosse cos√¨ non compilerebbe.
Questi sono tipi predefiniti quindi non c‚Äô√® problema, ma la cosa ci riguarda quando noi vorremmo attribuire uno di questi tratti ai tipi che noi creiamo e dobbiamo prenderci la briga di farlo a modo. Notate che quella relazione non vuol dire ‚Äú<em>eredita da Clone</em>‚Äù vuol dire ‚Äú<em>implica Clone</em>‚Äù, quindi chi implementa <code>Copy</code> deve anche implementare <code>Clone</code>, esattamente come in Java quando un‚Äôinterfaccia estende un‚Äôaltra interfaccia, chi implementa l‚Äôinterfaccia pi√π di dettaglio ha la responsabilit√† di implementare i metodi espliciti dell‚Äôinterfaccia di dettaglio e tutti i metodi dell‚Äôinterfaccia da cui deriva, e qui lo stesso.</p>
<p>Il tratto <code>Drop</code> √® <em><strong>mutuamente esclusivo</strong></em> a <code>Copy</code>: chi ha <code>Drop</code> non pu√≤ aver <code>Copy</code> e viceversa. Infatti vedete che i tipi <code>String</code> e <code>Vec</code> hanno <code>Drop</code> ma non <code>Copy</code>, i32 ha <code>Copy</code> ma non <code>Drop</code>; <code>Display</code> lo possono avere in tanti e cos√¨ via..</p>
<p><img src="images/il_linguaggio/image%205.png" alt="image.png" /></p>
<p>Breve rassegna dei tipi.
Abbiamo gi√† citato la famiglia degli interi i8, i16, i32, i64, i128, pi√π isize, dove <em>size</em> √® la dimensione naturale del processore, quindi su un processore 64bit isize vale 64 bit, su un processore 32 bit isize vale 32.
La stessa cosa senza segno.
I numeri a virgola mobile f32, f64.
I valori logici bool.</p>
<p><strong>Attenzione ai caratteri!</strong>
In Rust non sono la stessa cosa del C. Un carattere in Rust √® un 32bit perch√© permette di rappresentare qualunque carattere unicode.</p>
<p>I caratteri a 8bit sono una grossa fregatura perch√© ci scrivete le 26 lettere dell‚Äôalfabeto inglese maiuscole e minuscole, i 10 numeri, un po‚Äô di parentesi, virgole, punti esclamativi etc.. e cos√¨ avete consumato i primi 128. Poi vi restano altri 128 byte che potreste usare per certe lettere accentate, ma se fate cos√¨ allora quando scrivete le lettere accentate dell‚Äôitaliano non ci mettete le lettere greche, se ci mettete le lettere greche non ci mettete i caratteri cirillici.. casino!
Per questo motivo Rust dice <em>‚ÄúNo! Il carattere √® un 32 bit!‚Äù</em> perch√© adotta la codifica unicode dentro cui sono codificati tutti gli alfabeti presenti, passati e in parte futuri.</p>
<p>Quindi il carattere singolo √® un 32 bit, ma questo non vuol dire che le stringhe contengono degli array di 32 bit, perch√© Rust internamente sceglie, per le stringhe, di adottare la codifica UTF-8 (<em><strong>Unicode Text Format a 8 bit</strong></em>) che dice ‚Äú<em>Se quello √® un carattere frequente, cio√® un ASCII, lo scrivo col carattere ASCII, che √® un byte. Se quello √® un carattere un po‚Äô meno frequente lo scrivo su due byte, se quello √® un carattere ancora meno frequente lo scrivo su tre byte, se quella √® una faccina lo scrivo su 4 byte</em>‚Äù e questo gli permette di compensare.</p>
<p>Piccolo problema: la <code>strlen()</code> implementata alla C non funziona pi√π perch√© sapere che una stringa contiene 32 byte non vi dice niente su quanti caratteri sono: possono essere 8 faccine,  32 lettere semplici o qualunque combinazione che ci sta in mezzo.
<strong>Per cui l‚Äôoggetto <code>String</code> ha il suo simpatico metodo <code>length</code> che vi dice quanto √® lungo, per√≤ se iterate sulla stringa dovete scegliere: o iterate sui byte o iterate sui caratteri</strong>.</p>
<p>Poi c‚Äô√® un tipo che si chiama <em><strong>unit</strong></em>, che si scrive si pronuncia unit ma si scrive <code>()</code> e rappresenta quello che in C e in Java si chiama <em><strong>void</strong></em>.
Serve per descrivere il comportamento di quelle funzioni che non ritornano un valore esplicito. Fisicamente rappresenta la tupla vuota, ovvero ci dice <em>‚Äúio ti restituisco un insieme di zero elementi‚Äù</em>, non consuma byte per√≤ quella √® la sua notazione, quindi una funzione che ritorna void in realt√† non ritorna niente ma viene segnata in questo modo.</p>
<h2 id="21-tuple"><a class="header" href="#21-tuple">2.1 Tuple</a></h2>
<p><img src="images/il_linguaggio/image%206.png" alt="image.png" /></p>
<p>Visto che parliamo di tuple introduciamo le tuple.
√à il modo pi√π semplice con cui noi possiamo definire un <strong>dato custom</strong> ‚Äî  in alcune situazioni potremo aver bisogno di rappresentare qualcosa che non si presta bene a essere un singolo valore (pensate ad esempio la posizione di un ristorante, quella cosa l√¨ probabilmente vi conviene scriverla sotto forma di latitudine e longitudine, due numeri diversi che per√≤ devono andare insieme perch√© se ne sapete solo uno dei due ve ne fate assai poco).
Per questo genere di cose si usano le tuple: un gruppo ordinato di valori che possono essere o meno omogenei.
Potrebbero anche essere due cose molto distinte: io potrei darvi un voto, che √® un Int, e poi darvi un flag che rappresenta se avete la lode o meno.</p>
<p><em>Quanti elementi pu√≤ avere una tupla?</em>
Da 0 (la tupla unit, non ne ha nessuno e non occupa byte), un solo valore (occupa la dimensione di quel valore l√¨), due valori (occupa la somma della dimensione del primo e del secondo), e cos√¨ via..</p>
<p>Se avete una variabile che contiene una tupla accedete ai singoli campi con la notazione <code>variabile.0</code> per il primo campo, <code>variabile.1</code> per il secondo campo etc.. cio√® accediamo in modo posizionale, ma non √® un array perch√© i singoli pezzi <strong>non sono omogenei</strong>.
Nella tupla io ho degli elementi che possono essere eterogenei e quindi nomino con questa notazione <code>variabile.posizione</code>, dove la posizione non mi garantisce automaticamente un offset standard come nel caso dell‚Äôarray, il compilatore sa che per la tupla di tipo <code>(Int, Boolean)</code> il campo 0 ha offset 0 e il campo 1 ha offset 4.</p>
<p>Le tuple, esattamente come qualunque altra cosa, possono essere immutabili o mutabili.
Le tuple sono comode in tante situazioni, soprattutto quando avete una funzione che ritorna pi√π valori e li potete facilmente mettere insieme.</p>
<h2 id="22-puntatori"><a class="header" href="#22-puntatori">2.2 Puntatori</a></h2>
<p><img src="images/il_linguaggio/image%207.png" alt="image.png" /></p>
<p>Poi potete avere a disposizione dei puntatori ‚Äî il mondo dei puntatori in Rust √® variegato, ce ne sono tanti.
Il tipo pi√π frequente e all‚Äôinizio pi√π acido da capire √® il <code>ref</code> .
Ad esempio ho la variabile <code>i</code> che contiene un i32, e voglio far avere il puntatore a questa variabile a qualcuno, quindi non voglio copiare quel 5, ma voglio fargli avere il puntatore in modo tale che quest‚Äôaltro possa vedere cosa c‚Äô√® adesso l√¨ dentro e se in futuro io lo cambier√≤, avendo il puntatore e guardando in futuro vedr√† il nuovo valore che c‚Äô√®.</p>
<h3 id="221-ref"><a class="header" href="#221-ref">2.2.1 Ref</a></h3>
<p>Come faccio? Faccio come farei in C: a quell‚Äôaltro gli d√≤ <code>&amp;i</code>, che si legge <em><strong>ref i</strong></em>, √® un riferimento ‚Äî concretamente √® semplicemente il puntatore, nient‚Äôaltro. Con un vincolo per√≤: quello l√¨ √® un riferimento <strong>in sola lettura</strong>.
Chi lo riceve non pu√≤ cambiarlo e farmi diventare <code>i</code> 6, perch√© √® un riferimento in sola lettura.</p>
<p>I riferimenti in sola lettura io <em>li posso dare a chi voglio e quanti ne voglio</em>, perch√© tanto tutti guardate ma non modificate.
Piccolo problema, o meglio grande opportunit√†: nel momento in cui io d√≤ un riferimento a qualcuno Rust dice ‚Äú<em>Caspita adesso siete in due a conoscere questa cosa, tu che hai la variabile e lui che comunque la pu√≤ vedere, ergo adesso nessuno la tocca. Fintanto che siete in due a conoscere questa cosa col cavolo che chiunque ci mette le mani: lui no di sicuro perch√© ce l‚Äôha in sola lettura, ma tu che ne saresti il possessore non la cambi perch√© siccome non sai che cosa sta facendo lui, se la cambiassi adesso lui potrebbe vedersela modificata sotto il naso</em>‚Äù, ad esempio ha appena preso una decisione chiedendosi se l√¨ dentro c‚Äô√® meno di 10, e al momento in cui ha guardato c‚Äôera meno di 10 ma tu subito dopo glielo cambi e quindi la decisione che prende √® sbagliata.</p>
<p><strong>Quindi mentre esiste in vita un riferimento il dato √® congelato.</strong></p>
<p><em>Quando riprender√≤ il pieno possesso del mio valore?</em>
Quando tutti i riferimenti saranno andati via dai piedi.</p>
<p><em>Come fa il compilatore a sapere quando saranno andati via dai piedi?</em>
Tracciando il tempo di vita. Non √® una cosa che scrive a runtime, se lo segna nelle sue strutture dati perch√© va a guardare quella roba l√¨ fino a che righe √® visibile etc.. si fa tutte i suoi ragionamenti e deduce quando i pezzi sono visibili e quando non sono visibili.
I riferimenti semplici sono danno <em><strong>l‚Äôaccesso a un‚Äôinformazione</strong></em>, se io ti passo un intero quasi conviene che ti passi la copia piuttosto che il riferimento, perch√© l‚Äôintero vale 4 byte e il riferimento ne vale 8, quindi sarebbe pi√π furbo. Ma se io avessi invece che un intero anche solo una tupla dentro cui ci sono 10 cose, beh passarti il riferimento √® conveniente perch√© ti do solo quello e poi sei in grado di andarci a vedere i vari pezzi, per√≤ mentre tu hai un riferimento io mi impegno questa cosa qua a non toccarla, cos√¨ non c‚Äô√® rischio.
Lo posso dare a tanti un riferimento di questo genere, il compilatore vigila e finch√© sa che ce n‚Äô√® ancora uno vivo il dato non si tocca; quando il compilatore ha l‚Äôevidenza che non c‚Äô√® pi√π nessun riferimento vivo l‚Äôoriginale riprende il pieno possesso delle sue cose e, se era stato dichiarato mutabile, pu√≤ essere mutato (se l‚Äôoriginale era stato creato non mutabile non pu√≤ essere mutato a prescindere).</p>
<p>Quindi di base sui riferimenti il compilatore verifica il <em><strong>possesso</strong></em> e il <em><strong>tempo di vita</strong></em>.
Lo divide in due modi il tempo di vita: non solo mentre esiste il riferimento l‚Äôoriginale non deve cambiare, ma devo garantire anche che l‚Äôoriginale viva pi√π a lungo del riferimento, perch√© altrimenti quel riferimento l√¨ mi diventa un <strong>dangling pointer</strong>.</p>
<h3 id="221-ref-mut"><a class="header" href="#221-ref-mut">2.2.1 Ref mut</a></h3>
<p>Posso anche creare i <em><strong>ref mut</strong></em>.</p>
<p><em>Come si fa un ref mut?</em>
Se la mia variabile era <code>i</code> (che deve essere mutabile perch√® se <code>i</code> √® immutabile non posso ricavare un ref mut perch√© a priori era immutabile quindi di l√¨ non ne ricavo niente che cambia) posso creare un refmut scrivendo <code>&amp;mut i</code> e passando questa cosa qui a chi di dovere.
A questo punto √® stato creato un <em>riferimento mutabile</em>, <em><strong>riferimento mutuamente esclusivo</strong></em>. Mentre esiste un riferimento mutabile, chi lo riceve pu√≤ non solo leggere cosa c‚Äô√® scritto dentro ma pu√≤ anche cambiarlo perch√© ha ottenuto il permesso temporaneo di cambiare le cose.</p>
<p>Mentre esiste un refmut, l‚Äôoriginale √® <strong>inaccessibile</strong> ‚Äî n√® lo leggo n√® lo scrivo, e di refmut <strong>ne pu√≤ esistere uno solo</strong>.</p>
<p>Questo garantisce al compilatore che non faccio casini: uno per volta, in questo √® mutuamente esclusivo.</p>
<p>I ref e refmut sono esempi di puntatori <em><strong>privi di possesso</strong></em>, li posso ricavare soltanto a partire da una variabile che gi√† esiste.
<strong>Quindi necessariamente chi li riceve non ha la responsabilit√† del rilascio.</strong>
La responsabilit√† del rilascio √® <strong>del possessore originale</strong>.</p>
<p>Quindi alle tante domande attraverso il meccanismo del tempo di vita il compilatore mi sa dire <em>‚Äúposso in questo momento accedere o meno?‚Äù</em> e fa le verifiche, e mi lascia compilare il codice solo se effettivamente posso e se non posso o al dubbio che potrei non essere in grado mi stoppa e mi blocca l√¨.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Dato che i <strong>ref</strong> e <strong>ref mut</strong> li posso solo costruire applicando l‚Äôoperatore <code>&amp;</code> o l‚Äôoperatore <code>&amp;mut</code> a una variabile esistente, sono certo che contengono un puntatore valido.</p>
<p>Al tempo stesso, poich√© sono riferimenti, cio√® puntatori privi di possesso, so per certo che non tocca a me rilasciarli, quindi chi si ritrova un ref o un refmut sa che ci pu√≤ accedere ma non √® compito suo occuparsi del rilascio, perch√© il rilascio √® del proprietario.</p>
<p><img src="images/il_linguaggio/image%208.png" alt="image.png" /></p>
<p><img src="images/il_linguaggio/image%209.png" alt="image.png" /></p>
</blockquote>
<p>Su un‚Äôarchitettura 64 bit i puntatori sono 64 bit, ma a volte 128 perch√© a differenza del C, dove i puntatori sono tutti uguali, qua <strong>in base a che cosa punto</strong> posso ottenere un puntatore semplice (uno <em><strong>slim pointer</strong></em>), o un <em><strong>fat pointer</strong></em>.
Se punto un dato la cui lunghezza non √® nota a tempo di compilazione, il compilatore lo fa diventare un fat pointer e ci mette insieme in una tupla (cio√® uno a fianco all‚Äôaltro) il <strong>puntatore</strong> e la <strong>lunghezza</strong>, in modo tale che il destinatario sappia regolarsi. Se quello √® un dato di tipo polimorfico il compilatore ci mette un fat pointer e mi dice ‚Äú<em>guarda il destinatario non sa esattamente questa roba qui che cosa sia, quindi io gli aggiungo una tabellina a lato che lo disambigua</em>‚Äù.</p>
<p>Quindi la dimensione dei puntatori effettiva minima √® quella dell‚Äôarchitettura, a volte √® il doppio dell‚Äôarchitettura, ma √® molto meglio cos√¨ perch√© lui in questo modo sa gestirsi e pu√≤ rispondere all‚Äôulteriore domanda che era nell‚Äôelenco ‚Äú<em>posso accedere solo all‚Äôindirizzo indicato o posso accedere anche pi√π avanti?</em>‚Äù ‚Äî per quei tipi la cui dimensione √® nota a priori non ho bisogno di aggiungere nient‚Äôaltro perch√© il compilatore si √® gi√† scritto quello l√¨ √® una roba da 7 byte, da 32, da 44 etc.. per i tipi invece la cui dimensione √® decisa a runtime necessariamente il compilatore mi include la lunghezza cos√¨ che chi la riceve possa regolarsi.</p>
<h3 id="223-box"><a class="header" href="#223-box">2.2.3 Box<T></a></h3>
<p>A volte ho dei puntatori che invece <strong>possiedono la memoria</strong>, quando prima con C++ abbiamo visto che facevamo <code>new Int</code>, fare <code>new Int</code> significa che ci facciamo dare sullo heap un blocco dentro cui ci scrivo il mio valore, e ne ottengo il puntatore (al blocco nello heap).</p>
<p>Perch√© faccio <code>new</code>?
Abbiamo spiegato che ci sono delle situazioni in cui ho bisogno di avere un valore che dura pi√π a lungo della chiamata della funzione in cui quel valore nasce.
Se io parto dalla variabile <code>i</code>, che √® locale (e vive dunque sullo stack), al massimo questa dura quanto l‚Äôinvocazione della funzione attuale, e quando la funzione torna <code>i</code> non c‚Äô√® pi√π e quindi non possono esistere pi√π riferimenti a quella cosa l√¨.
Se io ho bisogno di tenere in vita questa cosa pi√π a lungo allora non posso lavorare sullo stack, devo lavorare sullo heap.</p>
<p>Rust per queste situazioni mi mette a disposizione il tipo <code>Box</code>.
<code>Box&lt;T&gt;</code>, dove T √® un tipo, indica un puntatore a un dato che sta sullo heap che possiede il proprio dato.
Un box possiede il proprio valore.
Quando quel box li sparir√† il dato verr√† distrutto ‚Äî verr√† rilasciata la memoria.</p>
<p>Mentre i reference danno l‚Äôaccesso senza dare il possesso (e quindi io ho l‚Äôefficienza del puntatore perch√© vado dritto alla meta ma non ho nessuna responsabilit√† associata al suo rilascio), il box rappresenta un puntatore che sicuramente punta nello heap e che ha la responsabilit√† del rilascio: <strong>quando il box esce dalla sua visibilit√†, quel blocco svanisce,</strong> <strong>e svanisce automaticamente</strong>, non devo ricordarmi io di fare la delete come succede in C/C++!
Questo <strong>perch√© il box ha un distruttore</strong> ‚Äî box implementa il tratto <code>Drop</code>, e la sua implementazione del tratto <code>Drop</code> fa proprio questo: rilascia quel pezzo di memoria di cui √® padrone, per cui io sono tranquillissimo quando uso un box, so che quella memoria l√¨ la rilascio una e una sola volta senza fare nulla, automaticamente quando qualcosa svanisce.</p>
<h3 id="224-puntatori-nativi-c"><a class="header" href="#224-puntatori-nativi-c">2.2.4 Puntatori nativi C</a></h3>
<p>Ci sono poi, dentro Rust, anche gli stessi puntatori del C.
Ad esempio, <code>*const int</code> √® un <em><strong>puntatore nativo</strong></em>, un puntatore read only proprio come sarebbe un puntatore in C.
Ha tutti i problemi del C, quindi √® soggetto ad accessi illeciti, al fatto che quello pu√≤ contenere delle cose strambe etc..
C‚Äô√® anche il suo fratello, che √® la versione mutabile <code>*mut int</code> , questi per√≤ non li possiamo usare normalmente, l‚Äôunico modo per poterli utilizzare √® racchiuderli in un blocco <em><strong>unsafe</strong></em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
	// some unsafe things...
}
<span class="boring">}</span></code></pre></pre>
<p><em>Perch√© ci sono questi puntatori?</em>
Perch√® Rust si sforza di dire ‚Äú<em>guarda che io uso delle regole dove ti garantisco che dove ci metto le mani io non c‚Äô√® errore</em>‚Äù, in alcuni casi per√≤, per essere sicuro di non sbagliare, mi vieta delle cose che di per s√® sarebbero possibili. Semplicemente alla luce delle informazioni che lui ha non abbastanza evidenza, mentre alla luce di informazioni che abbiamo noi potremmo sapere altro ‚Äî ad esempio stiamo leggendo da una periferica hardware che sappiamo che √® costruita in modo tale che quando in un campo c‚Äô√® scritta una cosa in un altro non ce ne pu√≤ essere un‚Äôaltra, e questo il compilatore non pu√≤ capirlo, √® qualcosa di completamente esterno alla semantica, ma noi che stiamo scrivendo il driver di quella cosa li abbiamo letto il data sheet e sappiamo che √® fatto cos√¨. Allora il compilatore mi impedirebbe di prendere certe decisioni perch√© per quello che ne sa lui √® pericoloso ma noi sappiamo che in realt√† in quel caso particolare l√¨ si pu√≤ fare, e allora possiamo scrivere unsafe che dice ‚Äú<em>mi prendo io la responsabilit√†‚Äù.</em>
In realt√†, nel cuore di Rust alcuni suoi meccanismi sono unsafe, ma sono giusti proprio come anche nel C ‚Äî il fatto che il C abbia degli undefined behaviours e cose del genere non vuol dire che √® sbagliato, vuol dire che √® molto difficile costruirlo giusto, ma √® possibile scrivere programmi giusti, se no non saremmo mai arrivati fino ad adesso.</p>
<h1 id="3-riferimenti"><a class="header" href="#3-riferimenti">3. Riferimenti</a></h1>
<p><img src="images/il_linguaggio/image%2010.png" alt="image.png" /></p>
<p><code>let r1 = &amp;v;</code> dove v √® qualunque cosa, anche un‚Äôespressione ‚Äî <code>let r1 = &amp;75;</code> questo in C non √® scrivibile perch√© il valore immediato 75 in C non ha una locazione di memoria, in Rust si: quando lo scriviamo cos√¨ Rust scrive 75 dentro lo stack, come se avessimo creato una variabile temporanea, prende l‚Äôindirizzo di quella variabile e lo salva dentro <code>r1</code> e ci lascia fare delle cose.</p>
<p>Posso scrivere anche <code>let r1 = &amp;(i*5/4)</code> ‚Äî calcola il risultato, lo mette in un temporaneo sempre sullo stack, prende il puntatore e mi manda avanti.</p>
<p><code>r1</code> viene chiamato <em><strong>riferimento</strong></em> perch√© contiene dentro di s√© il puntatore al valore: √® un puntatore senza possesso, perch√© <em>lo prende in prestito</em> ‚Äî non √® suo, √® <code>v</code> che possiede quella cosa l√¨!</p>
<p>E il pezzo di compilatore responsabile del controllare cosa noi facciamo si chiama <em><strong>borrow checker</strong></em> ‚Äî il <em>controllore dei prestiti</em> verifica che tutti i prestiti siano onorati correttamente.</p>
<p><em>Come ci accedo al dato?</em>
Come farei in C ‚Äî se quello √® un puntatore ci metto un asterisco, quindi se <code>v</code> fosse stato un numero e io voglio sapere che numero √®, devo fare <code>*r1</code> e dentro ci leggo il numero.</p>
<p><strong>Attenzione:</strong> se invece di prendere il valore cos√¨ com‚Äô√®, quindi <code>*r1</code>, io volessi operare su <code>r1</code> e quindi su quel valore invocare un certo metodo ‚Äî abbiamo visto prima che gli interi hanno il metodo <code>to_string()</code> ‚Äî se <code>v</code> √® un intero e io voglio attraverso <code>r1</code> farmi dare la versione stringa, fossi in C dovrei scrivere <code>r1-&gt;to_string()</code> **perch√© asterisco e punto non si possono combinare, cio√® hanno un livello di aggregazione diverso, dovrei scrivere <code>(*r1).to*_*string()</code>.</p>
<p>In Rust, quando scrivo <em>punto qualcosa</em>, lui va automaticamente a vedere cosa c‚Äô√® prima del punto, e <strong>se quella cosa l√¨ √® un riferimento lui l‚Äôasterisco ce lo mette da solo</strong>.
Quindi se io ho bisogno di accedere al <code>to_string()</code> di quella cosa l√¨ scriverei <code>r1.to_string()</code> anche se <code>r1</code> √® un reference, solo perch√© in automatico tutto ci√≤ che √® preceduto da punto se √® un reference viene automaticamente dereferenziato, e se fosse un reference a un reference viene dereferenziato due volte etc.. quindi lui va avanti a dereferenziare finch√© ce n‚Äô√®.
Quando arriva al tipo base esegue il metodo, che √® molto comodo.
Il che vuol dire che l‚Äôasterisco lo usiamo in casi molto rari.</p>
<h2 id="31-esempi"><a class="header" href="#31-esempi">3.1 Esempi</a></h2>
<p><img src="images/il_linguaggio/image%2011.png" alt="image.png" /></p>
<p>Guardiamo il primo esempio: con <code>let r = &amp;i;</code> ho preso l‚Äôindirizzo di <code>i</code>.
Che c‚Äô√® in questo indirizzo?</p>
<p>Qui vediamo la notazione che la print line usa, adotta una notazione simile per certi aspetti alla printf del C, solo che mentre printf distingue %d, %s etc.. qua dice ‚Äú<em>tu dimmi soltanto, attraverso aperta graffa chiuse graffa, dove devo mettere i pezzi in ordine, in corrispondenza della prima coppia di graffa ci metter√≤ il primo valore, in corrispondenza della seconda copia di graffa ci metter√≤ il secondo valore e cos√¨ via</em>‚Äù.
Quindi print line prende una prima stringa che la stringa di formato come la printf seguita da tanti pezzettini quante sono le coppie di graffe che compaiono al suo interno che fanno da place holder.</p>
<p>Quindi stampiamo <code>*r</code> , cio√® il valore cui punta r: 32.
Questo se riuscissi a compilare, ma in realt√† alle righe dopo ci sono scritte ancora due cose: <code>i = i+1</code> , sto cambiando <code>i</code>, e dopo c‚Äô√® di nuovo print line di <code>*r</code>.
Qua c‚Äô√® un conflitto perch√© io sto tenendo in vita il mio riferimento, e durante la durata in vita di <code>r</code>, la parte attiva in cui lo sto usando per qualche motivo, c‚Äô√® un punto in cui il dato (cio√® <code>i</code>) sta cambiando!</p>
<p>√à un problema, perch√© fin tanto che esiste il riferimento l‚Äôoriginale deve stare fermo, se no prendo decisioni sbagliate e il compilatore mi blocca, e d√† questo errore qua: alla riga 8 hai preso in prestito i (<code>let r = &amp;i;</code>) ‚Äî <em><strong>borrow of i occurs here</strong></em>. Alla riga 11 <em><strong>assignment to borrowed i occurs here</strong></em> ‚Äî mi stai cambiando questa cosa qua.</p>
<p>Non sarebbe una tragedia se non ci fosse la riga 12, perch√© il compilatore √® <em>smart enough</em> da dire che dove finisce <code>r</code>, che di per se noi sappiamo che smetterebbe di esistere alla chiusa graffa, il compilatore dice ‚Äú<em>guarda che anche se fisicamente lui cessa di essere l√¨, io son tranquillo che per me il posto pi√π problematico √® l‚Äôultimo dove lo usi. Se non ci fosse la riga 12 andrebbe benissimo, <code>r</code> l‚Äôho usato un attimino, ci ho guardato dentro e poi non lo considero pi√π, come se non ci fosse. Ma se invece io cambio <code>i</code> e poi guardo ancora <code>r</code>  √® un casino perch√© vorrebbe dire che le due print line mi stamperebbero due cose diverse, che viola l‚Äôidea che quello √® un ref semplice, un ref immutabile, e quindi attenzione alla riga 11 mi hai assegnato <code>i</code> che √® in prestito, ma dopo mi vai ancora sul prestito e non va bene</em>‚Äù.</p>
<p>Nel secondo esempio sotto abbiamo la solita variabile mutabile <code>i = 32</code>, la prendiamo mutabile con <code>let r = &amp;mut i;</code>, mentre la prendiamo mutabile non possiamo accedere a <code>i</code>, e ci dice ‚Äú<em>attenzione alla riga 8 <strong>mutable borrows occurs here</strong>, ma alla riga 9 <strong>immutable borrow occurs here</strong></em>‚Äù ‚Äî per stampare <code>i</code> la devo prendere in prestito in realt√†, perch√© devo passare il puntatore alla print line e non va bene. In pi√π questo mutable borrow √® ancora valido perch√© alla riga 11 sto facendo <code>*r = *r+1;</code> se non ci fosse la riga 11 me lo farebbe anche fare, qui mi son preso un puntatore potenzialmente mutabile ma non lo uso quindi non √® un problema.</p>
<p><img src="images/il_linguaggio/image%2012.png" alt="image.png" /></p>
<p>Sebbene appaiano simili ai puntatori del C, sono tutta un‚Äôaltra cosa: i riferimenti implementano la logica <em><strong>multiple reader single writer</strong></em> ‚Äî posso avere quante copie ref voglio, una sola ref mut.</p>
<p>Fa comodo dire mutabile, ma in realt√† vuol dire mutuamente esclusivo perch√© mentre esiste quel mut non ce ne sono altri, di nessun genere!
E neanche la variabile originale √® toccabile, n√® la scrivo n√® la leggo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="il-linguaggio---malnati-6-7"><a class="header" href="#il-linguaggio---malnati-6-7">Il Linguaggio - Malnati 6-7 <!-- omit in toc --></a></h1>
<h1 id="indice-4"><a class="header" href="#indice-4">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#1-box">1. Box</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#11-esempio-box-1--insight-su-debug-e-display">1.1 Esempio Box 1 (+ insight su Debug e Display)</a></li>
<li><a href="05-il_linguaggio_parte_2.html#12-esempio-box-2--insight-sul-movimento">1.2 Esempio Box 2 (+ insight sul movimento)</a></li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#2-esempio-sul-movimento">2. Esempio sul movimento</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#21-differenza-indirizzo-stack-e-indirizzo-heap">2.1 Differenza indirizzo stack e indirizzo heap</a></li>
<li><a href="05-il_linguaggio_parte_2.html#22-distruttore">2.2 Distruttore</a></li>
<li><a href="05-il_linguaggio_parte_2.html#23-movimento">2.3 Movimento</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#231-il-tratto-copy">2.3.1 Il tratto copy</a></li>
<li><a href="05-il_linguaggio_parte_2.html#232-il-tratto-clone">2.3.2 Il tratto clone</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#3-array">3. Array</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#31-slice">3.1 Slice</a></li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#4-vec">4. Vec</a></li>
<li><a href="05-il_linguaggio_parte_2.html#5-stringhe">5. Stringhe</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#51-str">5.1 str</a></li>
<li><a href="05-il_linguaggio_parte_2.html#52-string">5.2 String</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#521-esempio">5.2.1 Esempio</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#6-istruzioni-ed-espressioni">6. Istruzioni ed espressioni</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#61-esempio-espressione">6.1 Esempio espressione</a></li>
<li><a href="05-il_linguaggio_parte_2.html#62-funzioni">6.2 Funzioni</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#621-esempi">6.2.1 Esempi</a></li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#63-cicli">6.3 Cicli</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#631-esempi">6.3.1 Esempi</a></li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#64-notazione-">6.4 Notazione <code>..</code></a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#641-esempi">6.4.1 Esempi</a></li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#65-match">6.5 Match</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#651-esempi">6.5.1 Esempi</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#7-riga-di-comando-e-argomenti">7. Riga di comando e argomenti</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#71-stdenvargs">7.1 std::env::args</a></li>
<li><a href="05-il_linguaggio_parte_2.html#72-clap">7.2 Clap</a>
<ul>
<li><a href="05-il_linguaggio_parte_2.html#721-esempio-clap">7.2.1 Esempio Clap</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="05-il_linguaggio_parte_2.html#8-io-da-console">8. I/O da Console</a></li>
<li><a href="05-il_linguaggio_parte_2.html#9-convenzione-sui-nomi">9. Convenzione sui nomi</a></li>
</ul>
<h1 id="1-box"><a class="header" href="#1-box">1. Box</a></h1>
<p><img src="images/il_linguaggio_2/image.png" alt="image.png" /></p>
<p>Abbiamo visto che Rust ci presenta puntatori di tipo diverso per gestire situazioni di tipo diverso.</p>
<p>In quelle situazioni in cui esiste una variabile che ha possesso di un dato, e quindi √® responsabile del suo rilascio, ma ha bisogno di far sapere a una funzione, a un altro oggetto, il valore attualmente contenuto senza copiarlo, pu√≤ passare un riferimento.
Il riferimento √® un prestito: io ti presto l'accesso a questa variabile.</p>
<p>I riferimenti possono essere semplici, quindi condivisi, e non permettono la modifica, oppure i riferimenti possono essere mutabili e mutuamente esclusivi.</p>
<p><strong>Finch√© esiste un riferimento di qualunque tipo, il dato non pu√≤ cambiare.</strong></p>
<p><strong>Se √® presente un riferimento mutabile, non pu√≤ essere presente nessun riferimento semplice e la variabile originale che possiede il valore non pu√≤ accedere al valore</strong>, perch√© mentre esiste un riferimento mutabile questo √® l'unico che pu√≤ accedere, ed eventualmente modificare.</p>
<p>I riferimenti sono puntatori che non hanno possesso. Vanno bene per ottimizzare: invece di muovere 200 byte ti muovo un puntatore.
Siccome io ho la semantica della condivisione o della condivisione mutabile, sono tranquillo: non possono succedere cose strane ‚Äî √® evidente qual √® lo scopo.</p>
<p>In altre situazioni invece noi abbiamo bisogno di manipolare dei dati di cui magari non conosciamo a priori la dimensione.
Potremmo aver bisogno di puntare un blocco da 10 byte, magari da 100, magari da 1000.
Lo sapremo solo a runtime.</p>
<p>Oppure abbiamo bisogno di prendere un dato la cui vita duri pi√π a lungo della funzione in cui quel dato nasce.
In queste situazioni non √® possibile usare una variabile locale semplice che include il valore.</p>
<p>Se il dato ha dimensione variabile non posso usare una variabile locale semplice perch√© i tipi hanno bisogno di avere una dimensione. Se quello non lo so non ce la faccio, mi serve un puntatore.</p>
<p>Ma anche se il dato ha una vita che dura pi√π a lungo devo fare in modo diverso, perch√© naturalmente la variabile, al termine del suo scope, della sua zona di visibilit√†, verrebbe buttata via e insieme a lei viene buttato via il valore che contiene.</p>
<p>Quindi in questo tipo di situazioni mi serve gestire un puntatore.
Un puntatore con una natura molto diversa da quello del reference, perch√© questo √® un puntatore <strong>che possiede il suo dato</strong>.</p>
<p>In Rust un puntatore che possiede il suo dato si chiama <strong>box</strong>.</p>
<p><img src="images/il_linguaggio_2/image%201.png" alt="image.png" /></p>
<p>Un box non √® nient'altro che un puntatore che punta sullo heap e che quando esce di visibilit√† rilascia quel blocco.</p>
<p>Creiamo i box semplicemente usando la sintassi <code>let b = Box::new(v);</code></p>
<p>Quello che succede √® che il valore che noi indichiamo viene preso, allocato dentro lo heap, quindi si cerca nello heap un blocco grande quanto serve per tenere quel valore, lo si mette dentro e nella variabile <code>b</code> ci arriva il puntatore a questo blocco.</p>
<p>Nel momento in cui abbiamo bisogno di andare a vedere cosa c'√® nella variabile <code>b</code> basta usare l'espressione <code>*b</code> che segue il puntatore e ci accede.</p>
<p>Se ci√≤ che c'√® nella variabile <code>b</code> √® un oggetto che ha dei metodi posso fare <code>(*b).qualcosa()</code> ma posso anche, come abbiamo visto prima, scrivere soltanto <code>b.qualcosa</code> perch√© la notazione <em>‚Äúpunto‚Äù</em> guarda automaticamente cosa c'√® prima di s√©, e quando vede che c'√® qualcosa che √® un puntatore prima di tutto lo dereferenzia.</p>
<p>Supponendo che la variabile <code>b</code> sia mutabile, se devo assegnare alla variabile <code>b</code> un qualche contenuto nuovo che finir√† nello heap in quella zona che ho preparato, scriver√≤ <code>*b = qualcosa;</code>.</p>
<p>La caratteristica di un box √® che possiede il blocco, di conseguenza il compilatore automaticamente nel momento in cui la variabile <code>b</code> giunge alla fine della propria vita e quindi sta per essere <em>ejected</em>, prima di buttarla via rilascia il blocco di memoria che la variabile <code>b</code> possiede, garantendoci quindi che non c'√® perdita.</p>
<p>Non dobbiamo essere noi a ricordare di fare la <code>delete</code> piuttosto che <code>free</code>.
Automaticamente nel momento in cui <code>b</code> esce <em>out of scope</em> quel blocco viene rilasciato.</p>
<p>Vediamo un esempio.</p>
<h2 id="11-esempio-box-1--insight-su-debug-e-display"><a class="header" href="#11-esempio-box-1--insight-su-debug-e-display">1.1 Esempio Box 1 (+ insight su Debug e Display)</a></h2>
<p><img src="images/il_linguaggio_2/image%202.png" alt="image.png" /></p>
<p>Qui abbiamo una funzione ipotetica nella quale io comincio ad allocare, giusto per far vedere che nello stack succede qualcosa, una variabile locale <code>let i = 4</code>.</p>
<p>La variabile <code>i</code> √® una variabile locale semplice, nel momento in cui io eseguo questa funzione lo stack cresce e all'interno viene prolungato di un 4 byte (in questo caso), e all'interno di quei 4 byte viene messo un normalissimo 4 che sta l√¨.</p>
<p><img src="images/il_linguaggio_2/image%203.png" alt="image.png" /></p>
<p>Alla riga successiva metto una tupla <code>(5, 2)</code> dentro un box.
Succede che innanzitutto nasce <code>b</code> e quindi lo stack si allunga un po' per contenere <code>b</code>, che di suo √® una variabile locale.</p>
<p>Quello che non √® locale √® il suo valore.</p>
<p><em>Cosa ci metto dentro</em> <code>b</code><em>?</em>
Automaticamente Rust va a cercare nello heap un blocco grande quanto gli serve per tenere la tupla, lo trova da qualche parte, inizializza la tupla nel modo opportuno, cio√® ci scrive 5 e 2 in questo caso, e il puntatore al primo byte di questo blocco viene salvato all'interno di <code>b</code>.</p>
<p>Di conseguenza <code>b</code> contiene il puntatore alla tupla.</p>
<p><img src="images/il_linguaggio_2/image%204.png" alt="image.png" /></p>
<p>Da qui in avanti io posso usarlo tranquillamente, ad esempio posso scrivere <code>(*b).1 = 7</code>, oppure <code>b.1 = 7</code> andrebbe bene ugualmente.</p>
<p>Seguo <code>b</code>, vado nel campo 1 e l√¨ ci scrivo 7. Quindi la tupla non √® pi√π 5 e 2, √® diventato 5 e 7.</p>
<p><img src="images/il_linguaggio_2/image%205.png" alt="image.png" /></p>
<p>Poi lo stampo.
Posso stampare <code>b</code> esplicitamente dereferenziandolo con l‚Äôasterisco (*b), oppure direttamente con <code>b</code>: non fa differenza in questo caso. Quando uso <code>println!("{:?}", ...)</code>, Rust cerca un‚Äôimplementazione del tratto <code>Debug</code> per il tipo in questione, e se necessario applica automaticamente la dereferenziazione per accedere al valore interno e formattarlo correttamente.</p>
<p>Vedete che <code>println!</code> qua, invece di usare come abbiamo visto le volte scorse <code>{ }</code> usa <code>{:?}</code>.
Questo perch√© in Rust ci sono due modi di stampare.</p>
<p>In Java mediamente se voi dovete stampare, sull'oggetto che stampate viene chiamato il metodo <code>to_string()</code> che ha il compito di trasformarlo in qualcosa di visibile.</p>
<p>In Rust ci sono due metodi diversi che corrispondono a due tratti che i tipi possono implementare.</p>
<p>Esiste il tratto <code>Display</code> che √® l'equivalente di <code>to_string()</code> diciamo di Java, serve a dare una rappresentazione utile all'utente finale di che cosa c'√® scritto l√¨ dentro.</p>
<p>E poi c'√® il tratto <code>Debug</code> che viceversa il pi√π delle volte in automatico deriva una rappresentazione che permette a un programmatore di capirci qualcosa ma non necessariamente a un utente finale.</p>
<p>Le tuple automaticamente implementano il tratto <code>Debug</code>.</p>
<p>Non ci devo fare niente perch√© una tuple dice ‚Äú<em>vabb√® io so che se per un programmatore che ha capito che cosa io significo io stampo direttamente come sono fatta</em>‚Äù.
A un utente finale sta cosa qua dice poco perch√© un utente finale ragiona in termini del significato di quell'informazione l√¨.
Se quello √® un punto sul piano √® una certa cosa, se √® il numero di genitori piuttosto che il numero di cugini piuttosto che il numero di nipoti √® tutta un'altra faccenda.</p>
<p>Chiaramente quando noi usiamo le strutture dati, a quelle strutture dati diamo un significato nel dominio del nostro problema.</p>
<p>Il tratto <code>Display</code> si occupa di fornire una rappresentazione comprensibile <em><strong>del dominio</strong></em> cio√® di cosa quell'informazione rappresenta nel dominio.
Non pu√≤ essere generato in automatico, bisogna farlo a mano perch√© il programma non ne pu√≤ avere la pi√π palli d'idea di che cosa siano quelle cose l√¨.</p>
<p>Mentre in automatico il pi√π delle volte (non sempre perch√© ci possono essere dei punti ambigui dove dobbiamo intervenire) il tratto <code>Debug</code> √® possibile generarlo in automatico.</p>
<p><em>Come si selezionano le due cose?</em>
Allora con <code>{ }</code> seleziona il tratto <code>Display</code> che √® implementato per default sui numeri.
Quindi quando stampiamo i numeri non fa nessuna differenza mettere <code>{:?}</code> o <code>{ }</code>, perch√© per Rust 7 √® 7 senza dirgli nulla di particolare.</p>
<p>Su tutto il resto invece c'√® distinzione, e quindi <code>{:?}</code>  dice <em>‚Äústampami la versione di debug‚Äù,</em> mentre <code>{ }</code> dice <em>‚Äústampami la versione di display‚Äù.</em></p>
<p>Ci sono altri modificatori: se nelle graffe scrivo <code>:p</code> quello che gli metto a fianco viene interpretato come puntatore, quindi mi fa vedere non cosa c'√® nella memoria, ma dov'√®! Ovviamente devo mettergli un puntatore, se non gli metto un puntatore e gli metto 7 il compilatore mi blocca.</p>
<p><img src="images/il_linguaggio_2/image%206.png" alt="image.png" /></p>
<p><img src="images/il_linguaggio_2/image%207.png" alt="image.png" /></p>
<p>Abbiamo stampato <code>b</code> in un paio di modi, viene sempre la stessa faccenda, e arriviamo al chiusa graffa.</p>
<p>Cosa succede quando arriviamo al chiusa graffa?
Lo stack si contrae e cosa c'era nello stack?
Nell'ordine c'era <code>b</code> che puntava qualcosa e poi c'era <code>i</code>.</p>
<p>Lo stack si contrae in un primo passo, sta per buttare via <code>b</code>, ma <code>b</code> √® un box!
Il box ha un distruttore che si occupa di rilasciare il blocco di memoria, e quindi in questo momento quello che succede √® che, per eliminare <code>b</code> quando lo stack si contrae, prima di tutto viene rilasciato il blocco.</p>
<p>Ma c'√® ancora <code>i</code>, lo stack si contrae anche per <code>i</code> che √® un i32 semplice ‚Äî non ha distruttori perch√© di suo non ha una semantica associata particolare.</p>
<p>Quindi arrivato al chiusa graffa la situazione che vedo sullo stack √® questa.</p>
<h2 id="12-esempio-box-2--insight-sul-movimento"><a class="header" href="#12-esempio-box-2--insight-sul-movimento">1.2 Esempio Box 2 (+ insight sul movimento)</a></h2>
<p><img src="images/il_linguaggio_2/image%208.png" alt="image.png" /></p>
<p>Vediamo qua un altro pezzo: qui ho una funzione main che chiama la funzione <code>makeBox</code>, la quale funzione ritorna un <code>Box</code>.</p>
<p>Questo serve per far vedere un dato che nasce in un punto ma che deve durare pi√π a lungo.</p>
<p>La funzione main chiama <code>makeBox</code>, la quale accetta un parametro e avr√† un valore di ritorno, quindi per poter chiamare la funzione <code>makeBox</code> nel main viene preparato sullo stack uno spazio nel quale possa essere depositato il valore che <code>makeBox</code> ritorner√†.</p>
<p><img src="images/il_linguaggio_2/image%209.png" alt="image.png" /></p>
<p>Dopo di che chiamo <code>makeBox</code>.
Viene chiamata con un parametro, 5, perfetto.
In realt√† il main, subito prima di chiamare <code>makeBox</code>, ha anche depositato 5 all'interno dello stack in modo tale da arrivarci e si accinge a fare la sua operazione.</p>
<p><img src="images/il_linguaggio_2/image%2010.png" alt="image.png" /></p>
<p>Entrando nella funzione, viene creata una variabile locale <code>r</code>.
Questa variabile locale dice ‚Äú<em>crea un nuovo box che contiene una tupla composta in questo caso dal parametro e 1</em>‚Äù.
Quindi al solito si va sullo heap, si cerca un blocco grande quanto serve, lo si inizializza e il puntatore viene salvato nella variabile <code>r</code>.</p>
<p>Fino a qua tutto tranquillo.
La riga successiva, che dice <code>return r</code>, ci farebbe dire ‚Äú<em>ok, prendi r e mettilo dentro b, ma siccome r √® arrivato al fondo distruggilo</em>‚Äù, e se distruggo <code>r</code> che cosa succede?
Succede che quel blocco dentro cui c'√® scritto <code>(5, 1)</code> viene rilasciato, ma <code>b</code> avrebbe gi√† una copia!
Problema!!!</p>
<p><img src="images/il_linguaggio_2/image%2011.png" alt="image.png" /></p>
<p>Ma qui emerge invece una delle caratteristiche fondamentali di Rust, che all'inizio mettono un po‚Äô di difficolt√† le persone: <strong>le assegnazioni, nella maggior parte dei casi, non copiano ‚Äî spostano!</strong></p>
<p><em>Cosa vuol dire che non copiano ma spostano?</em>
Quando scrivo <code>return r</code> di fatto <code>r</code> viene copiato nello spazio che √® stato preparato dal main in cui dovr√† stare, e di fatto i byte vengono ricopiati a destinazione, ma il compilatore dice ‚Äú<em>ah benissimo questo √® stato uno spostamento</em>‚Äù, cio√® <strong>il dovere di rilascio √® transitato dalla variabile <code>r</code> alla variabile destinazione</strong>, in questo caso <code>b</code>.</p>
<p><strong>Lo spostamento √® una copia</strong> (quindi io di fatto passo tutti i byte), <strong>ma perdo il diritto di accesso perch√© ho ceduto i miei byte a un altro.</strong>
E perdo il dovere del rilascio perch√© √® transitato a quell'altro.</p>
<p>Quindi adesso vedete che la riga da <code>r</code> √® tratteggiata, perch√© dentro <code>r</code> ci sono ancora scritti 3b7f5942 (quello che √®, l‚Äôindirizzo dell‚Äôheap in cui √® memorizzata la tupla), ma il compilatore sa che quel dato l√¨ non deve pi√π essere guardato ‚Äî non c'√® l√¨ la responsabilit√† del rilascio. La responsabilit√† del rilascio √® transitata sul destinatario, cio√® <code>b</code>.</p>
<blockquote>
<p>üí° <strong>Copia vs Movimento</strong></p>
<p>La <strong>copia</strong> √® una <strong>duplicazione</strong>: il nuovo valore √® indipendente dall‚Äôoriginale.
Tipi come gli interi (i32, u8, ecc.) vengono copiati quando vengono assegnati o passati a una funzione: si crea una nuova copia del dato, e l‚Äôoriginale resta valido.</p>
<p>Invece, per tipi come Box<T>, l‚Äôassegnazione comporta un <em><strong>movimento</strong></em> (move): il valore viene <em>spostato</em>, e l‚Äôoriginale non pu√≤ pi√π essere usato.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn main() {
   let x1 = 5;
   let x2 = x1; // Copy
   
   println!("x1: {}", x1);
   println!("x2: {}", x2);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">/* This doesn't compile */
fn main() {
   let b1 = Box::new(5);
   let b2 = b1; // Movement
   
   println!("b1: {}", b1);     // this should thrown an error
   println!("b2: {}", b2);
}</code></pre></pre>
<p>L‚Äôesempio a destra non funziona perch√®, dato che i dati posseduti da <code>b1</code> vengono <em>spostati</em> in <code>b2</code> (che ne diventa il nuovo proprietario), quando proviamo a stampare <code>b1</code> dopo il movimento, il compilatore ci blocca.
Ci suggerisce anche un modo per risolvere, qualora proprio volessimo tenere sia <code>b1</code> che <code>b2</code>: clonare <code>b1</code>.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn main() {
   let b1 = Box::new(5);
   let b2 = b1.clone();
   
   println!("b1: {}", b1);
   println!("b2: {}", b2);
}</code></pre></pre>
</blockquote>
<p><img src="images/il_linguaggio_2/image%2012.png" alt="image.png" /></p>
<p>Di conseguenza nel momento in cui contraggo lo stack va via <code>r</code> (variabile locale), vanno via i parametri etc.. quello che potrebbe esserci e torno al main.</p>
<p><img src="images/il_linguaggio_2/image%2013.png" alt="image.png" /></p>
<p>A questo punto √® <code>b</code> il vero proprietario di questo blocco, che sa assolutamente dove stava.
E quindi posso creare la variabile <code>c</code> come somma delle due parti.</p>
<p><img src="images/il_linguaggio_2/image%2014.png" alt="image.png" /></p>
<p>Dopodich√© arrivo al chiusa graffa del main.
Qui avevo sullo stack <code>c</code>, che √® un intero semplice e va via, avevo b, che √® un box e prima di andar via rilascia, motivo per cui quando termina questa cosa qua lascio pulito lo heap ‚Äî non ho perdite di memoria, tutto √® stato rilasciato una e una sola volta.</p>
<p>Il meccanismo del <em><strong>movimento</strong></em> √® challenging perch√© le persone inizialmente fan fatica a capirlo.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<blockquote>
</blockquote>
<p>Nota che qua non stiamo dicendo che il box √® mutabile: <code>r</code> non lo √®.
Ma avrei potuto dire in main <code>let mut b = makeBox(5);</code>, perch√© quando a <code>b</code> gli arriva, anche se il box √® stato costruito senza mutabilit√†, <strong>la variabile che viene ritornata √® proprietaria del box</strong> <strong>e chi √® proprietario pu√≤ in qualunque momento decidere che si d√† il diritto di mutare</strong>.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn makeBox(a: i32) -&gt; Box&lt;(i32, i32)&gt; {
   let r = Box::new( (a, 1) );
   return r;
}

fn main() {
   let mut b = makeBox(5);
   b.0 = b.0 + 1;
   
   println!("{:?}", b);
}</code></pre></pre>
</blockquote>
<p>Lo scegliere di non essere mutabili √® una scelta conservativa per evitare <em>misunderstandings</em>, ma non √® intrinseco nel valore, √® intrinseco nel possessore!
Nel momento in cui io cedo da un possessore a un altro, il possessore originale poteva aver scelto per quello che riguardava lui di non essere mutabile perch√© lui non aveva nessun bisogno di fare mutazioni, ma il nuovo possessore a cui viene ceduta la cosa pu√≤ decidere di farlo.</p>
<blockquote>
<p><em>Proprio come un padrone di casa che possiede un appartamento e decide che anche se brutto gli va bene cos√¨, poi un giorno lo vende e il nuovo padrone decide che butta via tutto e lo rif√†.
√à il nuovo padrone, quindi fa quello che vuole!</em></p>
</blockquote>
<h1 id="2-esempio-sul-movimento"><a class="header" href="#2-esempio-sul-movimento">2. Esempio sul movimento</a></h1>
<p><img src="images/il_linguaggio_2/image%2015.png" alt="image.png" /></p>
<p>Adesso introduciamo un pezzettino di sintassi i cui dettagli li vedremo in seguito, ma comunque li introduciamo gi√† adesso per far vedere che cosa succede dietro le quinte.</p>
<p>Prepariamo una struttura <code>S</code> all'interno della quale ci metto semplicemente un numero, quindi potr√≤ creare degli oggetti di tipo S(1), S(54), S(-2) etc.. semplicemente una struct cos√¨ √® di fatto equivalente a un <code>Int</code> ‚Äî √® semplicemente un <code>Int</code> con un nome.</p>
<p>A questa struct associo un paio di metodi che mi servono a far vedere che cosa succede.</p>
<p><img src="images/il_linguaggio_2/image%2016.png" alt="image.png" /></p>
<p>Per associare dei metodi si usa il costrutto <em><strong>impl</strong></em>.
Associamo il metodo <em><strong>display</strong></em>.</p>
<p>I metodi hanno un parametro che viene scritto nella loro definizione esplicitamente che dice ‚Äú<em>tu verrai chiamato su un oggetto di questo tipo (<strong>self</strong>), cio√® della classe S, e lo riceverai come riferimento non mutabile (in questo caso)</em>‚Äù.</p>
<p><img src="images/il_linguaggio_2/image%2017.png" alt="image.png" /></p>
<p>E qui possiamo fare print line e stampiamo una stringa che indica che si tratta di un oggetto S, che contiene un dato che si chiama <code>self.0</code> e che l‚Äôoggetto S vive ad un certo indirizzo, e l'indirizzo <code>self</code> √® tale indirizzo.</p>
<p>Questo metodo fondamentalmente serve per sapere cosa c'√® dentro S e dove sta S.</p>
<p>Facciamo una prova a chiamarlo nel main.</p>
<p><img src="images/il_linguaggio_2/image%2018.png" alt="image.png" /></p>
<p>Notate che il metodo <code>display()</code> prendeva il parametro <code>&amp;self</code> ‚Äî questo parametro lui ce l'ha, ma siccome √® <strong>self</strong>, √® scritto prima: <code>s.</code> √® il suo self.
In Java noi sappiamo che quando scriviamo <code>s.to_string()</code>, il metodo <code>to_string()</code> ha un <strong>this</strong> implicito ‚Äî in Rust, nell'implementazione del metodo, quello che negli altri linguaggi si chiama <em><strong>this</strong></em> si scrive esplicitamente <em><strong>self</strong></em>, perch√© noi lo possiamo passare in tanti modi.
In questo caso lo abbiamo passato non modificabile perch√© il metodo <code>display()</code> non ha bisogno di cambiare niente.</p>
<p>Lanciamolo:</p>
<p><img src="images/il_linguaggio_2/image%2019.png" alt="image.png" /></p>
<p>Quello √® un indirizzo sullo stack ‚Äî questa √® un variabile locale.</p>
<h2 id="21-differenza-indirizzo-stack-e-indirizzo-heap"><a class="header" href="#21-differenza-indirizzo-stack-e-indirizzo-heap">2.1 Differenza indirizzo stack e indirizzo heap</a></h2>
<p><img src="images/il_linguaggio_2/image%2020.png" alt="image.png" /></p>
<p><img src="images/il_linguaggio_2/image%2021.png" alt="image.png" /></p>
<p>Modifichiamo l‚Äôesempio, creando anche un Box e chiamando il metodo <code>display()</code> anche sul Box.
Lanciamo e vediamo che <code>s1</code> vive nello stack all'indirizzo indicato, mentre <code>s2</code> vive tutto da un'altra parte, sullo heap.</p>
<h2 id="22-distruttore"><a class="header" href="#22-distruttore">2.2 Distruttore</a></h2>
<p>Alla struct S aggiungiamo anche un <strong>distruttore</strong>, qualcosa che ci faccia vedere quando cessa di esistere.</p>
<p><img src="images/il_linguaggio_2/image%2022.png" alt="image.png" /></p>
<p>Per aggiungere un distruttore bisogna fare in questo modo.
Vediamo che in questo caso la funzione <code>drop()</code>, che √® predefinita dal linguaggio e che cos√¨ come in C++ il distruttore si scrive <code>~nome_classe</code>, qua il distruttore si scrive in questo modo e ha possibilit√† di manipolare quello che c'√® dentro ‚Äî riceve sempre l'oggetto che sta per essere distrutto come <strong>mutabile</strong>, e quindi sa di poter farci delle cose dentro.</p>
<p><img src="images/il_linguaggio_2/image%2023.png" alt="image.png" /></p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Notiamo inoltre che stiamo fornendo una implementazione del tratto <code>Drop</code> per il tipo S che abbiamo definito noi, prima invece avevamo solo definito un metodo che abbiamo chiamato ‚Äúdisplay‚Äù, che appartiene al tipo da noi definito.</p>
<p>Se avessimo voluto fornire l‚Äôimplementazione del tratto <code>Display</code>, per poter stampare il nostro tipo usando la macro <code>println!(‚Äù{}‚Äù, ‚Ä¶)</code> invece di fare <code>s1.display()</code>, avremmo dovuto fare cos√¨:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;
use std::fmt;

struct S(i32);
impl Display for S {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
       write!(f, "S value: {}, @{:p}", self.0, self)
   }
}
impl Drop for S {
   fn drop(&amp;mut self) {
       println!("Dropping.. S value: {}, @{:p}", self.0, self);
   }
}

fn main() {
   let s1 = S(5);
   
   println!("{}", s1); // Now this works!
}</code></pre></pre>
<p>Inoltre, in questo esempio, S √® una struct che contiene tipi elementari, dunque non vi √® allocazione di memoria sullo heap: le strutture di tipo S vivono quindi nello stack.
Dunque di fatto, non vi √® alcun ‚Äúrilascio della memoria‚Äù, abbiamo implementato <code>Drop</code> giusto per fare una stampa.</p>
<p>Per i tipi che invece allocano memoria sullo heap, <em>dopo</em> che viene eseguito il metodo <code>drop()</code> da noi implementato, il tratto <code>Drop</code> si occupa poi di rilasciare la memoria.</p>
<p><img src="images/il_linguaggio_2/image%2024.png" alt="image.png" /></p>
</blockquote>
<p>A noi in questo momento serve solo stamparlo.</p>
<p><img src="images/il_linguaggio_2/image%2025.png" alt="image.png" /></p>
<p>Vediamo che √® stato costruito S(1) sullo stack, √® stato costruito S(2) sullo heap, poi senza che noi abbiamo fatto niente altro se non rendere esplicita la distruzione (che avveniva comunque, solo che per default non stampava niente).</p>
<p>Vediamo che siccome abbiamo creato prima S(1) e poi S(2), nel contrarsi lo stack prima egetta S(2) e poi egetta S(1).</p>
<h2 id="23-movimento"><a class="header" href="#23-movimento">2.3 Movimento</a></h2>
<p>Ragioniamo meglio su questo movimento, questo passaggio per movimento.</p>
<p><img src="images/il_linguaggio_2/image%2026.png" alt="image.png" /></p>
<p>Momentaneamente ci dimentichiamo del Box e creiamo il nostro S(1), e verifichiamo dove sta, e poi diciamo <code>let s2 = s1;</code> ‚Äî lo copio..? No: lo muovo!</p>
<blockquote>
<p>üí° <strong>Drop vs Copy</strong>
Avendo implementato <strong><code>Drop</code></strong>, questo tipo <strong>non pu√≤ avere anche il tratto <code>Copy</code>.</strong>
Se non avessimo implementato il tratto <code>Drop</code>, essendo che questa struct contiene solo tipi elementari (un i32, nello specifico), allora avremmo potuto avere tranquillamente il tratto <code>Copy</code>.</p>
</blockquote>
<p><img src="images/il_linguaggio_2/image%2027.png" alt="image.png" /></p>
<p>Faccio <code>s2.display()</code>, e provo a fare anche <code>s1.display()</code> ma il compilatore mi blocca!</p>
<p>Ci dice <em>‚Äúsei partito da</em> <code>let s1 = S(1);</code><em>, poi hai chiamato display, bene, e poi me l'hai mosso dentro s2 ‚Äî <strong>value moved here</strong></em>‚Äù.</p>
<p>Dentro <code>s1</code> non c'√® pi√π niente, o meglio hai trasferito i byte dall'altra parte come qualunque copia, ma insieme hai trasferito diritti e doveri: non hai pi√π il diritto di andarci a guardare e non hai pi√π il dovere di distruggere.
<code>s2</code> ha acquisito il diritto di andarci a guardare e il dovere di distruggere.</p>
<p><img src="images/il_linguaggio_2/image%2028.png" alt="image.png" /></p>
<p>Infatti mi dice ‚Äú<em>l√¨ l'hai mosso, alla riga 16, e alla 18 hai fatto l‚Äôerrore: dopo aver detto che non era pi√π tuo ci vai ancora a guardar dentro ‚Äî <strong>value borrowed here after move</strong></em>‚Äù.</p>
<p><img src="images/il_linguaggio_2/image%2029.png" alt="image.png" /></p>
<p>Allora dobbiamo cancellare la riga 18 e a questo punto il programma diventa semplicemente: <code>s1 = S(1)</code>, che contiene un numero, ‚Üí lo stampo ‚Üí <code>let s2 = s1</code> (<strong>lo trasferisco</strong>) ‚Üí e poi <code>s2</code> lo posso guardare tranquillamente perch√© a questo punto <code>s2</code> ha guadagnato lui il diritto di accesso e quindi lo pu√≤ vedere, e il dovere di rilascio.</p>
<p><img src="images/il_linguaggio_2/image%2030.png" alt="image.png" /></p>
<p>Questa volta compila correttamente e qui vedo che <code>s1</code> l'avevo fatto, e l‚Äôho stampato: conteneva 1 e stava all'indirizzo che finisce con 84.
Nel momento in cui ho scritto <code>let s2 = s1;</code>, lui ha preso e quel valore l√¨ l'ha spostato!
Dentro <code>s2</code> c'√® ancora scritto 1, ma il suo indirizzo non √® pi√π 84: √® diventato 88, proprio perch√© l'ha spostato!</p>
<p>Adesso quando lo stack si contrarr√† per la parte di 84 non capiter√† niente, quando lo stack si contrae per 88 invece capita il drop.
L'informazione dropping ci viene stampata su 88, che √® l'indirizzo della seconda variabile, perch√© la seconda variabile nell'acquisire il valore ha acquisito i diritti e i doveri.</p>
<p><img src="images/il_linguaggio_2/image%2031.png" alt="image.png" /></p>
<p>La variabile <code>s2</code>, se ci servisse, la possiamo anche rendere mutabile.</p>
<p>Quindi nella maggior parte dei casi le assegnazioni sono in realt√† dei <em><strong>movimenti</strong></em>, cio√® io ti passo i byte e i diritti e i doveri.</p>
<h3 id="231-il-tratto-copy"><a class="header" href="#231-il-tratto-copy">2.3.1 Il tratto copy</a></h3>
<p>Ci sono piccole eccezioni: nel caso dei numeri, le assegnazioni sono semplici copie, perch√® questi godono del tratto <code>Copy</code>, che dice che √® lecito trasferire il valore senza trasferire i diritti e i doveri.
Il tratto <code>Copy</code> √® mutuamente esclusivo con il tratto <code>Drop</code> ‚Äî <code>Copy</code> va bene per quelle situazioni in cui non ci sono doveri associati: noi nell‚Äôesempio abbiamo implementato <code>Drop</code> giusto per fare una <code>println!</code>, ma Box implementa <code>Drop</code> per poter fare il rilascio, non pu√≤ farne a meno, altrimenti non rilascerebbe la memoria.</p>
<p>Nella maggior parte delle situazioni le assegnazioni sono dei movimenti, che vuol dire che copio i byte e trasferisco diritti e doveri.
Per quei tipi, come i numeri, che implementano il tratto <code>Copy</code> le cose sono pi√π semplici, cio√® io ho solo il trasferimento dei byte.</p>
<p>Ma ci sono dei vincoli: il tratto <code>Copy</code> lo possono avere solo alcuni.</p>
<h3 id="232-il-tratto-clone"><a class="header" href="#232-il-tratto-clone">2.3.2 Il tratto clone</a></h3>
<p><em>E allora non duplico mai le cose?</em>
C'√® un altro tratto interessante che si chiama <strong><code>Clone</code></strong>.
Il tratto clone √® un tratto pi√π impegnativo che dice ‚Äú<em>io voglio davvero duplicare questa cosa <strong>in profondit√†</strong></em>‚Äù ‚Äî in profondit√† vuol dire che non copio solo la superficie, ma vado avanti: se ad esempio clono il mio box di S, non √® che duplico il puntatore del box, ma alloco nell‚Äôheap un'altra cosa della stessa dimensione di ci√≤ a cui il box originale puntava, copio tutti i byte dalla sorgente alla destinazione e a quel punto l√¨ ho due puntatori distinti e vado bene.</p>
<p>Clone √® in generale un'operazione onerosa ‚Äî nella libreria standard del C c'√® una funzione che si chiama <em><strong>strdup</strong></em> che duplica una stringa.</p>
<p><em>Cosa fa strdup?</em>
Dice <em>‚Äúse tu parti da una stringa terminata da zero io mi conto quanti byte ha, poi gli aggiungo uno, poi alloco un blocco grande quanto √® venuto sto conteggio, poi copio tutti i byte originali nel loro blocco e poi ti restituisco il puntatore del blocco nuovo‚Äù</em> ‚Äî quello fa strdup, una copia in profondit√†.</p>
<p>Le copie in profondit√† sono onerose, possono essere estremamente onerose: dipende quanto √® grande il blocco da copiare.
Possono essere ricorsive, perch√© nel caso della stringa sono byte semplici, ma io posso avere delle cose che puntano a cose che puntano a cose etc..</p>
<p>Allora l'operatore <code>=</code> , quello che fa le assegnazioni, pu√≤ essere solo usato per il movimento (cio√® trasferisco dati, diritti e doveri), o la copia semplice (trasferisco dati l√† dove non ci sono particolari doveri associati).
Quando invece abbiamo bisogno di fare copia in profondit√† lo dobbiamo scrivere in modo esplicito: dobbiamo scrivere  <code>.clone()</code>, perch√© cos√¨ siamo obbligati a renderci conto che quella √® un'operazione potenzialmente onerosa.</p>
<p><img src="images/il_linguaggio_2/image%2032.png" alt="image.png" /></p>
<p>Prima abbiamo anche brevemente accennato che in realt√† Rust ammette anche i tipi elementari <code>*const T</code> e <code>*mut T</code> che corrispondono ai puntatori del C con tutti i limiti dei puntatori del C. Questi per√≤ possono solo essere usati all'interno di blocchi <strong>unsafe</strong>.</p>
<h1 id="3-array"><a class="header" href="#3-array">3. Array</a></h1>
<p><img src="images/il_linguaggio_2/image%2033.png" alt="image.png" /></p>
<p>Rust ci permette facilmente di gestire anche gli <strong>array</strong>.
Un array √® una sequenza contigua di n dati elementari di tipo T.
Gli array sono omogenei: tutti i loro elementi sono dello stesso tipo.
La lunghezza √® nota a priori.</p>
<p>Quando creo un array posso inizializzarlo direttamente, potrei scrivere <code>let a = [1, 2, 3, 4, 5];</code></p>
<p>Posso anche rendere esplicito il suo tipo con <code>let a: [i32, 5] = 1, 2, 3, 4, 5];</code> ‚Äî che vuol dire che ci sono 5 interi i32 consecutivi.</p>
<p>Posso anche scrivere <code>let b = [0; 5]</code>, che vuol dire ci sono cinque 0 consecutivi (siccome gli zeri il compilatore tende a leggerli come degli i32, a meno che non hanno un suffisso, lui mi fa un array che ha la stessa dimensione di quello sopra ma questa volta √® inizializzato con degli zeri).
Questa seconda notazione √® molto comoda perch√© se io devo allocare un array da un mega, posso scrivere <code>let buffer = [0; 1024*1024];</code> piuttosto che <code>let buffer = [0, 0, 0, ‚Ä¶];</code> fino a 1024.</p>
<p>Gli array hanno alcuni metodi built-in che ci vengono comodi: in particolare hanno il metodo <code>len()</code> che √® molto comodo e ci dice quanto √® lungo, perch√© a differenza del C dove gli array sono ridotti al puntatore al primo elemento (e quindi quando voi dichiarate un array di interi quello diventa di fatto un <code>int*</code> e il compilatore non sa pi√π quanto √® grande), qua invece gli array sono un tipo a tutti gli effetti e sanno quanto sono grandi e quindi in grado di dirti quanto √® lungo.</p>
<p><strong>Attenzione</strong>: la lunghezza di un array √® immutabile ‚Äî io ho creato questo array da 5 elementi, sar√† 5 elementi tutta la vita.
Dire che l'array √® mutabile significa che cambiano i valori che contiene, ma non la sua lunghezza.</p>
<h2 id="31-slice"><a class="header" href="#31-slice">3.1 Slice</a></h2>
<p><img src="images/il_linguaggio_2/image%2034.png" alt="image.png" /></p>
<p>Gli array hanno una dimensione fissa, ma a volte i nostri algoritmi nell‚Äôambito di un array grosso che √® gi√† stato allocato hanno bisogno di essere agili e muoversi per segmenti di questo array, quindi considerare delle parti.</p>
<p>Il C, e C++ come conseguenza, avevano elaborato l‚Äôidea <em><strong>dell‚Äôaritmetica dei puntatori</strong></em>: io alloco un array, l‚Äôarray automaticamente diventa il puntatore al primo elemento ma io poi posso fare ptr+1, ptr+7, ptr+54 etc.. per muovermi all‚Äôinterno di questa cosa.
Ma l‚Äôaritmetica dei puntatori √® tanto simpatica tanto quanto pericolosa, perch√© io posso sommare un miliardo e chiss√† dove vado a finire.</p>
<p>Io voglio passarti delle parti, e le voglio passare in modo efficiente, cio√® in realt√† non ti voglio ricopiare i byte.</p>
<p>Supponiamo di aver letto un grosso documento: stiamo facendo il syntax checker per vedere se ci sono parole strambe e una delle possibilit√† √® dire <em>‚Äúio ricopio le singole paroline che trovo e le mando alla funzione controllo_nel_dizionario‚Äù,</em> ma √® una cosa onerosissima perch√© i byte gi√† li ho letti una volta in memoria e poi devo prendermene tutte le volte dei segmenti, ricopiarli in un‚Äôaltra variabile e passarli.
Alla fine ho scandito l‚Äôintero documento ma l‚Äôho copiato praticamente tutto quanto, un po‚Äô per volta ma l‚Äôho copiato tutto.
L‚Äôidea dell‚Äôaritmetica dei puntatori dice <em>‚Äúguarda io ce l‚Äôho in memoria, parte qui e finisce l√¨, per√≤ ti do il puntatore. Vai a guardare la parola che comincia a questo punto, cos√¨ non devi ricopiare e te la leggi direttamente dalla fonte‚Äù.</em></p>
<p>In C++ l‚Äôidea √® stata estesa introducendo il concetto di <em><strong>iteratore</strong></em>, ******che fa proprio leva sulla sintassi dell‚Äôaritmetica dei puntatori: l‚Äôiteratore √® una cosa che <em>sembra un puntatore</em> ‚Äî lo dereferenziate con asterisco, gli fate la somma o la differenza come come fossero dei puntatori e serve a muoversi dentro le strutture dati di vario tipo.
Per√≤ √® soggetto a tutti i problemi dell‚Äôaritmetica dei puntatori.</p>
<p>Rust dice <em>‚Äúguarda io ti d√≤ la possibilit√† di identificare dei segmenti all‚Äôinterno di un array pi√π grande senza bisogno di dover copiare i dati presenti al loro interno ‚Äî ti d√≤ il tipo che si chiama <strong>slice</strong></em>‚Äù.</p>
<p>Una <strong>slice</strong> indica un segmento all‚Äôinterno di un array.
Una slice ha come notazione <code>&amp;[T]</code> dove T √® il tipo del singolo elemento dell‚Äôarray.
Possiamo avere una slice non mutabile oppure <code>&amp;mut[T]</code> √® una slice mutabile, ed √® quindi un riferimento a un blocco di <code>[T]</code>.
Notate che nel caso dell‚Äôarray il tipo √® <code>[T; n]</code>, dove n √® un numero, invece qui abbiamo <code>[T]</code> che vuol dire <em>‚Äúci sono dei T di fila‚Äù.</em>
Quanti? Boh, nel tipo non si sa, perch√© io solo a runtime capir√≤ se me ne servono 5, 12, 84 etc..</p>
<p><strong>Le slice in quanto reference possono solo essere ricavate da un dato che esiste, quindi se non ho un dato a priori (il mio array di partenza) non ho le slice</strong>.</p>
<p>Io posso prendere una slice all‚Äôintero array, posso prendere una slice di un pezzettino di quell‚Äôarray, o posso decidere che comincia prima o che comincia dopo e cose del genere.. la slice pu√≤ solo stare dentro l‚Äôarray: se io cerco di andare fuori se lui pu√≤ mi blocca gi√† a compile time, se non pu√≤ mi garantisce che a runtime mi bloccher√† (panicando).</p>
<p>Quando io dichiaro un array di tipo slice sto dicendo che quella variabile √® un <em><strong>fat pointer</strong></em>, perch√© contiene il puntatore al primo elemento della mia fettina e subito a fianco il numero di elementi che fanno parte della mia fetta. Questo permette di passare il riferimento ad altri che avranno modo di sapere che loro potranno partire da quel puntatore e al massimo accedere all‚Äôennesimo elemento e poi basta.
Se cercheranno di andare oltre succeder√† esattamente una condizione di panic dicendo <em>index out of bound</em>.</p>
<p>Io posso inizializzare una slice in modo esplicito con la scritta <code>let s1: **&amp;[i32]** = &amp;a;</code> ‚Äî se io non avessi messo l‚Äôannotazione <code>&amp;[i32]</code> lui avrebbe detto che s1 √® un ref al mio array, ma io in realt√† gli voglio dire che quello l√¨ √® un ref a un array di interi senza cablare nel tipo di s1 il numero. Il numero effettivo √® dentro il valore di s1 perch√© s1 contiene sia il puntatore al primo che quanti ne sono stati presi.</p>
<p><strong>s2</strong> ha lo stesso tipo di s1, in questo caso la prima parte del del fat pointer coincide con quella di s1 ma il secondo pezzettino del fat pointer invece di essere 4 contiene 2.</p>
<p><strong>s3</strong> ha lo stesso tipo di s1 e di s2 ma la prima parte del suo fat pointer non contiene l‚Äôinizio dell‚Äôarray ma l‚Äôinizio dell‚Äôarray spostato di due elementi (quindi punta al terzo elemento dell‚Äôarray), e nella seconda parte del fat pointer c‚Äô√® scritto 2 perch√© scrivendo da <code>[2..]</code> lui va a vedere ‚Äú<em>quanto era grande l‚Äôarray? Era 4, quindi da 2 a 4</em>‚Äù, e quindi ne prende 2.</p>
<p>Scritte cos√¨ sono tutte slice immutabili cio√® ci permettono di guardare quei numeri ma di non copiarle, se l‚Äôarray originale era mutabile possiamo estrarne una mutable slice.
<strong>Mentre esiste una mutable slice l‚Äôintero array √® inaccessibile!</strong>
Anche se io ne guardo solo un pezzettino, perch√© in realt√† lui non riesce a governarmi tutta la faccenda e dire ‚Äú<em>la coda non la scrivi, mentre l‚Äôinizio s√¨</em>‚Äù.
Quindi finch√© c‚Äô√® una mutable slice l‚Äôarray √® inaccessibile, come avere un ref mut all‚Äôarray nel suo intero.</p>
<p>Se ho una slice accedo ai suoi elementi esattamente come farei con un array e se vado fuori dal tutto mi genera un panic.</p>
<h1 id="4-vec"><a class="header" href="#4-vec">4. Vec<T></a></h1>
<p><img src="images/il_linguaggio_2/image%2035.png" alt="image.png" /></p>
<p>Gli array e le slice sono dei meccanismi abbastanza comodi, ma in realt√† non sempre cos√¨ versatili.
Il vero cavallo di battaglia dei programmi che andremo a scrivere, che alimenta la maggior parte dei meccanismi dove abbiamo bisogno dinamicamente di usare le cose, √® il <code>Vec</code>.</p>
<p><code>Vec</code> √® pi√π o meno quello che in Java si chiama <em><strong>arraylist</strong></em>, ovvero rappresenta un blocco di elementi omogenei allocato sullo heap ridimensionabile, cio√® che io posso far crescere, far diminuire e cos√¨ via, e quindi in cui posso memorizzare tutti gli elementi che mi servono.</p>
<p>Posso cercare quelli che mi interessano, posso ordinarlo (se gli elementi sono ordinabili, cio√® hanno un modo di essere confrontati come ‚Äúprima e dopo‚Äù), posso farci tante cose..</p>
<p>Il <code>Vec</code> √® un oggetto che gestisce in automatico la memoria che utilizza, e provvede a garantirne il rilascio corretto.
All‚Äôinterno di un <code>Vec</code> ci sono tre campi:</p>
<ul>
<li><strong>un puntatore ad un blocco sullo heap</strong> dove lui ha spazio per mettere le cose</li>
<li><strong>un intero senza segno che dice quel blocco l√¨ quanto √® grande</strong> complessivamente ‚Äî lui sa che sullo heap si √® preso 50 elementi di tipo T, qualunque cosa sia T.</li>
<li><strong>un intero senza segno che dice quanto, di quello spazio, stiamo effettivamente utilizzando</strong> ‚Äî  quanti di quei 50 sono gi√† usati: ovvero lui ha spazio per tenerne fino a 50 ma non ne ha necessariamente 50, perch√© ha riempito solo i primi tre e quindi ha ancora 47 caselle libere.
Quando arrivasse a riempire tutte le 50 caselle e io gli dico ‚Äúaggiungi‚Äù, lui dice ‚Äúaspetta‚Äù, va dal sistema operativo e dice ‚Äúmi dai un blocco da 100?‚Äù, e in quel blocco da 100 copia i suoi primi 50 e poi nella posizione 51 mette quello che volevamo aggiungere, dopodich√© il vecchio blocco da 50 lo rilascia.</li>
</ul>
<p>Quindi dinamicamente cresce. Vediamolo.</p>
<p><img src="images/il_linguaggio_2/image%2036.png" alt="image.png" /></p>
<p>Partiamo da un programma molto semplice: creiamo una variabile mutabile perch√© dovremmo metterci delle cose dentro (se fosse immutabile ce ne faremmo pochissimo).</p>
<p><code>let mut v = Vec::new();</code> ‚Äî questo √® il modo con cui costruiamo gli oggetti in Rust.
La parola <code>new</code> non √® una parola chiave del linguaggio, √® un metodo.
Convenzionalmente si chiama ‚Äúnew‚Äù, ma lo potremmo chiamare ‚Äúfrancesco‚Äù e andrebbe bene lo stesso.
Di solito i programmatori tendono a dare quel nome l√¨ ma vedremo che c‚Äô√® anche un altro modo di creare il nostro array ‚Äî potremmo crearlo <code>Vec::with_capacity(32)</code>: in quel caso l√¨ preallocheremmo gi√† un vettore che ha spazio per 32 elementi; questo va bene in quei casi in cui sappiamo gi√† immaginare con un buon grado di probabilit√† quanto spazio potrebbe servirci.</p>
<p>In questo caso gli stiamo dicendo <code>Vec::new()</code>, che vuol dire ‚Äú<em>guarda io non so neanche se ti metter√≤ mai qualche cosa</em>‚Äù, quindi Rust mi restituisce un oggetto che sta quindi sullo stack perch√© v √® una variabile locale che ha dentro di s√© tre campetti: il primo √® un <em><strong>puntatore</strong></em> che √® nullo, ma io non lo vedo tanto quel puntatore e non lo so che √® nullo, il secondo √® il campo <em><strong>size</strong></em> che ci dice quanti elementi hai in utilizzo sulla capienza totale (per ora nessuno), e l‚Äôaltro √® il campo <em><strong>capacity</strong></em>.</p>
<p><img src="images/il_linguaggio_2/image%2037.png" alt="image.png" /></p>
<p>Nel momento in cui io cerco di salvare dentro questo array un dato lo faccio col metodo <em><strong>push</strong></em>, che vuol dire ‚Äú<em>aggiungi al fondo, nella prima posizione libera, un dato</em>‚Äù.
Succede che lui dice ‚Äúaspetta io non ho spazio, allora momento: sistema operativo mi dai un blocchettino?‚Äù.
Grande quanto? Si prende quattro interi.
Si salva il puntatore, si segna dentro capacity che ne ha presi quattro, e nel primo ci mette il dato che abbiamo pushato, e quindi si segna che il size in questo momento √® 1.</p>
<p><img src="images/il_linguaggio_2/image%2038.png" alt="image.png" /></p>
<p>Subito dopo gli diciamo <code>v.push(4)</code> ‚Äî benissimo, abbiamo spazio libero? Si: size √® pi√π piccolo di capacity, dunque vado nell‚Äôarray che ho allocato nell‚Äôheap, vado all‚Äôindirizzo del size e ci metto 4.</p>
<p><img src="images/il_linguaggio_2/image%2039.png" alt="image.png" /></p>
<p>Poi posso prendermi un riferimento e in questo caso sto dicendo ‚Äú<em>mi dai valori che hai scritti dentro cos√¨ che io li possa anche eventualmente cambiare?</em>‚Äù.
Cosa succede? Viene creato uno slice agli elementi che contiene solo quelli che sono validi in questo momento.
Siccome √® un ref al vettore, di fatto il vettore fin tanto che esistesse √® inaccessibile, ha temporaneamente ceduto il suo valore.</p>
<p><img src="images/il_linguaggio_2/image%2040.png" alt="image.png" /></p>
<p><img src="images/il_linguaggio_2/image%2041.png" alt="image.png" /></p>
<p>Usando <code>s</code>, e dentro s vedete uno slice perch√© contiene il puntatore al primo elemento e la dimensione, posso andarci dentro e scrivere.</p>
<p><img src="images/il_linguaggio_2/image%2042.png" alt="image.png" /></p>
<p>Poi qui arrivo al fondo della mia funzione e cosa succede?
Si contrae lo stack una prima volta, si contrae buttando via s (buttare via s non ha effetti), perch√© s non ha possesso (√® un ref e quindi ha accesso ma non possesso), poi devo contrarre ancora, c‚Äô√® <code>v</code>.
Siccome s non esiste pi√π, v adesso √® di nuovo tornato in pieno possesso delle sue facolt√†, quindi ci posso posso invocare il metodo drop relativo.
Cosa fa il metodo drop di v? Fa un rilascio del blocco di memoria che aveva a disposizione e lo restituisce al sistema operativo, e poi se ne va.</p>
<h1 id="5-stringhe"><a class="header" href="#5-stringhe">5. Stringhe</a></h1>
<p><img src="images/il_linguaggio_2/image%2043.png" alt="image.png" /></p>
<p>Il mondo delle stringhe in Rust √® articolatissimo.
Le stringhe sono un oggetto estremamente utile nella programmazione perch√© spesso e volentieri abbiamo bisogno di trattare del testo comprensibile alle persone.</p>
<p>Le stringhe per√≤ sono anche una faccenda un po' complicata, perch√© ci sono tanti possibili caratteri.
Inizialmente le cose erano un po' approssimative, c'erano i caratteri ASCII, che vuol dire <em>American Standard Code for Information Interchange</em>. Pensato per gli americani. Gli americani hanno 26 lettere. Non hanno gli accenti.
E quindi l'hanno disegnato a propria misura.</p>
<p>L'ASCII da solo √® stato problematico: √® un codice a 7 bit.
I byte sono 8 bit. Quindi qualcuno ha subito detto <em>‚Äúvisto che ASCII definisce i primi 128 simboli, usiamo i simboli successivi per metterci altre lettere‚Äù.</em>
E sono nati una serie di alfabeti incompatibili. Per cui quelli dell'Europa centrale, che avevano lettere accentate e qualche simbolo un po' pi√π strano, tipo la Cedille in francese piuttosto che la doppia S in tedesco o cose del genere, hanno fatto l'alfabeto Latin 1.
Quelli dell'Europa orientale, che hanno simboli a volte un po' pi√π diversi, hanno fatto il Latin 2. Poi c'√® il greco, poi c'√® il cirillico. Tutti incompatibili perch√© gli stessi numeri da 128 a 255 vogliono dire cose diverse in alfabeti diversi.
Ne √® venuta fuori una babella ingestibile. Ma soprattutto, con quei simboli l√¨, il cinese non lo scrivevi, perch√© il cinese ha gli ideogrammi e gli ideogrammi sono tanti.</p>
<p>Quindi √® nato, guidato da Apple, tanti anni fa, un consorzio che si chiama Unicode.
Unicode ha cominciato a definire e standardizzare gli alfabeti in modo formale.
Ha assegnato a ciascun carattere un code point, cio√® un numero, che √® partito da quelli standard, quindi ha accettato che il code point della A maiuscola fosse 41 esadecimale, cio√® 65, e 97 quello della A minuscola, cio√® ha tenuto buono l'ASCII, perch√© non avrebbe avuto nessun senso fare diversamente, per√≤ √® andato avanti e ha cominciato a standardizzare tutto quello che veniva dopo.</p>
<p>Attualmente ci sono pi√π di due milioni di code point rappresentati, che contengono al loro interno tutti gli alfabeti scritti moderni, ma anche quelli antichi, per cui c'√® il siro babilonese, piuttosto che il fenicio o cose del genere, ma ci trovate sopra anche rappresentati le simbologie tecniche di vari tipi. Tutti i caratteri usati in matematica, l'integrale, la derivata, il segno di equivalenza, etc..</p>
<p>Lo Unicode, di base, avrebbe bisogno per rappresentare un code point, uno spazio tale da poter tenere almeno il numero due milioni.
Quindi ci vogliono sostanzialmente 24 bit.
24 √® un numero scomodissimo, e di conseguenza la scelta √® stata 32.
Quindi un carattere Unicode richiede 32 bit.</p>
<p>Dopodich√© Unicode ha definito delle rappresentazioni compatte per poter memorizzare questi dati.
Perch√© se mentre io elaboro il dato mi va bene avere un array di code point per farci dei ragionamenti, in realt√† quando memorizzo il dato questo mi porta uno spreco enorme, perch√© la maggior parte dei testi archiviati e cose del genere in realt√† sono poi scritti in ASCII.
E quindi io avrei quadruplicato il fabbisogno della memoria.
E quindi hanno scelto di avere delle rappresentazioni pi√π compatte che si chiamano UTF-8, 16 e 32.</p>
<p>UTF-32 √® banale. Un carattere √® 32 bit, quindi 4 byte, fine, non c‚Äô√® bisogno di conversione.
Nell‚ÄôUTF-8, viceversa, un carattere pu√≤ occupare un solo byte se il suo code point √® nel range degli ASCII.
Due byte se il suo code point √® tra 193 e 48 mila qualcosa.
Tre code point se √® tra 48 mila e 640 mila.
Quattro byte per arrivare fino al fondo.</p>
<p>Quindi √® una rappresentazione multi byte.
Nelle rappresentazioni multi byte c‚Äô√® sempre un‚Äôambiguit√†.
Se ho pi√π byte consecutivi scritti, come sono scritti questi byte? Big-endian o little-endian?</p>
<p>E allora i file UTF possono cominciare con un particolare marcatore che si chiama BOM, <em><strong>byte order marker</strong></em>, che vale <code>FFFE</code>, e che √® un simbolo impossibile altre volte, e permette, guardando, se io incontro nell‚Äôordine leggendo i byte prima <code>FF</code> e poi <code>FE</code>, vuol dire che quello l√¨ √® little-endian.
Se invece incontro <code>FE</code>, e poi <code>FF</code>, vuol dire che √® un‚Äôarchitettura big-endian e di conseguenza da l√¨ in avanti so cambiare le cose.</p>
<p>Quindi quando prendete Notepad e salvate un testo, guardate Save As, vi da le opzioni, potete salvarlo come file ASCII semplice oppure come UTF e se lo salvate come UTF vi dice ‚Äúwith BOM‚Äù o ‚Äúwithout BOM‚Äù.</p>
<p>Questo giusto per darvi un minimo di idee.</p>
<p>Rust decide che i caratteri li rappresenta come Code Point a 32 bit, ma le stringhe non le gestisce in quel modo l√¨, perch√© senn√≤ avrebbe bisogno di una montagna di memoria.
Quindi le stringhe le gestisce come UTF-8, senza BOM, perch√© tanto per un certo processore √® big-endian e quindi user√† la versione big-endian per tenersi le stringhe in pancia.
Quell‚Äôaltro sar√† little-endian e se li terr√† little-endian.</p>
<p>Fintanto che io i dati non li muovo da un processore o un altro, l‚Äôendianess non √® un problema.
Tengo quella di default della mia macchina che √® la pi√π efficiente possibile.</p>
<p>Detto questo, per√≤, la stringa √® una sequenza di byte.</p>
<p>Non tutte le sequenze di byte sono lecite in UTF, proprio perch√© UTF definisce questo meccanismo e le sequenze che richiedono due byte ricadono in certi range, ma ci sono delle sequenze impossibili.
Quindi non √® detto che se io ho un array di byte, quello √® interpretabile come array di carattere UTF-8.</p>
<p>Al contrario, se io ho un array di UTF-8, quello lo posso tranquillamente guardare anche come array di byte, semplicemente che certe combinazioni non le potr√≤ mai osservare.</p>
<p>Detto questo, c‚Äô√® il problema della <strong>mutabilit√†</strong>.
Io posso avere delle stringhe immutabili e posso avere delle stringhe mutabili perch√© mi interessa cambiare delle cose.</p>
<h2 id="51-str"><a class="header" href="#51-str">5.1 str</a></h2>
<p>Le stringhe immutabili sono di fatto degli <strong>slice di byte</strong>, con la restrizione che sono valide.
In realt√†, le stringhe immutabili sono rappresentate da un tipo primitivo che si chiama <code>str</code> e di fatto sono accedute sempre come <code>&amp;str</code>.</p>
<p>Quando io scrivo <code>let s = "ciao";</code>, <code>s</code> ha tipo <code>&amp;str</code>.
Questo perch√© "ciao", essendo una costante, viene scritto nella zona statica del programma, nell'area dei dati. Dentro <code>s</code> ci finisce uno slice, cio√® il puntatore al primo di questi byte, affiancato dal numero dei byte possibili: "ciao" ha quattro lettere, quindi c'√® <code>3B7F5924</code> e accanto c'√® scritto 4.
Notate che non c‚Äô√® il terminatore 0, perch√© la lunghezza √® espressa nello slice, quindi non ho bisogno di avere il terminatore. Queste sono le <code>&amp;str</code>.</p>
<p>Non tutte le slice sono statiche, cio√® allocate in questa parte di memoria.
Le stringhe che scrivete tra virgolette lo sono, ma potreste anche manipolare stringhe recuperate da altre fonti.
Le costanti stringa hanno durata illimitata perch√© sono integrate nell'eseguibile del programma - esistono dall'inizio alla fine e sono immutabili (il compilatore impedisce di modificarle). D'altra parte, i riferimenti stringa presi da un buffer hanno una durata limitata e pi√π breve.</p>
<h2 id="52-string"><a class="header" href="#52-string">5.2 String</a></h2>
<p>Spesso noi abbiamo bisogno di modificarle le stringhe, magari vogliamo trasformarle da minuscole a maiuscole, oppure vogliamo spezzarle, etc‚Ä¶</p>
<p>Allora Rust introduce il tipo <strong><code>String</code></strong>, con la S maiuscola.</p>
<p>Il tipo <code>String</code> √® di fatto molto simile al <code>Vec</code>, ovvero esattamente come il <code>Vec</code> contiene tre pezzettini:</p>
<ul>
<li>il primo √® un <strong>puntatore sullo heap</strong>, dove c‚Äô√® il buffer su cui opera</li>
<li>il secondo √® un numero che mi dice quanti di quegli <strong>elementi sono occupati</strong></li>
<li>il terzo √® la <strong>capacit√†</strong> che mi dice quel buffer l√¨ in generale quanto √® grande, in modo tale che nel momento in cui io lo riempissi tutto, ne vado a prendere un altro pi√π grande ancora</li>
</ul>
<p><code>&amp;str</code> e <code>String</code> sono parenti, ci sono moltissimi metodi gi√† definiti per <code>&amp;str</code>, quindi se io scrivo <code>‚Äúciao‚Äù.</code>, mi si apre un menu bello lungo di cose che posso fare su una costante stringa.</p>
<p>Sono tutte cose che non mutano la costante stringa, necessariamente.</p>
<p>Se io ho un oggetto <code>String</code> e ci metto <code>&amp;</code> davanti, lui diventa automaticamente, diventa automaticamente un <code>str</code>, quindi beneficia di tutto quello che <code>str</code> pu√≤ fare.</p>
<p>A questo si aggiungono le cose che pu√≤ fare solo una <code>String</code>. Adesso li vediamo.</p>
<h3 id="521-esempio"><a class="header" href="#521-esempio">5.2.1 Esempio</a></h3>
<p><img src="images/il_linguaggio_2/image%2044.png" alt="image.png" /></p>
<p><code>let hello: &amp;str = ‚Äúhello,‚Äù;</code> ‚Üí Cosa succede?</p>
<p>Il compilatore quando incontra questa cosa, oltre a generare il codice assembler di <code>let hello: &amp;str = ‚Äúhello,‚Äù;</code> e cosa via, da qualche parte nella mappa di memoria che prepara per il run time del programma (la zona disegnata in azzurrino in basso), si copia quei caratteri l√¨ e ci scrive ‚Äúhello,‚Äù.</p>
<p>Quando introduco la variabile <code>let hello</code>, questa variabile non fa nient‚Äôaltro che puntare allo slice.
√à uno slice, quindi contiene il puntatore, che finisce nella zona statica, e la dimensione.</p>
<p><img src="images/il_linguaggio_2/image%2045.png" alt="image.png" /></p>
<p>Poi vado avanti e dico <code>let mut s = String::new();</code></p>
<p>Quindi lo stack cresce e fa spazio per una String. Una String contiene 8 byte di puntatore (con l‚Äôarchitettura 64 bit), 8 byte di size, 8 byte di capacity.
Inizialmente il puntatore √® nullo, il size √® zero, la capacity √® zero.</p>
<p><img src="images/il_linguaggio_2/image%2046.png" alt="image.png" /></p>
<p>Siccome s √® mutabile, posso invocare i metodi che ne cambiano il contenuto: <code>s.push_str(hello);</code>.
Cio√®, voglio aggiungere al fondo della mia stringa questo slice.
Allora devo vedere se ho spazio per uno slice! Quanto e‚Äô grande sto slice? 6!
Ce li ho 6 byte liberi? No: la capacity √® 0, la size √® 0, la differenza fa 0, 0 e‚Äô pi√π piccolo di 6.
Quindi devo allungare la mia capacity.</p>
<p>Vado al sistema operativo e gli chiedo ‚Äú<em>mi dai un po‚Äô di byte? Ne ho bisogno di 6, ma dammene 8 che √® la prima potenza di 2 utile</em>‚Äù, e lui mi da 8 byte.</p>
<p>Aggiorno un attimo la stringa, adesso size e‚Äô ancora 0, capacity √® diventata 8. Ce li posso mettere i 6 che avevo? Si, posso, e quindi faccio questa operazione: porto il mio size a 6 e copio i singoli byte.
E quindi dentro s mi comincia a venire ‚Äúhello,‚Äù, e poi ho ancora due posti liberi.</p>
<p><img src="images/il_linguaggio_2/image%2047.png" alt="image.png" /></p>
<p>A questo punto faccio <code>s.push_str(‚Äù world‚Äù);</code>.</p>
<p>Quanto e‚Äô grande ‚Äú world!‚Äù? 7 byte!
Ce li ho 7 byte liberi? No, <code>capacity</code> meno <code>size</code> fa 2.</p>
<p><em>A quanto dovrei andare?</em>
Io sono 8, ne ho due liberi, me ne servono altri 5, dovrei andare a 13.
13 e‚Äô un numero strambo: <em>‚ÄúSistema operativo, dammene direttamente 16‚Äù.</em></p>
<p>Dunque da qualche parte nello heap c‚Äôera scritto ‚Äúhello,‚Äù, poi abbiamo preso un altro blocco grosso il doppio dentro cui lui ha temporaneamente ricopiato ‚Äúhello,‚Äù, e poi ci ha appiccicato ‚Äú world!‚Äù, dopo di che il blocco originale dove c‚Äôera solo ‚Äúhello,‚Äù l‚Äôha buttato via, e quando tutta l‚Äôoperazione finisce, la stringa punta a un nuovo indirizzo, dentro di s√® il puntatore √® da qualche altra parte dentro cui c‚Äô√® scritto ‚Äúhello, world!‚Äù.</p>
<p>Questo succede, quindi la stringa contiene dei dati che possono crescere.</p>
<p><img src="images/il_linguaggio_2/image%2048.png" alt="image.png" /></p>
<p>Quando arrivo al chiusa graffa lo stack si contrae.</p>
<p>Cosa c‚Äôera sullo stack?
Due cose: c‚Äôera <code>s</code> che possiede un buffer e che quindi quando viene eliminata ha un drop da fare. Cosa fa il suo metodo <code>drop()</code>? Rilascia, e quindi tutto quel buffer l√¨ esce.</p>
<p>Poi c‚Äôera <code>hello</code>, che era uno slice; lo slice non ha possesso, quindi va via senza fare nulla.
Lo spazio statico rimane scritto cos√¨, ma tanto quello era stampato nella pietra, non ci poteva fare nulla.</p>
<p>E quindi quando questo finisce, lo stack √® pulito, lo heap √® pulito, e nello spazio statico continua a starci scritto quello che c‚Äôera scritto fin dall‚Äôinizio.</p>
<p><img src="images/il_linguaggio_2/image%2049.png" alt="image.png" /></p>
<p>Come manipolo le stringhe?
Posso creare le stringhe in tanti modi, ne vediamo alcuni.</p>
<p><code>let s0 = String::new();</code>
Questo crea una stringa vuota. Se avr√≤ bisogno ci metter√≤ dentro delle cose e internamente si rialloca proprio come un Vec che va a prendersi la memoria quando ne ha bisogno.</p>
<p>Oppure, se so gi√† che voglio che contenga qualche contenuto, posso fare <code>let s1 = String::from("some text‚Äù);</code>.
In questo caso mi crea una stringa inizializzata con il valore che gli ho messo.</p>
<p>Posso anche fare al contrario <code>let s2 = "some text".to_string();</code>.
Il metodo <code>to_string()</code> va a tradurre quello slice di byte in una stringa corrispondente.</p>
<p>Se ho una <code>String</code> e voglio averne una versione congelata, quindi solo leggibile ma non modificabile, la posso ricavare con <code>s2.as_str()</code>.
Questo mi ritorna un <code>&amp;str</code> semplice. Notate che non esiste il <code>&amp;mut str</code>. Il linguaggio non ce l‚Äôha. La stringa mutabile √® <code>String</code> e l‚Äôaltro √® <code>&amp;str</code> e basta.</p>
<p>Se ho una <code>String</code> che ho dichiarato mutabile, posso farci delle cose.
Ad esempio posso <code>push_str(‚Äù‚Ä¶‚Äù)</code>, aggiungere al fondo, concateno.</p>
<p>Oppure <code>insert_str(‚Äù‚Ä¶‚Äù)</code>.
<code>insert_str()</code> dice <em>‚Äúmetti non al fondo ma nella particolare posizione che ti indico‚Äù.</em> In questo caso ‚Äú0‚Äù: questo vuol dire che tutto quello che c‚Äôera scritto l‚Äôho sposto pi√π avanti e davanti ci inietto questo pezzo qua.</p>
<p>Oppure posso eliminare un carattere <code>remove(4)</code>. Tolgo il quarto carattere.
Dove sta il quarto carattere?
Potrebbe stare nel quarto byte, o potrebbe stare nel quinto byte se uno dei caratteri precedenti era lungo due, oppure potrebbe stare nel sesto byte se due dei caratteri precedenti erano lunghi due o uno era lungo tre. Potrebbe stare nel dodicesimo byte se quelli che precedevano erano lunghi quattro.
Quindi quando io dico <code>remove(4)</code> gli sto dicendo <em>‚Äútoglimi il quarto carattere‚Äù</em> e la stringa si occupa di capire qual era effettivamente il quarto carattere.</p>
<p>Posso anche pulirla tutta la stringa, <code>clear()</code>.</p>
<p>Alcuni metodi come questi <strong>cambiano</strong> la stringa, altri metodi partono da una stringa e <strong>ne generano una nuova</strong>.
Ad esempio il metodo <code>to_uppercase()</code> o  <code>to_lowercase()</code> partono da una stringa e ne generano una completamente nuova.</p>
<p>Perch√©?
Perch√© la faccenda dell‚Äôuppercase e lowercase √® complicata.
Innanzitutto perch√© non tutte le lingue hanno il concetto di uppercase e lowercase ‚Äî in cinese l‚Äôideogramma maiuscolo non c‚Äô√®.
Poi perch√© in alcune lingue vengono fuori degli obbrobri ‚Äî in tedesco esiste il carattere che sembra una beta che rappresenta la doppia S minuscola. Peccato che la sua versione maiuscola si scrive con due S, per cui la lunghezza √® differente. E cos√¨ via.</p>
<p>Il metodo <code>replace()</code> crea una nuova stringa che contiene i caratteri della precedente tranne alcuni che sono stati sostituiti con qualcos‚Äôaltro.</p>
<p>Il metodo <code>trim()</code> crea una nuova stringa che contiene i caratteri della precedente tranne gli spazi iniziali e finali.</p>
<p>E tanti altri. Poi se vi mettete l√¨ e guardate un attimo la documentazione imparate un po‚Äô di cose utili..</p>
<p><img src="images/il_linguaggio_2/image%2050.png" alt="image.png" /></p>
<p>Ma di stringhe non ce ne sono solo due (<code>&amp;str</code> e <code>String</code>).
Rust ce ne d√† un bel po‚Äô, specializzate per fare cose diverse.
Al contrario C vi d√† <code>char*</code>, e siate contenti.</p>
<p>Vediamo, citiamone alcune.
<code>&amp;str</code> e <code>String</code>, le abbiamo gi√† viste. Di fatto <code>&amp;str</code> √® uno slice di byte.
Da un certo punto di vista, lo posso considerare simile a uno slice di byte di tipo <code>&amp;[u8]</code>.</p>
<p>Sono la stessa cosa? <em>Ni</em>: <code>&amp;str</code> √® effettivamente uno slice di byte, nel senso che √® fatto di un <strong>puntatore a una sequenza</strong> e di <strong>un numero che mi dice quanti byte √® lunga</strong> quella sequenza.</p>
<p>Rispetto a un <code>&amp;[u8]</code> la differenza √® che non tutte le combinazioni di byte in un <code>&amp;str</code> sono lecite, invece in un <code>&amp;[u8]</code>, in uno slice di byte, lo sono.
Per√≤, a volte ci viene comodo cos√¨, perch√© noi riceviamo, ad esempio, un pacchetto di rete che di per s√© contiene uno slice di byte, potenzialmente quindi qualunque combinazione di numeri uno dopo l‚Äôaltro, ma sappiamo che quel pacchetto l√¨ contiene, che ne so, il metodo GET.
E vogliamo trasformarlo in stringa, per poterlo manipolare come stringa.
E quindi ci sono metodi che il tipo <code>String</code> offre per passare da un slice di byte a un oggetto str, restituendo un errore se quella sequenza di byte √® illecita.</p>
<p>O al contrario, ci sono metodi che <code>&amp;str</code> offre per ricavare lo slice di byte corrispondente.
Questo non d√† mai errore, perch√© passo da un sotto insieme, vado verso un insieme pi√π grande, e quindi sono tranquillo.</p>
<p>Pu√≤ essere uno slice, pu√≤ essere un riferimento a un vettore: <code>&amp;[u8; N]</code>, vado a finire in un caso particolare, dove ho esattamente N byte.
L‚Äôoggetto String, per lo stesso motivo, di fatto √® equivalente a un Vec di byte.
Nel senso che se io guardo com‚Äô√® fatto, √® fatto proprio come un Vec di byte.
Qual √® la differenza? √à che nel Vec di byte posso metterci <code>.push(7)</code>, <code>.push(54)</code>, <code>.push(89)</code>.
Nella stringa non necessariamente questa sequenza √® lecita, perch√© potrebbe rappresentare un carattere illecito.</p>
<p>Il singolo <code>&amp;u8</code>, puntatore riferimento a un singolo byte, pu√≤ essere visto come una stringa di carattere di dimensione 1, sotto certe condizioni.</p>
<p>Poi abbiamo le <code>OsStr</code> e le <code>OsString</code>.
Sono le stringhe mutabili (le <code>OsString</code>) e non mutabili (le <code>OsStr</code>) come piacciono al sistema operativo.
Unix, internamente, tratta i caratteri come utf-8, e quindi va tutto bene, non devo fare nessuna modifica.
Windows, i caratteri li tratta come utf-16. Se devo chiamare la system call <code>create_file()</code>, che √® quella che Windows mi mette a disposizione per creare un file, il nome del file non glielo posso passare come utf-8, perch√© si spaccherebbe, Windows lo vuole utf-16.
E quindi se il file si chiama <code>f</code>, quella cosa l√¨ sono due byte, il primo dei quali √® il decimale <code>4f</code>, il codice della ‚Äúf‚Äù, e il secondo √® <code>0</code>.</p>
<p>Per lo stesso motivo i path esistono nella duplice versione: <code>Path</code>e <code>PathBuf</code>.
Il <code>Path</code> √® un path immutabile, che differenza c‚Äô√®?
Mentre un <code>OsStr</code> comprende semplicemente che √® una stringa, senza sapere che fa riferimento al file system, e quindi √® divisibile in segmenti come gli slash, un <code>Path</code> √® una stringa del sistema operativo che √® segmentabile con gli slash. Quali slash? Dipende: in Unix con lo slash dritto, e in Windows con lo slash al contrario.</p>
<p>Poi ci sono le <code>CString</code>.
Se io devo chiamare una funzione del C, il C vuole lo 0 come terminatore, altrimenti non va bene, ma Rust 0 non ce l‚Äôha, perch√© si tiene la lunghezza, che √® molto pi√π sicuro.
Per√≤ se io devo poter chiamare una funzione unsafe scritta in C, devo tradurre la mia stringa in una stringa del C. <code>CStr</code> √® una stringa immutabile, semplicemente un buffer pi√π lungo di 1, che contiene anche lo 0 finale, e <code>CString</code> √® un buffer mutabile che contiene lo 0 finale.</p>
<p>Tra tutte le <code>&amp;str</code>, ce n‚Äô√® un sottogruppo che √® l‚Äôinsieme delle <strong>costanti</strong>, cio√® quelle che avete scritto voi tra doppi apici.
Queste, oltre a essere degli <code>&amp;str</code>, hanno una caratteristica: hanno un tempo di vita che coincide con l‚Äôintero processo.
E quindi il loro vero nome √®, <code>&amp;‚Äôstatic str</code>.
Perch√©? Perch√© l√¨ il compilatore sa che quel particolare tipo di stringhe esistono da sempre e per sempre.
Tutti gli altri ref, invece, sono soggetti al tempo di vita del buffer da cui nascono, e quindi esistono da un certo punto, e solo finch√© il buffer corrispondente non si toglie dai piedi.</p>
<h1 id="6-istruzioni-ed-espressioni"><a class="header" href="#6-istruzioni-ed-espressioni">6. Istruzioni ed espressioni</a></h1>
<p><img src="images/il_linguaggio_2/image%2051.png" alt="image.png" /></p>
<p>In termini di istruzioni che abbiamo a disposizione, sono istruzioni, cio√® non danno nessun risultato.
Se io scrivo <code>let i = 0</code>, non posso fare come invece farei in C. In C posso dire <code>int i = j = k = 0</code>, perch√© l‚Äôassegnazione ha come risultato il valore assegnato, che quindi pu√≤ essere propagato.</p>
<p>Le istruzioni tipo <code>let</code> e <code>let mut</code>, viceversa, non restituiscono nessun valore.</p>
<p>Invece, quello che scriviamo tra graffe √® un‚Äôespressione.
Qual √® il valore ritornato da un blocco di graffe? √à l‚Äôultimo elemento presente nel blocco, a condizione che non abbia il <code>;</code>.</p>
<p><code>If else</code> √® un‚Äôespressione, <code>loop</code> √® un‚Äôespressione.</p>
<h2 id="61-esempio-espressione"><a class="header" href="#61-esempio-espressione">6.1 Esempio espressione</a></h2>
<p><img src="images/il_linguaggio_2/image%2052.png" alt="image.png" /></p>
<p><img src="images/il_linguaggio_2/image%2053.png" alt="image.png" /></p>
<p>E infatti se vado a vedere cosa mi ha stampato, mi ha stampato <code>fsf</code> perch√© √® entrato nel blocco, ha fatto le cose che c‚Äôerano scritte l√¨, e poi l‚Äôultimo pezzo, poich√© non aveva un <code>;</code>, √® finita dentro <code>i</code>.
Infatti <code>i</code> me lo dice che √® un <code>i32</code>.</p>
<p><img src="images/il_linguaggio_2/image%2054.png" alt="image.png" /></p>
<p>Se io 43 avessi messo <code>43;</code>, mi dice che <code>i</code> diventa <code>void</code>, di fatto la tupla unitaria.</p>
<p><img src="images/il_linguaggio_2/image%2055.png" alt="image.png" /></p>
<p>Posso anche dire <em>‚Äúif 3 maggiore di 2, i vale 43, else vale 54‚Äù</em>.</p>
<p><em><strong>Quindi il blocco restituisce un valore, l‚Äôif restituisce un valore, il while restituisce un valore.</strong></em></p>
<h2 id="62-funzioni"><a class="header" href="#62-funzioni">6.2 Funzioni</a></h2>
<p><img src="images/il_linguaggio_2/image%2056.png" alt="image.png" /></p>
<p>Le funzioni si scrivono <code>fn nome_funzione(param1, param 2, ...) -&gt; valore_ritorno</code></p>
<p>Se la funzione non ritorna niente, la freccia valore di ritorno si pu√≤ omettere ‚Äî il valore di ritorno sarebbe <code>()</code>, la tupla unitaria.</p>
<p><code>add_numbers</code> √® una funzione che ritorna un i32, notate che non c‚Äô√® il <code>;</code> finale, perch√©?
La funzione prende come valore il blocco corrispondente, questo blocco restituisce l‚Äôultimo elemento se non ha il <code>;</code>, questo non ce l‚Äôha e quindi questa funzione qui ritorna <code>x+y</code>, senza bisogno di scrivere la parola chiave <code>return</code>.
La parola chiave return mi √® utile quando ho bisogno di uscire a met√† di una funzione, quindi senza arrivare fino al fondo.</p>
<h3 id="621-esempi"><a class="header" href="#621-esempi">6.2.1 Esempi</a></h3>
<p><img src="images/il_linguaggio_2/image%2057.png" alt="image.png" /></p>
<h2 id="63-cicli"><a class="header" href="#63-cicli">6.3 Cicli</a></h2>
<p><img src="images/il_linguaggio_2/image%2058.png" alt="image.png" /></p>
<p>In generale √® possibile avere pi√π cicli, loop e while annidati all‚Äôinterno, √® possibile mettere delle etichette, delle label, mettendo apice qualcosa, e questo ci d√† la possibilit√† di uscire da un ciclo pi√π esterno.</p>
<p>Di solito le istruzioni break e continue riguardano il ciclo pi√π stretto, dentro cui vengono messe, se io voglio uscire dal ciclo esterno, ciclo esterno √® bisogno che sia etichettato con <em>‚Äòqualcosa</em>, e faccio <code>break ‚Äòqualcosa</code>, e lui esce dal ciclo pi√π esterno.</p>
<p><code>for</code> ha una sintassi particolare.
La sintassi del C, <code>for(i=0;i&lt;n;i++)</code>, non c‚Äô√®.
Potete solo scrivere <code>for variabile in qualcosa</code>.
Dove <code>for</code> e <code>in</code> sono keyword, la variabile √® una variabile basta, cio√® quindi ci mettete il nome di un identificatore, e l‚Äôespressione deve essere un‚Äôespressione <strong>iterabile</strong>.
Cio√® qualcosa che rappresenta una molteplicit√†.</p>
<p>Cos‚Äô√® che rappresenta una molteplicit√†? Un array rappresenta una molteplicit√†.
Se avete la variabile <code>let a =[2, 3, 4]</code> , <code>for s in a</code>, a <code>s</code> viene dato prima 2, fa le sue cose, poi viene dato 3, poi viene dato 4.
Quindi gli array sono naturalmente iterabili. Anche gli slice sono naturalmente iterabili. Lui tanto lo slice sa quanti pezzi sono e li va a prendere uno per volta.</p>
<p>I range sono iterabili: <code>for i in 0..10</code>.</p>
<h3 id="631-esempi"><a class="header" href="#631-esempi">6.3.1 Esempi</a></h3>
<p><img src="images/il_linguaggio_2/image%2059.png" alt="image.png" /></p>
<p>Qui vediamo l‚Äôuso degli apici per fare il break, per cui ho un loop esterno che si chiama <code>‚Äòouter</code>, e poi ne ho uno interno <code>'inner</code>, giusto per dargli dei nomi, e cos√¨ via.
E posso fare <code>break</code> dalle varie parti interrompere.</p>
<p><img src="images/il_linguaggio_2/image%2060.png" alt="image.png" /></p>
<p>Questo √® un esempio pi√π che altro fa vedere l‚Äôuso della libreria standard.
A volte abbiamo bisogno di servirci di tipi un po‚Äô pi√π sofisticati ‚Äî non c‚Äô√® bisogno di inventare l‚Äôacqua calda, la libreria di Rust viene gi√† con montagne di cose!</p>
<p>Ad esempio se avete bisogno di rappresentare la data corrente (data e ora corrente, cio√® il momento), esiste la libreria <code>std::time::instant</code>, che offre un metodo <code>now()</code>, che va a cercare sul vostro sistema operativo l‚Äôorologio, il real time clock, si fa dire che ore sono, e vi restituisce quel valore l√¨.</p>
<p>Cos√¨ come c‚Äô√® anche il <code>duration</code>, che rappresenta un intervallo di tempo.
Mentre un instant √® un punto specifico sull‚Äôasse temporale, un duration √® un segmento sull‚Äôasse temporale, una durata. Quindi rappresenta una distanza tra due instant.</p>
<p>Se voi avete due instant potete sottrarli e ottenete una duration.
Se voi avete un instant e una duration, li potete sommare per ottenere una nuova durata.</p>
<p>Qui crea una duration di un secondo, duration prende il numero di secondi e il numero di nanosecondi, quindi io prendo un secondo e zero nanosecondi, quindi una quantit√† pulita, e poi mi faccio dire che ore sono, e poi provo a interrogare l‚Äôorologio di sistema.</p>
<p>While instant now meno start e minore di un secondo incrementa, e questo mi fa vedere pi√π o meno quanto √® efficiente il sistema operativo dal milore a corrente, perch√© io gli chiedo l‚Äôora continuamente, ma a un certo punto sar√† passato un secondo. E alla fine mi faccio dire quanto viene.</p>
<h2 id="64-notazione-"><a class="header" href="#64-notazione-">6.4 Notazione <code>..</code></a></h2>
<p><img src="images/il_linguaggio_2/image%2061.png" alt="image.png" /></p>
<p>Il <em>range</em> lo posso scrivere nella forma <code>inizio..fine</code>, e questo vuol dire da inizio compreso a fine escluso, oppure <code>inizio..=fine</code>, e questo vuol dire da inizio a fine inclusi entrambi.</p>
<p>Laddove io ho un certo dominio possibile, posso usare delle notazioni compatte: la notazione <em>‚Äúpunto punto‚Äù</em> rappresenta tutti i valori di un certo dominio.
<code>for i: u8 in ..</code>Che cosa fa? u8 ha un dominio che va da 0 a 256 escluso, for i: u8, √® bene che glielo scriva altrimenti diventa un problema, in .. lui mi d√† 0, 1, 2, e arriva a 255 e si ferma.</p>
<p>Se <code>i</code> invece di essere un u8 fosse un u16, partirebbe da 0 e si fermerebbe a 65.575, e cos√¨ via.
Se io scrivo <code>for i: u8 in 25..</code>, parte da 25 e si ferma a 255, e cos√¨ via.</p>
<h3 id="641-esempi"><a class="header" href="#641-esempi">6.4.1 Esempi</a></h3>
<p><img src="images/il_linguaggio_2/image%2062.png" alt="image.png" /></p>
<h2 id="65-match"><a class="header" href="#65-match">6.5 Match</a></h2>
<p><img src="images/il_linguaggio_2/image%2063.png" alt="image.png" /></p>
<p>C‚Äô√® poi un‚Äôistruzione particolare, <code>match</code>, che adesso citiamo semplicemente, ma la tratteremo meglio appena parliamo delle enum, perch√© al momento fa casino.
Diciamo che serve pi√π o meno come serve in C o in Java avere lo switch.
Scegliere non tra due strade, come il caso di if, ma quando io devo scegliere tra molte strade.</p>
<p>Quindi uso match per scegliere una di molte strade.</p>
<p>La caratteristica di match √® che le strade che vado a indicare devono essere <strong>comprensive di tutte le possibili situazioni</strong>.
Cio√® il compilatore verifica che quando io uso un valore per scegliere, scrivo dei blocchi che coprono tutte le possibilit√†. Se esiste almeno una possibilit√† che non √® coperta, il match mi blocca e mi dice ‚Äú<em>non va bene perch√© qui manca qualcosa‚Äù</em>.</p>
<p>Ci√≤ che caratterizza il match rispetto al costrutto switch, il costrutto switch √® stupido, perch√© switch <code>i</code>, case 1, case 2, case 3. Potete solo chiedervi questo.</p>
<p>Qua il match invece utilizza il criterio proprio del <em><strong>pattern matching</strong></em>.
Cio√® voi potete dire se <code>i</code> √® tra 5 e 7, se √® divisibile per 3, etc..</p>
<p>Quindi rispetto al concetto di switch che vi pone a fare delle cose e vi fa fare poi delle porcate del tipo case 1, break, se non metto break finisco nel case 2 e cose del genere, ecco qui abbiamo dei match che sono mutuamente esclusivi, sono valutati in ordine e quindi io vedo se ricado nel primo caso faccio una cosa, basta.
Se non ricado nel primo caso verifico se ricado nel secondo caso, faccio quella cosa l√¨, etc..
E in ogni caso in uno devo sicuramente caderci e il compilatore me lo verifica.</p>
<h3 id="651-esempi"><a class="header" href="#651-esempi">6.5.1 Esempi</a></h3>
<p><img src="images/il_linguaggio_2/image%2064.png" alt="image.png" /></p>
<p>Ad esempio, supponendo che <code>item</code> sia un numero, se √® 0 restituisco il valore 0.
Se √® tra 10 e 20 inclusi restituisco la stringa ‚Äútra dieci e venti‚Äù.
Se √® 40 oppure 80 scrivo 40-80.
In tutti gli altri casi dico qualcos‚Äôaltro.
Se non mettessi quest‚Äôultima riga il compilatore mi bloccherebbe e direbbe ‚Äú<em>no, attenzione, non mi hai coperto tutte le possibilit√†</em>‚Äù.</p>
<p><img src="images/il_linguaggio_2/image%2065.png" alt="image.png" /></p>
<p><img src="images/il_linguaggio_2/image%2066.png" alt="image.png" /></p>
<p>Vado a cercare, guardo la slice di quell‚Äôarray l√¨ e dico ‚Äú<em>se √® una slice che comincia con 0 e</em> <em>prosegue per i fatti suoi, dico che comincia con 0‚Äù</em>.
Se invece comincia in qualche modo e poi c‚Äô√® una variabile <code>v</code>, e quella variabile <code>v</code> sta nel range 3, 5 compreso, allora dico che finisce con <code>v</code>, che diventer√† o 3 o 4 o 5‚Äù.
Se viceversa c‚Äô√® un primo elemento che ignoro, poi c‚Äô√® la variabile <code>v</code> e poi c‚Äô√® altro, dico il secondo valore √® <code>v</code>.
Se √® fatto di un solo elemento, che chiamo <code>v</code>, dico ha un solo elemento ed √® questo.
Ed infine se √® vuoto, dico che √® vuoto.</p>
<p>Anche in questo caso ho considerato tutti i casi possibili, perch√© se l‚Äôarray √® vuoto, se la slice √® vuota passo nell‚Äôultimo, se la slice contiene un solo elemento, quello che sia, cado nel penultimo.</p>
<p>Se ci sono due o pi√π elementi, cado sicuramente in uno dei tre, perch√© se il primo elemento √® 0, qualunque sia la continuazione finisco l√¨, se il primo elemento non √® 0, finisco sicuramente nel terzo, perch√© nel secondo potrei passarci prima e va bene, ma in ogni caso il terzo mi comprende, perch√© ignora il primo valore, prende il secondo, quello che sia, e ignora tutto quello che segue.</p>
<p>E quindi ho la garanzia di aver coperto l‚Äôintero dominio del mio slice.</p>
<p>Vedete che √® un costrutto potentissimo, consente di esprimere delle logiche molto sofisticate.
Ma ci torneremo perch√© c‚Äô√® bisogno di un po‚Äô per ragionarci sopra.</p>
<h1 id="7-riga-di-comando-e-argomenti"><a class="header" href="#7-riga-di-comando-e-argomenti">7. Riga di comando e argomenti</a></h1>
<h2 id="71-stdenvargs"><a class="header" href="#71-stdenvargs">7.1 std::env::args</a></h2>
<p><img src="images/il_linguaggio_2/image%2067.png" alt="image.png" /></p>
<p>Esattamente come in C possiamo passare dei parametri alla riga di comando.</p>
<p><em>Come li passiamo questi parametri alla riga di comando?</em>
Qui √® un po‚Äô diverso, in C il metodo <code>main()</code> prende <code>int argc, char **argv</code>, quindi riceve dei parametri espliciti che indicano quanti sono gli argomenti che sono stati passati dalla riga di comando e quali sono gi√† segmentati per spazio.</p>
<p>Qua il main invece √® sempre vuoto, se abbiamo bisogno di avere accesso alla riga di comando dobbiamo servirci del tipo predefinito che si chiama <code>std::env::args</code> e ci facciamo dare questi pezzi col comando <code>args.collect()</code>.</p>
<p><code>args</code> ci d√† un iteratore ai singoli elementi: il primo √® il nome del programma stesso, quindi se il mio programma l‚Äôho chiamato ‚Äútest‚Äù e lo lancio scrivendo <code>test 25 -f 44</code>, gli args comprendono la stringa <code>test</code>, la stringa <code>25</code>, la stringa <code>-f</code>, la stringa <code>44</code>.</p>
<p>Di solito il nome del programma non mi interessa, per cui <code>args.skip(1)</code>, per buttare via il primo, e tutti quelli che restano <code>.collect()</code>, per prenderli insieme e metterli in un vettore, a questo punto li ho nel vettore e vedo cosa farmene.</p>
<p>Il singolo argomento √® una <strong>String</strong>, quindi la posso poi mutare in qualche modo.</p>
<p>Se ho bisogno <code>args.len()</code> mi dice a priori quanti sono, se no li metto nel vettore e poi chiedo il vettore quanta roba c‚Äô√® dentro.</p>
<h2 id="72-clap"><a class="header" href="#72-clap">7.2 Clap</a></h2>
<p><img src="images/il_linguaggio_2/image%2068.png" alt="image.png" /></p>
<p>In realt√† i programmi Rust raramente accedono in quel modo l√¨ ai loro parametri, perch√© la comunit√† open source ha sviluppato una libreria potentissima che si chiama <code>clap</code>, che permette di gestire in modo dichiarativo i parametri che ottengo.</p>
<p>Il problema non √® accedere ai parametri, √® che quando tu mi passi <code>-f</code> qualcosa devo fare certi mestieri, quando mi passi <code>--help</code> devo stamparti l‚Äôhelp, etc...</p>
<p>Quindi il problema √® che nei programmi <em>command line</em> io devo raccoglierli questi parametri e poi devo agire di conseguenza.</p>
<p>Le azioni che faccio vanno misurate perch√© se ce n‚Äô√® solo uno faccio una cosa, magari se sono presenti in due devo vedere se sono compatibili e cos√¨ via.</p>
<p>Clap mi facilita tantissimo, mi permette di descrivere con poche righe le varie combinazioni lecite che io voglio gestire, mi automatizza buona parte dei comportamenti (ad esempio mi implementa di suo gi√† un help, mi implementa gi√† di suo una serie di descrizioni, etc..) e quindi √® tipicamente qualcosa di utile.</p>
<p><em>Come faccio a servirmi di questa libreria?</em>
Devo nel file <code>cargo.toml</code>, che descrive le mie cose, andare nella sezione <code>Dependencies</code> e scrivere che voglio usare <code>clap</code>.</p>
<h3 id="721-esempio-clap"><a class="header" href="#721-esempio-clap">7.2.1 Esempio Clap</a></h3>
<p><img src="images/il_linguaggio_2/image%2069.png" alt="image.png" /></p>
<p>Questo mi mette a disposizione un insieme di macro strutture dati su cui posso fare delle cose.</p>
<p><em>Come lo scrivo un programma che usa clap?</em>
Vedete, qui c‚Äô√® un main, che invece di andare a cercare <code>std::env::args</code>, va a prendere la libreria <code>clap::Parser</code>.</p>
<p>E <code>Args</code> √® la struttura che ho definito l√¨ sopra, che √® compilata, dice ‚ÄúVattele a leggere tutte, e poi per quelli che ci sono, salutami‚Äù.</p>
<p>La struttura <code>Args</code> √® definita con dei campi, dice <em>‚ÄúGuarda, io ho un nome e un count‚Äù.</em></p>
<p>Questi mi devono arrivare dalla command line.</p>
<p><em>Come mi arrivano?</em>
Allora, innanzitutto, name mi deve arrivare dalla command line con un <strong>prefisso</strong>.
Quel prefisso pu√≤ essere o <code>short</code> o <code>long</code>.
<em>Che vuol dire?</em>
Potr√≤ chiamare il mio argomento con <code>-n</code>, oppure <code>--name</code>.</p>
<p>Dire <code>#arg(short)</code> vuol dire automaticamente vai a cercare se c‚Äô√® il corrispondente <em>‚Äú-lettera_iniziale‚Äù</em>.
Se c‚Äô√® il long vuol dire automaticamente vai a cercare se c‚Äô√® <em>‚Äú--nome_completo‚Äù</em>, <code>name</code> in questo caso.</p>
<p>Quello sotto, <code>count</code>, anche lui √® short e long, quindi posso mettere <code>-c</code>, e posso mettere <code>--count</code>, e c‚Äô√® anche <code>default_value</code> (in questo caso se non metto argomenti, default_value fa finta che l‚Äôabbia messo e che ce ne sia scritto 1).</p>
<p>Quindi io posso invocare il mio programma, che in questo caso ho chiamato ‚Äúdemo‚Äù, in vari modi.</p>
<p>Oltre a questi due, che sono parametri che io user√≤, in questo caso per count volte stamper√≤ nel main <code>args.name</code>, lui me ne aggiunge alcuni altri.
Ad esempio mi aggiunge la versione, mi aggiunge un about e cos√¨ via.</p>
<p>Compilando questa cosa qua, quello che mi viene fuori √® che se lancio il mio programma <code>--help</code>, di suo mi mette gi√† una stringa.
<em>Dove se l‚Äô√® presa quella stringa?</em> Dal commento.
Perch√© era un commento con <strong>tre slash</strong> ‚Äî i commenti con tre slash servono a fare la documentazione, e di conseguenza lui ha capito immediatamente che quello √® la descrizione generale del programma.</p>
<p>Non solo mi ha stampato quel commento l√¨, ma mi d√† anche istruzioni su come posso eseguirlo.</p>
<p>Dicendo <em>‚Äúguarda, tu lo lanci col comando demo, che √® il suo nome, eventualmente exe se sei sotto Windows, puoi metterci delle opzioni, che dopo ti dico, e poi obbligatoriamente devi almeno mettermi --name‚Äù.</em></p>
<p><em>Quali sono le opzioni possibili?</em>
<em>‚ÄúGuarda, se mi metti -n mi pu√≤ andar bene, sarebbe l‚Äôequivalente di --name, ma dopo ci deve venire una stringa.‚Äù</em></p>
<p><em>Che cosa √® questa stringa?</em>
√à il nome della persona da salutare.</p>
<p><em>Dove si √® preso quella stringa l√¨?</em>
Dal commento col tre slash, etc‚Ä¶</p>
<p><em>Poi devi mettere un <code>-c</code> o un <code>--count</code>, indicando quante volte. Che cosa vuol dire?</em>
<em>‚ÄùIndica il numero di volte che ti saluter√≤. Se non me lo metti, guarda che ci metto io uno.‚Äù</em></p>
<p>Oppure mi chiami con <code>-h</code> o <code>--help</code>. Oppure mi chiami con <code>-v</code> o <code>--version</code>.
E in questo caso ti stampo la versione del programma.</p>
<p><em>Dove la prendo la versione?</em>
Dal file <code>cargo.toml</code>, perch√© nella descrizione del <code>cargo.toml</code> c‚Äô√® <code>version</code>, che di solito √® 0.1.0 se non la toccate.</p>
<p>Vediamo come con poca roba ci siamo arricchiti tantissimo e creiamo un‚Äôinterfaccia che √® professionale. Permette a chi usa il vostro programma di capirci qualcosa.</p>
<h1 id="8-io-da-console"><a class="header" href="#8-io-da-console">8. I/O da Console</a></h1>
<p><img src="images/il_linguaggio_2/image%2070.png" alt="image.png" /></p>
<p>Abbiamo visto che stampare si fa con <code>println!</code>.
Print line √® una macro: spacchetta quello che c‚Äô√® dentro e lo espande.</p>
<p>Oltre a print line √® presente <code>print!</code>, che fa la stessa cosa, semplicemente dopo non va a capo.
Quindi vi serve se volete stampare pi√π pezzi, uno a fianco all‚Äôaltro, sulla stessa riga.</p>
<p>A volte volete leggere.
Quando leggete, la maggior parte in realt√† delle operazioni di I/O possono andare a buon fine o meno.
Lo riconoscete perch√© se guardate i metodi offerti vi restituiscono degli oggetti di tipo <code>Result</code>.</p>
<p>I Result sono delle <strong>monadi</strong> che incapsulano il risultato. Il result pu√≤ essere <code>Ok</code> o <code>Error</code>.
Se √® Ok, dentro Ok c‚Äô√® scritto il vero risultato. Se √® Error, dentro Error c‚Äô√® scritto la ragione dell‚Äôerrore.</p>
<p><em>Cosa ve ne fate di un tipo Result?</em>
Innanzitutto potete controllare se √® buono o meno ‚Äî il metodo <code>.is_ok()</code> restituisce un booleano.</p>
<p>Nella maggior parte dei casi, se non siete riusciti a leggere da tastiera, per esempio, non √® tanto importante perch√© non siete riusciti, l‚Äôimportante √® che non siete riusciti e quindi magari dovete piantarla l√¨.</p>
<p>Se viceversa, siete riusciti, quindi se <code>.is_ok()</code> vi d√† true, potete chiamare il metodo <code>unwrap()</code>.</p>
<p><em>Cosa fa unwrap?</em>
Sbusta: tira fuori il valore che √® prigioniero dentro la monade.
Chiaramente dovete chiamare <code>unwrap()</code> solo se quello che √® stato l√¨ √® buono, perch√© se c‚Äô√® stato un errore, <code>unwrap()</code> vi pianta il programma, panicando, esattamente come se cercaste di accedere fuori dal range di un array, perch√© non avete fatto il controllo.</p>
<p><img src="images/il_linguaggio_2/image%2071.png" alt="image.png" /></p>
<p><em>Quindi, come leggo da tastiera?</em>
Mi preparo una stringa, <code>let mut s = String::new()</code>, e poi chiamo <code>io::stdin().read_line(&amp;mut s)</code>, a cui passo <code>s</code> come mutabile, passo un riferimento mutabile a <code>s</code>.</p>
<p>Questo permette a <code>read_line()</code> di scriverci dentro. Il metodo <code>read_line()</code> mi pu√≤ dare un risultato che √® <code>Ok</code>, oppure un <code>Error</code>.
Se √® Ok, dentro <code>s</code> mi trovo scritto quello che <code>read_line()</code> ha avuto.</p>
<p>Se sono sicuro che <code>read_line()</code> non mi d√† errori, posso invocare come scritto sotto: <code>io::stdin()::read_line(&amp;mut s).unwrap()</code>.
<strong>Attenzione:</strong> se qui non sono riuscito a leggere, questa riga mi provoca un panic e il programma si arresta.</p>
<h1 id="9-convenzione-sui-nomi"><a class="header" href="#9-convenzione-sui-nomi">9. Convenzione sui nomi</a></h1>
<p><img src="images/il_linguaggio_2/image%2072.png" alt="image.png" /></p>
<p>La comunit√† Rust ha sviluppato una serie di regole sulla nomenclatura, sull‚Äôuso degli identificatori e cose del genere.
L‚Äôambiente di compilazione √® molto sofisticato e pistino, cio√® va a controllare che voi siate attenti a questa convenzione.</p>
<p><em>Quali sono le convenzioni?</em>
<strong>I tipi</strong> si scrivono nel formato <strong>upper camel case</strong>: cominciano con una lettera maiuscola, e se sono formati da due o pi√π parole, tutte le iniziali successive sono maiuscole.</p>
<p>Viceversa, per <strong>i valori</strong> (variabili, funzioni, metodi), si usa la notazione <strong>lower snake case</strong>: tutto minuscolo separando pi√π parole con l‚Äôunderscore.</p>
<p>Se non fate cos√¨ vi beccate dei warning.</p>
<p>√à bene che voi impariate a compilare i programmi senza warning, cio√® eliminandoli.
√à vero che il warning non √® bloccante, ma √® indice di uno smell, di qualcosa che non va bene.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="possesso---malnati-8-9"><a class="header" href="#possesso---malnati-8-9">Possesso - Malnati 8-9 <!-- omit in toc --></a></h1>
<h1 id="indice-5"><a class="header" href="#indice-5">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="06-possesso.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="06-possesso.html#11-esempio">1.1 Esempio</a></li>
</ul>
</li>
<li><a href="06-possesso.html#2-movimento">2. Movimento</a>
<ul>
<li><a href="06-possesso.html#21-esempi">2.1 Esempi</a></li>
</ul>
</li>
<li><a href="06-possesso.html#31-copy">3.1 Copy</a>
<ul>
<li><a href="06-possesso.html#31-esempio">3.1 Esempio</a></li>
</ul>
</li>
<li><a href="06-possesso.html#4-clone">4. Clone</a>
<ul>
<li><a href="06-possesso.html#41-esempio">4.1 Esempio</a></li>
<li><a href="06-possesso.html#42-confronto-con-c-e-c">4.2 Confronto con C e C++</a></li>
</ul>
</li>
<li><a href="06-possesso.html#5-riferimenti-simple-pointer-e-fat-pointer">5. Riferimenti: simple pointer e fat pointer</a></li>
<li><a href="06-possesso.html#6-tempo-di-vita-dei-riferimenti">6. Tempo di vita dei riferimenti</a>
<ul>
<li><a href="06-possesso.html#61-esempi">6.1 Esempi</a></li>
</ul>
</li>
<li><a href="06-possesso.html#7-possesso---riassunto-regole">7. Possesso - Riassunto regole</a></li>
<li><a href="06-possesso.html#8-slice">8. Slice</a></li>
<li><a href="06-possesso.html#9-vantaggi-introdotti-dal-possesso">9. Vantaggi introdotti dal Possesso</a></li>
<li><a href="06-possesso.html#10-riferimenti">10. Riferimenti</a></li>
</ul>
<h1 id="1-introduzione-1"><a class="header" href="#1-introduzione-1">1. Introduzione</a></h1>
<p><img src="images/possesso/image.png" alt="image.png" /></p>
<p>Ogni volta che in Rust noi creiamo un valore questo valore √® <strong>posseduto</strong> da una e una sola variabile.
Ci√≤ che √® posseduto √® il valore: <em>la variabile pu√≤ possederlo.</em></p>
<p>C'√® una parte del compilatore molto importante che si chiama <em><strong>borrow checker</strong></em> che verifica formalmente che nel programma che noi abbiamo scritto effettivamente ogni valore sia posseduto da una sola variabile, e nel momento in cui risulta che un valore non √® posseduto provvede a rilasciarlo e nel momento in cui verifica che invece c'√® un tentativo di far possedere lo stesso valore a due variabili si ribella e impedisce la compilazione.</p>
<p>Questo rende la compilazione di un programma Rust pi√π difficile ma ci obbliga a scriverlo giusto ed √® la garanzia del fatto che i programmi scritti in Rust funzionano e non riservano problemi dopo.</p>
<p><em>Cosa significa possedere un valore?</em>
Significa sostanzialmente essere responsabili del suo rilascio, ovvero di garantire che quando quel valore l√¨ non servir√† pi√π non solo la memoria in cui il valore √® contenuto viene correttamente restituita al sistema operativo, comunque si sia originata (se sullo stack contraendo lo stack, se sullo heap liberando l‚Äôheap con l'opportuna funzione di rilascio) ma anche che i dati contenuti all'interno di quella struttura, se hanno delle dipendenze (se sono cio√® oggetto di qualche tipo), vengano correttamente rilasciati.</p>
<p>Questo significa, ad esempio, che se io all'interno del mio valore contengo la handle di un file che √® stato aperto, ecco: devo notificare al sistema operativo che quel file l√¨ in ogni caso lo voglio chiudere e non mi serve pi√π.</p>
<p><em>Quando avviene il rilascio?</em>
Normalmente il rilascio avviene nel momento in cui la variabile che lo possiede <strong>esce dal proprio scope sintattico</strong> ‚Äî noi sappiamo che una variabile comincia a esistere nella riga in cui la dichiariamo, <code>let var = *qualcosa*;</code>, e cessa di esistere quando arriviamo al chiusa graffa corrispondente, quindi l'ho dichiarata all'interno di un blocco che quindi era stata aperta una qualche graffa poco prima, e quella variabile √® accessibile fino a raggiungere il chiusa graffa.</p>
<p>Questa √® la vita normale di una variabile, quindi che inizia il possesso nel momento in cui viene dichiarata e termina il proprio possesso nel momento in cui raggiunge il fine vita, ma possono succedere cose, perch√© il valore che √® memorizzato nella mia variabile <strong>pu√≤ essere ceduto</strong> a qualcun altro.</p>
<p>Se io ho dichiarato la variabile <code>v1</code>, che conteneva qualcosa, da qualche parte potrei scrivere <code>let v2 = v1</code>, mentre <code>v1</code> √® ancora in vita.</p>
<p>Negli altri linguaggi <code>v2 = v1</code> significa ‚Äú<em>copia il valore di v1 dentro v2</em>‚Äù e poi finisce l√¨.
In Rust invece significa ‚Äú<em>copia il valore di v1 in v2, e da questo momento cessa di considerare v1 come responsabile del valore</em>‚Äù, quindi chi si dovr√† occupare del suo rilascio non √® pi√π v1 ma √® v2!</p>
<blockquote>
<p>üí° <strong>Copy</strong></p>
<p>Abbiamo visto che ci sono alcune eccezioni a questa regola: per alcuni tipi semplici, come ad esempio i numeri, <code>let v2 = v1;</code> originerebbe una variabile <strong>indipendente</strong> da <code>v1</code>, che continuerebbe a possedere il suo valore.</p>
</blockquote>
<p>Le assegnazioni di fatto in Rust corrispondono a <strong>movimento</strong>, ovvero c'√® una cessione non solo del dato cos√¨ com'√® ‚Äî <code>v1</code> esiste in un qualche punto della mia memoria ad un certo indirizzo, la variabile <code>v2</code> esiste in un altro punto della memoria al proprio indirizzo, e i dati dall'indirizzo 1 vengono copiati nell'indirizzo 2 per la dimensione necessaria (quindi se quello l√¨ era un valore che occupava 10 byte vengono copiati 10 byte), dopodich√© responsabile del rilascio diventa il destinatario, il mittente l'ha perso.</p>
<p>Perso vuol dire che non √® pi√π lecito neanche andare a leggere che cosa c'√® scritto dentro.
Per il compilatore √® come se la variabile <code>v1</code>, dopo che √® stato eseguito <code>v2 = v1</code> √® come se <code>v1</code> non fosse pi√π inizializzata, non ha pi√π un valore lecito.
Se <code>v1</code> era mutabile sar√† possibile assegnargli un nuovo valore, e va bene: questo nuovo <code>v1</code> posseder√† questo nuovo valore e avr√† un altro pezzo di storia, ma il valore originale l'ha ceduto a <code>v2</code>.</p>
<p>Questa cessione si attua certamente nei momenti espliciti in cui io faccio <code>v2 = v1</code>, ma si attua parimenti quando io uso <code>v1</code> come argomento di una funzione.
Quindi se io chiamo la funzione <code>f</code> passandogli <code>v1</code>, succede che la variabile <code>v1</code> viene trasferita nel primo parametro della funzione <code>f</code> (o nell'ennesimo parametro la funzione <code>f</code>, a secondo di come √® stata dichiarata), e quel parametro l√¨ diventa possessore del valore.
La variabile <code>v1</code> a questo punto non ce l'ha pi√π: ha perduto diritti e doveri ‚Äî ha perduto il diritto di accesso e ha perduto il dovere del rilascio.</p>
<p><em>A chi sono stati stati a chi sono stati trasferiti diritti e doveri?</em>
Al destinatario, nel caso dell'invocazione a funzione dunque il parametro della funzione.</p>
<p>Vediamo un esempio.</p>
<h2 id="11-esempio"><a class="header" href="#11-esempio">1.1 Esempio</a></h2>
<p><img src="images/possesso/image%201.png" alt="image.png" /></p>
<p>Creo un vettore <code>v</code> sullo stack.</p>
<p>Un vettore pu√≤ essere creato in tanti modi ‚Äî un modo per crearlo √® usare la funzione costruttrice <code>Vec::new()</code>, che mi prepara un vettore completamente vuoto, o in alternativa posso usare <code>Vec::with_capacity()</code>, che mi crea un vettore che √® sempre vuoto ma ha gi√† preallocato un buffer sullo heap di una certa dimensione.</p>
<p>In questo caso io gli chiedo preparare un vettore che abbia gi√† fin dall'inizio uno spazio per contenere quattro cose, e quindi sullo stack mi compare la variabile <code>v</code> che dentro di s√© contiene 24 byte: i primi 8 puntano ad un blocco sullo heap (grande 4 unit√†), il secondo pezzo di 8 byte contiene la dimensione del blocco puntato sullo heap (4), e il terzo elemento mi dice quanti di questi slot sono occupati.</p>
<blockquote>
<p>üí° <strong><code>Vec::with_capacity(n)</code></strong></p>
<p>Quando scriviamo <code>let mut vec = Vec::with_capacity(n);</code>, dobbiamo sapere il tipo dei dati che verranno inseriti nel Vec. Il tipo viene esplicitamente scritto (scrivendo <code>let mut vec: Vec&lt;i32&gt; = Vec::with_capacity(n);</code>), oppure dedotto dal compilatore.
Nell‚Äôesempio sopra il tipo viene immediatamente dedotto quando scriviamo <code>v.push(i)</code>, ed essendo <code>i</code> un i32 (tendenzialmente), a run time verr√† fatto spazio per 4 i32 sullo heap.</p>
<p>Se avessimo creato il Vec tramite <code>Vec::new()</code>, una volta arrivati alla prima istruzione <code>v.push(i)</code>, sarebbe stato allocato solo lo spazio per un i32 sullo heap, per poi far crescere questo spazio durante il for.</p>
</blockquote>
<p><img src="images/possesso/image%202.png" alt="image.png" /></p>
<p>Dopo aver creato questo inizia un ciclo che faccio durare 5, a ogni iterazione del ciclo inserisco un numero nel mio vettore.</p>
<p><img src="images/possesso/image%203.png" alt="image.png" /></p>
<p>A un certo punto cercher√≤ di inserire 5, ma il 5 in quel vettore non ci starebbe pi√π, quindi il vettore alloca un nuovo spazio nello heap grande il doppio di quello che aveva prima (quindi se prima aveva 4 adesso si prende uno spazio da 8), e nei primi 4 slot ci copia i 4 slot che aveva prima e nel quinto ci piazza il valore che gli sto mettendo.</p>
<p><img src="images/possesso/image%204.png" alt="image.png" /></p>
<p>Dopodich√© raggiungo la fine del for e stampo il contenuto del vettore, questa stampa mi fa vedere normalmente 12345 perch√© nel vettore in questo momento questo √® presente.
Quindi finch√© la variabile <code>v</code> √® in scope, siccome io non l'ho trasferita e non ho fatto niente di stravagante, lei √® responsabile del rilascio.</p>
<p><img src="images/possesso/image%205.png" alt="image.png" /></p>
<p><em>Quando arrivo al chiusa graffa cosa succede?</em>
La variabile <code>v</code> deve essere eliminata, ma siccome la variabile <code>v</code> al suo interno conteneva delle risorse (ovvero puntava al blocco presente sullo heap), questa eliminazione passa attraverso dapprima il rilascio delle sue risorse, quindi viene invocato il metodo <code>drop()</code> sulla variabile v, che provvede a restituire al sistema operativo il blocco che possedeva; dopodich√© lo stack si contrae e mi ritrovo in questa situazione in slide dove la memoria √® pulita ‚Äî ho raggiunto la fine della mia funzione e ho rilasciato tutto quello che aveva ‚Äî <code>v</code> possedeva un blocco sullo heap, e giunto alla fine della sua vita l‚Äôha rilasciato.</p>
<h1 id="2-movimento"><a class="header" href="#2-movimento">2. Movimento</a></h1>
<p><img src="images/possesso/image%206.png" alt="image.png" /></p>
<p>Il possesso da parte di una variabile del relativo valore inizia all'atto della sua inizializzazione, quindi nel momento in cui ho scritto <code>let v = Vec::with_capacity(4)</code>, in quel momento <code>v</code> comincia a possedere il suo valore.</p>
<p>Nel momento in cui io dovessi copiare il mio <code>v</code> dentro un <code>v1</code>, il possesso si trasferisce.
Se ad una variabile mutabile √® assegnato un nuovo valore, e quindi se <code>v</code> fosse mutabile e io facessi il contrario, cio√® dicessi <code>v = v1</code>, il valore che possedevo prima di prendermi quello nuovo di <code>v1</code> viene rilasciato.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Alcuni tipi di dato hanno un obbligo particolare: sono quelli che implementano il tratto <code>Drop</code>.
Altri sono pi√π semplici, e queste cose avvengono lo stesso ma il compilatore si accorge che sono semplificabili e quindi le salta, ma di per s√© avviene per tutto ‚Äî anche con gli interi avverrebbe cos√¨, ma semplicemente l'intero dice <em>‚Äúah benissimo, tu avevi la variabile <code>i</code> che conteneva 5, adesso ci sto mettendo 7. Dovrei rilasciare quel 5, ma siccome il 5 come tipo non implementa il tratto</em> <code>Drop</code> <em>posso non fare niente‚Äù</em> perch√© il fatto che il tipo i32 (o quello che sia) non implementa il tratto <code>Drop</code> vuol dire che dietro quel valore l√¨ non c'√® un significato particolare, se quello invece fosse sempre 5 ma inteso come <strong>file descriptor</strong> (cio√® un numero che mi ha concesso il sistema operativo per indicare una risorsa che sta nel kernel che √® un file che ho aperto da qualche parte) allora pur essendo concettualmente sempre solo un numero quello √® un numero che per√≤ ha una valenza per il sistema operativo, quindi non posso semplicemente dire che √® perduto, devo prima dire al sistema operativo ‚Äú<em>tu mi avevi dato sto 5 che rappresentava un file, ora non mi serve pi√π, quindi sappi che quel file l√¨ te lo puoi gestire per qualche altra cosa</em>‚Äù, quindi quello che conta √® <strong>che cosa significano quei valori</strong>. ****</p>
<p>Di conseguenza noi metteremo il file descriptor tendenzialmente dentro un oggetto che pur avendo le dimensioni di un intero sia qualificato non come <code>Int</code> ma come qualcosa di diverso che permette al sistema operativo di riconoscere che quello l√¨ √® un intero un po‚Äô particolare.</p>
</blockquote>
<p>Quindi nel momento in cui una variabile venga assegnata ad un'altra variabile, oppure venga passata come argomento una funzione, il suo contenuto viene mosso nella sua nuova destinazione. Mosso significa che i suoi bit vengono copiati.</p>
<p>Ma al di l√† del fatto che i suoi bit vengono copiati il compilatore si segna che la variabile <code>v1</code> ha perso i diritti e i doveri e li ha trasferiti su <code>v2</code>, quindi quando <code>v1</code> uscir√† di scope non dovr√† essere fatto nulla perch√© in questo momento √® come se fosse non inizializzata ‚Äî √® come se dentro di lei non ci fosse nulla.
Invece quando <code>v2</code> uscir√† di scope bisogner√† fare quelle azioni necessarie per rilasciare le cose e quindi pulire il pulibile.</p>
<p><strong>Di fatto non √® che lo stack si contragga in quel momento l√¨</strong>: la mia variabile <code>v1</code>, che conteneva qualcosa, dal punto di vista dell'occupazione di memoria, dopo che ho fatto <code>v2 = v1</code>, esiste ancora ‚Äî √® l√¨ al suo posto e star√† al suo posto fin quando non arrivo al chiusa graffa, perch√© solo il chiusa graffa corrispondente lo stack si contrae.
Per√≤ √® inaccessibile! Se io cercassi di andarla a leggere il compilatore mi blocca dicendo <em>‚Äúguarda da questa linea in avanti non √® pi√π inizializzata‚Äù,</em> quindi eventuali accessi in lettura a quella variabile l√¨ dopo che il movimento √® avvenuto portano un errore di compilazione.</p>
<p>Eventuali viceversa accessi in scrittura, ammesso che la variabile fosse mutabile, andranno bene perch√© nel momento in cui io deposito nella mia variabile qualcosa di diverso la variabile diventa di nuovo possessore di un nuovo valore e quindi quest'altro valore lo gestir√† fino a che ne ha bisogno (finch√© non lo cede o non arriva al fondo).</p>
<p><img src="images/possesso/image%207.png" alt="image.png" /></p>
<p><strong>Il movimento da un punto di vista pratico √® semplicemente la copia bit a bit dell'originale</strong>, quindi quando scrivo <code>v1 = v2</code>, prendo <code>v1</code> che ha una sua dimensione (nel caso del Vec sono 24 byte), e solo la parte dello stack viene copiata da una parte all'altra.</p>
<p>Quello che c'√® sullo heap non viene toccato: il mio vettore originale qui dentro possedeva un puntatore, un usize che vale 8 e un usize che vale 5.
Nel momento in cui io scrivessi <code>v2 = v</code> in questo caso da qualche parte quello che succederebbe √® che nel nuovo <code>v2</code> metterei nel primo campo lo stesso puntatore che c'√® dentro <code>v</code>, nel secondo campo 8 e nel terzo campo metterei 5, cio√® copia esattamente cos√¨ com'√®, e la parte sullo heap viene completamente ignorata, perch√© io ho solo spostato i pezzi sullo stack.</p>
<h2 id="21-esempi"><a class="header" href="#21-esempi">2.1 Esempi</a></h2>
<p><img src="images/possesso/image%208.png" alt="image.png" /></p>
<p>Lo vediamo meglio qua con una stringa (le stringhe sono fatte come i vettori, quello che cambia √® l'interpretazione delle sequenze).
In questo caso crea una stringa <code>s1</code> ‚Äî quello che succede √® che <code>s1</code> viene creato come stringa e quindi contiene dentro di s√© un puntatore sullo heap, che punta un blocco grande quanto il numero di byte contenuti nella <code>String</code> ‚Äúhello‚Äù, la quale √® fatta solo di caratteri ASCII e quindi stanno ciascuno in un byte, quindi quella cosa l√¨ √® fatta di un blocco di 5 byte i cui valori sono quelli corrispondenti a ‚Äúhello‚Äù quindi <code>68656c6c6f</code> esadecimali.</p>
<p>Quella √® la stringa ‚Äúhello‚Äù, quindi <code>s1</code> contiene un puntatore ad un blocco di 5 byte seguito da una sua <strong>capacity</strong> (5), seguito da una sua <strong>size</strong> (5).</p>
<p><img src="images/possesso/image%209.png" alt="image.png" /></p>
<p>Poi scrivo <code>let s2 = s1</code>, quindi a questo punto introduco sullo stack una nuova variabile <code>s2</code>. Quant‚Äô√® grande s2? √à una <code>String</code> e quindi anche lei √® grande 24 byte: 8 di puntatore, 8 di capacity e 8 di size.</p>
<p>Nel puntatore ci metto lo stesso puntatore che c'era su <code>s1</code>, nella capacity ci metto la stessa capacity che c'era in <code>s1</code>, e nella size ci metto la stesso size di <code>s1</code>.
Se in questo momento congelassi il mio processo e vado a fare l'inspect della memoria vedo che <code>s1</code> esiste benissimo sullo stack e punta alla stringa hello, vedo che <code>s2</code> esiste sullo stack e punta allo stesso blocco, quindi quel blocco l√¨ in questo momento lo conoscono in due.
Il compilatore lo sa benissimo e dice ‚Äú<em>per me non √® un problema, perch√© tanto io s1 non te lo faccio pi√π toccare, √® come se non ci fosse. Non mi d√† fastidio e non c'√® il rischio di doppio rilascio perch√© s1 √® stata taggata come <strong>mossa</strong>, e di conseguenza ha perso l'obbligo del rilascio. Viceversa quell'obbligo se l'√® guadagnato s2</em>‚Äù.</p>
<p>Posso stampare <code>s2</code> e vedr√≤ di nuovo stampato ‚Äúhello‚Äù esattamente come prima.
Nel momento in cui raggiungessi il fondo delle cose <code>s2</code> verrebbe rilasciato.</p>
<p><img src="images/possesso/image%2010.png" alt="image.png" /></p>
<p>Se invece dopo aver stampato <code>s2</code> provassi ad accedere ancora ad <code>s1</code> aggiungendo questa riga che qui √® segnata in rosso barrata, il compilatore mi bloccherebbe perch√© dice ‚Äú<em>guarda che tu alla riga 4 hai scritto s2 = s1, e quindi s1 adesso √® come se fosse vuota quindi non la vai a leggere</em>‚Äù.</p>
<p>Se invece io decommentassi la riga <code>s1 = "world".to_string();</code>, la riga che adesso √® marcata in rosso diventerebbe perfettamente lecita perch√© dentro <code>s1</code>  (che in questo esempio √® stata dichiarata mutabile) posso riassegnargli delle cose, e prenderebbe possesso di nuovo di qualcosa.</p>
<p>Questo √® il principio del possesso: <em><strong>un valore √® posseduto da una sola variabile</strong></em>.</p>
<p>Non √® il contrario: non √® che una variabile possiede un solo valore, questo succede in tutti i linguaggi ‚Äî √® chiaro che se la variabile √® una, dentro c'√® scritta una cosa sola, ma √® il contrario che invece √® significativo.
<strong>Il valore ha una sola variabile che la possiede</strong> ‚Äî non √® cos√¨ in quasi nessun altro linguaggio.</p>
<p><img src="images/possesso/image%2011.png" alt="image.png" /></p>
<p>Quello che succederebbe se io cercassi di compilare il pezzo di prima senza decommentare la riga <code>s1 = "world".to_string();</code> sarebbe un errore di questo genere dice ‚Äú<em>attenzione: tu avevi inizializzato s1 con ‚Äúhello‚Äù, per√≤ quando vai a cercare di stamparmi s1.to_uppercase(), questa cosa non funziona pi√π perch√© nel frattempo s1 ha perso quello che possedeva</em>‚Äù.</p>
<p><code>s1</code> alla riga 20 √® stato trasferito dentro <code>s2</code>, quindi alla riga 23 <code>s1</code> non ha pi√π niente dentro, e siccome <code>s1</code> √® una stringa che non gode del tratto <code>Copy</code> quel movimento l√¨ effettivamente la depaupera delle sue cose.</p>
<p><em>Cosa vuol dire che non gode del tratto</em> <code>Copy</code><em>?</em>
Spieghiamoci meglio.</p>
<h1 id="31-copy"><a class="header" href="#31-copy">3.1 Copy</a></h1>
<p><img src="images/possesso/image%2012.png" alt="image.png" /></p>
<p>Alcuni tipi, specialmente quelli numerici (quando quei numeri non hanno altro significato che un numero), hanno una particolare caratteristica: godono di un tratto che si chiama <code>Copy</code>.</p>
<p>Quel tratto l√¨ ha una caratteristica: quando avviene un'assegnazione o avviene un passaggio di parametro viene effettuata sempre la copia bit-a-bit esattamente come prima, ma non c'√® una perdita di diritto ‚Äî <strong>non ho perso il diritto di andarci a guardare dentro</strong>.</p>
<p>Non ho perso il diritto di andarci a guardare dentro perch√© in realt√† il tratto <code>Copy</code>, che √® mutuamente esclusivo col tratto <code>Drop</code>, <strong>mi garantisce che non avevo doveri</strong>.
Il tratto <code>Drop</code> se lo implemento implica che ho un dovere, se ho il tratto <code>Copy</code> non posso avere il tratto <code>Drop</code> perch√© il compilatore mi blocca, non me lo lascia manco di dichiarare.</p>
<p>Quindi quella l√¨ √® una variabile che non aveva dei doveri, e se non aveva dei doveri va benissimo fare delle copie perch√© non ci diamo fastidio.</p>
<p><strong>√à possibile perch√© il valore contenuto non √® una risorsa che richiede ulteriori azioni di rilascio.</strong></p>
<p>Ad esempio √® un numero semplice che posso usare per fare le somme, le moltiplicazioni etc.. non √® l'indice di un array, non √® una cosa strana che richiede che altri ci facciano dei conti sopra, invece i file descriptor, ad esempio, che sono un'informazione che mi viene dal kernel che mi permette di stare allineato tra quella che √® la mia immagine del kernel e quello che il kernel sa davvero, ecco quelle cose l√¨ devono restare gestite bene.
Io sul file descriptor non ci faccio le somme o le moltiplicazioni, lo prendo solo come identificativo univoco.</p>
<p>Quindi <strong>i tipi semplici e le loro combinazioni</strong> (ad esempio le tuple di tipi semplici o gli array di tipi semplici) <strong>sono automaticamente copiabili</strong> e quindi questo mi garantisce che io posso accedere dopo un'assegnazione ancora all'originale.</p>
<p><strong>Anche i riferimenti non mutabili sono copiabili</strong>: se io ho preso un riferimento semplice <code>&amp;T</code> e lo assegno ad un altro riferimento, entrambi restano visibili.
L'unica faccenda √® che nel momento in cui esiste un riferimento, il dato originale non √® modificabile anche se era mutabile, perch√© la presenza del riferimento √® un prestito e dice ‚Äú<em>mentre l'hai prestato a qualcun altro quel dato l√¨ non lo tocchi, perch√© non deve cambiargli sotto il naso‚Äù</em>.
Se io un riferimento lo copio, allungo la durata del prestito, ovvero la durata del prestito diventa il massimo tra la durata della prima copia e la durata della seconda copia, quindi solo quando tutte le copie saranno finite e avranno esaurito la propria visibilit√† allora il dato torner√† ad essere modificabile.</p>
<p><img src="images/possesso/image%2013.png" alt="image.png" /></p>
<p>Quindi quando io avessi un tipo (come String o Vec) che non implementa <code>Copy</code>, nel momento in cui io cerco di riassegnare o di consumare il valore originale ‚Äî ad esempio qui abbiamo <code>let s = String::from("hello");</code> , benissimo ho creato una stringa, e poi <code>let b = s + " world";</code> ‚Äî di fatto quell‚Äôistruzione <code>s + ‚Äú world‚Äù</code> √® la chiamata ad una funzione (anche se non lo vedo apparentemente in modo esplicito), la funzione <code>concat()</code> che unisce il contenuto di <code>s</code> con il contenuto di ‚Äú world‚Äù.</p>
<p>Quindi <code>s</code> √® stata passata come argomento alla funzione <code>concat()</code> di String, e di conseguenza <code>s</code> ha ceduto, ha mosso il suo contenuto dentro il parametro di <code>concat()</code> che l'ha usato per i fatti suoi.
Dunque <code>s</code> non √® pi√π accessibile.</p>
<p>Viceversa per i tipi che implementano il tratto <code>Copy</code> questa cosa non succede: <code>let i = 42</code> e poi <code>let j = i + 1;</code>  si pu√≤ fare perch√© <code>i</code> inteso come numero semplice godeva del tratto copy perch√© non ha obblighi, quindi posso tranquillamente copiarlo dentro <code>j</code>: non ci sono doppi obblighi dell'uno e dell'altro, quindi quando <code>i</code> cesser√† di esistere sparisce dallo stack per i fatti suoi, quando <code>j</code> finir√† di esistere sparir√† dallo stack per i fatti suoi, e non c'erano obblighi di rilascio.</p>
<p>Quindi non si pu√≤ verificare il doppio rilascio, non potendosi verificare il doppio rilascio va tutto bene.
Questa √® la ragione per cui <code>Copy</code> e <code>Drop</code> sono mutuamente esclusivi: per risolvere il problema del doppio rilascio che invece affligge il C e C++.</p>
<h2 id="31-esempio"><a class="header" href="#31-esempio">3.1 Esempio</a></h2>
<p><img src="images/possesso/image%2014.png" alt="image.png" /></p>
<p>Con <code>let string2 = string1</code>  trasferisco tutto quello che c'era dentro <code>string1</code> in <code>string2</code>, quindi adesso ho due puntatori di fatto che vanno allo stesso blocco sull'heap, ma la prima terna √® <strong>inaccessibile</strong> e non ha nessun obbligo, quindi per il compilatore <code>string1</code> √® come se fosse vuota ‚Äî non mi generer√† assolutamente nessuna chiamata a <code>drop()</code>, non fa nulla.</p>
<p>Se io cerco di accedere a <code>string1</code> vengo bloccato, invece subito dopo c'√® <code>let num1 = 3</code>, e <code>let num2 = num 1</code>, e in questo caso invece <code>num2</code> contiene un altro 3 indipendente da <code>num1</code> ‚Äî non si danno fastidio, posso decidere che (ammesso che sia mutabile) <code>num1</code> lo faccio diventare qualcos'altro, posso leggerli entrambi e non si impicciano perch√© i numeri sono <em><strong>copiabili</strong></em>.</p>
<h1 id="4-clone"><a class="header" href="#4-clone">4. Clone</a></h1>
<p><img src="images/possesso/image%2015.png" alt="image.png" /></p>
<p>Il movimento piace perch√© spesso quando ho le stringhe, i vettori etc.. posso avere delle cose molto grosse allocate ‚Äî io posso trovarmi ad avere un vettore con 100.000 elementi tranquillamente.
Io posso tranquillamente copiare <code>v1 = v2</code> sapendo che quello che sposto sono 24 byte, i tre puntatori, quindi va bene.</p>
<p>Per√≤ chiaramente ho un unico buffer che transita dal possessore 1 al possessore 2.
In certe situazioni invece io ho bisogno di creare due buffer disgiunti, perch√® io l'originale non me lo voglio perdere, quindi in quel caso l√¨ non posso fare <code>v1 = v2</code> perch√© se facessi cos√¨, s√¨ <code>v2</code> avrebbe il buffer ma <code>v1</code> non ce l'avrebbe pi√π.
Io vorrei avere una copia completa delle due cose.</p>
<p>Questo tipo di operazione in Rust si chiama <strong>clonazione</strong>, √® fattibile a condizione che il tipo implementi il tratto <code>Clone</code> ‚Äî il tratto <code>Clone</code> √® un tratto molto semplice: dispone dell‚Äôunico metodo <code>clone()</code>, che provvede a generare una copia in profondit√† di tutto quello che c'√® dentro l'originale, quindi io non solo ho sullo stack un nuovo vettore con i suoi 24 byte ma ho sullo heap un nuovo blocco grande quanto era grande il blocco originale e che contiene una copia completa del tutto.</p>
<p>Clonare √® un‚Äôoperazione costosa ma √® sotto il controllo del programmatore che sceglie quando applicarla, e <em>come</em> applicarla.
Nel momento in cui definite le vostre strutture dati siete liberi di scegliervi qual √® l‚Äôalgoritmo pi√π adeguato per effettuare le copie in profondit√†, implementando il tratto Clone e il corrispondente metodo <code>.clone()</code>.</p>
<p>Viceversa le assegnazioni che sottendono un movimento o una copia a seconda del caso voi non le potete governare perch√© √® il compilatore che genera il codice, e il codice che viene generato √® una <code>memcpy</code> dall‚Äôindirizzo della variabile di partenza verso l‚Äôindirizzo della variabile di destinazione per una quantit√† di byte pari al size del tipo ‚Äî quindi se quel tipo l√¨ √® un tipo che ha come size 30 byte lui copia 30 byte sapendo che va bene cos√¨ e che non c‚Äô√® bisogno di fare altro.</p>
<p>Il tratto <strong><code>Clone</code> √® implicato dal tratto <code>Copy</code></strong> ‚Äî cio√® un tipo per poter implementare <code>Copy</code> deve anche implementare <code>Clone</code>.
Il tratto <code>Copy</code> √® mutuamente esclusivo a <code>Drop</code>, mentre <code>Clone</code> no.
Infatti un <code>Vec</code> √® clonabile ed √® anche droppable, viceversa un numero non √® droppable, ma √® copiabile ed √® anche clonabile (di fatto se voi prendete <code>let x = 1</code> e scrivete <code>let x2 = x.clone()</code> ottenete un altro 1 paro paro ‚Äî √® inutile ma si pu√≤ fare).</p>
<p><img src="images/possesso/image%2016.png" alt="image.png" /></p>
<p>Questo √® una sottolineatura che trova una sua giustificazione nel fatto che il C++ invece si comporta molto diversamente.
Nel C++ il programmatore √® responsabile di definire per i tipi che si crea per i fatti propri <strong>l‚Äôoperatore di copia</strong>: cosa succede quando scrivo <code>a = b</code>.</p>
<p>Se a e b hanno come tipo il tipo t1 di qualche genere io dovr√≤ definire nel tipo t1 il comportamento del costruttore di copia e dovr√≤ anche definire il comportamento dell‚Äôoperatore di assegnazione, e i due (che sono distinti tra di loro) devono per√≤ essere congruenti.</p>
<p>Questo mette nel programmatore una responsabilit√† grossa, perch√© deve farle bene le cose, e il linguaggio non ti aiuta: se tu definisci il costruttore di copia che faccia certe cose e l‚Äôoperatore di assegnazione che ne fa di diverse puoi trovarti in una situazione molto brutta in cui certe volte il tuo programma fa in un modo e certe volte in un altro e non sai perch√©.
Non solo, ma tutte le volte che assegni ‚Äî e questo succede tantissimo ad esempio usando l‚Äôstd::string del C++ ‚Äî tu stai in realt√† clonando ma non lo capisci, non √® evidente.
Siccome quando scrivi <code>s1 = s2</code> in C++ tu stai allocando un nuovo buffer e stai copiandotele, e se quelle due stringhe erano grosse stai muovendo un mucchio di cose, ma magari tu non avevi intenzione di fare quella faccenda l√¨.</p>
<p>Rust mette in ordine tutto questo e stabilisce una netta distinzione: quando segni uguale oppure passi come parametro tu stai facendo un <strong>movimento</strong>, un‚Äôoperazione superficiale che dice semplicemente ‚Äú<em>io trasferisco il possesso dall‚Äôuno all‚Äôaltro, l‚Äôoriginale ha perso le cose</em>‚Äù, invece quando hai veramente bisogno di duplicare i valori lo chiedi esplicitamente.</p>
<p>Rust ti obbliga a capire cosa stai facendo: quando copi lo puoi fare solo se quel dato √® elementare; puoi clonare prendendoti la responsabilit√† del fatto che la clonazione √® potenzialmente un‚Äôoperazione lenta.</p>
<p>Dunque le assegnazioni sono prevalentemente assegnazioni per movimento, quindi costano poco e quelle che non sono per movimento costano comunque poco perch√© la definizione √® che in realt√† movimento e copia da un punto di vista del runtime hanno lo stesso costo: la copia di fatto di n byte, dove n √® noto a priori perch√® dipende dal tipo di partenza e non dalla dimensione delle sue aggiunte (sullo heap).</p>
<h2 id="41-esempio"><a class="header" href="#41-esempio">4.1 Esempio</a></h2>
<p><img src="images/possesso/image%2017.png" alt="image.png" /></p>
<p>Qui vediamo un esempio di clonazione.</p>
<p><img src="images/possesso/image%2018.png" alt="image.png" /></p>
<p><code>let s2 = s1.clone();</code> ‚Üí quello che succede √® che <code>s2</code> esiste sullo stack, ha un nuovo puntatore che punta ad un buffer differente da quello di <code>s1</code>, e i due buffer al momento hanno la stessa lunghezza e lo stesso contenuto.</p>
<p><img src="images/possesso/image%2019.png" alt="image.png" /></p>
<p>Siccome <code>s1</code> era mutabile decido di aggiungere al fondo un punto esclamativo, ma non ho capacit√† residua! Allora rialloco un altro buffer un po‚Äô pi√π grande: prima avevo un buffer da 2, ne facciamo uno da 4.
Quindi <code>s1</code> adesso si trova ad avere dentro di s√© un buffer da 4, con due spazi vuoti e quindi diventa possibile inserire l‚Äôesclamativo.
Al termine di questa operazione <code>s1</code> ha una capacity di 4 e un size di 3.</p>
<h2 id="42-confronto-con-c-e-c"><a class="header" href="#42-confronto-con-c-e-c">4.2 Confronto con C e C++</a></h2>
<p><img src="images/possesso/image%2020.png" alt="image.png" /></p>
<p>Questo ci serve per mettere un po in prospettiva le scelte che sono fatte.</p>
<p>In C il concetto di movimento non esiste, esiste solo il concetto di copia ‚Äî quindi quello che succede √® che quando voi assegnate la variabile 1 alla variabile 2 viene fatta una copia della variabile cos√¨ com‚Äô√®.</p>
<p>In C++ invece esiste il concetto di movimento ‚Äî quando voi definite un tipo custom (tipicamente una classe) avete la possibilit√† di (a condizione che usiate il C++ dallo standard 2011 a seguire) associare al tipo anche <em><strong>un</strong></em> <em><strong>costruttore di movimento</strong></em> <em><strong>e un operatore di assegnazione per movimento</strong></em>.</p>
<p>Quindi definite un tipo, gli spiegate qual √® il suo costruttore, qual √® il suo distruttore, poi definite il costruttore di copia (cosa fare quando io partendo da zero creo una nuova istanza che deve essere una copia di un altro oggetto dello stesso tipo), l‚Äôoperatore di assegnazione che dice ‚Äú<em>io avevo gi√† un valore precedentemente, tu adesso mi stai chiedendo di sovrascriverlo con quest‚Äôaltro. Che faccio?</em>‚Äù ‚Äî devo prima sbarazzarmi del valore vecchio, e quindi √® un pezzo di responsabilit√† simile al distruttore, e poi ci metto quello nuovo.</p>
<p>Allora <em>l‚Äôoperatore di assegnazione</em> si distingue dal <em>costruttore di copia</em> perch√© il costruttore di copia crea dal nuovo, non c‚Äô√® niente da buttare via!
L‚Äôoperatore di assegnazione invece riscrive sul vecchio, c‚Äô√® qualcosa prima da liberare e poi ci metto il nuovo.</p>
<p>Dopodich√© il C++ moderno ci dice ‚Äúoltre a costruttore, distruttore, operatore di copia, operatore di assegnazione puoi anche definirti il <em><strong>costruttore di movimento</strong></em> e l‚Äô<em><strong>operatore di assegnazione</strong></em> <em><strong>per movimento</strong></em>‚Äù e che fanno questi qua?
Sottraggono il contenuto dell‚Äôoriginale e lo piazzano nella destinazione, quindi si pigliano i pezzi e se li mettono dentro ma hanno la responsabilit√† di riempire la sorgente da dove hanno attinto con dei placeholder, in modo tale che la distruzione del pezzo da cui hanno attinto non faccia casino (di nuovo grande responsabilit√† sul programmatore che deve fare le cose congruenti).</p>
<p>In pi√π il C++ pur dando la possibilit√† di avere l‚Äôidea di movimento, di suo la applica in pochissimi casi e richiede invece al programmatore in modo esplicito di dire <em>‚Äúqui voglio muovere‚Äù,</em> e lo fa invocando una funzione che si chiama <code>std::move</code> che serve proprio a invocare il movimento.</p>
<p>Quindi per default il C++ adotta il concetto di copia, e in alcuni casi ti lascia scegliere di mettere il movimento, ma tu come programmatore hai la responsabilit√† di implementarlo correttamente ‚Äî c‚Äô√® una famosa regola (la regola dei 5) che dice che se implementi uno qualunque tra distruttore, costruttore di copia, costruttore di momento, operatore di assegnazione per copia, operatore di assegnazione per movimento, devi implementare anche tutti gli altri quattro, e devi farlo in modo coerente ‚Äî un gran casino!
Quindi il debugging anche di una semplice classe in C++ √® complicato, richiede un approccio estremamente metodico da parte del programmatore che deve avere molto chiaro nella testa che ha tutta quella responsabilit√† sulle spalle.</p>
<p>Allora l‚Äôavere introdotto il concetto di movimento in C++ nasce proprio dall‚Äôesigenza di ricercare una ottimizzazione nel codice, di raggiungere un livello di efficienza pi√π elevata perch√© io posso scegliere (laddove non ho bisogno un duplicato) di <em>riusare</em> delle parti, ma siccome √® l‚Äôeccezione e non la regola, bisogna che il programmatore scelga lui quando farlo.</p>
<p>Rust adotta il contrario, dice ‚Äú<em>per me la regola √® il movimento, la copia √® un‚Äôeccezione. Io la faccio in automatico l√† dove son tranquillo che non ci sono rischi: √® stato implementato il tratto Copy, che √® implementabile solo se non c‚Äô√® Drop, e il fatto che non ci sia Drop vuol dire non ci sono risorse da rilasciare, quindi sono tranquillo. Oppure la faccio perch√© me lo chiede un esplicito <code>.clone()</code></em>"</p>
<p>Perch√© la copia davvero √® l‚Äôeccezione: non abbiamo sempre bisogno di copiare le cose, nella maggior parte dei casi ci basta guardarci dentro, non ci serve <em>farne un altro</em>.</p>
<h1 id="5-riferimenti-simple-pointer-e-fat-pointer"><a class="header" href="#5-riferimenti-simple-pointer-e-fat-pointer">5. Riferimenti: simple pointer e fat pointer</a></h1>
<p><img src="images/possesso/image%2021.png" alt="image.png" /></p>
<p>Dopodich√®, in alcune situazioni io ho bisogno di poter accedere a un dato e guardarci dentro senza prenderne il possesso.
O se ho bisogno anche di modificarlo posso chiedere di farlo senza per√≤ aver la responsabilit√† di doverlo rilasciare.</p>
<p>Per permettere questo genere di cose Rust introduce il concetto di <strong>riferimento</strong>.
Il riferimento non √® nient‚Äôaltro che un modo per avere accesso in lettura o in scrittura (se ho un riferimento mutabile) a un dato che non sto possedendo.
Questo accesso non ce l‚Äôho per sempre, ce l‚Äôho <em>temporaneamente</em>, √® un prestito.</p>
<p><em>Io chiedo in prestito questa cosa, la uso per il mio scopo, e la restituisco.</em></p>
<p><em>Come avviene la restituzione?</em>
Nel momento in cui cesso di usarla il compilatore tiene traccia di questa cosa e capisce automaticamente <em>‚Äúqui hai cessato di usarla, quindi il prestito √® finito‚Äù.</em>
Il modulo che governa tutta la faccenda del possesso si chiama <em><strong>borrow checker</strong></em>.</p>
<p>Il riferimento √® un puntatore in sola lettura a un blocco che appartiene a un‚Äôaltra variabile, quindi se mi viene dato un riferimento io posso dereferenziarlo (cio√® metterci l‚Äôasterisco davanti e andarci a guardare dentro per leggere quello che c‚Äô√® scritto), non ho obblighi se non quello di piantarla l√¨ a un certo punto in modo che il possessore possa poi ritornare in pieno possesso delle sue cose.</p>
<p>Un riferimento permette di accedere ad un valore senza trasferirne la propriet√†, chiaramente questo pone dei vincoli: bisogna che il riferimento esista solo nel momento in cui la variabile che possiede il valore di cui ho ottenuto il riferimento esista anch‚Äôessa.
Il compilatore si prende la briga di verificare questa cosa qua, e se io cerco di accedere ad un riferimento in un momento in cui la variabile originale (da cui quel riferimento nasce) ha cessato di esistere, mi blocca.</p>
<p>Nella slide vediamo un esempio: ho creato una tupla che contiene un paio di numeri, 1 e 0, e poi <code>let reference = &amp;point</code>, se io scrivessi <code>let reference = point</code> ne farei a tutti gli effetti una copia (in questo momento point sono due float a 64 bit, e quindi √® grande 128 bit, cio√® 16 byte), reference di suo sono solo 8 Byte.
Se avessi scritto <code>let reference = point</code> avrei fatto una copia, questo perch√© quella tupla l√¨ √® fatta di numeri, le tuple fatte di numeri sono copiabili perch√© i numeri sono copiabili e quindi l√¨ si concludeva velocemente.
Qui invece ho preso l‚Äôindirizzo, e posso usarlo per accedere ai singoli campi: in questo caso nella print line successiva stampo reference.0 e reference.1 ‚Äî quando uso l‚Äôannotazione punto con un reference, il compilatore automaticamente va a guardare cosa c‚Äô√® prima del punto e se √® un reference ci mette un asterisco, se il tipo che gli viene √® ancora un reference ci mette un secondo asterisco e cos√¨ via quanti ne servono fino ad accedere al livello giusto. Questa √® l‚Äôauto dereferenziazione.
Questo avviene solo con l‚Äôannotazione punto, se io non avessi l‚Äôannotazione punto questa cosa non succede: ci devo mettere l‚Äôasterisco esplicito.</p>
<p><img src="images/possesso/image%2022.png" alt="image.png" /></p>
<p>Un riferimento prende a prestito l‚Äôindirizzo in cui esiste il valore.
Fino che il riferimento √® accessibile non posso modificare il valore anche se la variabile originaria che lo possiede √® mutabile, questo perch√© il prestito presuppone che ‚Äú<em>io te l‚Äôho data in lettura, tu la puoi leggere, io anche la posso leggere ma nessuno la cambia‚Äù</em>, perch√© se no c‚Äô√® il rischio di prendere delle decisioni sbagliate.</p>
<p>Nel momento in cui io creo un prestito e ottengo un reference, quel reference lo posso facilmente copiare, perch√© i reference in lettura sono copiabili tranquillamente ‚Äî sto copiando un indirizzo, √® un numero.
La presenza di pi√π riferimenti a un valore originale aumenta la durata del prestito, che rimane in essere fino a che c‚Äô√® almeno un riferimento presente.
Quando anche l‚Äôultimo riferimento sar√† andato via allora la variabile torner√† in pieno possesso del suo valore.</p>
<p>Il compilatore si fa garante di questo: il fatto che in un dato momento ci siano <code>n</code> riferimenti esistenti al valore originale √® un‚Äôinformazione che il compilatore tiene al suo interno, e che non si vede a runtime, √® un puro dato di compilazione, fa parte delle strutture dati che il compilatore si tiene per garantire la correttezza del nostro programma, quindi non c‚Äô√® costo a runtime.
C‚Äô√® un po‚Äô pi√π di costo in compilazione, motivo per cui compilare i file Rust √® pi√π lento rispetto a C++.</p>
<p><img src="images/possesso/image%2023.png" alt="image.png" /></p>
<p>A partire da una variabile che possiede un valore, se la variabile √® mutabile potete creare un riferimento mutabile.
Se la variabile non era mutabile non potete creare un riferimento mutabile.
Il riferimento mutabile esiste <strong>in modo univoco</strong>, √® mutuamente esclusivo: mentre c‚Äô√® un riferimento mutabile a quella variabile l√¨ non ce ne pu√≤ essere un altro, e non ci pu√≤ essere neanche un riferimento immutabile, e la variabile originale non √® accessibile n√© in lettura n√© in scrittura.</p>
<p><em>Come funziona un metodo che prende e modifica una stringa?</em>
Ad esempio io potrei avere il metodo <code>.push()</code> che abbiamo visto prima che mi aggiunge un carattere al fondo della stringa. Quando scrivo <code>s.push()</code> quello che succede √® che il metodo push √® dichiarato ad agire su un riferimento mutabile della stringa <code>s</code>, quindi bisogna che <code>s</code> sia mutabile e quello che succede √® che il metodo push riceve un riferimento mutabile, quindi viene preso temporaneamente il riferimento, il metodo push vedr√† l‚Äôindirizzo di <code>s</code> e potr√† andare dentro e farci delle cose, quindi per esempio chiedere di riallocare e fare cose del genere, e quando il metodo push finisce, quel riferimento l√¨ √® restituito ed <code>s</code> torna in pieno possesso delle facolt√†, solo che sar√† diversa dall‚Äôoriginale.</p>
<p>In questo modo i metodi possono decidere come operano:</p>
<ul>
<li>possono operare prendendo il <strong>totale possesso</strong> del dato, che quindi dopo l‚Äôinvocazione del metodo non √® pi√π accessibile</li>
<li>possono prendere accesso in <strong>sola lettura</strong> al dato, e quindi mentre loro girano quel dato l√¨ √® ancora leggibile e possono succedere altre cose</li>
<li>possono prendere accesso con un <strong>riferimento mutabile</strong> e quindi mentre il metodo √® in esecuzione il dato originale √® inaccessibile</li>
</ul>
<p><img src="images/possesso/image%2024.png" alt="image.png" /></p>
<p>Qui vediamo questa cosa rappresentata, abbiamo una variabile <code>s</code> mutabile e faccio aperta graffa ‚Äî inizia un blocco.
Quindi c‚Äô√® uno scopo sintattico ridotto. Dentro questo blocco dichiaro <code>m</code> come <code>&amp;mut s</code> ‚Äî cosa c‚Äô√® dentro <code>m</code>?
C‚Äô√® un puntatore che punta alla struttura <code>s</code>, e che pu√≤ modificarne il contenuto, quindi <code>m</code> di per s√© √® un puntatore.
Pu√≤ essere mosso, quindi lo posso trasferire da un‚Äôaltra parte.
Posso dire <em>‚Äúnon mi serve pi√π mutabile, lo riduco a riferimento semplice‚Äù,</em> sto riducendomi il privilegio d‚Äôaccesso ‚Äî questo √® lecito, nel momento in cui mi riduco il privilegio d‚Äôaccesso permetto di farne delle copie.
Quello che non posso fare √® copiarlo, perch√© di riferimenti mutabili ce ne pu√≤ essere uno solo.
E non posso neanche accedere ad <code>s</code> in alcun modo.</p>
<p>Quando giungo al chiusa graffa <code>m</code> evapora perch√© ha finito il suo ciclo di vita, ed <code>s</code> diventa nuovamente accessibile.</p>
<p>Il comportamento di Rust √® molto <em>smart</em>: di fatto l‚Äôinaccessibilit√† di <code>s</code> non si estende necessariamente fino al chiusa graffa. Rust fa attenzione e vede che se l‚Äôultima volta che avete usato <code>m</code> √® a met√† del pezzo viola da l√¨ in avanti dice ‚Äú<em>m non lo stai pi√π usando, quindi anche se di fatto esiste ancora io ti rid√≤ l‚Äôaccesso ad s</em>‚Äù, quindi la durata effettiva del vincolo corrisponde all‚Äôuso effettivo.</p>
<p>Al contrario quando mi procuro un riferimento semplice, r √® sempre un riferimento, √® sempre un puntatore, non √® cambiato niente rispetto a prima se non nei poteri.
Lo posso duplicare senza problemi, ne posso fare quante copie voglio, chiaramente queste copie andranno ad aumentare il tempo in cui s √® immodificabile (a parte il fatto che in questo momento s √® tutta immodificabile perch√© l‚Äôabbiamo creata non mutabile, ma avessimo scritto <code>let mut s = String::from"hello");</code> non potrei farci delle cose).
Quello che non posso fare √® fare l‚Äôupgrade a riferimento mutabile, perch√© mentre esiste un riferimento semplice so che potrebbero esisterne anche degli altri.
Non posso sicuramente muovere s: √® leggibile ma non posso cederla a nessun altro, perch√© se la cedessi a qualcun altro il suo indirizzo non sarebbe pi√π valido (o meglio l‚Äôindirizzo sarebbe quello l√¨ ma i dati contenuti al suo interno non rifletterebbero pi√π la vera natura delle cose).</p>
<p><img src="images/possesso/image%2025.png" alt="image.png" /></p>
<p>A differenza di quello che succede in C e in C++ i riferimenti non sono di dimensione costante: <strong>dipende da cosa puntano</strong>.
Ci sono riferimenti che sono grandi usize e ci sono riferimenti che sono grandi 2*usize ‚Äî ovvero possono essere, con un‚Äôarchitettura a 64 bit, grandi 64 bit oppure 128.</p>
<p><em>Perch√®?</em>
Tutte le volte in cui il compilatore sa esattamente qual √® la dimensione del tipo a cui puntano, il riferimento √® implementato come un puntatore semplice, e quindi √® grande usize, cio√® su un‚Äôarchitettura 64 bit √® grande 64 bit.
Quando invece il compilatore non sa la dimensione del dato puntato, perch√® questa √® nota solo a runtime, come ad esempio nel caso degli slice, un reference √® un <em><strong>fat pointer</strong></em>, ovvero √® grande 2*usize (64 + 64) ‚Äî il primo √® il puntatore all‚Äôinizio dello slice, il secondo √® la dimensione dello slice.</p>
<p>√à quello che succede ad esempio con <code>&amp;str</code>.
Gli oggetti <code>&amp;str</code> sono grandi 128 bit perch√® contengono nel primo pezzo il puntatore al buffer dove i caratteri sono memorizzati, e nel secondo pezzo la dimensione di quel buffer.</p>
<p>Oppure potrebbe trattarsi di un <em><strong>doppio puntatore</strong></em>, questo succede con i dati di <strong>tipi dinamici</strong>, che implementano il polimorfismo.
Si riconoscono perch√® sono marcati <code>&amp;dyn</code>.</p>
<p>Qui vediamo i primi due tipi.</p>
<p>Se abbiamo la variabile <code>i</code> di tipo i32, che vale 10 e poi ci prepariamo il riferimento, il compilatore sa che quello l√¨ √® un riferimento ad un i32.
Un i32 √® grande 4 byte, perfetto, non ho bisogno di nient‚Äôaltro, mi basta il puntatore, e quindi il suo riferimento √® un <em>simple pointer</em>.</p>
<p>Nell‚Äôaltro esempio a destra abbiamo un array dove ci sono tre interi: mi creo <code>r2</code> come slice, ovvero non solo come riferimento all‚Äôarray, che di per s√© saprei essere un array di tre interi, ma in questo caso <code>r2</code> l‚Äôho ribattezzato come slice di interi, quindi r2 √® un riferimento <em>a un pezzo</em>, che in questo caso coincide con l‚Äôintero array, ma avrei potuto scrivere <code>&amp;a[..]</code>, oppure <code>&amp;a[0..1]</code>, oppure <code>&amp;a[..2]</code>, etc.. quindi avrei la possibilit√† di prenderne solo delle parti.
Di conseguenza il riferimento diventa un <em><strong>fat pointer</strong></em>, e quindi il compilatore alloca 128 bit: i primi 64 puntano all‚Äôarray, i secondi 64 mi dicono di quanti pezzi √® fatto quell‚Äôarray, in questo caso tre pezzi.</p>
<p><img src="images/possesso/image%2026.png" alt="image.png" /></p>
<p>La terza situazione possibile √® quando io ho un dato che ha un certo tipo, ad esempio <code>f</code> √® di tipo <code>File</code> .
In questo caso io voglio dire ‚Äú<em>vai a vedere se nella cartella corrente c‚Äô√® gi√† un file che si chiama test.txt, se no crealo. Se c‚Äô√® gi√† lo fai diventare lungo zero, come se lo creassi da nuovo</em>‚Äù, su questo file io potr√≤ poi leggere e scrivere.</p>
<p>Di per s√© <code>f</code> √® un oggetto <code>File</code> che √® un oggetto pi√π o meno complicato che ha dentro di s√© tanti campi x per i fatti suoi.
L‚Äôoggetto <code>File</code> ha un certo numero di capacit√† che sono rappresentate dai tratti che implementa. Uno dei tratti che implementa √® il tratto <code>Write</code> ‚Äî il tratto <code>Write</code> √® la capacit√† di fare 4 operazioni, oltre al drop: <code>write()</code> , <code>write_vectored()</code>, <code>is_write_vectored()</code> e <code>flush()</code>. Da notare che non c‚Äô√® solo l‚Äôoggetto <code>File</code> che implementa questo tratto, anche <code>Vec</code> implementa lo stesso tratto.</p>
<p>Ovviamente in modi diversi: quando invoco <code>write()</code> sul file, e gli passo un contenuto, quello che succede √® che il file sul disco si allunga e mette al suo interno l‚Äôinsieme dei byte che gli ho passato come parametro di <code>write()</code>, appendendoli.
Se chiamassi su un <code>Vec</code> il metodo <code>write()</code> anche l√¨ nel vector i bytes li appenderei ma chiaramente l‚Äôoperazione √® molto diversa: nel caso del vector starebbero solo in memoria, nel caso del file vanno proprio sul disco, quindi l‚Äôinsieme di istruzioni che poi vado a eseguire sono totalmente diverse, ma in ogni caso io farei sempre <code>write()</code>.</p>
<p>Quando ho un blocco come quello scritto in giallo nella slide <code>let f = File::create("test.txt");</code> e poi <code>let r3: &amp;dyn Write = &amp;f;</code>, con quest‚Äôultima istruzione io prendo <code>f</code> non come un riferimento a file (quindi volendo sapere che quello l√¨ √® un file), ma mi limito a considerare il fatto che <code>f</code> √® <em>una cosa scrivibile</em>.</p>
<p>Avrei potuto inizializzare lo stesso <code>r3</code>, di tipo <code>&amp;dyn Write</code>, prendendo il riferimento di un <code>Vec</code> di byte, avrei acquisito le stesse possibilit√†, chiaramente con dei metodi totalmente diversi.</p>
<p><em>Come farebbe il compilatore a questo punto a capire qual √® la vera funzione da chiamare? Devo fare la write() sul File o devo fare la write() sul Vec?</em>
In queste situazioni il reference diventa un <em><strong>double pointer</strong></em>: nella prima met√† punta alla <strong>struttura</strong> vera e propria (in questo caso alla struttura file), nell‚Äôaltro punta a una tabellina che si chiama <em><strong>vtable</strong></em> che contiene per il tratto in questione ‚Äî <code>r3</code> √® dichiarato come tratto dinamico <code>Write</code> ‚Äî l‚Äôinsieme dei metodi che il tratto <code>Write</code> mi mette a disposizione, mi dice <em>‚Äúok tu vuoi guardare f non come file ma genericamente come cosa scrivibile‚Äù.</em></p>
<p><em>Come √® fatta una cosa scrivibile?</em>
Una cosa scrivibile √® una cosa che ha un metodo <code>drop()</code>, un metodo <code>write()</code>, un metodo <code>write_vectored()</code>, un metodo <code>is_write_vectored()</code> e un metodo <code>flush()</code>.
Sapendo questa cosa, lui mi compila quella tabellina mettendomi le giuste funzioni da chiamare, quindi nell‚Äôesempio r3 siccome bisogna associare a una graffia forse un titolo √® utilizzato r3 che tipo √®?</p>
<blockquote>
<p>üí° <strong>Ma il tratto √® un tipo?</strong></p>
<p>I <strong>tratti</strong> in Rust non sono ‚Äútipi‚Äù nel senso diretto del termine, ma rappresentano un <strong>insieme di comportamenti</strong> (cio√® metodi e/o funzioni associate) che un tipo pu√≤ implementare. Un tratto definisce un contratto che i tipi devono soddisfare per essere considerati come ‚Äúaderenti‚Äù a quel tratto.</p>
<p>Possiamo paragonare i tratti alle interfacce di Java o di altri linguaggi orientati agli oggetti. In Java, un‚Äôinterfaccia √® un tipo astratto che pu√≤ essere implementato da una classe concreta. Similmente, un tratto in Rust definisce un contratto che un tipo (ad esempio, una struct o un enum) pu√≤ implementare. In Rust, si usa la parola chiave impl per implementare i tratti.</p>
<p>Anche se i tratti non sono ‚Äútipi‚Äù in s√©, Rust consente di utilizzarli come <strong>trait object</strong> tramite puntatori come <code>&amp;dyn Trait</code> o <code>Box&lt;dyn Trait&gt;</code>. Questo permette di trattare i tipi che implementano un tratto come se fossero dello stesso tipo astratto. Ad esempio:</p>
<p><img src="images/possesso/image%2027.png" alt="image.png" /></p>
<p>L‚Äôidea che un tratto rappresenti ‚Äúun pezzo di tipo‚Äù √® utile per capire che un tratto definisce un insieme di capacit√† che un tipo pu√≤ avere. Per√≤, dire che una variabile √® ‚Äúdi tipo Runnable‚Äù (per esempio) significa, tecnicamente, che la variabile √® un <strong>trait object</strong>, non il tratto stesso.</p>
<p>Un tratto da solo non pu√≤ essere ‚Äúistanziato‚Äù. Pu√≤ essere implementato da tipi concreti, e puoi usare trait object per lavorare con tipi che lo implementano in modo polimorfico.</p>
</blockquote>
<p>Quindi quello che succede √® che i riferimenti cos√¨ costruiti, che riconosciamo perch√© sono dichiarati di tipo <code>&amp;dyn</code>, la parola <em>dynamic</em> √® messa l√¨ a posta per aiutare il programmatore a capire che quello che sta costruendo √® un <strong>double pointer</strong>, gli costa il doppio ma probabilmente gli va bene che gli costi il doppio perch√© implementato in questo modo il programmatore pu√≤ scrivere del codice che funziona sia con i file che con i vettori e quindi gli pu√≤ star bene.</p>
<p>In seguito approfondiremo l‚Äôargomento dei tratti e andremo a imparare tutto quello che serve a riguardo, per il momento ci serve prendere in considerazione il fatto che Rust si √® dato delle libert√† nel scegliere delle cose, ha detto ‚Äú<em>non √® che tutti i riferimenti debbono essere uguali, tutti i riferimenti devono darmi le informazioni di cui ho bisogno. Laddove le informazioni che io posso capire staticamente dal programma mi bastano, il riferimento √® un puntatore semplice. Laddove invece non mi bastano, il riferimento √® un fat pointer (costituito da puntatore e size). Laddove non mi bastano ancora il riferimento √® un double pointer (costituito da un puntatore alla struttura e un puntatore ad una vtable)</em>‚Äù.</p>
<p>Notate che la vtable contiene al suo interno, oltre che il puntatore e i vari metodi (e quindi al codice effettivo che dovr√† essere invocato nelle varie situazioni), anche due dati che sono <em><strong>size</strong></em> e <em><strong>alignment</strong></em>.
Quel size l√¨ permette di dire <em>‚Äúok, ho capito che il primo pezzo del mio fat pointer punta al blocco dove c‚Äô√® scritto hidden implementation, ma quel blocco l√¨ quanto √® grande?‚Äù,</em> e allora guardando la vtable vedo size.
L‚Äôalignment mi dice se l‚Äôoggetto puntato pu√≤ cominciare ad un indirizzo qualsiasi o pu√≤ iniziare solo un indirizzo pari, o pu√≤ iniziare ad un indirizzo che sia multiplo di 4, che sia multiplo di 8 e cos√¨ via.. questo perch√© permette poi, dovendo manipolare questo oggetto, di manipolarlo in un modo che sia congruente con i vincoli con cui quel blocco di memoria √® stato acquisito.</p>
<blockquote>
<p>üí° <strong>La vtable</strong></p>
<p>Il double pointer punta a una vtable che √® allocata <strong>una volta sola</strong>, quindi se io avessi 25 file diversi di cui mi faccio dare il reference, la prima parte del puntatore punta in 25 zone diverse dello heap, la seconda parte del puntatore punta alla stessa vtable perch√© di tipo <code>File</code> ce n‚Äô√® uno solo: c‚Äô√® una sola versione del metodo <code>drop()</code> per <code>File</code>, una sola versione del metodo <code>write_vectored()</code> etc...</p>
<p>La vtable non sta nello heap, sta nella zona statica del programma (dove vivono ad esempio le stringhe costanti) perch√© il compilatore la prealloca. √à una zona che esiste da sempre: nel momento in cui io ho definito che esiste un tratto il compilatore si crea sta tabellina che rappresenta l‚Äôinsieme delle funzioni che quel tratto in particolare sta dichiarando.</p>
</blockquote>
<blockquote>
<p>‚ö†Ô∏è <strong>Fat pointer e double pointer</strong></p>
<p>In questa spiegazione abbiamo fatto distinzione tra <strong>fat pointer</strong> e <strong>double pointer</strong> per maggiore chiarezza, ma in seguito parleremo di fat pointer indistintamente, indicando un riferimento che √®, in generale, grande 2*usize.</p>
<p>In un caso, il secondo usize indica un valore (la size del dato puntato), nell‚Äôaltro caso invece indica un puntatore alla vtable.</p>
</blockquote>
<h1 id="6-tempo-di-vita-dei-riferimenti"><a class="header" href="#6-tempo-di-vita-dei-riferimenti">6. Tempo di vita dei riferimenti</a></h1>
<p><img src="images/possesso/image%2028.png" alt="image.png" /></p>
<p>I riferimenti hanno un tempo di vita.
Questo, di nuovo, √® quello che il borrow checker mette a disposizione per garantirmi che non scriviamo stupidaggini ‚Äî ovvero, il borrow checker garantisce che io utilizzo un certo riferimento solo in quell‚Äôintervallo di tempo in cui il dato originale (da cui quel riferimento nasce) esiste, per evitare di creare dei <strong>dangling pointer</strong>.</p>
<p>Perch√© se io accedessi al riferimento <em>dopo</em> che il dato originale √® stato distrutto avrei fatto un dangling pointer.</p>
<p>Il concetto di tempo di vita ‚Äî <em><strong>lifetime</strong></em> ‚Äî √® una di quelle cose che sfugge, perch√© non c‚Äô√® nessun linguaggio che lo manifesta.
Il fatto che non venga manifestato sintatticamente nei linguaggi, non vuol dire che non ci sia un tempo di vita.
In C, il tempo di vita √® assolutamente una cosa essenziale: se io scrivo <code>int *ptr = malloc(sizeof(int))</code> in quel momento il mio <code>ptr</code> comincia ad esistere.
Se 5 righe dopo scrivo <code>free(ptr)</code>, <code>ptr</code> l√¨ cessa di esistere, cio√® <code>ptr</code> come variabile c‚Äô√® ancora ma il numero puntato da <code>ptr</code> non mi indica pi√π un blocco su cui posso fare delle cose, ha cessato di esistere ‚Äî chiamando <code>free</code> l‚Äôho restituito al sistema operativo.</p>
<p>Il problema √® che <code>ptr</code> come variabile di per s√© potrebbe stare ancora in giro, il C non mi protegge su questo, tocca a me programmatore dire <em>‚Äúcaspita, ma io qui ho appena fatto la free, non devo pi√π andare a leggere o fare</em> <code>ptr*</code><em>,</em> <code>ptr-&gt;</code> <em>o cose del genere‚Äù.</em>
Ma siccome tocca a me come programmatore, √® difficile andare a cercare tutte le strade che un programma fa, mentre il borrow checker invece non si stufa e le fa tutte, e va a verificare che non ci sia nel nostro programma nessuna strada che mette a rischio questa situazione, ovvero per la quale possa esistere la possibilit√† che ad un certo punto la variabile originale ha cessato di esistere, ma il riferimento c‚Äô√® ancora.</p>
<p>Nella maggior parte delle situazioni quindi il tempo di vita √® un qualcosa che possiamo immaginare, ma non viene materializzato.
Rust a differenza degli altri linguaggi ci d√† la possibilit√† sintattica di <strong>materializzare il tempo di vita</strong>, ovvero quando introduciamo un reference (mutabile o non mutabile) abbiamo la possibilit√† di <em>decorarlo con un nome simbolico</em>: io posso scrivere, se ho la variabile <code>i</code> che contiene 42, <code>let r = &amp;i</code>, oppure posso dire <code>let r = &amp;‚Äôa i</code>.</p>
<p>Cosa succede quando scrivo <code>&amp;'*qualcosa*</code>?
Apice si legge <em><strong>tic</strong></em>, e poi di solito si usa un nome, una lettera singola, ad esempio <code>&amp;‚Äôa</code> .
Sto semplicemente dicendo che ho deciso di dare un nome a quel tempo di vita.
Non sto dicendo quanto √® lungo, non sto dicendo quale sia, gli ho dato solo un nome.</p>
<p><em>Perch√® gli ho dato un nome?
P</em>erch√® in certi casi pu√≤ servire esprimere il fatto che ho bisogno che due riferimenti abbiano lo stesso tempo di vita, e quindi posso dire che quel pezzo di codice vale nell‚Äôintersezione dei loro tempi di vita, oppure che vale nell‚Äôunione dei loro tempi di vita, oppure posso dire che io da due riferimenti diversi ricavo un risultato che √® ancora un riferimento, il cui tempo di vita √® legato in qualche modo all‚Äôuno piuttosto che all‚Äôaltro, per questo motivo esiste la possibilit√† di materializzarlo, cio√® di dargli un nome, ma √® solo un nome.</p>
<p>C‚Äô√® un‚Äôeccezione importante: il nome che d√≤ al tempo di vita √® quello che voglio (quindi una stringa, una lettera etc..), l‚Äôeccezione √® <strong>static</strong>.
<code>&amp;‚Äôstatic</code> il compilatore lo interpreta in un modo molto forte: vuol dire ‚Äú<em>questa cosa qua esiste dall‚Äôinizio alla fine</em>‚Äù.
Questa cosa √® importante sulle stringhe: quando voi scrivete ‚Äú<em>hello world</em>‚Äù, scritto cos√¨ questa stringa finisce nella zona statica del vostro programma, la crea il compilatore, ci sar√† dall‚Äôinizio fino alla fine.
Quella stringa l√¨ non √® solo una <code>&amp;str</code>, √® una <code>&amp;‚Äôstatic str</code>: siete sicuri che quella stringa l√¨ ha durata quanto l‚Äôintero vostro programma.</p>
<p>In alcune situazioni voi volete forzare una struttura dati, ad esempio un vettore o una mappa, a contenere delle <code>&amp;‚Äôstatic str</code>, in quel caso ci potrete mettere solo delle costanti e non potrete mettere dei valori di altro tipo perch√© quegli altri avranno un tempo di vita differente.</p>
<p><img src="images/possesso/image%2029.png" alt="image.png" /></p>
<p>Indipendentemente dal fatto che noi li materializziamo o meno i tempi di vita vengono verificati dal compilatore.
Per il compilatore i tempi di vita non sono nient‚Äôaltro che l‚Äôintervallo di righe in cui √® lecito accedere a quel particolare riferimento.</p>
<p>Quando noi creiamo una funzione che prende come parametro dei riferimenti dotati di un tempo di vita materializzato, il compilatore andr√† a verificare che quando noi chiamiamo quella funzione gli passiamo dei parametri che vivano in modo compatibile con i vincoli che abbiamo espresso nella funzione stessa.</p>
<p>Il primo criterio che il compilatore adotta √® controllare che un riferimento esista soltanto nell‚Äôintervallo di tempo in cui esiste il valore da cui √® stato tratto.
Se io ho creato il riferimento <code>r</code> preso dalla stringa <code>s</code>, <code>r</code> pu√≤ esistere solo fin tanto che <code>s</code> esiste, quando <code>s</code> non c‚Äô√® pi√π <code>r</code> non deve esserci, perch√© se ci fosse sarebbe un dangling pointer.</p>
<p>Il tempo di vita √® un aiuto enorme ‚Äî voi lo vivrete inizialmente come un impiccio perch√® √® difficile, perch√® non ha corrispondenza negli altri linguaggi.
Le variabili hanno un tempo di vita e ragionarci sopra √® essenziale.
Il fatto che il compilatore per noi faccia questo mestiere √® davvero un enorme servizio perch√® √® quello che ci garantisce che non facciamo schifezze.
Nel momento in cui ci troviamo a dover salvare dei riferimenti dentro delle strutture pi√π complesse o passare dei riferimenti alle funzioni, i tempi di vita hanno bisogno di essere esplicitati.</p>
<p>Questa cosa √® un pezzo un po‚Äô meno ovvio, perch√® cosa succede?
Immaginate che abbia una bottiglia di latte che scade domani, se io con quel latte l√¨ ci faccio il budino, ho trasferito la scadenza del latte nel budino.
Anche il budino adesso scade domani.</p>
<p>Quindi se io ho una variabile di tipo riferimento che scade perch√® prende dati da qualche parte che tra un po‚Äô evaporano, se questa variabile la metto dentro qualcosa di pi√π grande anche questa cosa pi√π grande riceve il limite, si riduce in possibilit√† di utilizzo.</p>
<p>Questo √® una delle conseguenze poco ovvie dei tempi di vita, ma assolutamente vere.
E quindi io sono obbligato a dire che se io in quella struttura l√¨ metto un dato che dura <code>a</code> tutta quella struttura dura al massimo <code>a</code>, perch√® se durasse di pi√π potenzialmente leggerebbe schifezze ‚Äî c‚Äô√® una propagazione del tempo di vita.
E se chiamo la funzione che consuma il dato <code>'a</code> e lo usa per darmi il suo risultato, il suo risultato ha tempo di vita <code>'a</code>, al massimo.
E se faccio la funzione che consuma il dato <code>'a'b</code>, il suo risultato ha tempo di vita che √® il pi√π breve tra i due.</p>
<p>Vediamo un esempio.</p>
<h2 id="61-esempi"><a class="header" href="#61-esempi">6.1 Esempi</a></h2>
<p><img src="images/possesso/image%2030.png" alt="image.png" /></p>
<p>Qui partiamo con una variabile <code>r</code>, l‚Äôabbiamo solo introdotta senza dargli un valore iniziale o un tipo.
Il compilatore ce lo lascia fare, quello che sa √® che r comincia l√¨ alla riga 2 e finir√† all‚Äôultima chiusa graffa.</p>
<p>Poi apriamo un blocco, e introduciamo <code>x = 1</code>, il compilatore prepara un <code>x</code> e ci mette dentro un 1, e poi subito dopo diciamo <code>r = &amp;x</code>, quindi il compilatore ha capito che <code>r</code> √® un reference non mutabile, e punta alla variabile <code>x</code>.
Poi chiudiamo la graffa, chiudendo la graffa <code>x</code> cessa di esistere, lo stack si accorcia. Per√≤ <code>r</code> rimane, e punta dove?
Nel vuoto, in una zona che non √® pi√π nostra.</p>
<p>Sotto ci chiediamo ‚Äú*√® vero che <em>r vale 1?</em>‚Äù.
Perigliosissimo!
Tra l‚Äôaltro gi√† solo facendo quell‚Äôassert, questa √® una macro, che viene espansa e diventa una chiamata funzione eccetera, quel pezzo di stack si sporca, non c‚Äô√® pi√π scritto 1, chiss√† cosa c‚Äô√®.</p>
<p>Qua il compilatore ci aiuta perch√© dice ‚Äú<em>x non vive abbastanza, sta roba non la puoi fare. Alla riga 9 hai preso in prestito x, alla riga 11 x √® morto ma alla riga 12, 13 tu sei andato ancora a leggere r che puntava ad x, ma non puoi leggere r che punta un x che non c‚Äô√® pi√π</em>‚Äù.</p>
<p><img src="images/possesso/image%2031.png" alt="image.png" /></p>
<p>Questo √® l‚Äôintervallo in cui x esiste: dalla riga in cui compare fino alla chiusa graffa.</p>
<p><img src="images/possesso/image%2032.png" alt="image.png" /></p>
<p>Questo √® l‚Äôintervallo di valit√† di r: da dove viene inizializzata fino al suo ultimo uso.</p>
<p><img src="images/possesso/image%2033.png" alt="image.png" /></p>
<p>Ma non si sovrappongono!
E quindi c‚Äô√® almeno un punto, la riga in fondo, in cui c‚Äô√® una <strong>violazione</strong>, e quindi il compilatore mi dice <em>‚Äúno, non si pu√≤ fare‚Äù.</em>
Il compilatore C non ve lo dice..</p>
<p><img src="images/possesso/image%2034.png" alt="image.png" /></p>
<p>Queste regole valgono anche quando si crea un riferimento a una parte di struttura dati pi√π grande.</p>
<p>Se ad esempio io ho un Vec <code>v</code> che contiene [1, 2, 3], e prendo il riferimento al secondo elemento con <code>let r = &amp;v[1];</code>, che cosa succede? Che <code>r</code> pu√≤ esistere solo finch√© esiste <code>v</code>!
Dal fatto che ho preso un riferimento ad un suo pezzettino, <code>v</code> diventa immutabile per tutto il tempo in cui esiste <code>r</code>, perch√© se io <code>v</code> lo lasciassi mutabile quello che potrebbe succedere √® che magari qualcuno me lo fa crescere e lui si sposta, ha bisogno di riallocare quindi quel puntatore che avevo preso non punta pi√π o al contrario qualcuno potrebbe invocare <code>clear()</code> sul mio vettore e me lo cancella tutto, e di nuovo mi trovo un puntatore dangling o qualunque altra cosa.</p>
<p>Quindi se memorizzo dei riferimenti in una struttura (come l‚Äôesempio di prima del latte e del budino), la struttura diventa a scadenza: scade non appena scade il pi√π giovane, il pi√π prossimo di tutti gli elementi.
E quindi io devo garantire che quella struttura l√¨ esiste al massimo quanto esiste il pi√π vicino degli elementi a scadenza.</p>
<p>Il compilatore Rust √® molto preciso nelle sue indicazioni e si sforza di dirci con chiarezza che cosa succede, ovviamente noi dobbiamo capirne un po‚Äô: nell‚Äôesempio di questa slide io sto cercando di inserire in questo vettore un riferimento, e quindi quello l√¨ diventa un vettore di riferimenti, ad un dato che per√≤ appena arrivo alla chiusa graffa prima della println non c‚Äô√® pi√π, e quindi subito sotto quando cercher√≤ di stampare cosa c‚Äô√® nel vettore farei casino perch√© mi troverei in quel vettore l√¨ un dato che non esiste pi√π e quindi il compilatore non me lo fa fare.</p>
<h1 id="7-possesso---riassunto-regole"><a class="header" href="#7-possesso---riassunto-regole">7. Possesso - Riassunto regole</a></h1>
<p><img src="images/possesso/image%2035.png" alt="image.png" /></p>
<p>Cerchiamo di mettere un minimo di ordine in tutta questa serie di regole.</p>
<p><strong>Ogni valore ha uno e un solo possessore</strong>.</p>
<p><em>Chi √® il possessore del valore?</em>
√à una variabile singola, ad esempio <code>v = 27</code>, oppure il campo di una struttura, se io ho preparato un vettore, e ho inserito nel vettore un certo dato il vettore diventa proprietario di quel dato, e quando il vettore sparir√† quel dato l√¨ sar√† rilasciato.
A sua volta il vettore potr√† essere posseduto da qualcun altro, che sar√† posseduto da qualcuno etc.. quindi il possesso √® una catena lunga.</p>
<p><strong>A un dato valore pu√≤ esistere al pi√π un solo riferimento mutabile</strong>.
<strong>Oppure, a un dato valore possono esistere molti riferimenti immutabili</strong>, ma fin tanto che esiste almeno un riferimento immutabile il dato originale (quindi il possessore del valore) pu√≤ solo leggerlo e non pu√≤ cambiarlo.
Viceversa mentre esiste l‚Äôunico riferimento mutabile l‚Äôoriginale non ci pu√≤ proprio accedere, questo significa che se io prendo un riferimento mutabile al terzo elemento di un <code>Vec</code>, io quel <code>Vec</code> non lo leggo proprio, perch√® se lo potessi leggere leggerei anche il terzo elemento, per√≤ non devo e quindi propago il lock ‚Äî che √® un lock che esiste solo nella testa del compilatore, nelle sue strutture dati e nei suoi ragionamenti ‚Äî per tutto il tempo in cui ho quel riferimento l√¨.</p>
<p><strong>Tutti i riferimenti devono avere una durata di vita inferiore a quella del valore a cui fanno riferimento da cui sono stati tratti</strong>, ****perch√® altrimenti diventano dei dangling pointer.</p>
<p><strong>I riferimenti sono implementati come <em>puntatori semplici</em> quando il dato ha dimensione nota,</strong> <strong>come <em>puntatori fat</em></strong> (cio√® come puntatori fatti di un puntatore e di un size) <strong>quando il dato ha dimensione del dato nota solo a run time,</strong> <strong>e come <em>doppi puntatori</em> quando il dato √® conosciuto non per il suo tipo ma solo per un tratto che implementa</strong> e quindi il dato √® un dato che √® conosciuto non per il suo tipo ma solo per un tratto che implementa e in questo caso il doppio puntatore rappresenta il puntatore al dato vero e proprio e il puntatore alla vtable che mi descrive il tratto per il quale io lo conosco.</p>
<h1 id="8-slice"><a class="header" href="#8-slice">8. Slice</a></h1>
<p><img src="images/possesso/image%2036.png" alt="image.png" /></p>
<p>Le slice le abbiamo gi√† incontrate, sono fette ‚Äî possiamo definire uno slice come <em><strong>viste</strong></em>, un po‚Äô come nei database.</p>
<p><em>Cos‚Äô√® una vista in un database?</em>
√à un modo di guardare un gruppo di record senza avere accesso alla tabella stessa.
Una vista pu√≤ essere una selezione, per cui vedete non tutta la tabella ma solo righe che hanno certe caratteristiche.
Su una vista leggete ma non scrivete.</p>
<p>Tipicamente noi creiamo delle slice, le possiamo creare a partire da dati replicati, quindi si possono fare delle slice su degli array, si possono fare delle slice su dei vettori.
Tipicamente la slice √® un blocco di elementi consecutivi la cui dimensione √® nota a run time.</p>
<p>Le slice sono rappresentate da dei fat pointer: il primo elemento punta all‚Äôinizio della mia slice, il secondo mi dice quanti elementi ho considerato all‚Äôinterno.
<strong>In quanto riferimento la slice non possiede</strong>, quindi ho creato la slice a partire da un <code>Vec</code>, ad esempio, ed √® il <code>Vec</code> a possedere il dato.
La slice lo guarda, mi da l‚Äôaccesso, mi d√† la possibilit√† di manipolarlo in alcune situazioni.</p>
<p>Posso creare una slice partendo da un array, ma anche partendo da vari tipi di contenitori: posso creare slice a partire da dei <code>Vec</code>, dei <code>Box</code>, da delle <code>String</code> e cos√¨ via.</p>
<p>Gli <code>&amp;str</code> sono delle slice, sono slice di byte.
Un <code>&amp;str</code> √® una sequenza consecutiva di n byte, quegli n byte in generale corrispondono a m caratteri con m ‚â§ n, dato che alcuni caratteri sono rappresentati dal singolo byte, alcuni da 2, alcuni da 3, e alcuni da 4, quindi il fatto che io abbia una slice di 8 byte non mi dice niente di per s√© su quanti caratteri ci sono: ce ne possono essere da 2 a 8.</p>
<p><img src="images/possesso/image%2037.png" alt="image.png" /></p>
<p>Qui vediamo una rappresentazione: se io ho un <code>Vec</code> posso trasformarlo in un <em><strong>boxed slice</strong></em>, cosa succede?
Il <code>Vec</code> evapora, lo consumo, ma tengo di buono puntatore e lunghezza, e butto via la capacity, e mi rimane il boxed slice associato, e quindi ho creato un <code>Box</code> che rappresenta un array degli n elementi che sono attualmente presenti.</p>
<p>Al contrario, se io ho un boxed slice, posso trasformarlo e farlo diventare un vector, e quindi gli d√≤ la possibilit√† di aggiungere elementi.
Quando lo faccio diventare un vector, di solito il vector ha capacity pari alla len perch√© a priori non avrei una preallocazione.</p>
<p>Notate che <code>Vec</code> e <code>String</code> sono parenti stretti, nel senso che da un punto di vista della disposizione in memoria una <code>String</code> √® esattamente un <code>Vec</code> di byte.
Dal punto di vista dei metodi sono molto diversi: la <code>String</code> ha metodi per essere messa in maiuscolo, in minuscolo, per essere divisa in token e cose del genere, cose che il vector non ha. Il fatto che la <code>String</code> sia un <code>Vec</code> di byte, non vuol dire che (come dicevamo prima) ha tanti caratteri quanti sono i byte presenti, per via della codifica utf-8.</p>
<p>Parimenti, una <code>&amp;str</code> ha lo stesso layout di memoria di uno slice di byte, semplicemente √® un puntatore ad una sequenza di n byte all‚Äôinterno.</p>
<h1 id="9-vantaggi-introdotti-dal-possesso"><a class="header" href="#9-vantaggi-introdotti-dal-possesso">9. Vantaggi introdotti dal Possesso</a></h1>
<p><img src="images/possesso/image%2038.png" alt="image.png" /></p>
<p><em>Perch√© tutto questo √® importante?</em>
Il problema di gestire in modo affidabile la memoria √® una cosa che affligge i programmatori da quando sono stati introdotti i linguaggi ad alto livello.
Con l‚Äôintroduzione dei linguaggi di alto livello si √® messo nelle mani del programmatore la capacit√† di creare delle cose pi√π complicate, ma al tempo stesso ha sollevato l‚Äôenorme problema dell‚Äôallocazione della memoria e della corretta gestione.</p>
<p>Nel 1992-1993 nel tentativo di dare una risposta a questo enorme problema √® nato Java, che poi √® stato copiato per questa idea iniziale da n altri linguaggi.
Java introduce il concetto di <em>garbage collector</em>, dicendo ‚Äú<em>Ok, gestire la memoria √® un grosso problema. Il programmatore non ce la fa, quindi ci penso io. Mi prendo la briga di rilasciarla, quindi io ‚Äî garbage collector ‚Äî sono il possessore della memoria. Quando la rilascio? La rilascio nel momento in cui vedo che pi√π nessuno la sta usando, e quando la rilascio posso compattarla. Ma se la compatto cambio gli indirizzi: una cosa che prima stava qua la sposto un po‚Äô pi√π in l√† perch√© devo compattare. Ma questo mi spacca tutto, quindi devo fare in modo che quando compatto la memoria nulla si muova</em>‚Äù, e qui nasce il problema della garbage collection.</p>
<p>La garbage collection in Java blocca l‚Äôesecuzione.
Se sto facendo un gestionale per le paghe e stipendi non √® mica un problema, ogni tanto questa cosa qua si ferma e fa la sua garbage collection e poi riparte.
Se sto facendo un sistema real time invece √® un grosso problema, perch√© nel frattempo la fisica va avanti e se ad esempio sto cadendo continuo a cadere etc..</p>
<p>Secondo problema: la maggior parte dei linguaggi che gestiscono l‚Äôidea di puntatore lo fanno alla luce del fatto che il puntatore permette di rappresentare delle cose che i tipi elementari non permettono, in particolare permette di condividere l‚Äôaccesso a strutture o a rappresentare dei grafi o cose del genere che altrimenti sarebbe molto complicato.
Solo che la maggior parte dei programmi che usano i puntatori √® afflitta da quello che si chiama il ‚Äú<em><strong>billion dollar error</strong></em>‚Äù, cio√® il fatto che √® stato introdotto il concetto di <strong>null pointer</strong>.
Concetto di null pointer che √® problematico in quanto spesso ce lo si dimentica: Java non risolve il problema del null pointer, tanto che rimane il grosso casino delle <em><strong>null pointer exceptions</strong></em>.</p>
<p>Per questo motivo sono stati introdotti altri linguaggi come Kotlin che duplicano il sistema dei tipi e ti dicono ‚Äú<em>c‚Äô√® tutta una gerarchia di tipi non annullabili, non possono mai diventare null, e parimenti c‚Äô√® una gerarchia di tipi annullabili: possono diventare null. Tocca a te caro programmatore dirmi che cosa √® l‚Äôuno e cosa √® l‚Äôaltro, se un tipo non √® annullabile io compilatore vigilo che tu non ci metti mai null dentro, se un tipo √® annullabile io compilatore vigilo che tu acceda soltanto con un null safe expression, e non faccia casino la cosa</em>‚Äù.
La cosa si migliora un po‚Äô, ma non √® ancora perfetta.</p>
<p>In Rust il problema √® molto pi√π facile: non esiste il riferimento nullo, non pu√≤ essere scritto e dunque non c‚Äô√® possibilit√† che venga fuori, per lo meno fin tanto che usiamo la parte safe di Rust.</p>
<p>Poich√© il borrow checker vigila sull‚Äôassegnazione dei riferimenti e sugli intervalli temporali in cui sono usati non c‚Äô√® il rischio di accedere in modo illecito a dei contenuti, non c‚Äô√® il dangling pointer n√© tantomeno ho problemi di <em><strong>segment violation</strong></em> dovuti al fatto che vado a leggere a casa di qualcun altro, cio√® in zone che non sono mappate nel mio spazio di indirizzamento.</p>
<p>Inoltre poich√© tutte le strutture hanno una dimensione nota a compile time, oppure hanno un esplicito campo che permette a runtime di validarle, risolvo a priori i problemi dei <em><strong>buffer overflow</strong></em> che affliggono disperatamente i programmi scritti in C e C++, e sono la sorgente della maggior parte degli attacchi hacker, perch√© se io ho una slice che ha lunghezza ignota a compile time, a runtime l√¨ c‚Äô√® scritto quanto √® grande, e se provo ad andare oltre i suoi limiti (quindi a prendere un indice pi√π piccolo di zero, questo sarebbe facile comunque, o un indice pi√π grande della sua vera dimensione) il programma mi blocca, va in panico.
Andare in panico vuol dire che lui si ferma, ma √® un comportamento deterministico!
Non mi lascia andare avanti e poi bene se viene, perch√© √® proprio su questa cosa qua che gli hacker lavorano per forzare i sistemi.</p>
<p>Quindi non possono verificarsi n√© buffer overflow n√© buffer underflow, cio√® cerco di andare prima del loro inizio.
Analogamente gli iteratori presenti in Rust, che mi consentono di esplorare delle strutture dati complesse come un vettore, una mappa o cose del genere per prendere gli elementi presenti al loro interno, non possono mai eccedere il limite e quindi non c‚Äô√® il rischio di andare oltre il fondo o prima dell‚Äôinizio, e questo mi d√† garanzia di correttezza.</p>
<p><img src="images/possesso/image%2039.png" alt="image.png" /></p>
<p>Tutte le variabili per default sono immutabili e tocca a noi come programmatori scegliere quali rendere mutabili.
La scelta fatta cos√¨ √® ispirata al <em>principio del minimo privilegio</em>: se una cosa non ti serve, non ce l‚Äôhai.  Se proprio hai bisogno lo chiedi, e siccome lo devi chiedere, allora chiedere √® sempre un po‚Äô faticoso e questo vuol dire che dovrai spenderci qualche secondo per pensarci ‚Äî e questo √® buono per valutare meglio cosa stai facendo.</p>
<p>Notate che il principio di possesso si vede esplicitamente in modo evidente con la gestione della memoria per cui non ho doppio rilascio, non ho dangling pointer, non ho null pointer exception, non ho tutta questa serie di cose qua‚Ä¶ ma vale anche con tutte le altre risorse: se posseggo un file lo debbo rilasciare, se posseggo un socket lo debbo chiudere, se posseggo un mutex altrettanto e cos√¨ via.
Quindi vale nei confronti di qualunque tipo di risorsa io possa aver preso in prestito dal sistema operativo ‚Äî il concetto di prestito √® molto ampio.</p>
<p><img src="images/possesso/image%2040.png" alt="image.png" /></p>
<p><em>Un‚Äôapplicazione Rust √® automaticamente sicura rispetto agli attacchi degli hacker?</em>
In parte si, in parte no.</p>
<p>Certamente io ho una buona parte del mio programma, che √® quella che qui √® rappresentata da quel blocco disegnato in giallo nella zona in basso a sinistra di questa slide, che √® data da tutte quelle garanzie che nascono a compile time ‚Äî per cui a compile time so che non posso accedere a una variabile se non √® stata inizializzata, so che posso usare solo riferimenti validi, so che non ci sono dangling pointer e non ci sono le corse critiche tra thread differenti, quando cio√® due thread cercano di leggere o di scrivere insieme una certa variabile.
Questi li abbiamo esclusi a priori <em>by design</em>.</p>
<p>In pi√π Rust mi aggiunge una serie di safety che nascono a run time, ad esempio se tu accedi a uno slice che a compile time ha dimensione ignota io non posso a priori vedere se tu stai uscendo o meno dai limiti, ma a run time stai tranquillo che ti becco, perch√© me lo sono scritto quanto √® grande e di volta in volta lo vado a verificare.
Questo mi garantisce che non ho rischi sullo stack, quindi non posso andare in overflow perch√© mi becca prima, posso essere tranquillo sui bound per cui gli slice non escono dai loro confini e su un insieme di cose posso fare dei controlli su alcune API unsafe.</p>
<p>Detto questo, per√≤, il mio programma consiste della parte verde che √® quella in qualche modo controllata ‚Äî √® il cosiddetto <em><strong>safe Rust</strong></em>, quella parte l√¨ o a run time o a compile time √® stata validata e sono sicuro che l√¨ non ci sono errori ‚Äî ma nel mio programma pu√≤ essere presente qualche blocco unsafe, che dipende come √® stato scritto, potrebbe essere soggetto ad attacco, devo scriverlo proprio bene.
Se fa uso di librerie native in C e quelle sono tutte attaccabili, sono soggetto a vulnerabilit√†.</p>
<p>Dopodich√© il mio programma fa uso del sistema operativo, che a sua volta √® attaccabile e a sua volta il sistema operativo fa uso dell‚Äôhardware, che anche lui √® attaccabile.</p>
<p>Quindi Rust √® certamente un contesto dove la sicurezza √® stata considerata in modo serio.
La superficie di attacco √® grande e quindi Rust difende se stesso, e tutto il resto bisogna difendersi.
Allora va detto che i sistemi operativi crescono nel tempo e fanno tutto il possibile per difendersi a propria volta.
Le librerie C che mediamente usiamo sono, nella maggior parte, librerie C di lunga data che hanno in qualche modo gi√† dimostrato nel tempo la loro solidit√†, per√≤ il rischio esiste sempre.
Se poi mettiamo dei blocchi unsafe, chiaramente dobbiamo prenderci la responsabilit√† di quello che facciamo con l‚Äôunsafe.</p>
<h1 id="10-riferimenti"><a class="header" href="#10-riferimenti">10. Riferimenti</a></h1>
<p><img src="images/possesso/image%2041.png" alt="image.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipi-composti---malnati-10"><a class="header" href="#tipi-composti---malnati-10">Tipi composti - Malnati 10 <!-- omit in toc --></a></h1>
<h1 id="indice-6"><a class="header" href="#indice-6">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="07-tipi_composti.html#1-introduzione">1. Introduzione</a></li>
<li><a href="07-tipi_composti.html#2-struct">2. Struct</a>
<ul>
<li><a href="07-tipi_composti.html#21-rappresentazione-in-memoria">2.1 Rappresentazione in memoria</a></li>
<li><a href="07-tipi_composti.html#22-visibilit%C3%A0">2.2 Visibilit√†</a>
<ul>
<li><a href="07-tipi_composti.html#221-esempio">2.2.1 Esempio</a></li>
</ul>
</li>
<li><a href="07-tipi_composti.html#23-metodi">2.3 Metodi</a></li>
<li><a href="07-tipi_composti.html#24-costruttori">2.4 Costruttori</a></li>
<li><a href="07-tipi_composti.html#25-distruttori">2.5 Distruttori</a></li>
<li><a href="07-tipi_composti.html#26-metodi-statici">2.6 Metodi statici</a></li>
</ul>
</li>
<li><a href="07-tipi_composti.html#3-enum">3. Enum</a>
<ul>
<li><a href="07-tipi_composti.html#31-rappresentazione-in-memoria">3.1 Rappresentazione in memoria</a></li>
<li><a href="07-tipi_composti.html#32-enum-e-clausole-match">3.2 Enum e clausole match</a>
<ul>
<li><a href="07-tipi_composti.html#321-destrutturazione-nei-costrutti-if-let-e-while-let">3.2.1 Destrutturazione nei costrutti <code>if let</code> e <code>while let</code></a></li>
</ul>
</li>
<li><a href="07-tipi_composti.html#33-enum-generiche">3.3 Enum generiche</a>
<ul>
<li><a href="07-tipi_composti.html#331-option">3.3.1 Option</a></li>
<li><a href="07-tipi_composti.html#332-result">3.3.2 Result</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-introduzione-2"><a class="header" href="#1-introduzione-2">1. Introduzione</a></h1>
<p>L'obiettivo di questa lezione √® cominciare a costruire dei tipi un pochino pi√π complessi di quelli che abbiamo visto fino adesso. Ora sappiamo che esistono i tipi elementari, gli interi, i numeri di vario tipo, i booleani, eccetera. Abbiamo scoperto che ci sono alcuni tipi precostituiti alquanto utili come le stringhe e i Vec.</p>
<p>Abbiamo visto che le stringhe hanno anche associato il concetto di <code>&amp;str</code>, che ci d√† la possibilit√† di rappresentare uno slice di byte sostanzialmente e quindi di poter avere accesso in sola lettura dei contenuti, ma nel momento in cui realizziamo dei programmi che hanno una qualche funzionalit√† abbiamo bisogno di poter rappresentare dei dati pi√π elaborati e questi dati pi√π elaborati li facciamo aggiungendo dei tipi al sistema.</p>
<p>Oggi parliamo di <em><strong>struct</strong></em> e se ce la facciamo di <em><strong>enum</strong></em> e la settimana successiva introdurremo i tratti come strumento per arricchire la definizione dei nostri tipi.</p>
<p><img src="images/tipi_composti/image.png" alt="image.png" /></p>
<p>In C e in C++ al canto ai tipi elementari noi sappiamo che possiamo creare le struct come modo per aggregare delle informazioni eterogenee tra di loro dando un nome ai campi. In C questo √® l'elemento di base che ci permette di definire un nuovo tipo. Ci sono alcuni altri pezzi che adesso vedremo ma sostanzialmente il grosso delle cose le facciamo in quel modo l√¨.</p>
<p>In C++ ammette le struct parimenti, dicendo che una struct √® semplicemente un blocco di memoria dove si trovano consecutivamente una serie di sottocampi e questi sottocampi hanno un nome e noi possiamo accedere. L'accesso alle struct √® sempre completamente libero quindi se io conosco l'indirizzo di una struct posso accedere a qualunque campo al suo interno.</p>
<p>Nel C++ le cose sono un pochino pi√π elaborate, perch√©? Perch√© il concetto di struct viene esteso passando alla <strong>classe</strong>.</p>
<p><em>Cos'√® una classe?</em>
√à sempre una struct n√© pi√π n√© meno, cio√® un blocco di byte consecutivi dentro cui ci sono dei campi ma quei campi non sono necessariamente tutti visibili.</p>
<p>Alcuni sono disponibili a tutti e sono <em><strong>public</strong></em>, alcuni sono disponibili solo al codice della classe stessa e sono <em><strong>private</strong></em>, alcuni sono disponibili al codice della classe stessa o delle sue sottoclassi se ne ha e sono <em><strong>protected</strong></em>.
In Java le cose sono in qualche modo simili.</p>
<p><img src="images/tipi_composti/image%201.png" alt="image.png" /></p>
<p>Qui ci sono degli esempi in C e in C++ delle varie parti.
Pezzo interessante nel C++ √® che il blocco class ha al suo interno delle sottoparti che sono delimitate dalle parole chiare <code>public:</code>, <code>protected:</code>, o <code>private:</code>, che radunano le varie parti. In questo √® una sintassi un po' diversa da Java dove invece ogni singolo campo ha il modificatore e quindi io posso dire che <code>private int</code>, <code>public void f</code> e cose del genere‚Ä¶</p>
<p>Quindi ho la possibilit√† di definire i vari elementi.</p>
<p>A parte il fatto della visibilit√† che √® una questione puramente sintattica che il compilatore ascrive a s√© dicendo <em>‚Äúio non ti lascio accedere a un campo se non hai il livello di accesso necessario‚Äù</em> non c'√® nessun'altra differenza tra <code>struct</code> e <code>class</code>. Sono blocchi di byte.</p>
<p><img src="images/tipi_composti/image%202.png" alt="image.png" /></p>
<p>Oltre a questo sia in C++ che in C sono presenti anche altri modi di estendere, di creare dei tipi custom.
Esiste il tipo <em><strong>enum</strong></em> che fondamentalmente mi d√† la possibilit√† di rappresentare un gruppo di identificatori. Ad esempio posso dire:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Days {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};
<span class="boring">}</span></code></pre></pre>
<p><em>Che cosa diventa quella faccenda l√¨?</em>
Il compilatore la trasforma in un intero dove sunday sar√† 0, monday sar√† 1 e cos√¨ via‚Ä¶
Ma mi permette di lavorare con delle costanti esplicite che hanno pi√π senso perch√© quando io leggo 3 devo farmi conto di a quale giorno corrisponde, mentre se leggo <code>Tuesday</code> dovrei capirlo pi√π facilmente. Quindi il vantaggio di lavorare con l'enum √® quello.</p>
<p>L'enum pi√π semplice che noi conosciamo √® il booleano. Il booleano ha due solo possibili valori true e false. Di fatto √® un intero, non √® niente altro che un intero un booleano. Ok? Ma poich√© √® definito in quella maniera l√¨ noi riusciamo a trattarlo in modo pi√π semplice. Per cui true √® pi√π ovvio di uno.</p>
<p>Esiste poi un tipo particolare che √® <code>union</code> che √® fonte di casino eccetera. Lo vediamo pi√π avanti.
Union sostanzialmente √® strutturalmente scritta come una struct. Quindi cos√¨ come faccio <code>struct S { int A, float B, char* C }</code>. Quindi ho questi 3 pezzettini A, B e C che sono un intero, un float e un puntatore.</p>
<p>Una union sintatticamente si presenta nello stesso modo. Ma dal punto di vista dell'organizzazione in memoria √® <strong>totalmente diversa</strong>. Perch√© mentre nella struct i primi 4 byte sono occupati dall'intero, i secondi 4 byte sono occupati dal float, i prossimi 8 byte sono occupati dal puntatore, nella union tutto √® insieme.</p>
<p>Quindi negli stessi 8 byte ci sono il puntatore, l'intero o il float.
<em>E come √® possibile?</em>
Sono in alternativa: <code>union</code> dice <em>‚Äúqua dentro ci posso mettere di volta in volta, secondo sulla base di quello che mi pare, o un intero o un float o un puntatore‚Äù</em>.</p>
<p><em>Ah e come faccio a sapere cosa ci ho messo?</em>
Se ne occupa il programmatore. <em>‚ÄúIo, compilatore, ti do il permesso di farlo. Tu, caro programmatore, troverai un modo intelligente di ricordarti cosa c'hai messo dentro.‚Äù</em></p>
<p><em>‚ÄúIo ti garantisco che la union √® grande come il pi√π grande dei pezzi che ci sono. In modo da farci ristare qualunque altra cosa.‚Äù</em></p>
<p>Quindi, quando io ho le union in C e in C++ sto definendo un pezzo di memoria che ha interpretazioni alternative.</p>
<p>Questa cosa qua √® un obbrobio: serve soltanto in situazioni vicino all'hardware dove necessariamente ho bisogno di farmi piacere una cosa che posso guardare in modo distinto. Perch√© spesso e volentieri l'hardware mi d√† dei bit che possono essere interpretati a volte come numeri, a volte come flag singoli, a volte in un'altra maniera. Se non ci fosse questo la <code>union</code> di suo non avrebbe ragione di esistere.</p>
<h1 id="2-struct"><a class="header" href="#2-struct">2. Struct</a></h1>
<p><img src="images/tipi_composti/image%203.png" alt="image.png" /></p>
<p><em>Cosa capita in Rust?</em>
La prima cosa √® che in Rust abbiamo le <code>struct</code>, in modo analogo a quello che succede in C.</p>
<p>In questo caso qui abbiamo <code>Player</code> che ha <code>name</code> che √® una stringa, <code>health</code> che √® i32, <code>level</code> u8.</p>
<p><em>Cosa succede quando io dichiaro una struct?</em>
Succede che viene allocata tanta memoria quanto ne serve per la somma di tutti i campi pi√π un delta eventuale se ho bisogno di garantire dell'allineamento.</p>
<p>L'allineamento nasce dal fatto che se il compilatore deve poi impaccare tante di queste struct una a fianco all'altra, ad esempio in un array, e il primo campo deve iniziare un indirizzo pari, la struct non pu√≤ avere una lunghezza dispari perch√© quella successiva nell'array si troverebbe nel posto sbagliato e quindi mi mette del padding ulteriore.</p>
<p><em>Dove lo mette il padding?</em>
Di solito al fondo, per√≤ a noi interessa abbastanza poco perch√© tanto il compilatore sceglie lui come organizzarsi la memoria, noi sappiamo semplicemente che la user√† nel modo pi√π conveniente possibile.</p>
<p>Quindi una struct √® un costrutto che ci permette di rappresentare un blocco in memoria che ha un certo numero di informazioni.</p>
<p><img src="images/tipi_composti/image%204.png" alt="image.png" /></p>
<p>Come usiamo una struct? In modo semplicissimo: dopo averla dichiarata, la utilizziamo per dichiarare delle variabili.</p>
<p><code>let player1 = Player { ... }</code> e poi elenchiamo i suoi campi dandogli un valore.</p>
<p>Quindi banalmente io quando istanzio una struct sono chiamato a dare un valore a ciascuno dei suoi campi. Se ometto qualcuno dei suoi campi il compilatore mi blocca e mi dice.</p>
<p>La struct la uso esattamente come la userei in C, con la notazione punto. Quando scrivo <a href="http://s.name/"><code>s.name</code></a> vedr√≤ <code>mario</code>, quando faccio <code>s.earth</code> vedr√≤ <code>25</code>, etc‚Ä¶</p>
<p>Posso accedere in lettura ai singoli campi, se la struct √® mutabile posso accederci in scrittura, quindi posso scrivere <code>s.level += 3</code> e cos√¨ via.</p>
<p>Tutte le volte che noi definiamo una struct stiamo introducendo, arricchendo il sistema dei tipi di Rust, che quindi si trova un oggetto in pi√π.</p>
<p><em>Perch√© ci si interessa aumentare il sistema dei tipi?</em>
Perch√© i tipi ci aiutano ad arricchire il vocabolario con cui noi ci esprimiamo. Se stiamo parlando di un problema che riguarda la pianificazione dei lavori per lo stretto di Messina, allora abbiamo bisogno di rappresentare una serie di concetti che sono tipici di quel dominio l√¨, per cui c'√® la <em>commessa</em>, per cui c'√® il <em>progetto esecutivo</em>, per cui c'√® lo <em>studio ambientale</em>, la <em>valutazione di impatto ambientale</em> e cos√¨ via.</p>
<p>Allora poter definire dei tipi che usano come nome un nome preso dal dominio ci rende pi√π facile capire cosa stiamo facendo.</p>
<p>In realt√† in Rust le struct possono essere definite in due modi:</p>
<ul>
<li>La prima √® quella pi√π simile al C, che abbiamo visto prima, dove i campi hanno tutti un nome esplicito.</li>
<li>La seconda √® un ibrido con le tuple, ovvero posso definire la mia struct, in questo caso <code>Playground</code>, invece che con aperta graffa, con aperta tonda.</li>
</ul>
<p><em>Cosa vuol dire fare struct aperta tonda?</em>
Vuol dire che questa struct continuer√† ad avere un certo numero di campi, ma a questi campi non sento il bisogno di dare un valore, un nome. Semplicemente gli dico che cosa contiene.</p>
<p>Questa struct <code>Playground</code> contiene il primo campo √® una stringa e poi ha due interi a 32 bit.</p>
<p><em>Come far√≤ a riferirmi a questi campi?</em>
Come farei con una tupla, e quindi lo chiamer√≤, se io ho la variabile <code>P</code> di tipo <code>Playground</code> potr√≤ fare <code>P.0</code> e l√¨ vedr√≤ il nome, cio√® vedr√≤ la stringa <code>P.1</code> e vedr√≤ il primo intero, <code>P.2</code> e vedr√≤ il secondo intero.</p>
<p>Quindi di fatto le struct scritte con le tonde sono come delle tuple, semplicemente sono delle <strong>tuple con un nome</strong>.</p>
<p>Se io avessi fatto la tupla e basta mettendo le tonde senza mettere nome, quella era una tupla anonima. Facendo, mettendogli davanti la parola chiave struct con un nome ho dato un nome al mio tipo.</p>
<p>√à anche possibile definire una struct che non ha nessun campo. L√¨ vedete <code>Empty</code>.
Quella struct l√¨ √® particolare, √® un esempio di <em><strong>zero size type</strong></em>, cio√® un tipo che occupa zero byte. Rust √® molto sofisticato e ad esempio vi permette di gestire un vettore di cose di quel tipo.</p>
<p><em>E come √® fatto un vettore di cose di dimensione zero?</em>
√à solo un contatore. Non alloca memoria, perch√© non ne ha bisogno, ma ha il conteggio di quante sono.</p>
<h2 id="21-rappresentazione-in-memoria"><a class="header" href="#21-rappresentazione-in-memoria">2.1 Rappresentazione in memoria</a></h2>
<p><img src="images/tipi_composti/image%205.png" alt="image.png" /></p>
<p><em>Come √® fatta la struttura</em> <code>Player</code> <em>all'interno della mia memoria?</em>
Allora, come √® fatta esattamente lo decide il compilatore e se voi cambiate versioni del compilatore potrebbero venire anche versioni diverse, perch√© il compilatore sceglie (in funzione dell'architettura per cui sta compilando e di parametri suoi di qualche tipo) qual √® la disposizione migliore.</p>
<p>Qui c'√® una differenza importantissima rispetto al C. Il C vi garantisce che se voi avete definito la struct con i campi A, poi B e poi C, in memoria prima trovate i byte di A, poi i byte di B, poi i byte di C. Quindi il C da questo punto di vista √® fedele nella sequenza. Se tu hai scelto di scriverli in quell'ordine, lui li mette in quest'ordine.</p>
<p>Il compilatore Rust dice: <em>"A meno che tu non mi chieda di fare diversamente, io li metto nell'ordine che mi viene pi√π comodo".</em></p>
<p><em>Perch√©?</em>
Perch√© alcuni tipi hanno un bisogno di allineamento e quindi se io posso scambiare l'ordine posso ottimizzare. In questo caso avevamo una stringa (24 byte: 8 di puntatore, 8 di capacity, 8 di size), un intero a 32 bit (4 byte), e un intero a 8 bit (1 byte). Totale: 29 byte. 29 √® un numeraccio, soprattutto perch√© √® dispari. Se ci appiccico un altro <code>Player</code>, mi viene scomodissimo perch√® questo altro <code>Player</code> deve cominciare con un indirizzo multiplo di 8. Quindi Rust aggiunge 3 byte di padding, probabilmente al fondo, ma potrebbero anche essere messi in mezzo, se volesse metterli a met√† tra <code>health</code> e <code>level</code> potrebbe anche andare bene lo stesso.</p>
<p>Quindi √® il compilatore che sceglie come organizzarsi la memoria per quello che riguarda. Noi in prima battuta possiamo ragionare sul fatto che probabilmente li metter√† nell'ordine che gli hanno detto.
In realt√† il motivo, come dicevamo, √® legato al fatto che lui deve garantire che i singoli campi rispettino i vincoli di allineamento.</p>
<p>Quindi un vettore, una stringa pu√≤ solo cominciare a indirizzi che sono multipli di 8.
Un intero a 32 bit pu√≤ solo iniziare a indirizzi che sono multipli di 4.
Un intero a 16 bit pu√≤ iniziare solo a multipli di 2 e cos√¨ via.</p>
<p>E di conseguenza deve aggiustare.
Se io ho bisogno per qualche motivo di garantirmi il controllo su come √® veramente disposta la memoria posso anteporre alla definizione della struct la parola chiave <code>#[repr(C)]</code>.
Questa annotazione chiede <em>"caro compilatore, stante che puoi fare un po' come ti pare, non fare come ti pare e invece fai come farebbe il C".</em>
In questo modo io sono tranquillo che quella struct cos√¨ fatta, se dovessi passarla a una libreria scritta in C, il C capirebbe cosa c'√® scritto dentro.</p>
<blockquote>
<p>‚ö†Ô∏è <strong>Attenzione</strong></p>
<p>La struct √® un blocco, che in quanto blocco pu√≤ vivere dovunque (stack o heap, e in particolare: di norma starebbe sullo stack, ma nulla mi vieta di boxarla, il che significherebbe allocare la struct sullo heap).</p>
</blockquote>
<h2 id="22-visibilit√†"><a class="header" href="#22-visibilit√†">2.2 Visibilit√†</a></h2>
<p><img src="images/tipi_composti/image%206.png" alt="image.png" /></p>
<p>Sia la struct nel suo complesso che i singoli campi possono essere preceduti dalla parola chiave <code>pub</code>, che ne cambia la visibilit√†. Per default le struct nel loro complesso e i campi al loro interno sono considerati <strong>privati</strong>, ma con un'accezione di privato diversa da quella che potete avere da un linguaggio come Java.</p>
<p>In Java privato vuol dire <em>‚Äúappartiene alla classe‚Äù</em>.
Qua le classi non esistono, non pu√≤ appartenere alla classe. Privato qui vuol dire <em>‚Äúappartiene al modulo‚Äù</em>.</p>
<p>Fintanto che il mio programma √® tutto acchiuso in un unico modulo, il concetto di privacy non esiste, perch√© ho solo quello. Ma se io comincio a dire che il mio programma √® fatto di due blocchi, che chiamo modulo 1 e modulo 2, quello che √® descritto dentro modulo 1 non √® direttamente visibile da modulo 2, a meno che io non lo renda pubblico.</p>
<p>Facciamo una prova.</p>
<h3 id="221-esempio"><a class="header" href="#221-esempio">2.2.1 Esempio</a></h3>
<p><img src="images/tipi_composti/image%207.png" alt="image.png" /></p>
<p>In questo caso, nel <code>main</code> posso usare la struct dichiarata senza problemi, e quindi posso dire <code>let t = Test { a: 12, b: false };</code>.
Sono nello stesso modulo, quindi la vedo e posso usarla.</p>
<p><img src="images/tipi_composti/image%208.png" alt="image.png" /></p>
<p>Se io invece la Struct <code>Test</code> la racchiudo all'interno di <code>module1</code>, cosa √® capitato?
La Struct esiste ancora, ma non √® nel mio stesso <strong>namespace</strong>, il suo nome completo non √® pi√π Test, ma √® <code>module1::Test</code>.</p>
<p>√à diventata un pezzettino di una parte. Perch√© mai io vorrei fare una cosa del genere? Perch√© questo mi aiuta a dividere il mio programma, che potrebbe diventare a un certo punto troppo grande, in blocchi elementari dove ciascun blocco, <strong>modulo</strong>, √® responsabile di un pezzettino e per cui in un'applicazione ipotetica per le paghe e per gli stipendi ho un modulo utenti che contiene la storia di tutti i miei dipendenti della mia azienda, ho il modulo cedolini che invece si occupa di calcolare la paga etc‚Ä¶</p>
<p>In questo modo riesco a separare logicamente le parti.</p>
<p>Nel momento in cui io dichiaro una struct dentro un modulo, al suo interno √® raggiungibilissima, non mi d√† nessun fastidio. Se io in questo modulo, quindi dentro le graffe del modulo, mi creo una funzione <code>f</code> :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod module1 {

	struct Test {
		a: i32,
		b: bool
	}
	
	fn f() {
		let t = Test { a: 1, b: false}; // This is fine
	}
	
}
<span class="boring">}</span></code></pre></pre>
<p>Questa cosa funziona, perch√© sono dentro il modulo, quindi la struct di default ha visibilit√† dentro il modulo in cui compare.</p>
<p><img src="images/tipi_composti/image%209.png" alt="image.png" /></p>
<p>Nel main viceversa, <code>Test</code> √® segnato in rosso e se vengo sopra col mouse mi dice <em>‚Äúnon trovo un tipo test in questo scope‚Äù</em>.
Ok, proviamo ad importarlo: <code>use module1::Test</code>.</p>
<p><img src="images/tipi_composti/image%2010.png" alt="image.png" /></p>
<p>Adesso ha capito di che <code>Test</code> parliamo, peccato che <code>module1::Test</code> √® <strong>private</strong>, lo possiamo usare. Ok, questo mi d√† la possibilit√† di creare del codice che √® incapsulato.</p>
<p><img src="images/tipi_composti/image%2011.png" alt="image.png" /></p>
<p><em>Come posso fare?</em>
Beh, possiamo rendere pubblica la struct <code>Test</code>.</p>
<p>Ma mi resta un altro problema. Adesso mi sottolinea <code>a</code>.
<code>Test</code> come struttura √® pubblica, quindi la puoi vedere, sai che c'√® e quindi la usi, ma non sai com'√® fatta, perch√© i suoi campi dentro per default sono <strong>privati</strong> e quindi qui vedete che nel main sia <code>a</code> che <code>b</code>, mi li sottolinea in rosso.</p>
<p>Se voglio rendere visibili anche i campi, devo dichiarare <code>pub a</code> e <code>pub b</code>. In questo modo ho reso la struct completamente pubblica. Questo mi permette di controllare cosa rendere visibile all'esterno e cosa no.</p>
<p>Ma se √® cos√¨, sembrerebbe che o la struct √® tutta pubblica o non √® utilizzabile.</p>
<p><em>Come posso manipolare una struct</em> <code>Test</code> <em>nel main se non ho accesso ai suoi campi?
A cosa servono i campi se non posso leggerli?</em>
Se fosse una struct come in C, dove c'√® solo spazio per i dati, sarebbe effettivamente inutile.</p>
<p>Tuttavia, proprio come le classi in C++, le struct possono avere dei metodi associati. Con i metodi associati, ha senso avere una parte privata che solo i metodi della struct possono manipolare.</p>
<p>Quando inizializziamo la struct cos√¨ (cio√® senza rendere i campi pubblici) abbiamo un problema, quindi dobbiamo creare qualcosa di pubblico per l'inizializzazione.</p>
<p><img src="images/tipi_composti/image%2012.png" alt="image.png" /></p>
<p>Per esempio, possiamo creare una funzione <code>f</code> che restituisce un <code>Test</code>.</p>
<p><img src="images/tipi_composti/image%2013.png" alt="image.png" /></p>
<p>Possiamo quindi scrivere <code>let t: Test = module1::f()</code>.
Vediamo che ci d√† un errore sull‚Äôinvocazione di <code>f</code> perch√® √® privata, ma possiamo renderla pubblica.</p>
<p><img src="images/tipi_composti/image%2014.png" alt="image.png" /></p>
<p>Dunque nel modulo possiamo creare un <strong>inizializzatore</strong>.
In questo momento, questa funzione <code>f</code> cos√¨ com'√® serve a poco, ma potremmo modificarla per accettare solo un intero (<code>i32</code>) da usare per il campo <code>a</code>. Questo garantisce che i <code>Test</code> costruiti in questo modo possano essere creati con un numero qualsiasi (per esempio <code>f(42)</code>), ma avranno sempre <code>false</code> come valore di <code>b</code>.</p>
<p>Oppure posso metterci <strong>qualunque logica</strong> mi pare all'interno della funzione <code>f</code> per farmeli costruire come mi pare. Sapendo che a questo punto fuori dal modulo io manipolo dei <code>Test</code>, perch√© il Test come concetto √® pubblico, ma non ho possibilit√† di sporcarlo pi√π di tanto. Questo addirittura mi lascerebbe togliere il <code>pub</code> anche da <code>a</code>.</p>
<p><img src="images/tipi_composti/image%2015.png" alt="image.png" /></p>
<p>Quindi, il fatto che io possa dichiarare come pubblico, oppure non dichiarare e di conseguenza lasciare <strong>privato</strong>, mi d√† uno modo per realizzare quel meccanismo di <strong>incapsulamento</strong> che spesso √® considerato alla base dell'<em>object orientation</em>, ma di suo non √® dell'object orientation, √® semplicemente un meccanismo di <strong>data hiding</strong>. Nascondo un pezzo di informazione, te la rendo inaccessibile.</p>
<p>Nella maggior parte dei linguaggi a oggetti, il <strong>data hiding</strong> si lega al concetto di <em>classe</em>. Rust ci fa vedere che √® possibile ottenere il meccanismo del data hiding senza fare riferimento a una classe. Lui dice <em>"io suddivido il mio codice in unit√† pi√π o meno grosse, chiamate <strong>moduli</strong>, e il livello di incapsulamento √® legato al modulo".</em></p>
<p>Se nel modulo 1 io avessi creato un sottomodulo, quindi all'interno delle graffe <code>module1</code> avessi messo <code>module2</code>, <code>module2</code> in quanto sottomodulo di <code>module1</code>, fatto dentro, vede tutto quello che si pu√≤ vedere in <code>module1</code>. Viceversa, se il <code>module2</code> fosse fuori, parallelo a <code>module1</code>, invece √® come se fosse fuori da tutto. Quindi vede le cose sue e degli altri solo la parte pubblica.</p>
<p>Per essere efficace per√≤, l'<strong>incapsulamento</strong> richiede che possiamo associare dei <em><strong>comportamenti</strong></em> (quelli che noi in altri linguaggi chiameremmo <em>metodi</em>) alla nostra struct.</p>
<pre><code class="language-java">class Point {
    private int x, y, z;
    
    public Point() {
        // costruttore
    }
    
    public double distance() {
        // calcola distanza
    }
    
    public void whatever() {
        // altro metodo
    }
}
</code></pre>
<p>Mentre in Java i metodi vengono definiti contestualmente alla classe, e questi sono dentro il blocco <code>class</code>, in Rust le cose sono separate, nel senso che noi definiamo la struct e poi, normalmente l√¨ vicino, in un blocco ci permette di definire quali sono le strutture associate.</p>
<h2 id="23-metodi"><a class="header" href="#23-metodi">2.3 Metodi</a></h2>
<p><img src="images/tipi_composti/image%2016.png" alt="image.png" /></p>
<p><img src="images/tipi_composti/image%2017.png" alt="image.png" /></p>
<p>Qui vediamo per confronto dal punto di vista strutturale come stanno le cose. In C++, ma anche in Java, JavaScript, sono tutti uguali da questo punto di vista, io ho <code>class Something</code> che ha l'insieme degli attributi al suo interno e, sempre nel blocco delle graffe, l'insieme dei metodi.</p>
<p>In Rust io ho la definizione della classe che contiene solo i dati che contiene, e poi separato, di solito messo l√¨ vicino, ho il blocco <code>impl</code>, <code>impl struct_name</code>, che dice <em>‚Äúper questa struct implemento i seguenti metodi‚Äù</em>.</p>
<p>Nel blocco <code>impl</code>, tra graffe, indico una serie di cose, di funzioni. Queste funzioni sono caratterizzate dall'avere tra gli argomenti dei valori di tipo <code>self</code>. I valori di tipo <code>self</code> ci rendono esplicito come quel particolare metodo accede alla struct da cui piglia le sue informazioni.</p>
<p>In questo caso vedo che la mia struct <code>Something</code> ha un metodo chiamato <code>process</code> che prende <code>ref self</code> e ne ha un altro che si chiama <code>implement</code> che prende <code>ref mut self</code>. Potrei avere altre combinazioni, adesso le vediamo.</p>
<p><em>Cosa vuol dire?</em>
Vuol dire che quando io, avendo la variabile <code>s</code> di tipo <code>Something</code>, invocher√≤ uno di questi metodi e scriver√≤ ad esempio <code>s.process()</code>, quello che succeder√† √® che sulla variabile <code>s</code>, di cui io sono il possessore, verr√† preso un <strong>reference</strong>, e questo reference verr√† passato in sola lettura alla funzione <code>process</code>, quindi la funzione <code>process</code> potr√† s√¨ accedere alla mia struct, ma solo leggere.</p>
<p>Viceversa, se io su quella variabile <code>s</code>, che dovr√† essere mutabile, facessi <code>s.increment()</code>, quello che succeder√† √® che il compilatore, a partire da quella variabile <code>s</code>, si piglia il <code>ref mut</code>, lo passa alla funzione <code>increment</code>, che quindi ha la possibilit√† di manipolare, di cambiare il contenuto della mia variabile <code>s</code>, e poi lo rilascia, perch√© finita l'esecuzione, quello <code>ref mut</code> viene buttato via.</p>
<p>I metodi possono essere dichiarati con diverse capacit√† di accesso alla <strong>struct</strong> a cui si applicano:</p>
<ul>
<li>in sola <em>lettura</em></li>
<li>in <em>scrittura</em> (e quindi anche in scrittura)</li>
<li>oppure, invece di usare <code>ref self</code> o <code>ref mut self</code>, possono prendere semplicemente <code>self</code>.</li>
</ul>
<p>Se un metodo prende semplicemente <code>self</code>, questo significa che il metodo prende il <strong>possesso</strong> della variabile. Di conseguenza, dopo aver chiamato tale metodo, la variabile originale non sar√† pi√π utilizzabile, avendo ceduto la sua <em>sovranit√†</em>.</p>
<p><em>Perch√© cedere la sovranit√†?</em>
Ci sono diversi motivi - ad esempio il metodo potrebbe dover trasformare la struct in qualcos'altro, utilizzando le sue componenti per creare qualcosa di diverso.</p>
<p>Un esempio pratico: quando lavoriamo con un vettore e iteriamo al suo interno. Il vettore offre due modi per estrarre i suoi elementi:</p>
<ul>
<li>il metodo <code>.iter()</code> (definito con <code>ref self</code>) che permette di guardare dentro</li>
<li>il metodo <code>.into_iter()</code> (che prende <code>self</code>) che rimuove gli elementi uno alla volta, non prendendone solo un riferimento ma <em>"strappandoli via"</em>, lasciando il vettore vuoto alla fine.</li>
</ul>
<p>Questo meccanismo ci permette di specificare cosa succede alla struttura originale quando invochiamo i metodi:</p>
<ul>
<li>Con <code>ref self</code>: la struttura rimane immutata, ma non modificabile durante l'esecuzione del metodo (prestito in sola lettura)</li>
<li>Con <code>ref mut self</code>: nessun altro pu√≤ accedere alla struttura durante l'esecuzione, ma il metodo pu√≤ modificarla</li>
</ul>
<p>Per esempio, quando usiamo <code>string.append()</code> o <code>string.push()</code>, questi metodi sono di tipo <code>ref mut</code>. Lo stesso vale per i <code>Vec</code>. Se invece il metodo √® definito con solo <code>self</code>, prende possesso della struttura che non esister√† pi√π dopo l'esecuzione - rimarr√† solo il risultato del metodo.</p>
<p><img src="images/tipi_composti/image%2018.png" alt="image.png" /></p>
<p>In essenza, i metodi sono <strong>funzioni</strong> legate a un'istanza di un certo tipo. Questo legame si manifesta sia a livello <em>sintattico</em> che <em>semantico</em>:</p>
<ul>
<li><strong>Sintatticamente</strong>: l'invocazione segue sempre il pattern <code>variabile.metodo()</code>, come nella maggior parte dei linguaggi (es. <code>s.toUpperCase()</code>)</li>
<li><strong>Semanticamente</strong>: possiamo specificare come il metodo tratta la struttura in input (il "ricevitore" del metodo, ci√≤ che precede il punto, quindi per esempio <code>s</code>, in <code>s.toUpperCase()</code>). Questo √® definito dal primo parametro del metodo che pu√≤ essere <code>self</code>, <code>ref self</code>, o <code>ref mut self</code>.</li>
</ul>
<p>In realt√† esistono anche altre combinazioni pi√π avanzate: il ricevitore potrebbe essere un <code>Box&lt;self&gt;</code>, <code>Pin&lt;self&gt;</code>, <code>Rc&lt;self&gt;</code>, <code>Arc&lt;self&gt;</code>, e altre‚Ä¶
Rust gestisce ciascuna di queste varianti con un significato specifico.</p>
<p><img src="images/tipi_composti/image%2019.png" alt="image.png" /></p>
<p>Il primo parametro di ciascun metodo indica come il metodo acceder√† all'istanza.</p>
<p>Se il primo parametro √® <code>self</code> scritto minuscolo, vuol dire che il metodo <strong>prende possesso</strong> del ricevitore. Quindi il ricevitore viene mosso dentro il metodo e il metodo ci fa quello che gli pare. Prendendone possesso pu√≤ leggerlo, scriverlo o distruggerlo come preferisce.</p>
<p>Se il primo parametro √® <code>ref self</code>, il metodo accede in <strong>prestito</strong> alla struct e la legge. Se il primo parametro √® <code>ref mut self</code>, il metodo accede in <strong>lettura-scrittura</strong> tramite un prestito.</p>
<p>Queste tre notazioni - <code>self</code>, <code>ref self</code>, <code>ref mut self</code> - sono semplicemente una contrazione di un'espressione pi√π estesa. All'interno del metodo, il ricevitore si chiama sempre <code>self</code>, perch√© quando scriviamo <code>self</code> minuscolo √® come se scrivessimo un parametro <code>self</code> minuscolo di tipo <code>Self</code> maiuscolo.</p>
<p><em>E cos'√® il tipo</em> <code>Self</code> <em>maiuscolo?</em>
√à una <strong>parola chiave riservata</strong> che rappresenta il tipo che stiamo implementando. Quando facciamo <code>impl Player</code>, <code>Self</code> maiuscolo diventa <code>Player</code>. Quindi nei blocchi <code>impl</code>, la parola chiave <code>Self</code> maiuscolo rappresenta il tipo che stiamo implementando.</p>
<p>Quindi <code>self</code> minuscolo √® un modo conciso per dire <em>"ho un primo parametro</em> <code>self</code> <em>minuscolo di tipo</em> <code>Self</code> <em>grande",</em> cio√® prendo possesso del ricevitore. Analogamente, <code>ref self</code> √® una contrazione di <code>self: &amp;Self</code>, cio√® la variabile <code>self</code> √® un riferimento al tipo che stiamo implementando. E <code>ref mut self</code> √® <code>self: &amp;mut Self</code>. Queste tre forme sono cos√¨ frequenti che il compilatore le riconosce e gestisce automaticamente.</p>
<p>In situazioni pi√π complesse, come quando vogliamo operare su un <code>Box</code> o simili, non avremo una sintassi analoga e dovremo scriverlo esplicitamente. Ad esempio, se volessimo che il nostro metodo operasse solo su istanze <em>boxed</em> di un certo dato, dovremmo scrivere <code>self: Box&lt;Self&gt;</code>. Questo funziona tecnicamente, ma rende il codice pi√π difficile da gestire, specialmente quando si introducono i tratti.</p>
<p>√à importante notare che il parametro <code>self</code>, se presente, <strong>deve essere il primo</strong>. Se lo mettiamo come secondo, terzo o quarto parametro, il compilatore non lo accetta. Ma perch√© <em>"se presente"</em>? Perch√© potremmo anche avere un metodo che non prende <code>self</code> - questo sarebbe un <strong>metodo statico</strong>, che possiamo cio√® chiamare senza un ricevitore.</p>
<p><em>Qual √® l'utilit√† di un metodo senza ricevitore?</em>
Il caso pi√π comune √® quello del <strong>costruttore</strong>. Serve per creare un'istanza. Nell'esempio precedente abbiamo usato una funzione <code>f</code> per creare oggetti. Ma quella era una funzione slegata dalla classe che casualmente ritornava un oggetto di tipo <code>Test</code> - si pu√≤ fare, ma non mi fa capire bene come stanno le cose.</p>
<p>√à pratica comune, quando dichiariamo una struct, aggiungere nel blocco <code>impl</code> uno o pi√π metodi costruttori. Come nei tipi predefiniti del linguaggio: per un nuovo vettore scriviamo <code>let v</code> o <code>let mut v = Vec::new()</code>. Cos'√® <code>new</code>? √à un metodo che non ha argomenti (quindi non ha <code>self</code>) e ritorna <code>Self</code>. La classe <code>Vec</code> lo fornisce per creare un vettore vuoto. Ma <code>Vec</code> offre anche il metodo <code>with_capacity</code> - anch'esso senza <code>self</code>, ma con un parametro <code>usize</code> che specifica quanta memoria pre-allocare.</p>
<p><img src="images/tipi_composti/image%2020.png" alt="image.png" /></p>
<p>Vediamo alcuni esempi. La struct <code>Point</code> √® molto semplice: rappresenta un punto geometrico con due coordinate <code>x</code> e <code>y</code> numeriche. Possiamo aggiungere metodi utili per calcoli in un'ipotetica applicazione grafica.</p>
<p>Con <code>impl Point</code> aggiungiamo metodi alla struct. All'interno del blocco <code>impl</code>, il tipo <code>Self</code> significa <code>Point</code>. Questo vale fino alla chiusura del blocco - fuori dal blocco <code>impl</code>, il tipo <code>Self</code> non esiste pi√π.</p>
<p>La funzione <code>mirror</code> prende un <code>self</code> e produce un nuovo <code>Self</code>. Trasforma un punto in un altro punto, <strong>consumando</strong> l'originale ‚Äî che non c‚Äô√® pi√π!
Il nuovo punto ha le coordinate scambiate: la <code>x</code> diventa <code>y</code> e viceversa. √à un esempio di metodo che consuma il ricevitore per produrre qualcosa di diverso.</p>
<p>La funzione <code>length</code> prende <code>&amp;self</code> e calcola la distanza del punto dall'origine usando il teorema di Pitagora: radice quadrata di <code>x¬≤+ y¬≤</code>. Per accedere a <code>x</code> e <code>y</code> dobbiamo usare la notazione completa: <code>self.x</code>, <code>self.y</code>.</p>
<p>A differenza di Java o C++, dove il compilatore aggiunge automaticamente <code>this</code>, in Rust dobbiamo essere espliciti. In Java, nella classe <code>Point</code> con campi <code>x</code> e <code>y</code>, possiamo scrivere direttamente <code>x</code> o <code>return x</code> e il compilatore capisce che si tratta di <code>this.x</code>. In Rust dobbiamo sempre usare il nome completo: <code>self.x</code>, <code>self.y</code>.</p>
<p>Infine, <code>scale</code> √® un metodo che allontana il punto dall'origine moltiplicando le coordinate per un fattore di scala. Prende <code>&amp;mut self</code> (per modificare l'istanza) e il fattore di scala come parametri. Modifica l'istanza moltiplicando sia <code>self.x</code> che <code>self.y</code> per il fattore di scala.</p>
<p>Quindi quando io come primo parametro ho <code>self</code> e basta consumo il ricevitore, quando ho <code>&amp;self</code> leggo dal ricevitore, quando ho <code>&amp;mut self</code> leggo e scrivo sul ricevitore.</p>
<p><img src="images/tipi_composti/image%2021.png" alt="image.png" /></p>
<p>Dopodich√® lo uso: <code>let p1 = Point{ x: 3, y: 4 }</code>, l'ho inizializzato. Arrivo, <code>p2 = p1.mirror()</code> e quindi <code>p1</code> adesso non c'√® pi√π - <code>p1</code> √® stato consumato da <code>mirror</code>, quindi ho creato <code>p2</code> che contiene questa volta <code>(4,3)</code>. Poi faccio il conto <code>l1 = p2.length()</code>, ok, <code>length</code> non sporca <code>p2</code>, lo lascia integro e alla fine ci trover√≤ <code>(4,3)</code> e <code>5</code> come distanza per interno di Pitagora. <code>p2.scale(2)</code>, adesso <code>p2</code> √® cambiato: prima c'erano <code>(4,3)</code>, dopo ci sono <code>(8,6)</code>. A questo punto ricalcolo la <code>length</code> e chiaramente con <code>(8,6)</code> per il teorema di Pitagora mi viene <code>10</code>.</p>
<h2 id="24-costruttori"><a class="header" href="#24-costruttori">2.4 Costruttori</a></h2>
<p><img src="images/tipi_composti/image%2022.png" alt="image.png" /></p>
<p>In C++ come in Java come in tanti altri linguaggi le classi contengono dei <em>costruttori</em>. I costruttori sono dei metodi particolari che in C++ e in Java vengono riconosciuti per via del loro <strong>nome</strong>, si chiamano esattamente come la classe e hanno la responsabilit√† di creare delle versioni inizializzate, delle istanze debitamente inizializzate, riempiendo tutti i campi con dei valori appropriati.</p>
<p>In Rust non viene definito una funzione costruttrice in modo esplicito. Semplicemente, siamo noi che siamo liberi di definire all'interno della nostra <code>struct</code>, un metodo (o pi√π di uno) che ritorna <code>Self</code> maiuscolo, perch√© ritorna una nuova istanza di <code>self</code> che prima non esisteva. Normalmente si chiama <code>new</code>.</p>
<p>Siccome in Rust non esiste l'<em>overloading</em>, (in Java, in C++ io posso avere pi√π costruttori, basta che i parametri siano distinguibili e quindi da quel tipo <code>String</code>, ad esempio, posso fare una <code>String</code> che prende un'altra <code>String</code> come parametro, una <code>String</code> che prende un numero e quindi mi crea una <code>String</code> che alloca quel numero di byte nel suo buffer, etc‚Ä¶), i metodi devono chiamarsi tutti diversi: non posso avere due versioni di <code>new</code>, una con un parametro, e una senza parametro, ad esempio.</p>
<p>Di conseguenza io posso fare pi√π funzioni costruttrici inventandomi dei nomi diversi. √à esattamente quello che succede con i <code>Vec</code>. <code>Vec::new()</code> mi crea un vettore vuoto, <code>Vec::with_capacity()</code> mi crea un vettore sempre vuoto ma con preallocato un buffer di una certa dimensione.</p>
<p>La nomenclatura standard che trovate nelle classi della libreria e che siete invitati a usare, perch√© cos√¨ la gente capisce grossomodo, √® che il costruttore, diciamo, quello pi√π semplice possibile si chiama <code>new</code>, quelli che invece hanno una serie di particolarit√† sono introdotti dalla parola chiave <code>with</code>, perch√©? Perch√© questo io lo leggo come <code>nome_struct::with_something()</code> e quindi ad esempio posso avere il mio <code>Point::with_position(7,5)</code>, che mi crea un punto alla posizione <code>(7,5)</code>.</p>
<h2 id="25-distruttori"><a class="header" href="#25-distruttori">2.5 Distruttori</a></h2>
<p><img src="images/tipi_composti/image%2023.png" alt="image.png" /></p>
<p>Abbiamo avuto modo di vedere all'inizio del corso come il C++ oltre al concetto di costruttore introduca il concetto di <em>distruttore</em>, ovvero dice <em>‚Äúse nel momento in cui tu hai creato un'istanza ti sei procurato delle risorse di qualche tipo, quando sar√† ora di buttarla via questa istanza dovrai liberarti di queste risorse‚Äù</em> e quindi ci offre un metodo particolare il cui nome comincia con <code>~</code> ed √® seguito dal nome della classe stessa che viene invocato esclusivamente dal compilatore stesso nel momento in cui quel dato giunge alla fine del suo ciclo di vita.</p>
<p>C++ √® unico da questo punto di vista nel senso che in Java c'√® una cosa che gli assomiglia lontanamente che √® il metodo <code>finalize</code> che per√≤ √® deprecato e quindi sar√† tolto, forse √® gi√† stato tolto dall'ultimo versione di Java. In Rust non c'√® il concetto di distruttore come in C, scritto cos√¨, ma c'√® il tratto <code>Drop</code> che fa le veci. Se io ho bisogno di rilasciare qualcosa devo implementare per il mio tipo il tratto <code>Drop</code>. Il tratto <code>Drop</code>, se presente, mi garantisce che quando il mio valore √® giunto alla fine della sua vita viene invocato e provoca l'azione necessaria.</p>
<p>Detto questo, il fatto che non sia esplicitamente chiamato distruttore non impedisce che un paradigma di programmazione estremamente potente elaborato in C++ non sia stato sposato nel mondo di Rust. Questo paradigma estremamente potente si chiama <strong>RAII</strong>, il nome √® poco utile, letteralmente √® un acronimo di <em>Resource Acquisition Is Initialization</em>. Vi dice poco, l'acquisizione di risorse √® l'inizializzazione. Il vero motivo √® che avrebbe dovuto chiamarsi al contrario, <em>Resource Finalization Is Destruction</em>. Cio√®, se √® vero che nell'inizializzazione le risorse le prendi, √® vero soprattuto che quando vieni distrutto le risorse le devi rilasciare, finalizzare.</p>
<p>Indica sostanzialmente il fatto che un oggetto che possiede qualcosa ha la responsabilit√† di rilasciarlo. L'abbiamo gi√† raccontato tante volte, se ho aperto un <code>File</code>, nel momento in cui la mia variabile file √® giunta alla fine del suo ciclo di vita, devo andare dal sistema operativo e dire <em>"sto file non mi serve pi√π, lo chiudo".</em> Se ho acquisito un <code>Mutex</code>, devo andare dal sistema operativo e dire <em>"sto mutex non mi serve pi√π, lo rilascio".</em> Se ho aperto un <code>Socket</code>, vado al sistema operativo e gli dico <em>"non mi serve pi√π, chiudo anche il socket"</em> e cos√¨ via.</p>
<p>C'√® questa responsabilit√†. La responsabilit√† la si spartisce un po' nel punto in cui costruisco, un po' nel punto in cui distruggo. Questo ha fatto s√¨ che in C++ siano nate un certo numero di classi estremamente utili e che hanno una corrispondenza pressoch√© uno a uno, e lo incontreremo un po' pi√π avanti appena facciamo le cose di programmazione concorrente, classi che apparentemente sono stranissime. Sono classi che non hanno metodi, se non un costruttore o un distruttore. E che noi a un certo punto dichiariamo in un punto del nostro codice e non usiamo.</p>
<p>Diciamo <em>"sei scemo, perch√© hai preso questa scatola che non ti serve a niente e te la sei messa qua?"</em>
E' come se nel mio blocco di codice da qualche parte io creo l'oggetto <code>pippo</code>. Poi non lo guardo e dice <em>"che ti serve?"</em> In realt√† serve molto, perch√© quell'oggetto <code>pippo</code> nel momento in cui l'ho creato il suo costruttore pu√≤ aver fatto certe cose, ma soprattutto quando io avr√≤ finito e quell'oggetto <code>pippo</code> verr√† eliminato, il suo distruttore ne far√† delle altre. E la garanzia di quello che succede l√¨ in mezzo √® legata al fatto che il costruttore aveva iniziato e il distruttore ha chiuso.</p>
<p>Ad esempio se io devo scrivere su un database un oggetto di questo tipo, nel suo costruttore inizia la transazione. Nel suo distruttore fa il commit della transazione. E di conseguenza tutte le operazioni che io posso aver fatto, scrivi, leggi, inserisci e cancella, sono garantite a venire tutte in modo transazionale, cio√® tutte insieme oppure nessuna. Se io non avessi neanche allocato questo oggetto, non ci sarebbe stato il concetto di transazione. Lui in modo silenzioso, nel suo costruttore ha creato la transazione, se l'ha tenuta in pancia, non l'ha detto nessuno, tanto va bene cos√¨. Nel suo distruttore fa il commit e io sono pi√π che contento. Ho garantito che il mio codice esegui in modo coerente.</p>
<p>Ma se io leggo il codice e non so cosa fa il suo costruttore e il suo distruttore, dico <em>"No, ma non serve a niente, √® un orpello inutile‚Äù</em>, magari lo butto anche via e il programma non funziona pi√π. Paradigma importantissimo, Rust lo sposa pienamente. Ricordatevi, si chiama <strong>RAII</strong>, lo richiameremo pi√π volte, tutte le volte che lo incontriamo lo andiamo a riprendere.</p>
<p><img src="images/tipi_composti/image%2024.png" alt="image.png" /></p>
<p>Qui √® descritto in ulteriore dettaglio.</p>
<p><img src="images/tipi_composti/image%2025.png" alt="image.png" /></p>
<p>Qui racconta i distruttori del C++.</p>
<p><img src="images/tipi_composti/image%2026.png" alt="image.png" /></p>
<p>Allora, la <strong>distruzione in Rust</strong> √® un'istruzione che consta di due pezzi. A un certo punto io dovr√≤ <em>liberare</em> la memoria che sto occupando. Ma prima di averla liberata devo essere sicuro che quello che c'√® scritto in quella memoria non abbia un significato ulteriore, perch√© se ha un significato ulteriore devo <em>liberare il significato ulteriore</em>.</p>
<p>Per questo esiste il <strong>tratto <code>Drop</code></strong>. Il tratto Drop consiste di un unico metodo che si chiama <code>drop</code> minuscolo.</p>
<p><em>Come lo si implementa?</em>
In generale i tratti si implementano in un blocco <code>impl</code>.
Solo che il blocco impl normale √® <code>impl Nome_struttura</code>.
Per i tratti √® <code>impl Nome_Tratto for Nome_struttura</code>.</p>
<p>Qui vedete una struttura chiamata <code>Shape</code>. E quello che faccio √® <code>impl Drop for Shape</code>.</p>
<p>Quindi la struttura <code>Shape</code> viene con i suoi campi e metodi, quindi <code>struct shape</code>, campo <code>position</code>, <code>size</code> e <code>type</code>. Va bene, tutto fatto cos√¨.
Poi avr√≤ il blocco <code>impl Shape</code> e dentro avr√≤ il metodo <code>new</code>, avr√≤ il metodo <code>reposition</code>, <code>reposition_size</code>, <code>translate</code>, <code>rotate</code>, etc‚Ä¶ tutto quello di cui pu√≤ aver bisogno una Shape.
E l√¨ c'√® un bloccone impl con 200 metodi.</p>
<p>Poi separato c'√® un blocchettino, che √® quello scritto nella parte in basso a destra della slide, <code>impl Drop for Shape</code>.</p>
<p><em>E cosa fa</em> <code>impl Drop for Shape</code><em>?</em>
Dentro di s√© contiene semplicemente il metodo drop, che ha questa signature particolare, <code>&amp;mut self</code>.
Riceve un puntatore, perch√© <code>mut</code>? Perch√© io devo smontarlo probabilmente il contenuto di <code>Shape</code>, cio√® se <code>Shape</code> possedeva qualcosa devo avere la possibilit√† di farci delle cose.</p>
<p>Dopo che questo metodo ritorna, la memoria in cui stava la <code>Shape</code> viene mandata via.
Lo stack si contrae, se era solo heap viene rilasciato etc‚Ä¶ non c'√® pi√π.
<strong>Drop √® l'ultima cosa che una struct fa nel suo ciclo di vita</strong>, se viene implemento.</p>
<p><img src="images/tipi_composti/image%2027.png" alt="image.png" /></p>
<p>La presenza di <code>Drop</code> d√† la possibilit√† di implementare il concetto di RAII all'interno di Rust. Proprio per poter implementare correttamente il concetto di RAII io devo essere sicuro per√≤ che per ogni costruzione ci sia <strong>una sola invocazione a <code>Drop</code></strong>. Per questo motivo <code>Copy</code> non pu√≤ esistere con <code>Drop</code>. Perch√© se potesse esistere con <code>Drop</code> io a seguito del <code>Copy</code> avrei una costruzione originale, poi ho fatto la copia, a questo punto avremo due entit√† separate, ed entrambe distruggerebbero. Ma distruggerebbero un'unica cosa, perch√© nel <code>Copy</code> io ho fatto una copia bit-a-bit di ci√≤ che ho sullo stack, ma non di ci√≤ che ho sullo heap! E quindi non va.</p>
<p>Questo √® il motivo per cui <strong><code>Drop</code> e <code>Copy</code> non possono stare insieme, sono mutuamente esclusivi</strong>. Questo √® garantito da un vincolo per cui il tratto <code>Drop</code> √® implementabile solo per un tipo T che non sia <code>Copy</code>. Non c'√® invece nessuna restrizione sul tratto <code>Clone</code>. <code>Drop</code> e <code>Clone</code> vivono benissimo insieme. Tanto che sia <code>Vec</code> che <code>String</code>, tanto per fare due esempi semplici, implementano sia <code>Drop</code> che <code>Clone</code>.</p>
<h2 id="26-metodi-statici"><a class="header" href="#26-metodi-statici">2.6 Metodi statici</a></h2>
<p><img src="images/tipi_composti/image%2028.png" alt="image.png" /></p>
<p>Notate che il metodo <code>new</code>, oltre a essere pensato come costruttore, pu√≤ anche essere pensato in generale come <strong>metodo statico</strong>.</p>
<p><em>Perch√©?</em>
Perch√© non ha un ricevitore. Siccome la signature di <code>new</code> √® aperta tonda e chiusa tonda, non c'√® ricevitore, non c'√® scritto <code>&amp;self</code>, <code>&amp;mut self</code> o qualcosa del genere, quindi come facciamo a invocarlo? Lo invochiamo a partire dal nome della struct. <code>Vec::new()</code>, ad esempio, appunto.</p>
<p>Che √® la stessa cosa che succede in Java o negli altri linguaggi con i metodi statici (cio√® metodi che appartengono direttamente alla classe, e che possono essere invocati dunque senza un‚Äôistanza della classe, ma da questa stessa). Quando in Java voi avete il metodo statico <code>log</code>, lo chiamate <code>Math.log()</code>.</p>
<p>Allora, in Rust i <strong>metodi statici</strong> sono semplicemente dei metodi che:</p>
<ul>
<li>sono stati definiti nel blocco <code>impl</code></li>
<li>non hanno n√© un Self di qualunque genere come parametro (<code>&amp;self</code>,  <code>&amp;mut self</code>, o <code>self</code>)</li>
<li>non ritornano neanche un Self</li>
</ul>
<h1 id="3-enum"><a class="header" href="#3-enum">3. Enum</a></h1>
<p><img src="images/tipi_composti/image%2029.png" alt="image.png" /></p>
<p>Le struct sono una cosa potentissima, estremamente utile e adesso avendo imparato a scriverle ci danno un boost perch√© possiamo cominciare a scrivere delle cose un pochino pi√π sensate. Ma c'√® un concetto altrettanto potente, anzi pi√π potente, che ci abilita a fare delle cose estremamente interessanti ed √® il concetto di <strong>enum</strong>.</p>
<p>Nella sua versione <em>semplice</em> l'enum (come in C) √® semplicemente una sequenza di etichette a cui io posso associare dei valori dicendo <em>‚Äú√® pi√π facile mnemonicamente capire cosa vuol dire l'etichetta piuttosto che ricordare il singolo valore‚Äù</em>. Per cui √® pi√π facile dire <code>standard_out</code> che non <code>1</code> o <code>standard_error</code> piuttosto che <code>2</code>. Ma di fatto <code>standard_error</code> non √® nient'altro che <code>2</code> e <code>standard_out</code> vale sempre <code>1</code>, e <code>standard_in</code> vale sempre <code>0</code> (quantomeno sulle macchine di tipo POSIX). Per cui il nome √® pi√π chiaro che non il numero perch√© se io vedo <code>0</code> posso avere il dubbio <em>‚Äúma zero cos'√®?‚Äù</em> ‚Äî se io vedo scritto <code>standard_in</code> sono tranquillo, non mi confondo, quello √® il nome di un file da cui voglio leggere.</p>
<p>Quindi io posso introdurre in per esempio l‚Äôenum <code>HTTPResponse</code> ‚Äî il protocollo HTTP genera una serie di risposte, posso dire che le risposte sono dei numeri a tre cifre, potrei tenerlo come intero ma non capisco bene cosa vuol dire e allora posso elencarli.
<code>200</code> √® in realt√† la stringa "Ok". Benissimo allora faccio l'enum <code>HTTPResponse { Ok = 200, NotFound = 400, InternalError = 500 }</code>, per cui io quando nel mio codice scrivo <code>return HTTPResponse.Ok</code> poi questo  diventer√† <code>200</code>.</p>
<p>Analogamente con <code>HTTPResponse.NotFound</code>, e cos√¨ via..</p>
<p>Ma fin qua non mi √® cambiato molto ‚Äî se io non gli dessi un uguale con un valore lui li chiama <code>0,1,2</code> nel modo pi√π tranquillo possibile.</p>
<p>Dove <strong>Rust</strong> si differenzia in modo massiccio da tante altre cose √® nel darmi la possibilit√† di dire che le mie alternative non sono solo delle <em>etichette</em> ‚Äî <code>not_found</code>, <code>ok</code>, <code>internal_server_error</code>, ma sono delle intere <strong>struct</strong> che in alternativa si <strong>pongono una rispetto all'altra</strong>.</p>
<p>Ad esempio possiamo pensare ad una cosa del tipo:</p>
<ul>
<li><code>Ok</code> √® una struct vuota - √® andato tutto bene, non c'√® bisogno che aggiunga altro.</li>
<li><code>NotFound</code> ‚Äî <em>va bene, ma cosa non hai trovato?</em>
Te lo passo come stringa. In questo caso ti ho dato una struct di tipo tupla che ha un unico campo: il campo <code>0</code> che conterr√† una stringa.</li>
<li><code>InternalServerError</code> ‚Äî magari qui posso passarti una cosa pi√π ampia: ti passo una struct dettagliata che ha due campi nominati, uno si chiama <code>desc</code> che √® una stringa e l'altro <code>data</code> che contiene un array di byte dentro cui ci sar√† qualcosa che mi aiuta a capire cosa si √® rotto dentro il server.</li>
</ul>
<p>Quindi le mie <strong>enum</strong> non sono pi√π solo delle etichette che posso usare (che certamente gi√† migliorano tantissimo il mio modo di scrivere) ma <strong>si possono portare dietro delle informazioni</strong> e quelle informazioni l√¨ io le posso usare facilmente.</p>
<p><img src="images/tipi_composti/image%2030.png" alt="image.png" /></p>
<p>La cosa pi√π simile che avete le enum la incontrate con i <em><strong>tipi somma</strong></em> di <strong>TypeScript</strong>. I tipi somma sono quelli <strong>il cui dominio √® l'unione dei domini delle parti che lo costituiscono</strong>.</p>
<p>Nel caso precedente se andiamo a vedere il dominio di <code>HTTPResponse</code> √® fatto dall'unione del dominio vuoto di <code>Ok</code> (Ok vale solo Ok, non contiene nient'altro), unito all'insieme di tutte le stringhe racchiuse dentro <code>NotFound</code>, unito all'insieme di tutti gli <code>InternalError</code> che sono costituiti dal prodotto di tutte le stringhe con tutti i vettori di byte.</p>
<p>Quindi quello che io ottengo √® la capacit√† di poter tenere in una variabile di tipo <strong>enum</strong> cose molto diverse tra di loro ma, a differenza della <code>union</code> del C che mi dava la possibilit√† di tenere cose diverse ma non sapevo cosa ci stavo mettendo dentro, qua le enum vengono tutte con un prefisso: se <code>Ok</code> non c'√® niente, se √® un <code>NotFound</code> c'√® una stringa, se √® un <code>InternalServerError</code> c'√® una stringa e un array di byte. Quindi io sono certo di che cosa trovo.</p>
<h2 id="31-rappresentazione-in-memoria"><a class="header" href="#31-rappresentazione-in-memoria">3.1 Rappresentazione in memoria</a></h2>
<p><img src="images/tipi_composti/image%2031.png" alt="image.png" /></p>
<p><em>Come le rappresento le <strong>enum</strong>?</em>
Internamente sono rappresentate cos√¨: normalmente le enum hanno un primo byte che mi indica in quale delle alternative sono e poi hanno dei byte successivi in cui viene racchiusa la struttura. Ad esempio qui viene introdotta un enum <code>Shape</code> che pu√≤ essere o uno <code>Square</code> che contiene la dimensione del lato o un <code>Point</code> che contiene le coordinate <code>x</code> e <code>y</code> (che qui sono immaginate molto piccole intese come numero a 8 bit) oppure potrebbe essere <code>Empty</code>.</p>
<p>Allora banalmente Rust dice ho tre cose le chiamo <code>0</code>, <code>1</code>, <code>2</code> quindi mi preparo una struttura dove il primo byte √® gi√† indicativo: se comincia con <code>0</code> vuol dire che √® uno <code>Square</code>, se comincia con <code>1</code> √® un <code>Point</code>, se comincia con <code>2</code> √® un <code>Empty</code>.</p>
<p><em>Cosa contiene uno</em> <code>Square</code><em>?</em>
Uno Square contiene un numero <code>u32</code>, ma <code>u32</code> che allineamento ha? Allineamento √® 32 bit, vuole un multiplo di 4 byte, quindi non posso metterlo alla posizione dispari e quindi mi faccio un po' di padding ‚Äî sicuramente questa roba deve cominciare ad un multiplo di 4 e quindi io mi faccio un po' di spazio e vado a finire, cio√® mi sposto di 3 byte di padding e poi ci metter√≤ il mio intero.</p>
<p><em>Cosa contiene un</em> <code>Point</code><em>?</em>
In quel caso abbiamo 2 byte, benissimo quelli non hanno vincoli di allineamento quindi vicino all'<code>1</code> che mi dice che sono nel caso <code>Point</code> mi mette il primo e il secondo <code>u8</code>.</p>
<p>Cosa contiene un <code>Empty</code>?
Non c'√® niente, c'√® solo il tag.</p>
<p>Quindi quanto consuma complessivamente un enum di questo tipo? √à la pi√π grande di tutte: √® la prima che sono 8 byte e io alternativamente ci metto cose.
Non √® un esempio particolarmente felice perch√© spreca un mucchio di memoria, spesso volentieri Rust fa un mucchio di ottimizzazioni e riesce a compattare queste cose alquanto.</p>
<p>In quelle situazioni in cui ha certezza che sia possibile sempre capire pu√≤ anche decidere che il primo byte, quello che mi dice in quale dei casi sono caduto, lo toglie. √à la cosa che succede ad esempio quando io creo dei <em>puntatori opzionali</em>. Se il puntatore √® presente non √® nullo, se il puntatore non c'√® posso usare il valore <code>null</code> per rappresentarlo e di conseguenza io un puntatore opzionale lo rappresento su 8 byte esattamente come un puntatore non opzionale. Sapendo che tanto il valore nullo con tutti i 0 non potrebbe essere mai generato e quindi se viene scritto tutti i 0 allora vuol dire che quello l√¨ era <em>non presente</em>. Questo lascia un mucchio di libert√† al compilatore di fare le cose.</p>
<h2 id="32-enum-e-clausole-match"><a class="header" href="#32-enum-e-clausole-match">3.2 Enum e clausole match</a></h2>
<p><img src="images/tipi_composti/image%2032.png" alt="image.png" /></p>
<p>L'uso degli <strong>enum</strong> si sposa tantissimo con l'uso del <strong>match</strong> .</p>
<p><em>Perch√©?</em>
Se io qui ho un altro enum, posso avere una forma che pu√≤ essere un quadrato, un cerchio o un rettangolo. Se √® un quadrato ha un lato, se √® un cerchio ha un raggio, se √® un rettangolo ha una base o un'altezza. Supponiamo di fare la funzione calcola l'area.</p>
<p><em>Come scrivo la funzione calcola l'area?</em>
La funzione calcola l'area prende come parametro uno <code>Shape</code>, qui lo prende per movimento, potrebbe anche prenderlo per riferimento, cambierebbe poco.</p>
<p><em>Come lo tratta?</em>
Fa un match. Ricordate che match confronta il suo valore, il valore che riceve, con un set di alternative verificando che abbiamo coperto tutte le possibili. In questo caso le alternative sono tre: abbiamo detto che <code>Shape</code> √® uno <code>square</code>, o un <code>circolo</code>, o un <code>rectangle</code>.</p>
<p>E allora io scrivo <code>match shape</code>:</p>
<ul>
<li>se √® uno <code>Square</code>, questo conterr√† il campo <code>s</code>, e l'area sar√† <code>s * s</code></li>
<li>se √® un <code>Circle</code>, questo conterr√† il campo <code>r</code>, e l'area sar√† <code>r * r * 3,14</code></li>
<li>se √® un <code>Rectangle</code>, questo conterr√† i campi <code>w</code> e <code>h</code>, e l'area sar√† <code>v * w</code>.</li>
</ul>
<p>In un unico costrutto ho espresso tre computazioni disgiunte in modo molto compatto facendo leva sul <em>destructuring</em>. Cio√®, contemporaneamente lui ha matchato <code>Square</code> e ha legato alla variabile <code>s</code> il valore che c'era dentro lo <code>Square</code> che quindi posso usare per dare risposta alla mia funzione.</p>
<h3 id="321-destrutturazione-nei-costrutti-if-let-e-while-let"><a class="header" href="#321-destrutturazione-nei-costrutti-if-let-e-while-let">3.2.1 Destrutturazione nei costrutti <code>if let</code> e <code>while let</code></a></h3>
<p><img src="images/tipi_composti/image%2033.png" alt="image.png" /></p>
<p>Questa cosa qua la posso usare anche in altri modi. Quando non ho bisogno di provare tutte le strade possibili posso usare il costrutto <code>if let</code>.</p>
<p><code>If let</code> prova a vedere se √® possibile destrutturare quello che sta dopo l'uguale col pattern che viene prima. Quindi se dentro <code>Shape</code> c'era uno <code>Square</code> che conteneva un <code>s</code>, dentro <code>s</code> mi finisce il valore che mi interessava.</p>
<p>Lo posso fare con <code>if let</code>, lo posso fare con <code>while let</code>. In entrambi i casi quel <code>if</code> ha successo se √® possibile la destrutturazione, e cio√® se quello che viene dopo l'uguale ha la forma di ci√≤ che √® scritto prima dell'uguale, riempiendo quindi tutte le variabili. A volte viene anche utile per capire come √® costruita una struttura, come vedremo in un esercizio.</p>
<h2 id="33-enum-generiche"><a class="header" href="#33-enum-generiche">3.3 Enum generiche</a></h2>
<p><img src="images/tipi_composti/image%2034.png" alt="image.png" /></p>
<p>Ci sono due enum essenziali da conoscere. Una si chiama <code>Option</code> e l'altra si chiama <code>Result</code>. La maggior parte delle funzioni di sistema ritornano o degli <code>Option</code> o dei <code>Result</code>.</p>
<h3 id="331-option"><a class="header" href="#331-option">3.3.1 Option</a></h3>
<p><code>Option</code> ha solo due alternative:</p>
<ul>
<li><code>None</code> ‚Äî non c'√® niente</li>
<li><code>Some&lt;T&gt;</code> ‚Äî c'√® qualcosa di tipo generico <code>T</code></li>
</ul>
<h3 id="332-result"><a class="header" href="#332-result">3.3.2 Result</a></h3>
<p><code>Result</code> ha due alternative:</p>
<ul>
<li><code>Ok</code> ‚Äî contiene un valore</li>
<li><code>Err</code> ‚Äî contiene un altro valore che per√≤ descrive l'errore</li>
</ul>
<p><code>Result</code> si usa per tutte le volte in cui fate qualcosa che pu√≤ rompersi, ad esempio leggere dal disco. Se io leggo dal disco l'operazione potrebbe rompersi e quindi mi arriva un <code>Result</code>. Se va bene c'√® <code>Ok</code> e dentro <code>Ok</code> c'√® scritto quello che ha letto. Se va male c'√® <code>Err</code> e dentro <code>Err</code> c'√® scritto perch√© si √® rotto, ad esempio non hai diritti di accesso, il file non esiste o qualcosa del genere...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polimorfismo---malnati-11-12"><a class="header" href="#polimorfismo---malnati-11-12">Polimorfismo - Malnati 11-12 <!-- omit in toc --></a></h1>
<h1 id="indice-7"><a class="header" href="#indice-7">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="08-polimorfismo.html#1-introduzione-al-polimorfismo">1. Introduzione al Polimorfismo</a>
<ul>
<li><a href="08-polimorfismo.html#11-concetti-base">1.1 Concetti Base</a></li>
<li><a href="08-polimorfismo.html#12-implementazione-nei-linguaggi">1.2 Implementazione nei Linguaggi</a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#2-ereditariet%C3%A0-e-polimorfismo-in-c">2. Ereditariet√† e Polimorfismo in C++</a>
<ul>
<li><a href="08-polimorfismo.html#21-costi-del-polimorfismo">2.1 Costi del Polimorfismo</a></li>
<li><a href="08-polimorfismo.html#22-metodi-virtuali-puri--funzioni-virtuali-astratte">2.2 Metodi virtuali puri / funzioni virtuali astratte</a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#3-tratti-in-rust">3. Tratti in Rust</a>
<ul>
<li><a href="08-polimorfismo.html#31-concetto-di-tratto">3.1 Concetto di Tratto</a></li>
<li><a href="08-polimorfismo.html#32-esempio">3.2 Esempio</a></li>
<li><a href="08-polimorfismo.html#33-vtable-in-rust">3.3 VTable in Rust</a></li>
<li><a href="08-polimorfismo.html#34-definire-ed-usare-un-tratto">3.4 Definire ed usare un tratto</a></li>
<li><a href="08-polimorfismo.html#35-tipi-associati-nei-tratti">3.5 Tipi Associati nei Tratti</a></li>
<li><a href="08-polimorfismo.html#36-implementazioni-default-nei-tratti">3.6 Implementazioni Default nei Tratti</a></li>
<li><a href="08-polimorfismo.html#37-gerarchia-dei-tratti">3.7 Gerarchia dei Tratti</a></li>
<li><a href="08-polimorfismo.html#38-come-invochiamo-un-tratto">3.8 Come invochiamo un tratto?</a></li>
<li><a href="08-polimorfismo.html#39-tratti-nella-libreria-standard">3.9 Tratti nella Libreria Standard</a>
<ul>
<li><a href="08-polimorfismo.html#391-eq-e-partialeq">3.9.1 Eq e PartialEq</a></li>
<li><a href="08-polimorfismo.html#392-ord-e-partialord">3.9.2 Ord e PartialOrd</a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#310-display-e-debug">3.10 Display e Debug</a>
<ul>
<li><a href="08-polimorfismo.html#3101-esempio">3.10.1 Esempio</a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#311-clone-e-copy">3.11 Clone e Copy</a></li>
<li><a href="08-polimorfismo.html#312-drop">3.12 Drop</a></li>
<li><a href="08-polimorfismo.html#313-index">3.13 Index</a></li>
<li><a href="08-polimorfismo.html#314-deref">3.14 Deref</a>
<ul>
<li><a href="08-polimorfismo.html#3141-esempio">3.14.1 Esempio</a></li>
<li><a href="08-polimorfismo.html#3142-esempio">3.14.2 Esempio</a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#315-rangebounds">3.15 RangeBounds</a></li>
<li><a href="08-polimorfismo.html#316-from">3.16 From</a>
<ul>
<li><a href="08-polimorfismo.html#3161-esempio">3.16.1 Esempio</a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#317-tryfrom-e-tryinto">3.17 TryFrom e TryInto</a></li>
<li><a href="08-polimorfismo.html#318-error">3.18 Error</a></li>
<li><a href="08-polimorfismo.html#319-la-macro-derive">3.19 La macro <code>derive</code></a></li>
</ul>
</li>
<li><a href="08-polimorfismo.html#4-tipi-generici">4. Tipi generici</a>
<ul>
<li><a href="08-polimorfismo.html#41-complementarit%C3%A0-dei-due-approcci">4.1 Complementarit√† dei Due Approcci</a></li>
<li><a href="08-polimorfismo.html#42-esempio">4.2 Esempio</a></li>
<li><a href="08-polimorfismo.html#43-relazione-tra-tratti-e-tipi-generici">4.3 Relazione tra Tratti e Tipi Generici</a></li>
<li><a href="08-polimorfismo.html#44-oggetti-tratto-e-polimorfismo">4.4 Oggetti Tratto e Polimorfismo</a></li>
<li><a href="08-polimorfismo.html#45-compromessi-e-ottimizzazioni">4.5 Compromessi e Ottimizzazioni</a></li>
</ul>
</li>
</ul>
<h1 id="1-introduzione-al-polimorfismo"><a class="header" href="#1-introduzione-al-polimorfismo">1. Introduzione al Polimorfismo</a></h1>
<p>Questa lezione spazia su diversi concetti, alcuni dei quali probabilmente vi sono gi√† noti, altri magari vi sono noti ma non li avete messi a fuoco con le parole giuste. Utilizzeremo alcuni termini che suonano strani, ma sono semplici per la verit√†. Vediamo di mettere insieme i vari problemi.</p>
<p>Di per s√© la lezione tratta del <em><strong>polimorfismo</strong></em>, che si realizza concretamente con tecniche diverse. Nel caso specifico di Rust si realizza con un misto tra l'uso dei <em><strong>tratti</strong></em> e l'uso della <em><strong>programmazione generica</strong></em>. Sono due termini che vi dicono poco, perch√© negli altri linguaggi di programmazione esiste in parte il concetto di programmazione generica, ma √® implementato in un modo totalmente diverso. I tratti si chiamano interfacce e quindi questo mette un po' in difficolt√†.</p>
<p>Tratti e programmazione generica sono due modi diversi di implementare il polimorfismo, non sono due modi alternativi. Spesso e volentieri ci sono tratti generici, oppure nella programmazione generica si usano i tratti come vincoli su cosa pu√≤ essere reso generico. Quindi sono due cose molto intrecciate e parenti. Adesso cerchiamo di slegarle e di vedere pezzettino per pezzettino che cosa significhino.</p>
<h2 id="11-concetti-base"><a class="header" href="#11-concetti-base">1.1 Concetti Base</a></h2>
<p><img src="images/polimorfismo/image.png" alt="image.png" /></p>
<p>Di base, nel momento in cui noi ci troviamo di fronte a un problema, ad esempio dobbiamo realizzare un programma che copi tutte le mail presenti sul server e le sposti all'interno di tanti file in una qualche cartella, siamo portati a cominciare a entrare nel dominio del problema ‚Äî in questo caso esempio il problema tratta di mail, mail che stanno su un server, quel server ha bisogno di un'autenticazione e cos√¨ via...</p>
<p>Abbiamo una serie di concetti che dobbiamo fare entrare nel nostro programma e tendenzialmente noi utilizziamo tipi diversi per rappresentare questa entit√† del mondo con cui dobbiamo fare. Per cui ci viene abbastanza naturale creare una struttura dati che rappresenta il singolo <strong>messaggio</strong>, una struttura dati che rappresenta magari una <strong>collezione di messaggi</strong> come la <em>inbox</em>, una struttura dati che rappresenta le <strong>credenziali</strong> con le quali noi possiamo collegarci al server per poterci accedere, una struttura dati che rappresenta il <strong>server</strong> in quanto tale con il suo indirizzo e altre cose etc...</p>
<p>Quindi la tendenza di base √® una tendenza alla moltiplicazione degi enti, dei tipi. Questi tipi possono essere strutture, possono essere numerazioni, in alcuni casi sono funzioni. Nei linguaggi a oggetti spesso e volentieri questi diventano classi.</p>
<p>Spesso per√≤ nel fare questa operazione ci rendiamo conto che i vari tipi che abbiamo introdotto, pur rappresentando qualcosa di completamente diverso, perch√© un messaggio di posta elettronica non √® una credenziale con la quale io accedo. Un messaggio ha i campi <code>from</code>, <code>to</code>, <code>date</code>, <code>body</code>, <code>subject</code>. Le credenziali hanno <code>user</code> e <code>password</code>, a volte qualcosa in pi√π, magari c'√® anche il codice one time che ho mandato sul cellulare o altre cose del genere.</p>
<p>Per√≤ magari hanno delle caratteristiche comuni. Entrambi per esempio devono essere trasformabili in un oggetto json per poterlo mandare in giro per il mondo in modo comodo. Entrambi al contrario devono poter essere leggibili da un oggetto json e questo oggetto json, che di fatto √® una stringa, dovr√† essere usato per riempire i campi del mio oggetto. Quindi anche se ho due entit√† molto diverse tra di loro, le credenziali e il messaggio, c'√® un aspetto comune perch√© entrambi sono <em>serializzabili</em> e <em>deserializzabili</em> nel formato json.</p>
<p>Ma potrei trovare altre caratteristiche che a volte hanno in comune cose molto diverse.</p>
<p>Chiaramente nessuno mi impedisce di dire, <em>‚Äúscrivo il codice per trasformare in json il mio messaggio e lo metto nella classe (o struct)</em> <code>EmailMessage</code><em>, poi un codice molto simile, magari in certi aspetti potrebbe anche essere lo stesso, se sono abbastanza bravo nel renderlo parametrico, lo posso mettere anche nella classe o nella struct</em> <code>Credentials</code> <em>che mi rappresenta delle altre cose‚Äù</em>.</p>
<p>S√¨, si pu√≤ fare, ma non √® un'idea saggia.</p>
<p>Perch√©? Perch√© c'√® un principio molto forte nella programmazione che si chiama <strong>DRY</strong>, che vuol dire "<em>don't repeat yourself</em>", evita di scrivere la stessa cosa in due posti diversi. Perch√©? Perch√© la probabilit√† che quella cosa cambi √® alta, e se tu l'hai scritta in pi√π posti devi cambiarla in tutti, e devi ricordarteli tutti ‚Äî √® un casino.</p>
<p>Per questo motivo spesso si adotta una tecnica che prende il nome di <strong>polimorfismo</strong>, ovvero offrire comportamenti <em>comuni</em> a cose che sono <em>eterogenee</em> tra di loro. Il concetto di polimorfismo l'avrete incontrato nella <em>programmazione a oggetti</em>, dove capita che grazie al meccanismo della <strong>ereditariet√†</strong> uno possa dire <em>"sai che c'√®? Io definisco questo comportamento comune in una <strong>superclasse</strong> e faccio ereditare le mie classi concrete da questa superclasse comune, cosicch√© lo scrivo una volta sola e automaticamente le mie due classi derivate ereditano, si trovano questo comportamento".</em></p>
<p>L'idea che venti/trenta anni fa sembrava sagacissima, e quindi tutti dicevano <em>"bella la programmazione a oggetti, l'ereditariet√†, grande idea"</em>, in realt√† √® un po' un casino, perch√© l'ereditariet√† si porta dietro tutta una serie di altri vincoli, anche solo concettuali.</p>
<p>Mentre per alcuni versi funziona bene in alcune situazioni, ad esempio, un mondo che viene spesso utilizzato √® quello della natura: abbiamo il concetto di <em>essere vivente ‚Äî</em> gli esseri viventi respirano, mangiano, dormono, emettono suoni.</p>
<p>Allora io modello la classe <code>EssereVivente</code> che ha questo comportamento base, poi derivo dagli esseri viventi gli animali, i vegetali, dagli animali tiro fuori i pesci rispetto ai mammiferi, rispetto a cosa, etc...</p>
<p>L√¨ un po' funziona, perch√©?
Perch√© il vincolo dell'ereditariet√† √® che una classe derivata <strong>deve essere anche la classe superiore.</strong>
√à abbastanza normale dire che un <em>pinguino</em> √® un <em>uccello,</em> che a sua volta √® un <em>animale</em>, che a sua volta √® un <em>essere vivente</em>. E ci sta ragionevolmente in questa catena di situazioni, quindi dire che le propriet√† di animale scendono naturalmente sul <code>Pinguino</code> che √® una classe concreta.</p>
<p>Quando venissimo invece al nostro dominio, qual √® la classe generale per cui le credenziali sono imparentate con un messaggio di posta elettronica? √à un po' forzata la cosa, non √® proprio ovvio dire che le credenziali sono serializzabili perch√© tutto il mondo √® serializzabile. Va bene, per√≤ a questo punto di classi comuni ce ne possono essere tante ed √® uno dei motivi che ha portato <strong>Bjorn Strostrup</strong>, l'inventore del C++, a immaginare nel C++ l'<strong>ereditariet√† multipla</strong>.</p>
<p>Perch√© in fondo le credenziali possono essere imparentate con il messaggio di posta elettronica perch√© sono <strong>serializzabili</strong>, ma al contrario le credenziali possono essere imparentate con un'altra cosa perch√© sono <strong>crittografate</strong> e il messaggio di posta elettronica √® imparentato con qualcos'altro perch√©, che ne so, ha gli <em>attachments</em>, che invece le credenziali non hanno, etc‚Ä¶</p>
<p>Quindi diventa un po' complicata sta faccenda qua e trovare delle classi comuni adatte √® difficile.</p>
<h2 id="12-implementazione-nei-linguaggi"><a class="header" href="#12-implementazione-nei-linguaggi">1.2 Implementazione nei Linguaggi</a></h2>
<p>La soluzione dell'<strong>ereditariet√† multipla</strong>, che di nuovo l'idea del C++ nasce alla fine degli anni '80, inizio degli anni '90, dove tutto questo mondo era in fermento, si cercava di dargli un senso, ha fatto s√¨ che ci si scontri facilmente con dei muri. Nel momento in cui ho due o pi√π classi da cui eredito, vado in difficolt√† perch√© posso trovarmi in situazioni in cui eredito da due classi diverse che per√≤ hanno una classe in comune e si crea una situazione brutta chiamata "<em>Diamond Death</em>" in cui ho del codice duplicato. Ho due metodi con lo stesso nome che mi arrivano per strade diverse, che potenzialmente sono stati arricchiti in modo diverso. Quale uso? Boh, disastro.</p>
<p>Per questo motivo, quando <strong>Java</strong> nasce nel '92-'93 sulle orme del C++, la scelta √® stata quella dell'ereditariet√†, ma specificamente dell'<strong>ereditariet√† singola</strong>. Con una piccola ma importante sfumatura: oltre all'ereditariet√† singola, c'√® la possibilit√† di implementare pi√π interfacce. In Java potete specificare che la vostra classe <code>extends something</code> e che <code>implements something</code>.</p>
<p>Pu√≤ implementare tutte le interfacce che volete, senza alcun problema.
<em>Perch√©?</em>
Perch√© in fondo implementare un'<strong>interfaccia</strong> indica semplicemente prendersi un impegno. Io non sto ricevendo niente dall'interfaccia se non l'impegno a mettere a disposizione dei metodi che hanno un certo nome, certi parametri di ingresso e certi valori restituiti in uscita. Quindi io sto semplicemente dicendo che sono conforme a una sorta di <em>protocollo</em>, cio√® a una convenzione generale per cui gli oggetti, istanza della mia classe, sicuramente mi offriranno il metodo X, Y e Z. Come √® fatto il metodo X, Y e Z l'interfaccia non me lo dice. Toccher√† a me dargli un senso opportuno.</p>
<p>Quindi mentre nella ereditariet√† mi ritrovo nella situazione in cui prendo cose diverse concretamente, quindi non solo la garanzia che quel particolare metodo lo metto a disposizione, ma ricevo anche il codice che eventualmente posso <strong>sovrascrivere</strong>. E questo apre un altro grosso problema nell'implementazione del linguaggio: cosa vuol dire sovrascrivere un metodo? Come lo sovrascrivo e come gestisco questa sovrascrittura?</p>
<p>Mentre tutto questo ragionamento avveniva e veniva via via rifinito negli altri linguaggi che nel frattempo venivano anche introdotti, siamo alla fine degli anni '90 in cui nasce anche JavaScript, che segue una storia diversa sull'ereditariet√†. Segue un'ereditariet√† basata sul <strong>template</strong>, per cui voi instanziate classi a partire da un template e questo template potete arricchirlo etc‚Ä¶ e quindi potete fare in modo che due oggetti, istanze della stessa classe, non hanno gli stessi metodi, perch√© nel frattempo il template √® stato arricchito, dando origine ad altri mostri.</p>
<p>Mentre queste cose avvenivano, lo stesso era il periodo in cui anche in Python si cominciava a ragionare, mettiamo le classi, come le mettiamo, eccetera, Strostrup e Sochi, seguendo il filone del C++, cominciavano a maturare un'idea che era altrettanto interessante, che era quella della programmazione generica, che diceva che ci sono molte situazioni, ad esempio i contenitori, le liste, i vector, le mappe, e queste cose qua in generale, in cui l'algoritmo √® abbastanza indipendente dal tipo di dato ‚Äî una lista di numeri, una lista di stringhe, una lista di messaggi di post elettronica, sempre una lista √®.</p>
<p>Le operazioni di inserisco, cancello, sostituisco, ordino, non √® che fa differenza tanto sulla base di <em>che cosa c'√® dentro la lista</em>.
<em>Perch√© devo scrivere codice diverso?</em>
Io potrei rappresentare la mia lista, l'algoritmo, l'insieme dei metodi che definiscono la lista, come operanti su un tipo T, che non ho bisogno di specificare fin dall'inizio.</p>
<p>Tutto al pi√π posso chiedere che questo tipo T abbia delle caratteristiche, magari deve essere copiabile, perch√© se non lo posso copiare non riesco a metterlo dentro la lista. Magari deve essere confrontabile, perch√© devo poter sapere, nella lista spesso mi chiedo <em>"questo elemento √® presente?"</em>, e allora se devo poter rispondere a una domanda √® presente o √® assente, devo avere un modo di fare dei confronti. Se ho bisogno di ordinarla la mia lista, quell'elemento l√¨ non solo deve essere confrontabile, deve essere anche confrontabile per ordine, cio√® devo poter dire se viene prima o dopo di un altro.</p>
<p>Queste sono un po' delle caratteristiche che quel tipo deve avere, ma tipi che hanno le caratteristiche di essere copiabili, di essere confrontabili per identit√† e confrontabili per ordine, ce n‚Äô√® a valangate.</p>
<p>E allora posso scrivere l'algoritmo, che agisce su un tipo che √® ‚Äúlista di T‚Äù, sapendo che la mia lista funzioner√† con tanti tipi diversi e nasce l'idea della <strong>programmazione generica</strong>.</p>
<p>Quest'idea qua ha preso un po' di tempo ad assumere una forma decente e ha avuto anche lei una biforcazione, cos√¨ come la storia dell'ereditariet√† si √® biforcata varie volte (ereditariet√† singola o ereditariet√† multipla, ereditariet√† sintattica con le interfacce o non sintattica, ereditariet√† a template o ereditariet√† basata su classe etc‚Ä¶), anche la programmazione generica ha avuto delle sue evoluzioni.</p>
<p>Il C++ la introduce con un concetto di <em><strong>monomorfizzazione</strong></em>, cio√® scrivi la tua lista di T, ma quando la usi dovrai specificare un <strong>tipo concreto</strong>. Nel tuo programma avrai la lista di interi, la lista di stringhe, la lista di <code>EmailMessage</code> ‚Äî non c'√® problema! Quando specifichi cosa metti dentro la lista, io genero dalla forma generica dell'algoritmo il codice specifico per quel tipo. Per esempio, una lista di interi avr√† record di 4 byte pi√π il puntatore al next, una lista di stringhe avr√† record di 24 byte pi√π il puntatore al next, e cos√¨ via per altre dimensioni. In questo modo posso generare il codice pi√π adatto per ogni tipo concreto specifico.</p>
<p><strong>E questa √® la scelta fatta dal C++ che ritroviamo anche in Rust.</strong></p>
<p>Per contro altri linguaggi fanno scelte completamente diverse. Java, Kotlin, JavaScript, Python e altri, in realt√† partono dall'assunzione che la gerarchia di ereditariet√† ha un <em>capostipite</em>, e la presenza di questo capostipite in realt√† mi permette di scrivere, in caso di Java, "Object" ‚Äî tutto deriva da <code>Object</code>. E allora la vera implementazione della classe <code>List</code> √® in realt√† una lista di <code>Object</code>, e voi in Java questo lo vedete bene perch√© una lista di <code>int</code> semplici non la fate, perch√© gli <code>int</code> sono un'eccezione in Java e non sono oggetti, ma sono <em>valori</em>. Potete fare la lista di <code>Integer</code> con la "i" maiuscola, che sono oggetti, ma la lista di int non si pu√≤ fare.</p>
<p>E quando in Java scrivete <code>List&lt;T&gt;</code> in realt√† state semplicemente dicendo che in quella roba l√¨ potete metterci delle restrizioni che il compilatore user√† in fase di compilazione, ma alla fine il tipo verr√† cancellato. L'oggetto <code>List</code> non sa che cosa ha dentro. Se voi andate dentro l'oggetto <code>List</code> e usate l‚Äôintrospezione di Java (cio√® il fatto che ogni oggetto Java ha un campo che si chiama <code>.class</code> che permette di accedere alla definizione della classe stessa, eccetera), la lista vi dice che √® una <code>java.util.List</code>, ma non sa dirvi "list di che cosa‚Äù. Non lo pu√≤ sapere, perch√© in Java si adotta una tecnica che si chiama <em><strong>Type Erasure</strong></em> ‚Äî cancello il tipo: quello a run time √® una lista di <code>Object</code>.</p>
<p>In quanto <code>List&lt;Object&gt;</code>, lo posso fare perch√© in Java <strong>tutto</strong>, tranne i tipi elementari, deriva da oggetti. E quindi sicuramente qualunque cosa io gli metta, se non √® un tipo elementare, √® anche un oggetto, e dunque va bene.</p>
<p>In C++ invece l'ereditariet√† √® possibile, ma non √® obbligatoria. Quindi il Type Erasure non pu√≤ funzionare.</p>
<p>In Rust, invece, l'ereditariet√† non c'√® proprio. Abbiamo risolto il problema.</p>
<p>Ma il polimorfismo s√¨, quello c‚Äô√®. E allora vediamo di capire. Questo per darvi un po' un panorama storico di questa cosa, perch√© i concetti che noi oggi consideriamo pi√π o meno scontati, non sono scontati. E non sono neanche necessariamente giusti. Cio√®, il sapere un minimo dell'evoluzione dei linguaggi ci serve a capire che ad oggi, con l'esperienza che abbiamo fatto, avendo realizzato sistemi pi√π o meno grandi, si √® capito che certe cose pi√π o meno possono andare ‚Äî non √® verit√† rivelata. Via via che si va verso sistemi pi√π complessi, ci si rende conto che le astrazioni che oggi ci sembrano buone, non sono poi cos√¨ buone. Hanno dei limiti. E questo spinger√† la vostra generazione a inventare delle cose migliori.</p>
<p>Per cui noi le impariamo, cerchiamo di capirle, cerchiamo di capire perch√© quelle che prima sembravano delle buone idee, poi cos√¨ buone non erano, non erano proprio cattive. Perch√© in qualche modo funzionavano. Anche il C funziona. Non √® che non funzioni. Per√≤ se devo realizzare un sistema molto grosso, devo pensare che mi coster√† molto. E non √® detto che sia cos√¨ sostenibile. Per questo motivo cerchiamo delle rappresentazioni ulteriori.</p>
<p><img src="images/polimorfismo/image%201.png" alt="image.png" /></p>
<p>Allora, in C sintatticamente non c'√® nessun supporto per il polimorfismo. Quindi se io ho due tipi che devono avere dei comportamenti comuni, il linguaggio in quanto linguaggio non mi d√† di suo nessuna struttura sintattica che mi aiuti.
Devo scolpire tutto a mano. Si pu√≤ fare, s√¨ certo, qui vi ho messo un link, andatevelo a leggere, dove vi raccontano come si pu√≤ approcciare il polimorfismo in C.
S<em>poiler</em>: scrivendo un bel po' di cose.</p>
<p>C++, trent'anni fa, parte con l'idea che l'ereditariet√† pu√≤ essere uno strumento a favore del meccanismo polimorfico. L'ereditariet√† nasce con quest'idea: racchiudo nella classe base quel comportamento comune che le classi derivate devono avere. Cos√¨ se lo trovano, tranquillamente, senza bisogno di fare grossi pasticci. C++, nell'affrontare questa cosa, dice <em>"guarda l'ereditariet√† √® possibile, addirittura √® possibile l'ereditariet√† multipla‚Äù</em>.</p>
<p>Quindi io posso derivare dalla classe <code>Alfa</code> e anche dalla classe <code>Beta</code>. Dalla classe <code>Alfa</code> ricevo il metodo <code>m1</code>, <code>m2</code>, <code>m3</code>, dalla classe <code>Beta</code> ricevo il metodo <code>m4</code>, <code>m5</code>, <code>m6</code>. Benissimo.
La classe <code>Alfa</code> mi rende parente di qualcun altro, che anche lui deriva da <code>Alfa</code>, la classe <code>Beta</code> mi rende parente di qualcun altro che anche lui deriva da <code>Beta</code>. E va bene: si crea un mondo di classi "<em>cugine</em>", pi√π o meno con delle affinit√†, ma diverse tra di loro.</p>
<p>Non solo io posso ereditare, quindi mi ritrovo, ad esempio, l'esistenza di un metodo e della sua implementazione, ma √® anche possibile, cos√¨ come in Java e in molti altri linguaggi, <strong>sovrascrivere</strong>. In Java tutti gli <code>Object</code> hanno il metodo <code>toString</code>.</p>
<p><em>Com'√® fatto il metodo</em> <code>toString</code> <em>nella classe</em> <code>Object</code><em>?</em>
Ti stampa un numerino che sembra a caso, e in realt√† √® il suo hashcode, e poi <code>@NomeClasse</code>. Per cui se io creo un oggetto di qualche tipo, ad esempio se ho creato una classe <code>Automobile</code>, che deriva da <code>Object</code>, e faccio <code>Automobile a = new Automobile()</code> e poi faccio <code>a.toString()</code>, vedr√≤ <code>7b5f49@Automobile</code>, o nome del package, quindi <code>it.polito.Automobile</code>.</p>
<p><em>E' utile?</em>
Meglio che niente, ma certo che se devo farlo vedere a un utente non √® che ci capisca molto, per cui non solo io eredito il metodo <code>toString</code>, ma ho la possibilit√† di fare <strong>l'override</strong>, ovvero nella classe automobile posso dire:</p>
<pre><code class="language-java">@Override
public String toString() {
    return "Car {" +
            "manifacturer ='" + manifacturer + '\'' +
            ", model ='" + model + '\'' +
            ", color =" + color +
            '}';
}
</code></pre>
<p>Java naturalmente introduce il concetto di polimorfismo e di <strong>metodi virtuali</strong>, perch√©? Perch√© se io prendo la mia Automobile <code>a</code>, quindi <code>a</code> √® una variabile di classe <code>Automobile</code>, la posso salvare dentro una variabile <code>o</code> di tipo <code>Object</code>? Certo che lo posso fare, √® lecito, la <code>Automobile</code> √® un <code>Object</code>, e quindi questa operazione la posso fare.</p>
<p>A quel punto se sull'Object <code>o</code> facessi <code>toString</code>, continuerei a vedere la versione di <code>toString</code> di <code>Automobile</code>. Non ci vedo l'implementazione che deriva dalla classe <code>Object</code>.
Cio√®, i metodi che sono <em><strong>overridden</strong></em>, legati a una certa istanza, si ricordano di preciso a che istanza appartengono, anche se sono memorizzati in una variabile che non conosce i dettagli di quella classe l√¨.</p>
<p>Questo √® per il fatto che in Java tutti i metodi pubblici sono naturalmente <strong>virtuali</strong>, ovvero, <strong>tengono traccia della classe concreta a cui l'istanza appartiene</strong>. Il modo con cui in Java questo pu√≤ avvenire √® perch√© tutte le istanze si portano dietro il punto class. Quindi gli oggetti in Java sono naturalmente pi√π grassi, perch√© devono tenersi traccia della classe vera a cui appartengono. Per cui se voi avete un <code>Object</code> di cui non sapete nient'altro, ma gli fate <code>System.out.println(o.getClass())</code>, lui vi dice che in realt√† non √® un <code>Object</code>, √® <code>Java.util.List</code>. Quindi il fatto che gli oggetti conoscano la classe gli rende facile sapere delle cose.</p>
<p>In C++ questa cosa non si √® voluta assolutamente fare, perch√©? Perch√© questo obbliga, nel mondo di Java (che peraltro √® un mondo supportato a una virtual machine, quindi che ha un costo associato non trascurabile), a tenere in memoria una rappresentazione delle classi. Nei programmi C e C++ e in generale nella programmazione di sistema, dove si lavora a basso livello, le classi, i tipi dati, eccetera, sono concetti che esistono solo nel codice sorgente, non ci sono nel run time. Non li vedo, ne vedo gli effetti. Se ho definito che la mia struct aveva due numeri e una stringa, guardando la struttura del run time, trover√≤ effettivamente il campo <em>numero1</em>, il campo <em>numero2</em>, il campo <em>stringa</em>. Ma non c'√® pi√π scritto che era cos√¨, √® compilato, cio√® il codice sa che all'offset 12 trova una cosa, all'offset 54 ne trova un'altra, punto. Ma ha perso di vista quella che era la struttura. Non potete interrogare un programma in C o in C++ per dire <em>"raccontami come sono fatte le tue classi".</em> Non c'√® questa consapevolezza, questa introspezione. Non c'√® perch√©, altrimenti ci porteremo dietro montagne di cose che va un po' contro l'efficienza.</p>
<p><em>Come posso, in assenza di introspezione, permettere comunque di garantire un comportamento polimorfico?</em>
La scelta dei signori del C++ √® stato quello di dire <em>"attenzione, prima di tutto non √® vero che tutti i metodi devono essere virtuali, perch√© √® una caratteristica che costa. Quindi, caro programmatore, dimmelo un po' tu, quelli che vuoi, dove vuoi spendere e dove non vuoi spendere.</em> <em>Dove non vuoi spendere questo comportamento non c'√®, e fine. Dove vuoi spendere io te lo do</em>".</p>
<p><em>Come faccio a dire che voglio spendere?</em>
Mi indichi che quel metodo l√¨ √® <strong>virtual</strong>, quindi il C++ introduce una parola chiave in pi√π, <code>virtual</code>, che permette di far capire che quel particolare metodo potr√† essere, nelle sottoclassi, sovrascritto e cambiato. Dopodich√©, per gestirsi questa cosa, C++ dice <em>"se una classe ha dei metodi virtual, io devo aggiungere nelle istanze un pezzettino"</em>: ogni istanza di una classe che ha almeno un metodo virtual, ha un puntatore in pi√π. Questo √® un costo in termini di memoria.</p>
<p><em>E cos'√® sto puntatore in pi√π?</em>
√à un puntatore a una struttura dati che si chiama <em><strong>Vtable</strong></em>. Adesso la vediamo disegnata cos√¨ riusciamo a capire. Questa struttura dati non √® nient'altro che una tabellina che contiene il puntatore all'implementazione concreta del metodo virtual che io sto chiamando. Questo vuol dire che chiamare un metodo virtual in C++ costa di pi√π che chiamare un metodo semplice. Mi costa di pi√π in termini di spazio, perch√© per avere un metodo virtual io devo avere il campo Vtable, che √® nascosto ma c'√®. Mi costa in termini di tempo, perch√© quella chiamata √® indiretta. Quindi io vado dentro un array, prelevo l'iesimo elemento, che √® l'effettivo indirizzo a cui dovr√≤ saltare. Solo a runtime sapr√≤ effettivamente quale metodo concreto sto chiamando. Questo mi fa perdere qualche ciclo macchina.</p>
<p>In Java voi perennemente perdete memoria, perch√© tutti i vostri oggetti contengono metodi virtuali, e perdete perennemente tempo, perch√© ogni volta che avete l'invocazione di un metodo dovete andare nella struttura class e andare a recuperare il metodo.. cio√®, non lo fate voi, lo fa la Java Virtual Machine per voi, ma questo ha un suo costo.</p>
<h1 id="2-ereditariet√†-e-polimorfismo-in-c"><a class="header" href="#2-ereditariet√†-e-polimorfismo-in-c">2. Ereditariet√† e Polimorfismo in C++</a></h1>
<p><img src="images/polimorfismo/image%202.png" alt="image.png" /></p>
<p><strong>Prendiamo questo esempio qua banale.</strong></p>
<p><strong>Classe Alfa:</strong> qui abbiamo una classe <code>Alfa</code> che contiene dentro di s√© un unico campo, <code>bool b</code>, e ha un metodo chiamato <code>getValue</code> che √® marcato con la parola chiave <em>virtual</em>, per far capire che questo metodo potr√† essere cambiato dalle sottoclassi. La versione di <code>Alfa</code> √® che questo metodo ritorna <code>1</code>.
Se instanzio oggetti di questa classe, questi occuperanno 1 byte (per il boolean <code>b</code>) pi√π 8 byte (per il puntatore alla vtable che tiene traccia dell‚Äôimplementazione di <code>getValue</code>, essendo questo un metodo virtuale) e dunque 1 + 8 = 9 ‚Üí Scomodo, e quindi prima potenza di 2 per allineamento = 16.
Un oggetto di classe <code>Alfa</code> occuper√† 16 byte in memoria ‚Äî notiamo gi√† quanto ‚Äúspreco‚Äù di memoria ci causa avere un metodo virtuale.</p>
<p><strong>Classe Beta:</strong> poi creo la classe <code>Beta</code>, che √® una sottoclasse di <code>Alfa</code>. <code>Class beta : public alfa</code>, quindi beta estende alfa. Estendendo alfa naturalmente eredita quello che c'√® dentro alfa. Eredita un campo b, booleano, che per√≤ per lei √® inaccessibile, perch√© sopra era privato. Non c'√® nessun modificatore davanti, quindi quello √® un campo privato. C'√®, ce l'ho in pancia, ma non lo posso vedere. E poi un campo <code>i</code> che invece √® proprio mio, ci posso fare delle cose. Dopodich√© non mi piaceva l'implementazione che ho ricevuto dall'alto di <code>getValue</code>. Quell'altro tornava un <code>1</code>, ma io sono un <code>Beta</code>, quindi lo cambio, e dico che torno <code>2</code>.
Analogamente per quanto descritto per <code>Alfa</code>, qui avremo 4 byte in pi√π per la variabile <code>i</code>, che ci stanno benissimo in quei 7 byte di padding in pi√π che avevamo in <code>Alfa</code>, quindi anche in questo caso abbiamo un‚Äôoccupazione in memoria di 16 byte totali, per oggetti di classe <code>Beta</code>.
Chiaramente, <code>Beta</code> ha un puntatore ad una sua vtable, con la relativa implementazione di <code>getValue</code> per la classe <code>Beta</code>.</p>
<p><strong>Classe Gamma:</strong> e poi un'altra classe <code>Gamma</code>, che √® sorella di beta, perch√© anche lei deriva da <code>Alfa</code>. Questa invece ha un campo privato suo <code>c</code>, di tipo <code>char</code>, anche lei ha il <code>b</code> booleano che non pu√≤ vedere, ce l'ha dentro ma non ci pu√≤ fare niente. E poi ha il suo metodo <code>getValue</code>, in cui invece ritorna <code>3</code>.
Anche qui, stesso discorso di sopra: in totale anche gli oggetti <code>Gamma</code> occupano 16 byte in memoria.</p>
<p>Questa √® la struttura delle classi, semplice.</p>
<p>A destra vediamo come le usiamo. Le usiamo con dei puntatori.</p>
<p>E quindi dichiaro un primo puntatore <code>ptr1</code> di tipo <code>Alfa</code> e posso dire che punta a un oggetto, a un'istanza di <code>Alfa</code>, quindi quel puntatore l√¨ che sono 8 byte punta da qualche parte nello heap a un blocco di 16 byte, e dentro mi crea un oggetto del genere.</p>
<p>Poi dichiaro un altro puntatore sempre di tipo <code>Alfa</code> (e lo posso fare perch√© <code>Beta</code> <em>is</em> <code>Alfa</code>) e chiedo di allocare altri 16 byte sullo heap per un oggetto <code>Beta</code>.</p>
<p>Discorso analogo per <code>ptr3</code>, che punter√† ad un blocco di 16 byte per contenere un oggetto <code>Gamma</code>.</p>
<p>Siccome tutti e 3 sono <code>Alfa</code>, tutti e 3 hanno sicuramente il metodo pubblico <code>getValue</code>. Vediamo che se lo invochiamo, torna i 3 valori diversi.</p>
<p><em>Come fa il compilatore a fare in modo che mi escano 3 risposte diverse per del codice che mi appare uguale?</em>
Perch√© se io mi limito a guardare le 3 righe in cui invoco il metodo <code>getValue</code>, ptr1, ptr2, ptr3 sono dello stesso tipo: sono tutti e 3 degli <code>Alfa*</code>. Eppure se io eseguo questo codice vedo effettivamente che mi ritornano 1, 2, 3. <em>Come √® possibile?</em></p>
<p><img src="images/polimorfismo/image%203.png" alt="image.png" /></p>
<p>Qui c'√® rappresentata la versione di queste classi evidenziando l‚Äôereditariet√†, c'√® la classe madre <code>Alfa</code> in alto che ha il suo metodo <code>getValue</code> e il suo campo privato <code>b</code>.</p>
<p>Sotto c'√® la classe <code>Beta</code> che ha il campo <code>b</code> ereditato ma inaccessibile (ha anche del padding che qua non √® esplicitato, ma c'√®) e poi c'√® l'intero <code>i</code>, con la sua versione <em>rossa</em> di <code>getValue</code>.</p>
<p>E poi c'√® la classe <code>Gamma</code> che ha sempre il booleano <code>b</code> ereditato, poi il carattere <code>c</code> e anche qui la sua versione <em>blu</em> di <code>getValue</code>.</p>
<p>Ma nero, rosso, e blu sono messi solo per un motivo didattico ‚Äî per far vedere che sono 3 cose diverse. Ma per il compilatore quello non si capisce.</p>
<p><img src="images/polimorfismo/image%204.png" alt="image.png" /></p>
<p>Allora, quello che realmente succede √® la seguente cosa.</p>
<p>Quando io dico <code>Alfa *ptr = new Alfa()</code> viene allocato il nostro blocco da 16 byte, in cui i primi 8 byte sono un puntatore alla vtable, ed in particolare la vtable di <code>Alfa</code>, che ha un‚Äôunica entry perch√® abbiamo un solo metodo virtuale. Tale entry √® un puntatore all‚Äôimplementazione di <code>getValue</code> per la classe <code>Alfa</code>.</p>
<p>Stesso discorso per le classi <code>Beta</code> e <code>Gamma</code>, i cui blocchi per√≤ puntano ognuno ad una vtable diversa, la quale a sua volta punta ad una implementazione diversa di <code>getValue</code>!</p>
<p>Questo √® come C++ implementa il polimorfismo.
Il costo √® che tutti questi oggetti, in assenza di metodi virtuali, sarebbero stati molto pi√π piccoli, e invece ora pesano tutti 16 byte (<code>Alfa</code>, ad esempio, sarebbe pesato solo 1 byte: cio√® lo spazio necessario per contenere il booleano).</p>
<p>Un altro costo √® che le invocazioni a getValue devono fare un po‚Äô di salti: quando viene eseguita <code>ptr1-&gt;getValue();</code>, bisogna necessariamente passare dalla vtable per capire qual √® l‚Äôimplementazione di <code>getValue</code> ‚Äî il codice generato dall‚Äôistruzione <code>ptr1‚ÜígetValue();</code> non contiene subito l‚Äôindirizzo della funzione da chiamare, perch√® non lo pu√≤ sapere: lo sapr√† solo a run time.
Notiamo che gli step sono:</p>
<ul>
<li>Segui il puntatore</li>
<li>Accedi alla vtable</li>
<li>Recupera la i-esima entry (in questo caso <code>getValue</code> √® l‚Äôunico metodo che c‚Äô√®, quindi sar√† la prima e unica entry)</li>
<li>Segui il puntatore contenuto nella entry per effettivamente accedere al codice del metodo desiderato</li>
</ul>
<p>Ed in caso di ereditariet√† multipla con metodo virtuale da entrambi i genitori, le vtable sono separate!</p>
<p>Questo nel C++ √® fautore di una serie di problemi, perch√© quando tu scrivi <code>Alfa *ptr2 = new Beta()</code>, di fatto hai creato il <code>Beta</code>, ma stai prendendo la vtable del padre, che contiene in questo caso <code>getValue</code>.</p>
<p>Nel caso di due genitori separati, dentro <code>Beta</code> troviamo due vtable: quando creiamo un oggetto con <code>new Beta</code>, supponiamo all'indirizzo 1000, viene allocata sia la vtable propria di <code>Beta</code> che quella del primo genitore, contenente i suoi metodi.
La prima tabella contiene in sequenza i metodi del genitore di <code>Beta</code> seguiti da quelli propri di <code>Beta</code>. I metodi del secondo genitore si trovano invece in una vtable separata, posizionata pi√π avanti in memoria.</p>
<p>Quando assegniamo <code>Beta</code> a <code>ptr2</code>, se il puntatore √® di tipo <code>Beta</code> o del primo genitore, assegniamo l'indirizzo 1000. Ma se <code>ptr2</code> √® un puntatore al secondo genitore, gli assegniamo l'indirizzo della seconda vtable!</p>
<p>Di conseguenza, gli oggetti in C++ con ereditariet√† multipla non hanno un unico indirizzo, ma <strong>ne hanno tanti quanti sono i loro genitori</strong>. Questi indirizzi, pur essendo vicini in memoria, sono distinti. Questo crea un problema serio: se salviamo lo stesso oggetto <code>Beta</code> in due puntatori <code>ptr1</code> e <code>ptr2</code> riferiti ai diversi genitori (cio√® dichiarando <code>ptr1</code> come puntatore a <code>Beta</code>, o <code>genitore1</code> di <code>Beta</code>, e <code>ptr2</code> invece come puntatore a <code>genitore2</code> di <code>Beta</code>) e poi confrontiamo i puntatori, risulteranno diversi nonostante puntino allo stesso oggetto ‚Äî una vera tragedia!</p>
<p>L'ereditariet√† multipla in C++ presenta diverse <strong>complessit√†</strong>, tanto che i progettisti di Java hanno deciso di eliminarla completamente. Nonostante offra molte possibilit√†, richiede che il programmatore abbia una <em>comprensione approfondita</em> dei meccanismi sottostanti.</p>
<h2 id="21-costi-del-polimorfismo"><a class="header" href="#21-costi-del-polimorfismo">2.1 Costi del Polimorfismo</a></h2>
<p>Il punto cruciale, tralasciando l'ereditariet√† multipla, √® il meccanismo di <strong>late binding</strong> che permette di determinare a runtime quale metodo chiamare. C++ implementa questo attraverso la vtable, ma ci√≤ comporta un <em>overhead</em> nella dimensione degli oggetti: un oggetto che potrebbe occupare un solo byte finisce per occuparne 16 (8 per il puntatore pi√π padding per l'allineamento).</p>
<p>Questo comporta due costi significativi:</p>
<ul>
<li>Un <strong>costo di spazio</strong>: nel caso di Alfa, ad esempio, abbiamo uno spreco di 15/16 dello spazio allocato</li>
<li>Un <strong>costo di tempo</strong>: quando invochiamo <code>ptr1-&gt;getValue()</code>, non possiamo determinare l'indirizzo in fase di compilazione. Dobbiamo prima consultare la vtable, con possibili penalizzazioni dovute a cache miss</li>
</ul>
<p>Se Gamma ridefinisce solo <code>getValue</code>, avremo sempre un solo metodo virtuale. Estendendo Beta, Gamma potrebbe aggiungere i propri metodi: la sua vtable inizierebbe con i metodi della vtable di Beta pi√π i propri. √à possibile chiamare esplicitamente i metodi con la sintassi <code>Alfa::getValue</code>.</p>
<h2 id="22-metodi-virtuali-puri--funzioni-virtuali-astratte"><a class="header" href="#22-metodi-virtuali-puri--funzioni-virtuali-astratte">2.2 Metodi virtuali puri / funzioni virtuali astratte</a></h2>
<p><img src="images/polimorfismo/image%205.png" alt="image.png" /></p>
<p>√à importante notare che <em>non tutte</em> le chiamate in C++ seguono questo meccanismo - sarebbe inefficiente. Solo i metodi marcati come <code>virtual</code> utilizzano la vtable. Per i metodi non virtuali, quando questi vengono chiamati il compilatore pu√≤ generare direttamente l'indirizzo della funzione, senza mettere alcuna vtable tra i piedi.</p>
<p>Il C++ permette, nella classe base (Alfa in questo caso), di dichiarare un metodo virtuale puro usando la sintassi <code>virtual int getValue() = 0</code>. Questo indica che <code>Alfa</code> dichiara il metodo <code>getValue</code> ma non lo implementa ‚Äî l'implementazione sar√† fornita dalle classi figlie.</p>
<p>Questa cosa in Java voi la scrivete con <code>abstract</code>. Quando in java scrivete <code>abstract int vattelapesca</code>, state dicendo <em>‚Äúio introduco il nome di un metodo che non ho, ma che le mie sottoclassi dovranno mettere, sono responsabili di questa cosa‚Äù</em>.</p>
<p>In Java l'effetto di scrivere <code>abstract</code> davanti a un metodo √® che siete obbligati a ripetere <code>abstract</code> anche davanti alla classe, se no il compilatore vi picchia.
Questo per rendere consapevole chi usa la classe che quella classe non √® istanziabile. Se voi in Java provate a fare <code>new</code> di una classe <code>abstract</code> il compilatore vi blocca. Per√≤ potete fare <code>new</code> di una sua sottoclasse.</p>
<p><em>Perch√© serve poter mettere uguale a 0?</em>
Perch√© permette di definire quelle che in C++ si chiamano le <em><strong>funzioni virtuali astratte</strong></em>. Cio√® sono gli <em>impegni</em> ad avere un metodo senza al momento potercelo avere ‚Äî √® un modo di <em>impegnare le proprie sottoclassi</em> a fornire un'implementazione adatta in base alla loro cosa.</p>
<p>La classe che ha almeno un metodo virtual uguale a 0, in C++ viene detta classe virtuale astratta, ma viene solo detta cos√¨ per intendersi: non c'√® un'annotazione come in Java (la notazione <code>abstract</code>, appunto) che te la rende evidente. Questo serve ai programmatori per capirsi, ma non compare nella sintassi del linguaggio. Quello che compare nel linguaggio √® il fatto che se voi provate a istanziare una classe virtuale astratta il compilatore blocca.</p>
<p>√à molto interessante il caso del C++ in cui voi create una classe che non ha nessun campo, quindi non contiene delle variabili proprie, e ha solo quindi dei metodi, e tutti questi metodi sono <code>virtual = 0</code>.
Quella classe l√¨ √® diventata l'impegno a mettere a disposizione dei metodi ‚Äî in Java una cosa di questo tipo si chiama <code>interface</code>. Cio√® un'interfaccia √® semplicemente una classe da cui √® possibile ereditare in modo multiplo (perch√© non ha contenuti e quindi non mi porta niente in termini di uso di memoria), e mi d√† l'impegno a fornire un'implementazione per un certo numero di metodi.</p>
<h1 id="3-tratti-in-rust"><a class="header" href="#3-tratti-in-rust">3. Tratti in Rust</a></h1>
<p><img src="images/polimorfismo/image%206.png" alt="image.png" /></p>
<p>Tutte queste cose qua sono nel C++, in parte in Java, ma le trovate modo simili in altri linguaggi che hanno l'ereditariet√†.</p>
<p>Veniamo ora a Rust. I signori che hanno implementato Rust hanno detto <em>"Bello il polimorfismo, assolutamente utile! Brutta l'ereditariet√†, fonte di casino a non finire‚Äù</em>. Per cui la scelta √® stata <em>‚Äúle strutture Rust (</em><code>struct</code><em>,</em> <code>enum</code><em>,</em> <code>tuple</code><em>..) non ereditano‚Äù</em>.</p>
<p>L'<em>ereditariet√† concreta</em>, cio√® quella dove mi porto dei pezzi intesi come variabili aggiuntive e dei metodi implementati √® un casino ‚Äî d√† pi√π malefici che benefici, quindi non la facciamo.
L'<em>ereditariet√† delle interfacce</em>, dei metodi virtuali puri eccetera, invece √® molto potente perch√© abilita un processo che si chiama <em><strong>composizione</strong></em>.</p>
<p><strong>Composizione:</strong> Piuttosto che dire che la vostra automobile <em>√®</em> un motore, che non √® vero, √® molto meglio dire che la vostra automobile <em>ha</em> un motore, che invece √® vero. E ne pu√≤ anche avere due, un elettrico e uno a benzina. La composizione vi permette di fare delle cose e pu√≤ esserci anche l'automobile a pedali, che il motore non ce l'ha proprio. Ma se voi dite che automobile eredita da motore perch√© viene tanto comodo, perch√© motore definisce il metodo accendi e spegni, e viene tanto comodo farselo avere anche all'automobile, √® un casino. Quindi la scelta √® stata quella di dire: non abilitiamo l'ereditariet√† che implica l'<em><strong>essenza</strong></em>, cio√® <em>essere</em> (quando io eredito da qualcuno, <strong>sono anche di quel tipo</strong>), molto meglio la <em><strong>composizione</strong></em> (una parte di me √® fatta cos√¨).</p>
<p>Il modo con cui questo viene fatto √® tramite il concetto di <em><strong>tratto</strong></em>.</p>
<h2 id="31-concetto-di-tratto"><a class="header" href="#31-concetto-di-tratto">3.1 Concetto di Tratto</a></h2>
<p><em>Che cos'√® un tratto?</em>
√à un <strong>tipo</strong>, che noi possiamo creare all'interno, che esprime l'impegno da parte di chi implementer√† quel tratto a mettere a disposizione un gruppo di metodi. E il tratto elenca quali sono i metodi che dovranno essere messi a disposizione. Diciamo che il tratto equivale a quello che in C++ √® una classe virtuale astratta pura, cio√® una classe che non ha nessun campo proprio, che ha solo dei metodi e tutti i metodi sono virtuali puri, cio√® non hanno un'implementazione.</p>
<p>Rust in realt√† fa un passo avanti e dice <em>‚Äúguarda, se vuoi nel tratto mi metti un metodo, e a tale metodo se vuoi ci aggiungi, oltre che alla sua firma (cio√® l'insieme dei parametri che ricevi in ingresso e il valore che ritorna), anche una implementazione, che per√≤ non viene considerata ereditata: √® la cosiddetta implementazione di default‚Äù</em>.
Cio√®, se chi implementa il tratto non d√† una sua versione, pu√≤ usare quella. Se d√† la sua versione, d√† la sua versione, punto ‚Äî quella di defaut √® come se non ci fosse.</p>
<p><em>Perch√© uso i tratti?</em>
Uso i tratti per esprimere quei comportamenti comuni che cose molto diverse tra di loro possono avere. Ad esempio il tratto <code>std::io::Write</code> indica che quell‚Äôaggeggio l√¨, chi lo implementa, √® capace di scrivere dei byte. Il tratto <code>std::fmt:Debug</code> indica che quella cosa l√¨ √® capace di essere stampata quando il modificatore √® <code>{:?}</code>.
Il tratto <code>Display</code> indica che quella cosa l√¨ pu√≤ essere stampata quando il modificatore √® <code>{ }</code>, e cos√¨ via.
Il tratto <code>Clone</code> indica che quell'oggetto l√¨ √® duplicabile, a costo pi√π o meno alto, ma √® duplicabile.
Il tratto <code>Iterator</code> indica che quell'oggetto l√¨ √® capace di tirare fuori uno alla volta dei pezzi.</p>
<p><strong>A differenza di quello che succede in C++, in Java, in JavaScript, in Python, e in molti altri linguaggi</strong>, nella maggior parte delle situazioni in cui in Rust usiamo dei tratti, non abbiamo nessun costo aggiuntivo, n√© in termini di spazio, n√© in termini di tempo.</p>
<p>Nella maggior parte delle situazioni, ma <em>non sempre</em>, perch√© ci sono alcune situazioni in cui il compilatore non ha abbastanza informazioni per capire cosa deve fare. In quelle situazioni l√¨ il compilatore aggiunge qualche cosa, e adesso vediamo dove e in che modo, e ci obbliga anche a renderlo evidente.</p>
<p>Queste situazioni sono quelle in cui, se noi dobbiamo passare una cosa e la vogliamo trattare come tratto e non come cosa concreta, dove il compilatore si rende conto che non avrebbe alternative perch√© c'√® ambiguit√†, ci obbliga a passarla come <code>&amp;dyn</code>. Noi abbiamo imparato a conoscere il <code>&amp;</code> semplice, il <code>&amp;mut</code>, ma possiamo avere anche il <code>&amp;dyn</code>.</p>
<p><strong>Che cos'√® il <code>&amp;dyn</code>?</strong>
√à un reference <em>fat</em>, perch√© in quanto reference sicuramente all'oggetto, almeno. Notate che in Rust, al contrario di C++, il polimorfismo funziona tramite i puntatori, non con le istanze concrete, perch√© se io ho degli oggetti che sono uno piccolo e uno grosso, non posso metterci indifferentemente l'uno o l'altro. Quando lavoro con i puntatori invece va tutto bene, perch√© i puntatori sono tutti della stessa dimensione.</p>
<p>Un puntatore <code>&amp;dyn</code> √® un particolare puntatore che ha nella prima parte il puntatore vero all'oggetto e nella seconda parte ha la <em>vtable</em>. Cio√®, mentre in C++ la vtable <em>sta nell'oggetto</em>, qua la vtable sta <em>nei puntatori</em>, ma non in tutti i puntatori in assoluto, ma solo in quei puntatori che sono <strong>potenzialmente ambigui</strong>, cio√® dove il compilatore non riesce a gestirsi la cosa.</p>
<p>Vediamo un esempio.</p>
<h2 id="32-esempio"><a class="header" href="#32-esempio">3.2 Esempio</a></h2>
<p><img src="images/polimorfismo/image%207.png" alt="image.png" /></p>
<p>Introduciamo un <strong>tratto</strong>. Prendiamo come esempio le figure geometriche: sebbene un triangolo sia molto diverso da un cerchio, entrambi condividono alcune caratteristiche. Sia i triangoli che i cerchi hanno un <em>perimetro</em> e un'<em>area</em>.</p>
<p>Definiamo quindi il tratto <code>Figura2D</code>.</p>
<p><em>Come √® strutturato?</em>
Ha due funzioni: <code>perimetro</code> che restituisce un <code>f64</code> e <code>area</code> che restituisce anch'essa un <code>f64</code>. Entrambi i metodi ricevono <code>&amp;self</code>, cio√® operano sull‚Äôoggetto che li sta invocando, in modalit√† di sola lettura. Stiamo descrivendo un comportamento comune: per ogni <code>Figura2D</code> possiamo calcolare perimetro e area. Non specifichiamo altro (non stiamo specificando quale √® questa figura) - questo √® l'unico impegno richiesto.</p>
<p>Definiamo ora la struttura <code>Cerchio</code>. Avr√† tre campi di tipo <code>f64</code>: <code>xc</code> e <code>yc</code> per le coordinate del centro, e <code>r</code> per il raggio. Rappresenta un cerchio posizionato sul piano.</p>
<p><img src="images/polimorfismo/image%208.png" alt="image.png" /></p>
<p>La struttura <code>Cerchio</code> pu√≤ implementare il tratto <code>Figura2D</code> usando <code>impl Figura2D for Cerchio</code>. Quando scriviamo questo, il compilatore ci avvisa: <em>"Non basta dichiarare l'implementazione, devi fornire il codice"</em>. <code>Figura2D</code> richiede l'implementazione di <code>perimetro</code> e <code>area</code>.</p>
<p><img src="images/polimorfismo/image%209.png" alt="image.png" /></p>
<p>Usando <code>Implement missing members of Figura2D</code> il compilatore genera automaticamente lo scheletro base necessario.
Poi ovviamente troviamo dentro un <code>todo!()</code>, se io provassi a eseguire a questo punto i metodi, non andrei da nessuna parte, si impianta e mi muore con un <code>panic</code>.</p>
<p><img src="images/polimorfismo/image%2010.png" alt="image.png" /></p>
<p>Forniamo quindi una valida implementazione dei due metodi.</p>
<p>Questa √® l'implementazione del <code>Cerchio</code>.</p>
<p><img src="images/polimorfismo/image%2011.png" alt="image.png" /></p>
<p>Poi facciamo la <code>struct Punto</code>. La <code>struct Punto</code> ha un <code>x</code> di tipo <code>f64</code> e una <code>y</code> di tipo <code>f64</code>. Questo rappresenta un singolo punto sullo spazio, sul piano. Anche <code>Punto</code> pu√≤ implementare il tratto <code>Figura2D</code>. In questo caso, sia il perimetro che l‚Äôarea di un punto sono uguali a 0.</p>
<p>Abbiamo ora due figure.</p>
<p><strong>Ho definito questo comportamento. Che me ne faccio?</strong> Nel main, possiamo cominciare a crearci degli oggetti.</p>
<p><img src="images/polimorfismo/image%2012.png" alt="image.png" /></p>
<p>Facciamo <code>let c = Cerchio { xc: 0, yc: 1, r: 10 }</code>. Poi posso dire <code>let p = Punto { x: 2.3, y: 2.4 }</code>.</p>
<p>Io qua vedo direttamente le caratteristiche di <code>c</code>, posso fare <code>c.area()</code>, <code>c.perimetro()</code>. <em>Perch√©?</em> Perch√© il compilatore sa che il cerchio implementa il comportamento di <code>Figura2D</code>. Quando qui scrivo <code>c.perimetro()</code>, e il compilatore non ha bisogno di informazioni particolari. Sa esattamente che <code>c</code> √® un tipo concreto, sa che quel tipo concreto implementa <code>Figura2D</code>, e quindi ha una sua versione del metodo <code>perimetro</code>, e quindi qua se io vado a vedere l'assembler che viene generato, vedo che ci mette direttamente la chiamata alla funzione specifica del perimetro, non ha dubbi.</p>
<p><strong>Quindi qua non c'√® bisogno di nessun gioco della VTABLE</strong>, questo costa 0, cio√® costa come qualunque altra chiamata.</p>
<p><img src="images/polimorfismo/image%2013.png" alt="image.png" /></p>
<p>Se io invece mi metto qua sopra, e aggiungo una funzione <code>fn f1</code>, che accetta un oggetto di tipo <code>Figura2D</code>, allora devo scrivere che questo prende <code>&amp;dyn Figura2D</code>. E qui posso scrivere <code>println!("L'area vale {}", f.area())</code>, e poi <code>println!("Il perimetro vale {}", f.perimetro())</code>.</p>
<p>E quando devo chiamare <code>f1()</code>, <em>non posso passargli direttamente</em> <code>c</code> o <code>p</code>, perch√© sono grossi diversi. <code>c</code>, che √® <code>Cerchio</code>, ha tre campi: centro <code>x</code>, centro <code>y</code> e raggio <code>r</code>, e invece <code>p</code> ha solo <code>x</code> e <code>y</code>.</p>
<p><img src="images/polimorfismo/image%2014.png" alt="image.png" /></p>
<p>Per√≤ posso passargli il puntatore, posso passare <code>&amp;c</code> e posso passare <code>&amp;p</code>.</p>
<p>Notate che nell‚Äôinvocazione passiamo semplicemente <code>&amp;</code>, mentre nella firma della funzione l'ho chiamato <code>&amp;dyn</code>, <em>perch√©?</em> Perch√© l'altro deve capire che <code>Figura2D</code> potrebbe essere l'uno o l'altro, e nel costruire il codice di <code>f1</code>, chi gli arriva come parametro non lo sa pi√π, e non lo pu√≤ sapere! Il codice di <code>f1</code> viene compilato per i fatti suoi, cos√¨ com‚Äô√®. √à ignorante, potrebbe essere chiamato dal main, ma potrebbe essere chiamato anche da un'altra parte, con oggetti di tipi diversi.</p>
<p>Quindi il compilatore non pu√≤ sapere nel momento in cui viene creato il codice di <code>f1</code>, che parametro specifico gli verr√† dato. E quindi devo dire <em>‚Äúguarda, cautelati: se ti arriva un parametro, quel parametro l√¨ deve essere un <strong>puntatore fat</strong>. Deve avere certamente il puntatore al dato, ma deve avere anche la vtable associata, in modo tale che tu te la possa risolvere.‚Äù</em></p>
<p><img src="images/polimorfismo/image%2015.png" alt="image.png" /></p>
<p>Se io adesso lo eseguo, mi dice che per il cerchio l'area vale <strong>314</strong> e ci sta perch√© ha dato raggio 10, e 10 per 10 fa 100, poi 100 per pi greco fa 314, e il perimetro vale <strong>6,28</strong> per 10, che ci siamo. Quindi 628.</p>
<p><strong>L'aspetto che ci interessa √® che il comportamento √® stato effettivamente polimorfico.</strong> Cio√®, abbiamo definito la funzione <code>f1</code> che accetta una cosa che √® una <code>Figura2D</code>, e questa <code>Figura2D</code> viene ricevuta come puntatore. Perch√© altrimenti non potrei passargli cose a volte piccole, a volte grosse. Quindi io devo necessariamente darglielo come puntatore.</p>
<p>Ma siccome le implementazioni possono essere molto diverse tra di loro (e in effetti lo sono, in un caso qua ci ritorna <code>0</code>, nell'altro ci ritorna il risultato di una formula), allora √® necessario che io aggreghi al puntatore, nella struttura dati, anche la vtable.</p>
<p><img src="images/polimorfismo/image%2016.png" alt="image.png" /></p>
<p>Questo √® reso evidente dal fatto che qua mi segno <code>&amp;dyn</code>. Se io cancellassi questo <code>dyn</code>, lui si arrabbia e mi dice <em>"attenzione, questo √® un tratto, non √® un oggetto. Se tu mi avessi passato &amp;Cerchio, a me andr√† bene, io so quanto √® grande un cerchio. Ma se mi passi &amp;Figura2D, io che ne so quanto √® grande Figura2D. E allora devi includere la dyn keyword."</em></p>
<p>Questo ci rende consapevoli che quella cosa l√¨ sar√† grande <strong>16 byte</strong>. Quindi le chiamate a <code>f1</code> si porteranno dietro due cose. Ma non √® un problema, perch√© tanto nel main, quando io faccio <code>f1(&amp;c)</code>, io sto prendendo il puntatore di <code>c</code>, ma <code>c</code> so che √® un cerchio, quindi il compilatore l√¨ mi mette sia il puntatore effettivo a <code>c</code>, che in questo momento √® borrowed finch√© questa funzione non torna, e mi mette anche il puntatore alla vtable, che lui non ha problemi a sapere, perch√© sa che <code>c</code> √® un cerchio e quindi quali sono i suoi metodi virtuali ce li ha. E lo stesso sotto <code>f1(&amp;p)</code>, di nuovo, mi mette i due pezzi che mi interessano.</p>
<h2 id="33-vtable-in-rust"><a class="header" href="#33-vtable-in-rust">3.3 VTable in Rust</a></h2>
<p><img src="images/polimorfismo/image%2017.png" alt="image.png" /></p>
<p><em>Come √® fatta la vtable?</em>
Quando ho un oggetto tratto, cio√® <code>&amp;dyn Something</code>, quello che succede √® che viene passato un puntatore doppio. La prima parte punta all'oggetto vero e proprio, quello che sia, nel caso della slide era un intero semplice, ma lui non sa che cosa sia, sa che inizia l√¨ e per√≤ fine. La seconda parte √® pi√π interessante, perch√© la vtable di Rust ci porta sempre almeno 4 entries. La vtable pu√≤ esistere solo se hai almeno un metodo virtual, cio√® un metodo preso dal tratto, altrimenti non avresti nessun tratto.</p>
<p>Un tratto senza metodi esiste ed √® chiamato tratto <em><strong>marker</strong></em>, ma ha un impatto limitato poich√© pu√≤ essere gestito interamente dal compilatore. D'altra parte, un tratto con metodi ‚Äî quelli che utilizziamo pi√π frequentemente ‚Äî contiene sempre 3 entries iniziali.</p>
<p>Il primo √® il metodo <code>drop()</code> ‚Äî se quell'oggetto l√¨ non √® droppable, non √® un problema: il metodo <code>drop()</code> sar√† nullo, ma lo gestisce il compilatore. Quindi il primo elemento della vtable √® il distruttore associato al dato, questo perch√© nel caso in cui il ricevitore dell'oggetto tratto dovesse distruggerlo per qualche motivo, deve sapere come poterlo fare.</p>
<p>La seconda informazione √® <em>quanto √® grande il dato</em>, io so che nella prima parte al mio puntatore ho l'inizio, ma non so quanto √® grande quella struttura l√¨. Nel caso del cerchio era grande 24 byte, nel caso del punto era grande solo 16. E quindi mi ritrover√≤ nella seconda entry della vtable la dimensione.</p>
<p>Nella terza entry della vtable mi trovo <em>l'allineamento</em>. Dice: <em>‚Äúguarda, se per caso lo devi spostare, farci cose, sappi che quest'oggetto qua comunque deve stare allineato a multipli di 2, 4, 8, o quel che sia‚Äù</em>. In questo caso qui l'oggetto era un <code>i32</code> e quindi aveva dimensione 4 e allineamento 4.</p>
<p>Quello che viene successivamente sono i <em>metodi specifici</em>. Siccome questo qui era il tratto <code>Print</code>, che qui era definito come un singolo metodo <code>print()</code>, l√¨ aveva il puntatore effettivo al metodo <code>print()</code>. Nel nostro esempio di prima, il nostro <code>Cerchio</code> avr√† due metodi specifici, <code>area()</code> e <code>perimetro()</code>.</p>
<h2 id="34-definire-ed-usare-un-tratto"><a class="header" href="#34-definire-ed-usare-un-tratto">3.4 Definire ed usare un tratto</a></h2>
<p><img src="images/polimorfismo/image%2018.png" alt="image.png" /></p>
<p><strong>Regole fondamentali per i tratti:</strong></p>
<p>Si definisce un tratto con la sintassi <code>trait SomeTrait {fn fun1(...) -&gt; SomeResult; ... }</code>.
Quindi quella √® la definizione del tratto.</p>
<p>La struttura dati concreta, come le <code>struct</code> o le <code>enum</code>, possono aggiungere l'implementazione di un tratto con la sintassi <code>impl SomeTrait for NomeStruttura</code>. Questo pu√≤ essere fatto con un vincolo. Si pu√≤ fare nel file in cui √® definita la struttura dati, e si pu√≤ fare nel file in cui √® definito il tratto.</p>
<p><strong>Importante:</strong> Non si pu√≤ fare in un file terzo, dove non √® definita n√© la struttura dati n√© il tratto, cio√® esiste la <code>struct String</code> che √® definita dal sistema. Io non ho accesso a quel file l√¨, ce l'ho nelle librerie standard. Posso, in un file mio, inventarmi il tratto <code>t</code> e dire che la <code>String</code> implementa il tratto <code>t</code>. Non posso definire il tratto <code>t</code> in un posto e poi in un file terzo dire che <code>String</code>, che non √® definito in questo momento, implementa il tratto <code>t</code>. Quindi l'implementazione del tratto si fa o <strong>dove si definisce il tratto</strong> o <strong>dove si definisce la struttura dati</strong>. Non in un posto terzo.</p>
<p><strong>Nota sull'autocompletamento:</strong> i tratti vi mettono in difficolt√† con l'autocompletamento. Se voi volete usare un metodo che √® definito in un certo tratto e quel tratto non √® nel vostro file corrente, lo dovete importare, se no l'IDE non ve lo fa comparire come metodo possibile. Ad esempio noi avevamo fatto il tratto <code>Figura2d</code>, che era nello stesso file in cui abbiamo messo il cerchio, per cui lavorando col cerchio facevamo <code>c.</code> qualcosa e immediatamente comparivano i metodi <code>area</code> e <code>perimetro</code>. Se avessimo definito il tratto <code>Figura2d</code> da un'altra parte, se non lo vado a importare tramite <code>use</code>, con il suo nome completo, i metodi <code>area</code> e <code>perimetro</code> non li avremmo visti.</p>
<p><strong>Preludio:</strong> Ci sono alcuni tratti (ad esempio <code>Clone</code>, <code>Iter</code>), che non √® necessario importare in modo esplicito. Il motivo √® che di fatto sono importati per noi dal compilatore, il quale fa riferimento a un blocco fondamentale che si chiama <em><strong>preludio</strong></em>, <code>std::prelud</code>, che contiene i tratti pi√π comuni per cui non abbiamo bisogno di fare l'import; √® lo stesso motivo per cui non dobbiamo importare <code>Vec</code>, √® lo stesso motivo per cui non dobbiamo importare <code>String</code>, eccetera, che fanno parte di questa definizione di cose frequenti e comuni. Solo alcuni tratti stanno nel preludio, quelli che sono di uso comune, quegli altri che sono un po' pi√π strani bisogna importarli in modo esplicito.</p>
<p><img src="images/polimorfismo/image%2019.png" alt="image.png" /></p>
<p><strong>Il riferimento self:</strong> Le singole funzioni dei tratti hanno bisogno normalmente di un riferimento a <code>Self</code>. Quel <code>Self</code> l√¨, nel tratto, non √® risolto. Mentre il compilatore esamina il codice del tratto, <code>Self</code> non sa che cos'√®, sar√† il tipo concreto che implementa. Tanto che noi abbiamo detto che avremmo il tratto <code>Figura2d</code> che aveva <code>perimetro</code> che prendeva <code>&amp;self</code>, ma in quel momento lui non sapeva che cosa fosse <code>self</code>. Quando abbiamo detto che implementavamo <code>Figura2d for Cerchio</code>, <code>Self</code> √® diventato <code>Cerchio</code>. Quando abbiamo detto che implementavamo <code>Figura2d for Punto</code>, <code>Self</code> √® diventato <code>Punto</code>. Quindi mentre esponiamo il tratto, lo definiamo semplicemente, <code>Self</code> √® un placeholder che prender√† valore per chi lo implementa. Il tipo <code>Self</code> pu√≤ essere ritornato dalle funzioni del tratto o pu√≤ essere consumato dalle funzioni del tratto.</p>
<p><img src="images/polimorfismo/image%2020.png" alt="image.png" /></p>
<p><img src="images/polimorfismo/image%2021.png" alt="image.png" /></p>
<p><strong>Parametri self nei tratti:</strong> Se le funzioni del mio tratto hanno bisogno di riferirsi all'istanza specifica su cui operano, ecco che possono prendere come parametro un <code>self</code> puro (in questo caso lo prendono per movimento), oppure un <code>&amp;self</code> (e quindi lo prendono a prestito in sola lettura), o un <code>&amp;mut self</code> (lo prendono a prestito in lettura e scrittura in modalit√† esclusiva). Vale la stessa cosa dei metodi delle struct: <code>self</code>, <code>&amp;self</code>, <code>&amp;mut self</code> sono degli shortcut sintattici per la notazione pi√π completa che √® <code>self: Self</code>, <code>self: &amp;Self</code>, <code>self: &amp;mut Self</code>.</p>
<h2 id="35-tipi-associati-nei-tratti"><a class="header" href="#35-tipi-associati-nei-tratti">3.5 Tipi Associati nei Tratti</a></h2>
<p><img src="images/polimorfismo/image%2022.png" alt="image.png" /></p>
<p>Quando definiamo un tratto abbiamo la possibilit√† di associargli dei tipi, √® una cosa che nelle librerie standard √® fatta tantissimo. Ad esempio il tratto <code>T3</code> che √® introdotto qua ha un tipo associato chiamato <code>AssociatedType</code>, serve perch√© la funzione che definisce, <code>f</code>, accetta come argomento che cosa? Un parametro <code>arg</code> di tipo <code>Self::AssociatedType</code>. Ok, se gi√† <code>self</code> √® ignoto, <code>Self::AssociatedType</code> √® doppiamente ignoto.</p>
<p>Le classi che implementano <code>T3</code> hanno il compito di dire ovviamente che cos'√® <code>Self</code> ‚Äî sono loro stesse ‚Äî ma anche che cos'√® l'<em>associated type</em>. In questo caso <code>SomeType</code>, scritto qui a fianco ha come associated type un <code>i32</code> e quindi la funzione <code>f</code> di fatto √® una funzione che prende un intero 32 bit.</p>
<p>Nell‚Äôesempio sotto, invece, <code>OtherType</code> implementa anche essa <code>T3</code> ma sceglie come tipo associato di avere un <code>&amp;str</code> e quindi la funzione <code>f</code> prender√† come parametro un <code>&amp;str</code>.</p>
<p>Questo ci fa gi√† intravedere che dietro i tratti c'√® un modo di fare delle cose molto pi√π articolate. A differenza di quello che succede con le interfacce di Java dove i metodi hanno una signature ben definita, qua la signature ha delle parti che sono definibili, parametrizzabili dal tipo effettivo, quindi io scelgo con chi vado. √à interessante, quindi nel main chiamer√≤ <code>SomeType::f(1234)</code> e <code>OtherType::f("Hello, Rust!")</code>, e tutto funziona. Sempre la funzione <code>f</code>, ma a seconda di a che cosa √® legata prender√† l'uno o l'altro valore.</p>
<h2 id="36-implementazioni-default-nei-tratti"><a class="header" href="#36-implementazioni-default-nei-tratti">3.6 Implementazioni Default nei Tratti</a></h2>
<p><img src="images/polimorfismo/image%2023.png" alt="image.png" /></p>
<p>Quando viene definito un tratto √® lecito associare al nome di una funzione anche un'implementazione di default. Le strutture dati, tipi concreti che implementano il dato tratto potranno scegliere se adottare per quella particolare funzione l'implementazione di default, semplicemente omettendola, oppure se fornire la loro implementazione specifica, e in quel caso ci mettono quel che vogliono.</p>
<p>Quindi qui <code>T4</code> introduce la funzione <code>f</code> che ha un'implementazione di default, <code>SomeType</code> implementa <code>T4</code> e non mette niente, si fa andare bene la funzione di default.</p>
<p><code>OtherType</code> viceversa implementa <code>T4</code> e lo fa rinunciando alla funzione di default e scegliendo la sua versione.</p>
<p>Di nuovo dentro main possiamo chiamare <code>SomeType.f()</code> e quindi avr√≤ l‚Äôimplementazione di <code>f</code> di default che stampa ‚Äúdefault‚Äù, oppure posso chiamare <code>OtherType.f()</code> e in questo caso vedr√≤ stampato ‚ÄúOther‚Äù.</p>
<h2 id="37-gerarchia-dei-tratti"><a class="header" href="#37-gerarchia-dei-tratti">3.7 Gerarchia dei Tratti</a></h2>
<p><img src="images/polimorfismo/image%2024.png" alt="image.png" /></p>
<p>I tratti possono essere legati in una struttura di <em><strong>implicazione</strong></em>. Quando scrivo <code>trait Subtrait: Supertrait</code>, sto definendo <code>Subtrait</code> e sto vincolandolo al fatto che i tipi che implementano <code>Subtrait</code> devono anche implementare <code>Supertrait</code>.</p>
<p>Non sto creando una gerarchia di ereditariet√†, <strong>sto creando una gerarchia di implicazioni</strong>. ‚Äî <em>‚ÄúPer poter implementare</em> <code>Subtrait</code> <em>devi anche implementare</em> <code>Supertrait</code><em>"</em>.</p>
<p><strong>Esempio pratico:</strong> Questo noi l'abbiamo gi√† incontrato, abbiamo visto che c'√® un tratto particolare che si chiama <code>Copy</code>. Il tratto <code>Copy</code> non ha nessun metodo, √® un tratto marker, perch√© l'unico metodo √® quello che conosce il compilatore che permette di duplicare un'area di memoria chiamando la <code>memcpy</code>. Ma il tratto <code>Copy</code> ha come implicazione il tratto <code>Clone</code>: per poter implementare il tratto <code>Copy</code> occorre implementare il tratto <code>Clone</code>. E ha anche un'implicazione negativa: il tratto <code>Copy</code> implica il tratto <code>Clone</code> e implica il <strong>non tratto</strong> <code>Drop</code>. Cio√® non √® possibile essere <code>Copy</code> e <code>Drop</code> allo stesso momento. Viceversa, il tratto <code>Drop</code> implica il non tratto <code>Copy</code>. Per lo stesso motivo.</p>
<h2 id="38-come-invochiamo-un-tratto"><a class="header" href="#38-come-invochiamo-un-tratto">3.8 Come invochiamo un tratto?</a></h2>
<p><img src="images/polimorfismo/image%2025.png" alt="image.png" /></p>
<p>L'abbiamo in parte gi√† visto, qui lo riassumiamo in modo da avere delle regole. Ci sono le invocazioni cosiddette <strong>statiche</strong>: ovvero in tutte quelle situazioni in cui il compilatore conosce il tipo concreto di cui stiamo invocando il metodo, l‚Äôinvocazione √® un'invocazione normalissima. Per cui banalmente il compilatore chiama la funzione associata.</p>
<p>Quando invece ci mettiamo in una situazione dove c'√® <strong>ambiguit√†</strong>, ovvero dove il compilatore sa solo che ha tra le mani una cosa che implementa il tratto, ma non sa che cosa sia, questa cosa gli deve arrivare sotto forma di puntatore e questo puntatore deve essere etichettato come <code>&amp;dyn</code>. Potrebbe anche essere <code>&amp;mut dyn</code>. <code>&amp;mut dyn</code> vuol dire che √® un puntatore il cui contenuto pu√≤ essere modificato, √® chiaramente in mutua esclusione, quindi mentre esiste questo non ne possono esistere altri, e non √® possibile l'accesso normale, come tutti i <code>&amp;mut</code> d‚Äôaltronde, ma in questo caso √® anche <code>dyn</code>, cio√® assieme al puntatore che ha le caratteristiche del caso, viene anche il puntatore alla <strong>vtable</strong> per potermi risolvere i vari metodi.</p>
<p>Notate che il puntatore pu√≤ essere un <code>&amp;dyn</code>, <code>&amp;mut dyn</code>, pu√≤ essere un <code>Box&lt;dyn Trait&gt;</code>, pu√≤ essere un <code>Arc&lt;dyn Trait&gt;</code>, pu√≤ essere un <code>Rc&lt;dyn Trait&gt;</code>, cio√® tutti i puntatori di vario tipo se contengono qualcosa che √® noto solo di tipo tratto, devono avere il <code>dyn</code> associato.</p>
<p><img src="images/polimorfismo/image%2026.png" alt="image.png" /></p>
<p>Gli oggetti tratti li abbiamo gi√† visti, sostanzialmente quando lo dichiariamo come <code>&amp;dyn</code>, <code>&amp;mut dyn</code>, <code>Box&lt;dyn Trait&gt;</code>, eccetera, stiamo passando 16 byte, i primi 8 puntano all'implementazione concreta, cio√® al dato effettivo, i secondi 8 puntano alla vtable, che ha questa struttura qua.</p>
<h2 id="39-tratti-nella-libreria-standard"><a class="header" href="#39-tratti-nella-libreria-standard">3.9 Tratti nella Libreria Standard</a></h2>
<p><img src="images/polimorfismo/image%2027.png" alt="image.png" /></p>
<p>La libreria standard √® piena di tratti e utilizza i tratti per permetterci di estendere la semantica del linguaggio ai tipi che stiamo introducendo. Noi abbiamo introdotto il tipo <code>Cerchio</code>, abbiamo voluto anche dirgli che il cerchio era una <code>Figura2D</code> e quindi aveva l'area e il perimetro, ma indipendentemente dal fatto che il cerchio ha l'area e il perimetro, in qualche momento ci potrebbe venire da chiedere <em>‚ÄúIo ho due cerchi,</em> <code>c1</code> <em>e</em> <code>c2</code> <em>‚Äî sono uguali? Come faccio a sapere se i due cerchi sono uguali?‚Äù</em></p>
<p>Se invece che cerchi fossero dei numeri, <code>i1</code> e <code>i2</code>, scriverei semplicemente <code>if i1 == i2</code>, esprimerei l'uguaglianza come si esprime normalmente.</p>
<p>Se io provassi a scrivere <code>if c1 == c2</code>, il compilatore mi bloccherebbe, perch√© mi dice <em>"scusa, che ne so io se i due cerchi sono uguali"</em>.
Affinch√® il compilatore possa capire se i due cerchi sono uguali o meno, ovvero affinch√® il compilatore possa usare l'operatore <code>==</code> per confrontare i due cerchi, occorre che la nostra struct <code>Cerchio</code> implementi il tratto <strong><code>Eq</code></strong>, ovvero nella libreria standard sono presenti un certo numero di tratti il cui scopo √® far capire come il compilatore deve agire quando trova certe espressioni scritte.</p>
<p>Il tratto <strong><code>Eq</code></strong> √® il tratto che viene utilizzato nel momento in cui io scrivo <code>if qualcosa == qualcosaltro</code>.
Il compilatore va a vedere <em>"questo qualcosa dispone del tratto</em> <strong><code>Eq</code></strong><em>?",</em> e se dispone del tratto <code>Eq</code> ne invoca il metodo associato. Lo stesso succede se io scrivessi <code>if qualcosa != qualcosaltro</code>, userei sempre il tratto <code>Eq</code>.</p>
<p>Viceversa, quando io scrivo <code>if c1 &lt; c2</code>, se introducessi questa cosa qua il compilatore andrebbe a vedere se <code>Cerchio</code> implementa il tratto <strong><code>Ord</code></strong>.</p>
<p><strong><code>Ord</code></strong> √® ordine, d√† il concetto di <em>‚Äúprima-dopo‚Äù</em>. Quindi se implementa il tratto <strong><code>Ord</code></strong> ha un metodo che si chiamer√† <code>le()</code> (<em>less or equal</em>) o <code>lt()</code> (<em>less than</em>) che mi permette di sapere se <code>c1</code> √® pi√π piccolo di <code>c2</code>, ad esempio.</p>
<p><strong>Uguaglianza</strong> e <strong>relazione d'ordine</strong> (<code>&lt;</code> e <code>&gt;</code>), prima di tutto sono imparentati, perch√© io posso avere <code>&lt;=</code> e <code>&gt;=</code>.
Allora √® chiaro che se ho minore-uguale bisogna che la definizione di uguale sia parente di minore-uguale. Se A √® uguale a B, deve anche essere che A √® minore-uguale a B. E deve anche essere che A √® maggiore-uguale a B. Quindi sono tratti diversi, ma io devo poi implementarli garantendo questa faccenda qua.</p>
<p>Quindi l√¨ √® una responsabilit√†, poi come facciamo a dire se due cerchi sono uguali? Due cerchi sono uguali se hanno lo stesso centro e lo stesso raggio, per esempio. Oppure potremmo dire che due cerchi sono uguali se hanno lo stesso raggio, fregandocene del centro.
Dipende da che significato vogliamo dare noi all'uguaglianza, ma dobbiamo sceglierne uno che abbia un senso e se implementiamo sia l'uguaglianza sia l'ordine, bisogna che l'ordine sia <strong>coerente</strong> con l'uguaglianza, se no rischiamo di fare dei pasticci inenarrabili.</p>
<p>C'√® un problema aggiuntivo: l'uguaglianza presuppone, dalla matematica e dalla logica, l'esistenza di <strong>tre propriet√†</strong>: riflessiva, simmetrica e transitiva.</p>
<p>Innanzitutto deve essere che <code>A = A</code> (riflessiva), quindi se confronto una cosa con se stessa, questa deve essere uguale. Questo dipende da come scrivo l'implementazione - pu√≤ darsi di s√¨, pu√≤ darsi di no.
Se <code>A = B</code>, deve essere altrettanto vero che <code>B = A</code> (simmetrica).
E deve essere transitiva: se <code>A = B</code> e <code>B = C</code>, deve anche venire fuori che <code>A = C</code>.</p>
<p>Sembrerebbe banale, ma non lo √®. Nei numeri ‚Äî il posto pi√π facile dove l'uguaglianza dovrebbe esistere ‚Äî tra i numeri in virgola mobile c'√® un valore impiccevole: si chiama <code>NaN</code> (<em>not a number</em>). √à il risultato, ad esempio, di:</p>
<ul>
<li><code>‚àö(-1)</code></li>
<li><code>0 √∑ 0</code></li>
<li><code>0‚Å∞</code></li>
</ul>
<p>e altre situazioni di questo genere‚Ä¶</p>
<p>Secondo lo standard <strong>IEEE 754</strong>, che definisce la rappresentazione dei numeri in virgola mobile e la loro semantica (standard adottato da tutti i linguaggi di programmazione per garantire operazioni coerenti), <strong><code>NaN</code> non √® uguale a <code>NaN</code></strong>.</p>
<p>Quindi se nella variabile <code>v1</code> avete <code>NaN</code> e nella variabile <code>v2</code> avete <code>NaN</code> e le confrontate, la risposta √®: ‚Äú<em>sono diversi‚Äù</em>.
Pu√≤ sembrare controintuitivo, ma √® cos√¨ per motivi fondamentali ‚Äî il primo pu√≤ essere il risultato di 0‚Å∞, e l'altro magari il risultato di ‚àö(-1).</p>
<p>0‚Å∞ non √® un numero perch√© pu√≤ essere qualsiasi numero. 0‚Å∞ implica sostanzialmente la divisione di 0 con se stesso, perch√© un esponente 0 lo potete vedere come risultato di una divisione: <code>x^n √∑ x^n = x^(n-n) = x‚Å∞</code></p>
<p>Se la base √® 0, quindi 0‚Å∞, la divisione √® di 0 con se stesso. La divisione di 0 con se stesso quanto fa? Qualunque numero moltiplicato per 0 d√† 0, quindi 0‚Å∞ come 0/0 non √® un numero definito. Mentre ‚àö(-1) non √® nessun numero reale ma vale <em>i</em> o <em>-i</em> ‚Äî sono almeno due e non sono numeri reali, bens√¨ complessi.</p>
<p>Per questo motivo due <code>NaN</code> non sono confrontabili. Di conseguenza, non vale la propriet√† riflessiva: quando confronto <code>NaN</code> con se stesso ottengo <code>false</code>.</p>
<h3 id="391-eq-e-partialeq"><a class="header" href="#391-eq-e-partialeq">3.9.1 Eq e PartialEq</a></h3>
<p>Per questo Rust distingue <strong>due tratti dell'uguaglianza</strong>:</p>
<ul>
<li><strong><code>Eq</code></strong></li>
<li><strong><code>PartialEq</code></strong></li>
</ul>
<p><code>Eq</code> implica <code>PartialEq</code>.</p>
<p><code>PartialEq</code> √® per tutte quelle classi di valori che sono <strong>simmetrici</strong> e <strong>transitivi</strong> ma <strong>non riflessivi</strong> (come i numeri in virgola mobile con il problema del <code>NaN</code>).</p>
<p><code>Eq</code>, l'uguaglianza piena, implica quella parziale e aggiunge la propriet√† <strong>riflessiva</strong>.</p>
<p>La maggior parte delle strutture dati che vogliamo avere sono complete - hanno l'<code>Eq</code> completa.</p>
<p>Lo stesso problema si pone nell'ordine: poich√© la propriet√† riflessiva non √® garantita, non √® vero che <code>NaN</code> sia minore o uguale di <code>NaN</code>. Di conseguenza anche qui abbiamo due tratti: <strong><code>Ord</code></strong> e <strong><code>PartialOrd</code></strong>. Questi ci servono tutte le volte che vogliamo confrontare due strutture dati.</p>
<p>Lo stesso ragionamento vale per molte altre situazioni. Ad esempio, cosa succede se abbiamo due variabili <code>c1</code> e <code>c2</code> che sono entrambi <code>Cerchio</code> e scriviamo <code>c1 - c2</code>? Cosa significa fare la differenza di due cerchi? In un'ipotetica geometria costruttiva sottrarre potrebbe significare fare un "buco", ammesso che uno sia dentro l'altro. O forse rimuoverne una fetta. O forse nulla se sono disgiunti.
Ma al di l√† del significato, per poter scrivere <code>c1 - c2</code> devo implementare il tratto <strong><code>Sub</code></strong>. Questo estende il comportamento dei nostri tipi custom a tutta la sintassi lecita - se posso scrivere <code>3 √ó 2</code> con i numeri, deve essere possibile farlo anche con i cerchi (ammesso che abbia senso), e questo pu√≤ essere fatto implementando il tratto <strong><code>Mul</code></strong>.</p>
<p>Quasi tutti questi tratti vengono con un tipo associato che per default √® <code>Self</code>. Se implemento <code>Eq</code>, di default confronto con un mio simile - <code>Cerchio</code> implementa <code>Eq</code> quindi confronto <code>Cerchio</code> con <code>Cerchio</code>.</p>
<p>Ma posso anche dire che <code>Cerchio</code> si confronta con <code>Rettangolo</code> implementando <code>Eq</code> due volte: una volta per <code>Self</code> (confronto tra cerchi) e una per <code>Rettangolo</code>. Cosa significa che un cerchio √® uguale a un rettangolo? Magari hanno la stessa area o lo stesso perimetro.</p>
<p>Possiamo quindi definire confronti sia omogenei (stesso tipo) che eterogenei (tipi diversi), proprio grazie al meccanismo del <em>tipo associato</em>.</p>
<p><img src="images/polimorfismo/image%2028.png" alt="image.png" /></p>
<p>Di base sia il tratto <code>Eq</code> che <code>PartialEq</code> richiedono un solo metodo obbligatorio, perch√® il secondo ha un'implementazione default: il metodo <code>eq</code> che confronta <code>&amp;self</code> con <code>&amp;RHS</code>, dove <code>RHS</code> (<em>right hand side</em>) √® un tipo associato, che per default √® <code>Self</code>, ma pu√≤ essere specificato diversamente.</p>
<p>Quindi posso scrivere:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Eq for Cerchio {
    type RHS = Rettangolo;
    // ...
}

<span class="boring">}</span></code></pre></pre>
<p>E questo mi permette di confrontare un cerchio con un rettangolo.</p>
<p><strong>PartialEq</strong>, come dicevamo, richiede solo simmetrica e transitiva, mentre <strong>Eq</strong> invece impone anche la propriet√† riflessiva, cosa che non vale sui numeri con la virgola. E per default <code>RHS</code> √® Self.</p>
<p>Il metodo <code>ne</code>, che fa parte della definizione del tratto, ha un'implementazione default che √® <code>not eq</code>, che di solito basta e avanza.</p>
<p>Se noi implementiamo ‚Äú<code>Cerchio</code> == <code>Rettangolo</code>", dobbiamo implementare anche ‚Äú<code>Rettangolo</code> == <code>Cerchio</code>".</p>
<h3 id="392-ord-e-partialord"><a class="header" href="#392-ord-e-partialord">3.9.2 Ord e PartialOrd</a></h3>
<p><img src="images/polimorfismo/image%2029.png" alt="image.png" /></p>
<p>Anche qua abbiamo i due tratti, il tratto <code>Ord</code> implica doppiamente il tratto <code>Eq</code> e il tratto <code>PartialOrd</code>, viceversa il <code>PartialOrd</code> implica soltanto il <code>PartialEq</code>, cio√® per poter fare una relazione d'ordine io devo avere anche la relazione di uguaglianza, perch√© l'ordine ammette il <strong>minore uguale</strong>, e quindi se non esiste un modo di decidere l'uguaglianza non riuscir√≤ mai a definire il minore uguale.</p>
<p>Notate che la relazione d'ordine mi richiede di implementare il metodo <code>cmp</code> o il metodo <code>partial_cmp</code>.</p>
<p><code>cmp</code>, la <strong>relazione d'ordine totale</strong>, vuole sostanzialmente un <code>enum Ordering</code> come risultato, quindi confronta due oggetti, in questo caso <code>other</code> e <code>self</code>, perch√© io posso mettere in ordine solo cose omogenee, altrimenti diventa una cosa complicata, mentre <code>PartialEq</code> mi ammette per default la possibilit√† di avere anche delle cose eterogenee, in quanto proprio perch√© <em>partial</em> posso anche arrivare a dire che se ho due cose diverse, non so dire chi viene prima: viene prima il <code>Punto</code> o il <code>Rettangolo</code>? Boh: sono incommensurabili, motivo per cui <code>partial_cmp</code> ritorna un <code>Option</code>, cio√® qualcosa che potrebbe anche essere <code>None</code>, oppure <code>Some</code> di <code>Ordering</code>, dove <code>Ordering</code> √® un'enumerazione che vale <code>Less</code> (vengo prima), <code>Equal</code> (siamo uguali) o <code>Greater</code> (vengo dopo).</p>
<p>Il tratto <code>PartialOrd</code> ha dentro di s√© una serie di metodi ulteriori che si chiamano <code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code> (<em>less than</em>, <em>less equal</em>, <em>greater than</em>, <em>greater equal</em>), che di fatto hanno un'implementazione di default che √® derivata da <code>partial_cmp</code>, motivo per cui <code>partial_cmp</code> √® messo in rosso nella slide, perch√© √® l'unico che √® necessario implementare, tutti gli altri si derivano normalmente.</p>
<p>Lo stesso vale per il tratto <code>Ord</code>, che ha il metodo <code>cmp</code>, questo ha anche una serie di metodi ulteriori come <code>max</code>, <code>min</code>, <code>clamp</code> che ulteriormente possiamo prendere per buoni come sono.</p>
<p>Notate che in quanto <code>Ord</code> implica sia <code>Eq</code> che <code>PartialOrd</code>, automaticamente se un tratto implementa <code>Ord</code> deve anche implementare <code>partial_cmp</code> e quindi ha sicuramente <code>lt</code>, <code>le</code> e compagnia bella che sono usati dal compilatore tutte le volte in cui scrivete <code>qualcosa &lt;= qualcosaltro</code> e cose del genere.</p>
<p>Come accennato, in <code>Ord</code> troviamo altri metodi:</p>
<ul>
<li><code>max</code> d√† il massimo tra due</li>
<li><code>min</code> d√† il minimo tra due</li>
<li><code>clamp</code> permette di far s√¨ che un certo valore stia dentro un intervallo, quindi se √® gi√† compreso in un intervallo restituisce il valore cos√¨ come gliel‚Äôabbiamo dato, se va oltre la fine dell'intervallo lo limita al massimo dell'intervallo, se √® pi√π piccolo del valore minimo lo porta in alto in modo da stare all'interno, in certe situazioni √® molto comodo.</li>
</ul>
<p>Quindi, per poter confrontare due tipi custom dobbiamo implementare dei tratti, <code>Ord</code> o <code>Eq</code>, <code>PartialOrd</code> o <code>PartialEq</code>.</p>
<h2 id="310-display-e-debug"><a class="header" href="#310-display-e-debug">3.10 Display e Debug</a></h2>
<p><img src="images/polimorfismo/image%2030.png" alt="image.png" /></p>
<p>Per poter stampare dei tipi custom dobbiamo implementare i tratti <strong><code>Display</code></strong> o <strong><code>Debug</code></strong>, qual √® la differenza? <code>Display</code> ha un unico metodo che fondamentalmente √® <code>fmt</code> (format), il cui compito √® produrre una rappresentazione utile all'utente finale della nostra applicazione, che quindi racconti qualcosa che ha un senso per una persona che non √® un programmatore.</p>
<p><code>Debug</code> permette di rappresentare una struttura dati in un modo che √® sensato per il programmatore. Anche <code>Debug</code> ha la stessa firma, quindi ha bisogno del metodo <code>fmt</code> che prende il riferimento a se stesso e poi prende un riferimento mutabile a un <code>Formatter</code>.</p>
<p>Mentre <code>Display</code> lo dobbiamo necessariamente implementare a mano, e possiamo venire aiutati dalla macro <code>write!</code>, il <code>Debug</code>, cos√¨ come <code>Eq</code> e <code>PartialEq</code>, possiamo chiedere al compilatore che li generi per noi, come? Aggiungendo prima della struct l'annotazione <code>#[derive]</code> e poi elencando le varie cose.</p>
<p>Per implementare il tratto <code>Debug</code>, usiamo <code>#[derive(Debug)]</code>. Per abilitare i confronti tra le nostre strutture dati (come i cerchi), possiamo usare <code>#[derive(Debug, Eq, Cmp)]</code>.</p>
<p>Vediamo un esempio pratico.</p>
<h3 id="3101-esempio"><a class="header" href="#3101-esempio">3.10.1 Esempio</a></h3>
<p><img src="images/polimorfismo/image%2031.png" alt="image.png" /></p>
<p>Nella definizione del <code>Cerchio</code>, aggiungiamo <code>#[derive(Debug)]</code>. Per quanto riguarda <code>Eq</code>, non possiamo usarlo direttamente perch√© la struct contiene un <code>f64</code> che potrebbe contenere <code>NaN</code> - dobbiamo quindi usare <code>PartialEq</code>. Possiamo anche aggiungere <code>PartialOrd</code>.</p>
<p><img src="images/polimorfismo/image%2032.png" alt="image.png" /></p>
<p>A questo punto possiamo usare <code>println!</code> con il nostro <code>Cerchio c</code>: <code>println!("Il cerchio {:?} ha perimetro {}", c, c.perimetro)</code>.</p>
<p><img src="images/polimorfismo/image%2033.png" alt="image.png" /></p>
<p>Il risultato mostrer√† la rappresentazione interna generata automaticamente: <code>Cerchio { x: 0, y: 1, r: 10 }</code> con perimetro 62.</p>
<p><img src="images/polimorfismo/image%2034.png" alt="image.png" /></p>
<p>Possiamo anche confrontare i cerchi. L'implementazione automatica di <code>PartialOrd</code> non √® molto sofisticata - confronta semplicemente i campi in ordine. Se il primo campo √® minore del primo campo dell‚Äôaltro, considera l'intero oggetto minore, dunque per ora √® preferibile limitarsi all'uguaglianza rimuovendo <code>PartialOrd</code>, oppure implementarlo manualmente confrontando i raggi, in questo caso.</p>
<p><img src="images/polimorfismo/image%2035.png" alt="image.png" /></p>
<p>Possiamo creare un secondo cerchio <code>c2</code>: <code>Cerchio { x: 0, y: 2.1, r: 10.0 }</code> e confrontarli con <code>println!("{:?} == {:?} ? {}", c, c2, c == c2)</code>.</p>
<p><img src="images/polimorfismo/image%2036.png" alt="image.png" /></p>
<p>Se eseguiamo il codice, vedremo il cerchio con centro (0,1) e raggio 10 confrontato con un cerchio con centro (0,1) e raggio 10, risultando in <code>true</code>.</p>
<p><img src="images/polimorfismo/image%2037.png" alt="image.png" /></p>
<p>Cambiando il raggio di uno dei due a 9, otterremo <code>false</code>.</p>
<p><img src="images/polimorfismo/image%2038.png" alt="image.png" /></p>
<p>L'implementazione dell'uguaglianza pu√≤ essere automatica tramite <code>derive</code>. In questo caso, confronter√† tutti i campi: il primo con il primo, il secondo con il secondo, il terzo con il terzo.</p>
<p>Per un'implementazione personalizzata, dobbiamo rimuovere <code>PartialEq</code> dalla macro <code>#[derive(Debug, PartialEq)]</code>, e scriverla manualmente. Ad esempio, per confrontare solo i raggi possiamo fare come mostrato.</p>
<p><img src="images/polimorfismo/image%2039.png" alt="image.png" /></p>
<p>Se modifichiamo il nostro cerchio con coordinate (1,2) e raggio 9, otterremo <code>false</code>.</p>
<p><img src="images/polimorfismo/image%2040.png" alt="image.png" /></p>
<p>Con raggio 10 ma coordinate diverse, otterremo <code>true</code> perch√© confrontiamo solo i raggi.</p>
<p><img src="images/polimorfismo/image%2041.png" alt="image.png" /></p>
<p>Un caso particolare: se usiamo <code>f64::NAN</code> come raggio per entrambi i cerchi, il confronto tra due cerchi con <code>NaN</code> risulter√† <code>false</code>, perch√© come dicevamo, in floating-point <code>NaN != NaN</code>. E questo vale in tutti i linguaggi.</p>
<blockquote>
<p>üí° <strong>La macro Derive</strong></p>
<p><strong>Derive</strong> √® in grado di implementare <code>Debug</code>, <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code> e alcuni altri tratti, ma non tutti, poich√© ogni tratto ha una semantica particolare - questi sono solo i tratti pi√π semplici.</p>
<p>Esistono anche librerie aggiuntive, come <code>derive_more</code>, che forniscono ulteriori tratti da derivare, ma richiedono l'importazione della libreria nel proprio <code>Cargo</code>. √à possibile creare i propri tratti derivabili, e ci sono altre librerie utili come <code>Serde</code> (<em>abbreviazione di serialization/deserialization</em>), che permette di derivare macro per serializzare - ovvero tratti per convertire i propri oggetti in JSON e leggerli da JSON.</p>
<p><code>Serde</code> offre anche la possibilit√† di leggere e generare XML, ma richiede l'importazione specifica del modulo <code>Serde XML</code>.</p>
</blockquote>
<p>Esistono numerosi <strong>tratti</strong> che arricchiscono il comportamento degli oggetti. Esaminiamoli brevemente:</p>
<h2 id="311-clone-e-copy"><a class="header" href="#311-clone-e-copy">3.11 Clone e Copy</a></h2>
<p><img src="images/polimorfismo/image%2042.png" alt="image.png" /></p>
<p>Il tratto <code>Clone</code> indica che un oggetto pu√≤ essere <strong>duplicato</strong>, creando una struttura completamente nuova, indipendente dall'originale (in termini di dipendenze) ma con lo stesso contenuto semantico.</p>
<p>Il tratto <code>Copy</code>, gi√† visto in precedenza, √® un'estensione di <code>Clone</code> (perch√® lo implica) che permette la copia tramite <code>memcpy</code>. Con <code>Copy</code>, le operazioni di movimento diventano operazioni di copia, mantenendo l'originale che quindi non perde il possesso.</p>
<h2 id="312-drop"><a class="header" href="#312-drop">3.12 Drop</a></h2>
<p><img src="images/polimorfismo/image%2043.png" alt="image.png" /></p>
<p>Il tratto <code>Drop</code> indica che l'oggetto ha azioni da eseguire al momento del rilascio, similmente al distruttore in C++. √à mutuamente esclusivo con <code>Copy</code>, prevenendo cos√¨ doppi rilasci in Rust (eccetto in blocchi unsafe).</p>
<p>Il tratto <code>Drop</code> √® parente di una funzione globale <code>drop</code> che permette di terminare immediatamente il ciclo di vita di un oggetto. Questa funzione prende possesso dell'argomento e, non facendone nulla, ne causa la distruzione non appena arriva alla chiusa graffa della funzione.</p>
<h2 id="313-index"><a class="header" href="#313-index">3.13 Index</a></h2>
<p><img src="images/polimorfismo/image%2044.png" alt="image.png" /></p>
<p>Il tratto <code>Index</code> permette di trattare qualsiasi oggetto come un array, usando la sintassi <code>[...]</code>. Ovviamente sta a noi dare un senso a questa cosa qua, laddove la usiamo.</p>
<p><img src="images/polimorfismo/image%2045.png" alt="image.png" /></p>
<p>Supporta:</p>
<ul>
<li>Accesso in lettura e scrittura</li>
<li>Parametri di tipo <code>usize</code> o <code>range</code></li>
<li>Restituzione di elementi singoli o <code>slice</code></li>
</ul>
<h2 id="314-deref"><a class="header" href="#314-deref">3.14 Deref</a></h2>
<p><img src="images/polimorfismo/image%2046.png" alt="image.png" /></p>
<p>Il tratto <code>Deref</code> √® particolarmente importante perch√© permette di trasformare una cosa qualunque in un puntatore. O meglio, di poter usare qualsiasi cosa (che non sia un puntatore) sintatticamente come se fosse un puntatore. √à alla base del comportamento degli smart pointer.</p>
<h3 id="3141-esempio"><a class="header" href="#3141-esempio">3.14.1 Esempio</a></h3>
<p><img src="images/polimorfismo/image%2047.png" alt="image.png" /></p>
<p>Per esempio, implementando <code>Deref</code> per il nostro <code>Cerchio</code>, dobbiamo specificare a quale tipo punta (<code>type Target = f64</code>) e cosa restituire (<code>&amp;self.r</code>).</p>
<p><img src="images/polimorfismo/image%2048.png" alt="image.png" /></p>
<p>Questo ci permette di utilizzare la sintassi dei puntatori (<code>*c</code>) su oggetti che tecnicamente non lo sono, ampliando notevolmente le possibilit√† di utilizzo.</p>
<p><img src="images/polimorfismo/image%2049.png" alt="image.png" /></p>
<p><code>c.deref()</code> dice <em>‚Äúprendi il puntatore associato a</em> <code>c</code><em>‚Äù,</em> e anteponendo l‚Äôasterisco, quindi <code>*c.deref()</code>, vediamo cosa c‚Äô√® dentro.</p>
<h3 id="3142-esempio"><a class="header" href="#3142-esempio">3.14.2 Esempio</a></h3>
<p><img src="images/polimorfismo/image%2050.png" alt="image.png" /></p>
<p>Questa funzionalit√† viene utilizzata in diverse situazioni per creare oggetti che, pur non essendo nativamente puntatori, possono essere usati sintatticamente in tutti i contesti dove si utilizzano i puntatori.</p>
<p>√à importante notare che <code>Deref</code> opera su un prestito di <code>self</code>, e le regole di privacy di Rust continuano ad applicarsi normalmente.</p>
<h2 id="315-rangebounds"><a class="header" href="#315-rangebounds">3.15 RangeBounds</a></h2>
<p><img src="images/polimorfismo/image%2051.png" alt="image.png" /></p>
<p>Il tratto <code>RangeBounds</code> mi d√† la possibilit√† di scrivere degli intervalli <code>..</code>, <code>a..</code>, <code>..b</code>, etc...</p>
<h2 id="316-from"><a class="header" href="#316-from">3.16 From</a></h2>
<p><img src="images/polimorfismo/image%2052.png" alt="image.png" /></p>
<p>Il tratto <code>From</code> mi permette di trasformare una cosa in un'altra.</p>
<h3 id="3161-esempio"><a class="header" href="#3161-esempio">3.16.1 Esempio</a></h3>
<p><img src="images/polimorfismo/image%2053.png" alt="image.png" /></p>
<p>Ad esempio io se ho una stringa, posso scrivere <code>String::from("Mario")</code>. <code>"Mario"</code> √® un <code>&amp;str</code>. Come faccio a farlo diventare una <code>String</code>? In questo caso uso il tratto <code>From</code>, <code>String::from("")</code>. Questo fa s√¨ che lui parta da <code>"Mario"</code> e ne ricavi una stringa. Come fa? Banalmente invocher√† il metodo <code>to_string</code> su Mario e ottiene quella cosa l√¨.</p>
<p><img src="images/polimorfismo/image%2054.png" alt="image.png" /></p>
<p>Ma potrei anche provare a vedere con un <code>i32</code>, e vedere se il suo tratto <code>From</code> √® in grado di convertire un float in i32, ma il compilatore ci d√† errore: il tratto <code>From&lt;{float}&gt;</code> non √® implementato da <code>i32</code>, per√≤ ci d√† la lista dei tipi che supporta, per <code>i32</code>.</p>
<p>In questo caso <code>i32</code> sa solo trasformare altri interi con e senza segno in se stesso.
Volendo potremmo cercare di aggiungere noi delle definizioni.</p>
<p><img src="images/polimorfismo/image%2055.png" alt="image.png" /></p>
<p>E qua ci sono altri esempi.</p>
<h2 id="317-tryfrom-e-tryinto"><a class="header" href="#317-tryfrom-e-tryinto">3.17 TryFrom e TryInto</a></h2>
<p><img src="images/polimorfismo/image%2056.png" alt="image.png" /></p>
<p>I tratti <code>From</code> e <code>Into</code> sono complementari: con <code>From</code> posso dire <em>"creo una stringa a partire da qualcos'altro"</em>, mentre con <code>Into</code> <em>‚Äùtrasformo qualcosa in una stringa‚Äù</em>. Sono due tratti uno all'opposto dell'altro.</p>
<p>C'√® anche la versione <code>TryFrom</code> e <code>TryInto</code>, la differenza √® che ritornano un <code>Result</code>.</p>
<h2 id="318-error"><a class="header" href="#318-error">3.18 Error</a></h2>
<p><img src="images/polimorfismo/image%2057.png" alt="image.png" /></p>
<p><code>Error</code> serve in quelle situazioni in cui si ha l'esigenza di descrivere qualcosa che si √® rotto. Implementare il tratto <code>Error</code> richiede che si implementino sia il tratto <code>Debug</code> che il <code>Display</code>.
Tutti gli altri metodi sono opzionali e hanno una versione default per cui possiamo non implementarli.</p>
<p>Invece occorre garantire che il dato che incastriamo all'interno, che dichiariamo implementare <code>Error</code>, abbia <code>Debug</code> e <code>Display</code>.</p>
<h2 id="319-la-macro-derive"><a class="header" href="#319-la-macro-derive">3.19 La macro <code>derive</code></a></h2>
<p><img src="images/polimorfismo/image%2058.png" alt="image.png" /></p>
<p>La macro <code>derive</code> ci permette di ricavare automaticamente le implementazioni per alcuni di questi tratti, a condizione che siano derivabili. Quindi a condizione che i tipi dei dati contenuti nel tipo per cui eseguiamo la derivazione soddisfino certi vincoli.</p>
<h1 id="4-tipi-generici"><a class="header" href="#4-tipi-generici">4. Tipi generici</a></h1>
<p><img src="images/polimorfismo/image%2059.png" alt="image.png" /></p>
<p>Questo fondamentalmente riassume un po' un insieme di informazioni sui tratti e sull'uso che Rust fa degli stessi. Spendiamo invece ora due parole su un altro modo di implementare il polimorfismo.</p>
<p>Un altro modo che √® sempre nato a casa del C++, ma ha seguito una strada totalmente diversa rispetto alla strada delle Vtable. E l'idea √® passata attraverso l'introduzione del concetto di <strong>programmazione generica</strong>.</p>
<p><em>Che cos'√® la programmazione generica?</em>
La programmazione generica √® l'idea che si possono esprimere degli algoritmi lasciando dei <em>placeholder</em>, diciamo quindi delle indicazioni, su alcuni dei parametri dell'algoritmo stesso. I parametri dell'algoritmo stesso possono essere delle costanti, che qualcuno dovr√† poi fornirmi a un certo punto, e altre sono dei tipi. L'idea √® quindi che io posso, ad esempio, introdurre una funzione <code>f</code>, che √® capace di fare un qualche mestiere indipendentemente, per esempio, dal tipo di parametro che mi viene passato. Perch√© trovo una maniera di combinarlo, oppure a condizione che il tipo di parametro che mi viene passato sia uno di alcuni.</p>
<p>Quest'idea qua richiede che il compilatore lavori in due fasi. Nella prima fase esamina il codice cosiddetto <strong>generico</strong> e verifica che sostanzialmente quel codice l√¨ sia coerente al suo interno, ovvero tutte le parentesi aperte siano chiuse, i punti virgola siano al loro posto, e dove si fa riferimento a qualcosa di generico, dove cio√® c'√® un <em>placeholder</em>, quel <em>placeholder</em> sia usato in modo congruente, quindi se in un punto lo uso come tipo, quando lo ritrovo pi√π avanti deve essere ancora un tipo e mantenere le stesse caratteristiche. Questa √® la fase iniziale, dove verifico semplicemente che il codice sia logicamente coerente.</p>
<p>Quando poi qualcuno user√† la mia funzione, il mio tipo generico, lo user√† in un <strong>modo concreto</strong>, cio√® passandomi e indicandomi che cosa ci vuol fare esattamente. E a questo punto, a quella analisi iniziale che avevo fatto, faccio corrispondere la generazione di codice specifico. Da qualche parte avevo introdotto il tipo <code>Vec</code>, che poteva lavorare sul tipo <code>T</code>, e dice <em>"guarda, io so gestire, so fare <code>Vec</code> di qualunque cosa, non c'√® problema".</em> Detto cos√¨, il compilatore ha preso atto, ma non ha generato ancora nessun codice utile.</p>
<p>Quando poi dico <em>"guarda, qui ho un vettore di <code>i32</code>"</em>, il compilatore capisce e genera una versione specifica di <code>Vec</code> per <code>i32</code>, dove il puntatore interno punta a un blocco di <code>i32</code> sullo heap. Se pi√π avanti creo un <code>Vec</code> di stringhe, il compilatore genera una versione diversa: il blocco sullo heap non contiene pi√π singoli <code>i32</code> da 4 byte, ma stringhe da 24 byte ciascuna, ognuna con un proprio puntatore a un'altra area dello heap dove sono memorizzati i caratteri.</p>
<p>Questa seconda parte, in cui in base a come lo uso genero la versione specifica, prende il nome di <em><strong>monomorfizzazione</strong></em>.
Cio√® il tipo generico <code>Vec&lt;T&gt;</code>, che era polimorfico, quindi andava bene in tanti modi distinti, nel momento in cui io lo istanzio, diventa monomorfico: cio√® ha una forma sola. Quello l√¨ √® un <code>Vec&lt;i32&gt;</code>, che non ha niente a che fare col <code>Vec</code> di stringhe. Sono due cose distinte.</p>
<p><img src="images/polimorfismo/image%2060.png" alt="image.png" /></p>
<p>Io posso utilizzare il concetto di programmazione generica con le funzioni, con le strutture dati, e con i tratti. Vediamo come.</p>
<p>Lo faccio aggiungendo alla definizione della funzione o del tipo l'annotazione scritta tra parentesi angolari, del mio <em>placeholder</em> <code>&lt;typename T&gt;</code>. Cos√¨ da annunciare al compilatore che quella cosa l√¨ non la deve cercare tra quelle che gi√† conosce, ma deve accettare che sia un parametro.</p>
<p>La sintassi √® un po' diversa tra C++ e Rust, ma sostanzialmente si assomigliano. In C++ la cosa √® introdotta dalla parola chiave <code>typename</code>, dentro cui vado a dire <em>"guarda, user√≤ una cosa <code>T</code> che √® un nome di un tipo, <code>typename T</code>"</em>.
A questo punto il compilatore dice <em>"ok, da qui in avanti mi aspetto che T rappresenti il nome di un tipo. Non so ancora che tipo sar√†, me lo dirai tu pi√π avanti‚Äù</em>. Per√≤ va bene, allora lo posso usare per introdurre in questo caso la funzione <code>max</code>, che ritorna il tipo <code>T</code> e accetta due parametri, <code>T1</code> e <code>T2</code>, entrambi di tipo <code>T</code>.</p>
<p>E cosa fa la funzione <code>max</code>?
Beh, in questo caso confronta se <code>T1</code> √® pi√π piccolo di <code>T2</code> mi ritorna <code>T2</code>, se no mi ritorna <code>T1</code>. Lo stesso lo posso fare in Rust: scrivo <code>fn max&lt;T&gt;</code>. Non uso la parola chiave <code>typename</code>, Rust capisce gi√† che quando vede una funzione <code>&lt;T&gt;</code>, quel qualcosa √® il nome di un tipo che potr√† essere usato pi√π avanti.</p>
<p>E infatti qui scriviamo che <code>max</code> prende <code>T1</code> che √® di tipo <code>T</code>, prende <code>T2</code> che √® anche lui di tipo <code>T</code> e restituisce a sua volta un <code>T</code>. E mi aggiunge anche una condizione pi√π specifica, <code>where T: Ord</code> ‚Äî cosa vuol dire questa faccenda qua? Beh, che rispetto al C++, che mi diceva <em>‚Äúio prendo un</em> <code>T</code> <em>qualunque‚Äù</em>, qui mi sta dicendo una cosa un po' pi√π stringente: <em>"guarda io prendo un T qualunque <em><em>a condizione che implementi il tratto</em> <code>Ord</code></em></em><em>, perch√© devo poterli confrontare. Devo confrontarli per ordine col minore."</em></p>
<p>In C++ se io gli passassi, provassi a chiamare <code>max</code> passando due cose che non sono confrontabili, otterrei un errore di compilazione, che non √® purtroppo cos√¨ chiaro. Io mi aspetterei che il C++ mi dicesse <em>"non posso applicare la funzione max a queste due cose qua che tu mi hai scritto, perch√© non so come confrontarle per minore."</em></p>
<p>Invece in queste situazioni i compilatori C++ il pi√π delle volte ti dicono una cosa che non c'entra assolutamente niente. Quattro pagine di errore dove non si capisce assolutamente nulla del perch√© si sta lamentando. Recentemente sono un po' migliorati, ma nella maggior parte di cose viene cos√¨.</p>
<p>Perch√©?
Perch√© C++ mette in queste situazioni tutta una serie di meccanismi che si chiamano <code>SFINAE</code> (<em>Substitution Failure Is Not An Error</em>), per cui lui dice <em>"beh se non ci provo cos√¨ provo a tradurre il tuo tipo T in un'altra cosa, se poi neanche viene lo traduco in una terza cosa"</em>, fa degli obrobri fino a che ha esplorato tutte le strade possibili.</p>
<p>Quando non ha pi√π strade possibili ti dice che l'ultima √® sbagliata. Peccato che l'ultima era pi√π cervellotica e non vi sarebbe mai venuto in mente. E di conseguenza vi trovate spesso in difficolt√† nello spiegare perch√© il codice non compila.</p>
<p>Rust a questo punto √® molto meglio perch√© ci permette di esprimere in modo esplicito i vincoli che vogliamo. In questo caso ci permette di dire che io posso usare questa funzione <code>max</code> con qualunque tipo <code>T</code> che sia ordinabile, cio√® che permetta il confronto con la relazione d'ordine.</p>
<p><img src="images/polimorfismo/image%2061.png" alt="image.png" /></p>
<p>Lasciamo per ora da parte i dettagli sul funzionamento del C++ e concentriamoci sulla parte Rust. Come abbiamo visto, possiamo usare la programmazione generica con le funzioni dichiarando una funzione che termina con <code>&lt;T&gt;</code>. Al posto di <code>T</code> possiamo usare anche <code>K</code> o <code>W</code> - la scelta del nome √® libera. Se necessitiamo di due parametri, possiamo scrivere <code>&lt;T,U&gt;</code> o qualsiasi altra combinazione: sono semplicemente dei nomi generici che, per convenzione, si scrivono in maiuscolo per facilitare la lettura.</p>
<p>Possiamo costruire anche strutture dati generiche.</p>
<p>Quando scriviamo delle strutture dati generiche, usiamo la sintassi <code>struct MyStruct&lt;T&gt;</code>. Come per le funzioni, dopo il nome della struttura mettiamo il parametro <code>T</code>. Possiamo anche aggiungere dei vincoli usando <code>where T: *qualche_caratteristica*</code>. In questo caso, stiamo definendo una struct che dipende da un tipo <code>T</code> a condizione che implementi <code>SomeTrait</code> - questa √® la nostra restrizione. Naturalmente, quando creiamo <code>MyStruct</code> in questo modo, avremo probabilmente dei campi di tipo <code>T</code> che useranno questo tratto.</p>
<p>Dopodich√© quando devo implementare dei metodi, scrivo per com‚Äô√® mostrato a destra: quindi se devo creare dei metodi per le mie struct scrivo <code>impl&lt;T&gt; for MyStruct&lt;T&gt;</code>, notate che quel <code>T</code> √® scritto due volte nell'implementazione: <strong>implemento per il tipo <code>T</code> la struct <code>MyStruct&lt;T&gt;</code> con il vincolo  <code>T: SomeTrait</code></strong>.</p>
<p>Questa faccenda qua la devo scrivere cos√¨ perch√© in certe situazioni (non in questo caso, in cui la stiamo scrivendo in modo assolutamente generico) posso avere delle <em>specializzazioni</em>: posso implementarla solo per gli interi, solo per le stringhe, etc‚Ä¶ cio√® posso aggiungere delle ulteriori varianti.</p>
<p><img src="images/polimorfismo/image%2062.png" alt="image.png" /></p>
<p>Nel momento in cui il compilatore incontra la definizione di tipi generici o di funzioni generiche, fa la prima fase della compilazione: legge quel costrutto che abbiamo messo e verifica che sia intrinsecamente coerente, quindi controlla le parentesi, punti e virgola, e le cose che pu√≤ capire alla luce dei vincoli che gli abbiamo dato. Se non va bene gi√† questo ci blocca. Se viceversa quella struttura l√¨ di per s√© √® coerente, non emette niente in termini di codici.</p>
<p>Quando pi√π avanti, in altre parti del programma, noi facciamo riferimento (invochiamo la funzione o utilizziamo il tipo), noi saremo obbligati a utilizzare la funzione passandogli dei dati concreti o useremo il tipo passandogli dei dati concreti. In quel punto lui dice <em>"Adesso ho capito, tu non vuoi un Vec<T>, vuoi un Vec<String>, benissimo. L'ho gi√† generata la versione di Vec per le stringhe? No? Allora la genero"</em>. In quel momento viene emesso del codice specifico, cio√® viene costruita <strong>la versione monomorfizzata del nostro tipo</strong>.</p>
<p>Se in un pezzo successivo si riusa il tipo generico con lo stesso dettaglio, uso l'implementazione gi√† generata, quindi non aggiungo niente, se viceversa faccio un <code>Vec</code> di un'altra cosa, generer√≤ una nuova versione di <code>Vec</code> adatta. Quindi alla fine, se io nel mio programma uso cinque tipi di vettori, avr√≤ cinque implementazioni del vettore. Una per ciascun tipo di dato intrinseco.</p>
<p>Questo, nonostante tutto, facilita tantissimo la vita del programmatore, perch√© se io ho capito come funziona un vettore, so che indipendentemente dal fatto che quello l√¨ contenga dei numeri, dei booleani o delle stringhe, posso sempre chiedergli <code>len()</code> per sapere quante cose ci sono, posso sempre chiedergli <code>first()</code> per prendere il primo elemento, posso sempre chiedergli <code>last()</code> per prendere l'ultimo, o cose del genere. Posso fare <code>push()</code> per inserire il fondo, <code>pop()</code> per estrarre dal fondo, e cos√¨ via. Quindi questo mi d√† un vocabolario generale indipendentemente dal tipo di dato presente dentro. Chiaramente <code>push()</code> per un vettore di interi vuole un parametro intero, per un vettore di stringhe vuole un parametro di tipo stringa.</p>
<p>E quindi si crea questa forma di polimorfismo attraverso la <strong>programmazione generica</strong>. I due metodi, il polimorfismo creato coi tratti e il polimorfismo creato con la programmazione generica, hanno tanto in comune da un punto di vista logico, perch√© entrambe mi rispondono al bisogno di avere un modo comune di fare delle cose. Da un punto di vista pragmatico, sono due mondi completamente distinti, perch√© usano tutte tecniche differenti.</p>
<h3 id="41-complementarit√†-dei-due-approcci"><a class="header" href="#41-complementarit√†-dei-due-approcci">4.1 Complementarit√† dei Due Approcci</a></h3>
<p>Non √® che ce n'√® uno che va meglio dell'altro, ci sono situazioni che si prestano pi√π facilmente alla programmazione generica, ce ne sono altre che si prestano maggiormente all'uso dei tratti, e spesso e volentieri noi facciamo con la programmazione generica riferimento a tratti o coi tratti facciamo uso della programmazione generica. Quindi le due tecniche si <em>ibridizzano</em>, diventano usate in modo congiunto per poter esprimere delle generalizzazioni ancora maggiori.</p>
<h3 id="42-esempio"><a class="header" href="#42-esempio">4.2 Esempio</a></h3>
<p><img src="images/polimorfismo/image%2063.png" alt="image.png" /></p>
<p>A volte io devo porre molte restrizioni sul tipo di dato su cui voglio operare. Ad esempio, io avrei bisogno qua di implementare una funzione chiamata <code>run_query</code> che probabilmente esegue una qualche richiesta su un database, che prende due parametri. Il primo parametro, lo chiamo <code>M</code>, √® una funzione che fa un mapping: trasforma un insieme di dati in qualche cos'altro. Il secondo, <code>Reducer</code>, √® un qualcosa che opera su sequenze di dati per produrmi un valore singolo.</p>
<p>Cosa sono? Quali tipi concreti sono? Non lo so, e allora posso crearmi questa funzione <code>run_query</code> che √® doppiamente generica: dipende dal tipo <code>M</code> e dal tipo <code>R</code>, dove il tipo <code>M</code> deve soddisfarmi in questo caso due vincoli, <code>Mapper</code> e <code>Serialize</code>, ovvero deve essere un tipo che implementa il tratto <code>Mapper</code>, che probabilmente mi definir√† una funzione <code>map</code> che mi consente di trasformare una cosa in un'altra, e il tipo <code>Serialize</code> che mi permette, ad esempio, di spedirlo attraverso la rete perch√© devo mandarlo al database che ci far√† delle cose. E il tipo <code>R</code> che deve implementare il tratto <code>Reducer</code> e anche il tratto <code>Serialize</code>.</p>
<p>Quindi qui sto esprimendo un vincolo doppio, lo faccio con il simbolo <code>+</code>.
La notazione <code>M: Mapper + Serialize</code> vuol dire <em>‚Äúva bene qualunque tipo purch√© abbia entrambi i tratti‚Äù</em>. Notate che <code>Mapper</code> e <code>Serialize</code> non sono tratto e sottotratto, si ignorano reciprocamente, io qui sto dicendo che devo metterci una cosa che le ha tutte e due.</p>
<p>Questo lo posso scrivere in due modi, lo posso scrivere direttamente nella notazione tra minore e maggiore, come fatto nel pezzo di sopra, o lo posso scrivere come fatto nel pezzo sotto.</p>
<p>Questa seconda notazione mi d√† la possibilit√† di esprimere anche delle relazioni molto pi√π complesse, in questo caso sia <code>M</code> che <code>R</code> hanno dei vincoli, ma non sono reciprocamente legati. In certi casi con la condizione <code>where</code> ho la possibilit√† di aggiungere anche il fatto che <code>M</code> dipende da <code>R</code> o viceversa.</p>
<p>Quindi la sintassi che mi viene offerta √® una sintassi profonda, quindi con la versione compatta quando introduco il tipo generico posso subito dargli dei vincoli, se sono dei vincoli solo per lui. Oppure con la versione stesa, dove introduco il tipo generico solo col nome, definisco tutto quello che devo, e al fondo aggiungo <code>where</code> e l√¨ posso mettere delle espressioni pi√π sofisticate.</p>
<h3 id="43-relazione-tra-tratti-e-tipi-generici"><a class="header" href="#43-relazione-tra-tratti-e-tipi-generici">4.3 Relazione tra Tratti e Tipi Generici</a></h3>
<p><img src="images/polimorfismo/image%2064.png" alt="image.png" /></p>
<p>Come dicevamo, tratti e tipi generici sono due modi apparentemente alternativi per implementare il polimorfismo, ma solo apparentemente, perch√© in realt√† esiste un legame profondo tra le varie parti.</p>
<p>Spesso e volentieri si usano i tratti per <em>limitare l'uso dei tipi generici</em>, ma allo stesso modo si possono definire dei <em><strong>tratti generici</strong></em>, ovvero dei tratti che operano su tipi <code>T</code> da definirsi, e quindi ci sono delle parentele complesse.</p>
<h3 id="44-oggetti-tratto-e-polimorfismo"><a class="header" href="#44-oggetti-tratto-e-polimorfismo">4.4 Oggetti Tratto e Polimorfismo</a></h3>
<p>Con i tratti il polimorfismo pi√π completo lo si ottiene attraverso gli <strong>oggetti tratto</strong>, quando devo scrivere <code>dyn</code>, <code>&amp;dyn</code> o <code>&amp;mut dyn</code>, che vuol dire sto passando un "fat pointer" composto dal puntatore al dato e dalla vtable relativa. Il vincolo con gli oggetti tratti √® che io posso soltanto implementare un tratto. Prima avevo creato la funzione che accettava un <code>&amp;dyn Summarizable</code>, potevo solo dire che era <code>Summarizable</code> quella cosa l√¨.</p>
<p>Se si utilizzasse l'implementazione generica, si potrebbe scrivere la funzione <code>display_summary</code> come <code>display_summary&lt;T&gt;</code> seguito da <code>where T: Summarizable</code>. In questo modo sarebbe possibile aggiungere ulteriori vincoli come <code>where T: Summarizable + Debug + Display</code>. La programmazione generica offre quindi la possibilit√† di esprimere vincoli pi√π sofisticati.</p>
<h3 id="45-compromessi-e-ottimizzazioni"><a class="header" href="#45-compromessi-e-ottimizzazioni">4.5 Compromessi e Ottimizzazioni</a></h3>
<p>In compenso, con la programmazione usando gli oggetti tratto, io sono sicuro che quella funzione l√¨ esiste in un'unica copia che viene implementata cos√¨ com'√®. Che prende sempre 16 byte di puntatore dell'oggetto tratto. Quando creo una funzione generica, nel caso della slide <code>generic_process&lt;T&gt;</code>, dove <code>T</code> deve implementare il tratto <code>Write</code>, io qui di funzioni <code>generic_process</code> ne avrei tante quante sono le diverse tipologie di dato <code>T</code> che vado a utilizzare.</p>
<p>Quindi la versione generica potrebbe generarmi molto pi√π codice della versione con l'oggetto tratto dinamico. √à pi√π flessibile (perch√® appunto consente di esprimere vincoli pi√π complessi), ma mi genera pi√π codice, perch√© ho copie disgiunte, una per ciascuna versione.</p>
<p><img src="images/polimorfismo/image%2065.png" alt="image.png" /></p>
<p>Quindi le <strong>struct generiche</strong>, in generale, portano per√≤ a codice pi√π efficiente, perch√© pu√≤ essere ottimizzato, possibilmente permettendo di togliere quelle parti che sono compilabili a priori, perch√© sono in grado, attraverso l'analisi statica del codice, di vedere cosa capita. Mi permette di usare l'inlining e cos√¨ via.</p>
<p>In pi√π, gli oggetti tratto li posso creare solo nella condizione in cui mi ritrovo a non avere metodi statici all'interno del tratto stesso. Quindi non posso definire un oggetto tratto legato a pi√π tratti disgiunti, mentre lo posso fare dall'altra parte.</p>
<blockquote>
<p>üí° <strong>Monomorphism vs Trait Objects</strong></p>
<p><img src="images/polimorfismo/image%2066.png" alt="image.png" /></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime---malnati-13-14"><a class="header" href="#lifetime---malnati-13-14">Lifetime - Malnati 13-14 <!-- omit in toc --></a></h1>
<h1 id="indice-8"><a class="header" href="#indice-8">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="09-lifetime.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="09-lifetime.html#11-esempio">1.1 Esempio</a></li>
</ul>
</li>
<li><a href="09-lifetime.html#2-riferimenti-e-funzioni">2. Riferimenti e funzioni</a></li>
<li><a href="09-lifetime.html#3-riferimenti-e-strutture-dati">3. Riferimenti e strutture dati</a></li>
<li><a href="09-lifetime.html#4-elisione-dei-tempi-di-vita">4. Elisione dei tempi di vita</a></li>
</ul>
<h1 id="1-introduzione-3"><a class="header" href="#1-introduzione-3">1. Introduzione</a></h1>
<p>Tutti i valori hanno un <strong>tempo di vita</strong>.
Un valore comincia a esistere nel momento in cui viene creato e memorizzato all'interno di una variabile che lo possiede, e resta in vita fino a quando la variabile che lo possiede (o quella che eventualmente l‚Äôha ricevuto dopo un movimento) non viene distrutta.</p>
<p>Nel momento in cui creiamo dei prestiti attraverso il concetto di riferimento, il tempo di vita di un singolo valore comincia a legarsi al tempo di vita di altri valori e questo in Rust √® tracciato in modo esplicito. Adesso vogliamo capire meglio le regole che ci stanno dietro.</p>
<p><img src="images/lifetime/image.png" alt="image.png" /></p>
<p>Noi gi√† sappiamo che un valore inizia a esistere all'interno del blocco in cui √® definito e se non viene mosso cessa di esistere nel momento in cui esce dal proprio blocco, quando l'esecuzione cio√® raggiunge il chiusa graffa corrispondente. Se di questo valore noi ricuperiamo il riferimento, il riferimento potr√† esistere e quindi essere acceduto in vari modi soltanto nell'intervallo di tempo in cui il valore cui il riferimento si riferisce esiste, altrimenti si romperebbe tutto.</p>
<p>Questa √® la grossa differenza che Rust pone rispetto al C e al C++. In C e in C++ voi potete <em>recuperare</em> l'indirizzo di un valore quando vi pare, poi per√≤ il linguaggio non tiene traccia della durata dell‚Äôindirizzo, cio√® del puntatore che ne avete ricavato, rispetto alla durata del valore stesso. Conseguentemente pu√≤ succedere che il puntatore ci sia ancora quando il valore non c'√® pi√π e questo genera i vari problemi di dangling pointer, wild pointer, doppio rilascio o cose del genere.</p>
<p>Tuttavia garantire il controllo dell'esistenza in vita del valore nel momento in cui ho un riferimento a questo pone dei vincoli sul linguaggio stesso, cio√® devo occuparmi di gestirlo.</p>
<p><em>Cosa succede nel momento in cui io recupero il riferimento di un valore e lo passo a una funzione?</em>
Se lo passo a una funzione e la funzione ritorna subito, verosimilmente vuol dire che ho potuto prendere il riferimento a un valore e chiamare una funzione, quindi l'invocazione della funzione √® sintatticamente tutta compresa nello scope in cui il riferimento √® stato passato e di conseguenza per la durata strettamente della funzione le cose vanno bene.</p>
<p>A condizione per√≤ di mettere alcuni puntini sulle i: questo riferimento ha una durata, una durata che il pi√π delle volte noi non esplicitiamo perch√© Rust riesce in moltissime situazioni a capire quale sia effettivamente la durata e non ci chiede di annotare. Tuttavia se noi decidiamo di invocare una certa funzione passandogli uno o pi√π riferimenti, in qualche modo internamente il compilatore si segna che questa invocazione √® soggetta ai vincoli di quel tempo di vita.</p>
<p>La cosa diventa particolarmente importante nel momento in cui la funzione ricevesse non un solo riferimento ma ne ricevesse due o pi√π perch√© occorre che le azioni che la funzione fa siano compatibili con i tempi di vita dei relativi riferimenti. Quindi se noi avessimo una funzione come quella che √® riportata a met√† slide <code>fn f(p: &amp;i32)</code>, di fatto il compilatore trasforma questa notazione (di cui noi abbiamo fatto l'omissione del tempo di vita) nella sua forma esplicita, ovvero quella √® una funzione che √® soggetta a un tempo di vita chiamato <code>a</code> che coincide col tempo di vita del suo riferimento, cio√® √® lecito chiamare questa funzione nel momento in cui quel riferimento esiste, altrimenti non √® lecito chiamare questa funzione.</p>
<p>Questa annotazione permette al compilatore di rendersi conto che quel riferimento l√¨ non esiste per sempre, esiste in un certo periodo e le azioni che vengono svolte all'interno della funzione sono soggette all'esistenza in vita del parametro.</p>
<p>Nel caso in cui la funzione ricevesse pi√π riferimenti, quello che succede √® che il compilatore tenderebbe ad assumere che questi riferimenti abbiano un tempo di vita tendenzialmente <em><strong>disgiunto</strong></em> e quindi se avessimo due riferimenti la riscrittura diventerebbe una cosa <code>fn &lt;'a, 'b&gt;</code>, che vuol dire che ho due riferimenti, il primo gli do un tempo di vita che chiamo a, il secondo un tempo di vita che chiamo b e vado a dire che i parametri sono rispettivamente un riferimento che ha tempo di vita <code>a</code> e si chiama <code>p1</code> e un altro che ha un tempo di vita che si chiama <code>b</code> e il parametro si chiama <code>p2</code>. In questo modo il compilatore prende atto che i due riferimenti sono in qualche modo <strong>indipendenti</strong>.</p>
<p>Ci possono essere delle situazioni in cui noi vogliamo far sapere in modo esplicito al compilatore che quei due riferimenti necessariamente devono durare la stessa quantit√† di tempo. In questo caso dovremmo in modo esplicito andare a dire che la nostra funzione di tempi di vita ne ha uno solo, lo possiamo chiamare come ci pare, di solito si usano le lettere a, b, o c per farla semplice, ed entrambi i riferimenti condividono il tempo di vita.</p>
<p><em>Cosa vuol dire condividere il tempo di vita?</em>
Significa che facciamo delle assunzioni sull'uso dei riferimenti <code>p1</code> e <code>p2</code> passati alla funzione: non solo durante l'esecuzione della funzione stessa, ma anche per le loro conseguenze successive, questi riferimenti devono avere un periodo di sovrapposizione. Le operazioni che la funzione pu√≤ eseguire sono quindi vincolate all'intersezione dei due tempi di vita ‚Äî il periodo in cui entrambi i riferimenti esistono.</p>
<p>Notate che la notazione dei tempi di vita assomiglia un po' alla <strong>notazione generica</strong>, perch√© usa le parentesi angolari alla stessa maniera. Tuttavia, per il compilatore √® solo una notazione. Se la nostra funzione fosse davvero generica, potrebbe ricevere, oltre agli indicatori del tempo di vita, nelle parentesi angolari, anche le metavariabili di tipo(<code>T</code>, <code>U</code>, <code>V</code>, o quelle che vogliamo usare, che normalmente si indicano con una singola lettera maiuscola).</p>
<p><strong>Per sintassi</strong>, il linguaggio prevede che i tempi di vita precedano sempre le eventuali metavariabili di tipo usate nella programmazione generica. Quindi, se abbiamo una funzione generica che prende dei riferimenti, prima ci sono tutte le cose con l'apice, e poi tutte le parti restanti. Ma questo basta saperlo e uno lo fa.</p>
<p>√à importante anche rendersi conto che, quando quella funzione generica venisse usata, il compilatore costruir√† delle versioni specifiche per i tipi con cui la funzione √® stata utilizzata: se io ho detto che la mia funzione agiva su un riferimento al tipo <code>T</code>, qualunque esso sia, nel momento in cui io la chiamo passandogli un riferimento a tipo <code>i32</code>, la funzione verr√† rigenerata dicendo ok, questo <code>T</code>, in questo caso √® un <code>i32</code>, e quindi costruir√† la versione specializzata per gli <code>int32</code>. Questo processo, abbiamo detto, √® la <em>monomorfizzazione</em>.</p>
<p><strong>Gli indicatori di tempo di vita</strong> <strong>non partecipano al processo di monomorfizzazione</strong>, sono solo utili, una notazione sintattica utile, affinch√® il borrow checker possa capire quali sono le conseguenze dei particolari puntatori che noi stiamo passando e quindi possa verificare che non facciamo schifezze.</p>
<p><img src="images/lifetime/image%201.png" alt="image.png" /></p>
<p>Il punto cruciale ****in cui diventa evidente che la nostra funzione ha bisogno dei tempi di vita espliciti comincia a prendere forma nel momento in cui la funzione ritornasse un riferimento.
Qui abbiamo un esempio di un'ipotetica funzione <code>f</code>, che prende due riferimenti <code>p1</code> e <code>p2</code>, a qualunque cosa esse siano (<code>Foo</code> e <code>Bar</code> non ci importa in questo momento cosa siano), e ci ritorna un riferimento. Questa funzione qua ritorna un riferimento a un singolo intero.</p>
<p>√à essenziale dire: <em>"ma questo intero di cui ci viene tornato il riferimento da dove √® preso?"</em>
Non certo da dentro la funzione stessa, deve essere preso <strong>da uno dei suoi parametri</strong>.
Allora, il fatto che noi abbiamo esplicitato che i due parametri avevano tempo di vita <code>'a</code> e <code>'b</code> ci consente di andare a dire che l'<code>i32</code> che viene restituito viene da uno dei due parametri in modo particolare. In questo caso noi stiamo evidenziando il fatto che derivi dal secondo parametro. E infatti andando a leggere nel codice vediamo che il valore restituito √® <code>p2.y</code>, immaginando che il tipo <code>bar</code> abbia un campo <code>y</code>, riferimento a <code>p2.y</code>.</p>
<p>Quindi ci√≤ che √® fondamentale da capire √® che la notazione dei tempi di vita ci serve.</p>
<p>Perch√©? Perch√© se io passo due cose che possono svanire, quindi due cose che ho in prestito, e te ne restituisco una terza, che √® sempre un prestito, devo farti capire questo ulteriore prestito quanto potrebbe durare.</p>
<p>Indicata in questa maniera (nell‚Äôesempio della slide), il compilatore capisce che le conseguenze dell'invocazione di questa funzione sono valide solo nello stesso intervallo di tempo del secondo parametro. Se io invece avessi etichettato la funzione con un'unica lettera, quindi <code>'a p1</code>, <code>'a p2</code>, le conseguenze del risultato erano vere solo nell'<em><strong>intersezione</strong></em>, cio√® potevo accedere al valore risultante solo nell'intervallo di tempo in cui esistevano ancora entrambi i parametri.</p>
<p>Notate che il compilatore da solo non riesce a estrapolare che cosa viene fuori. Tocca a noi farglielo sapere. Questo √® lo sforzo che noi abbiamo nel momento in cui vogliamo costruire una funzione che ritorna un riferimento. E costruire una funzione che ritorna un riferimento ci interessa in tutte quelle situazioni in cui vogliamo esplorare una struttura dati senza fare delle copie, perch√© fare delle copie √® mediamente un'operazione costosa. Esplorare una struttura dati ci piace di pi√π.</p>
<p>Nel caso in cui il compilatore, vedendo che noi abbiamo indicato delle cose, trovasse che c'√® almeno una situazione in cui il risultato della funzione viene usato fuori dal tempo in cui √® lecito usarlo, ci blocca e ci dice <em>"guarda che questa cosa non la puoi fare"</em>.</p>
<p>Vediamo degli esempi.</p>
<h2 id="11-esempio-1"><a class="header" href="#11-esempio-1">1.1 Esempio</a></h2>
<p><img src="images/lifetime/image%202.png" alt="image.png" /></p>
<p>Qui abbiamo una funzione che riceve due riferimenti. Una funzione molto semplice. Il primo √® un riferimento a una stringa (uno slice sostanzialmente), il secondo √® un riferimento mutabile a un vettore. E la funzione, in modo molto banale, inserisce lo slice all'interno del vettore.</p>
<p>Se noi scrivessimo direttamente questa cosa, per il compilatore quello vuol dire <em>‚Äúio ho una stringa che pu√≤ esistere per un tempo</em> <code>a</code><em>, qualunque esso sia, la metto dentro un vettore che esiste in un tempo</em> <code>b</code><em>, qualunque esso sia. Caspita, problema! E chi mi garantisce che il tempo</em> <code>a</code> <em>in cui la stringa esiste √® pi√π grande del tempo in cui esiste il vettore?‚Äù</em>
Se io metto la stringa nel vettore, vuol dire che il vettore la terr√†, ma se posso usare il vettore quando quella stringa non √® pi√π valida, potrei ritrovarmi in una situazione che non va bene. Quindi √® necessario che la stringa duri almeno quanto il vettore, altrimenti non va bene.</p>
<p>Quindi, se io mi limitassi a scrivere questo blocco di codice qua, il compilatore mi blocca con l'errore che viene mostrato nella slide.
Dice <em>"guarda, tu hai due tipi. Siccome non mi hai detto che tempi di vita hanno, per me sono due tempi diversi. Li chiamo genericamente</em> <code>a</code> <em>e</em> <code>b</code><em>. Ma siccome me ne metti uno dentro l'altro e sono diversi, io come faccio a garantirmi che coincidano? Non lo posso sapere‚Äù</em>.</p>
<p><img src="images/lifetime/image%203.png" alt="image.png" /></p>
<p>Quindi aggiungo una notazione e ti dico <em>"guarda, questo slice che ti passo ha tempo di vita</em> <code>a</code><em>, che coincide con il tempo di vita del vettore. O meglio, mi impegno a garantire che duri almeno quanto il vettore, altrimenti me lo segnalerai"</em>.
Perfetto. Ora so che questo vettore, che continuer√† a esistere successivamente, esister√† certamente almeno quanto la stringa che vi ho inserito.</p>
<p>Ma il compilatore non √® contento ancora, perch√© sapere che il vettore esiste per il tempo di quella stringa non mi √® ancora garante che il vettore contenga <strong>solo</strong> cose che sono valide. E quindi mi dice <em>"guarda che non solo il vettore deve durare quanto quello slice, ma tu mi devi anche dire che questo vettore contiene solo cose che sono valide per tutto il suo tempo di vita"</em>. E quindi la notazione <code>'a</code> non va aggiunto solo al riferimento del vettore, ma va aggiunto <strong>anche a ci√≤ che il vettore contiene</strong>. Quindi quello √® un vettore che ha tempo di vita <code>a</code> e che contiene cose che durano almeno <code>a</code>. E a questo punto gli possiamo aggiungere un'altra cosa che dura almeno <code>a</code>.</p>
<p>Per cui, il compilatore ci aiuta da questo punto di vista e ti dice <em>"aggiungi il tempo</em> <code>a</code> <em>al tipo di</em> <code>v</code><em>, ovvero dimmi che</em> <code>v</code> <em>√® un ref mut (che dura</em> <code>a</code><em>) a un vettore che contiene slice che durano</em> <code>a</code><em>"</em>. Questo √® come il compilatore ci guida per capire. Cos√¨ non capita che noi mettiamo nel vettore cose che durino di meno, perch√© diventa parte della sua firma esplicita.</p>
<p>A questo punto abbiamo corretto questa cosa e la funzione <code>f</code> compila.</p>
<p><img src="images/lifetime/image%204.png" alt="image.png" /></p>
<p>Poi per√≤ nel main scriviamo questa cosa qua. Creiamo il vettore <code>v</code>. Bene.</p>
<p>Poi apriamo un blocco. All'interno di questo blocco creiamo una stringa. Nessun problema. Salviamo nel vettore, tramite <code>v.push</code> o tramite la funzione <code>f</code>, il riferimento alla stringa.</p>
<p><em>Ah, questo √® un problema.</em> Quella stringa che abbiamo creato esiste nella coppia di graffe dentro cui l'abbiamo definita. Di conseguenza il suo riferimento dura quanto la coppia di graffe. Ma il vettore dura di pi√π, perch√© il vettore √® nato prima e lo usiamo dopo.</p>
<p>Quindi <strong>non √® vero</strong> che nel vettore stiamo infilando quello che stiamo dicendo. E quindi il compilatore ci blocca. <code>Borrowed value does not live long enough</code>.</p>
<p><strong>Questo √® il modo con cui Rust ci aiuta.</strong> In C questa cosa voi non la vedete. E' sbagliata, ma il compilatore la compila senza nessun problema. Non ha nessuna consapevolezza che state scrivendo un'idiozia. E di conseguenza quel codice l√¨ passa, va avanti e a un certo punto si spacca. E non sapete quando e come. E il pi√π delle volte non sapete dire perch√©.</p>
<p>Il Borrow Checker non verifica solo questi casi banali - questo √® solo un piccolo esempio fatto per essere comprensibile e spiegabile in una slide. Il Borrow Checker fa tutte le verifiche anche in situazioni complesse, quando passo un puntatore attraverso una catena di funzioni e lo sposto in diverse parti del programma. Ti intercetta ogni volta con precisione perch√© <strong>dimostra il teorema della correttezza dei tempi di vita</strong>. √à fondamentale che capiate e apprezziate questo concetto.</p>
<p><strong>Quindi il fatto che ci siano delle funzioni che prendono riferimenti e generano riferimenti</strong> richiede che noi facciamo questo piccolo sforzo di dare indicazioni sulla semantica della nostra funzione, cio√® <em>‚ÄúQuanto dura il riferimento restituito rispetto ai riferimenti passati?‚Äù</em></p>
<h1 id="2-riferimenti-e-funzioni"><a class="header" href="#2-riferimenti-e-funzioni">2. Riferimenti e funzioni</a></h1>
<p><img src="images/lifetime/image%205.png" alt="image.png" /></p>
<p><em>Caso 1: Un solo riferimento</em>
Se una funzione ha un unico riferimento in ingresso assume che l'eventuale riferimento in uscita abbia la stessa durata e quindi ci consente questo processo chiamato <strong>elisione dei tempi di vita</strong>. Quindi noi possiamo banalmente scrivere la funzione <code>f</code> che prende riferimento <code>x</code> e restituisce riferimento <code>y</code>. Visto che ce n'√® solo un ingresso e uno in uscita il compilatore tranquillo dice quello in uscita durer√† quanto quello in ingresso.</p>
<p><em>Caso 2: Riferimenti multipli</em>
Se invece ce ne sono almeno due in ingresso e uno in uscita, il compilatore non √® in grado di decidere e non pu√≤ farlo perch√© potrebbero esserci degli <code>if</code> o altri costrutti condizionali all'interno del nostro codice che possono essere valutati solo nel momento in cui abbiamo tutti i parametri in ingresso, quindi l'analisi statica non permetterebbe di dire quanto dura. Di conseguenza tocca a noi andare a descrivere questa cosa qua.</p>
<p>Esempio slide:
In questo caso qui abbiamo una funzione <code>f</code> che prende due riferimenti con relativi tempi di vita che abbiamo chiamato <code>b</code> e <code>c</code>, e tale funzione ci restituisce un parametro che ha tempo di vita <code>c</code>. Questo permette al compilatore di farci dei ragionamenti sopra. Siccome ci restituisce un riferimento che ha tempo di vita <code>c</code> questo ha due livelli di implicazione:</p>
<ul>
<li>Un livello di implicazione sull'accesso al riferimento in quanto tale, cio√® io non posso leggere il contenuto di quel riferimento (cio√® dereferenziarlo) oltre il periodo in cui lui esiste.</li>
<li>Ma anche una cosa al contrario: siccome quello √® ‚Äúun pezzo‚Äù del parametro <code>y</code> che ho ricevuto, il valore che era stato attribuito al parametro <code>y</code> (in questo caso <code>v2</code>) non pu√≤ essere cambiato fin tanto che io uso quel riferimento (il riferimento restituito), perch√© altrimenti non appattano pi√π le cose.</li>
</ul>
<p><strong>Esempio concreto:</strong> L√¨ ho <code>v1</code> che √® una tupla [<strong>ndr:</strong> <em>Il prof continua a parlare di tupla, ma io tuple non ne vedo, al massimo S mi sembra una ipotetica struct</em>.] che contiene il numero 1 e <code>v2</code> che √® un'altra tupla e contiene il numero 2. I due riferimenti a questa tupla li passo alla funzione <code>f</code> la quale si fa delle cose sue e poi decide di ritornarmi un pezzo della seconda tupla. Che sia un pezzo della seconda tupla lo capisco dal fatto che la signature del tempo di vita del risultato coincide col tempo di vita del secondo parametro.</p>
<p>Questo il compilatore capisce. Di conseguenza esiste un vincolo:</p>
<ul>
<li>Non posso accedere al risultato <em>oltre la durata</em> di <code>v2</code></li>
<li>Non posso modificare <code>v2</code> fin tanto che faccio accesso al risultato</li>
</ul>
<p>In questo caso se io provassi a compilare il codice lasciando la riga barrata in rosso otterrei un errore che mi dice <em>‚ÄúAttenzione: qui c'√® un conflitto perch√© tu stai cambiando le carte in tavola, stai mutando una struttura, e un pezzo di questa struttura √® osservato dalla riga successiva‚Äù</em>. Questo non si fa: finch√© gli ti ho dato il prestito, l'impegno √® che non me lo cambi.</p>
<p>Notate che se non ci fosse questo legame dovuto ai tempi di vita espliciti, un parametro era la struttura di tipo tupla, e il valore restituito √® un riferimento a <code>u8</code> ‚Äî apparentemente sono due cose separate, non c'√® un legame di tipo tra i due ma c'√® un legame sostanziale: quell'u8 √® parte della tupla in qualche misura, o almeno abbiamo dichiarato cos√¨.</p>
<p>Quindi l'aver aggiunto questa notazione consente al compilatore di fare questo ragionamento ed evitare delle schifezze. Questa faccenda qua √® la base della solidit√† di Rust.</p>
<p><img src="images/lifetime/image%206.png" alt="image.png" /></p>
<p><strong>Notate che √® pi√π complesso.</strong> Allora, dal punto di vista del compilatore l'aggiunta dei tempi di identificatori dei tempi di vita ha <strong>due valenze</strong>.</p>
<p><em>Prima di tutto</em> nel momento in cui io invoco questa funzione senza sapere cosa c'√® scritto dentro (quindi limitandomi a guardare la sua firma) arrivo a capire che mi verr√† generato un risultato che dipende da entrambi o da uno solo dei parametri che io sto passando alla funzione. Di conseguenza devo prolungare tutti i vincoli legati al prestito per il tempo in cui non solo esistono i due prestiti specifici ma esiste anche il risultato.</p>
<p>Perch√© se io mi limitassi, nell'esempio precedente, a guardare il codice, <code>&amp;v1</code> e <code>&amp;v2</code> esistono esclusivamente per la durata dell'invocazione di <code>f</code>. Quindi potrei dire <em>"ah ma quando</em> <code>f</code> <em>ritorna quei prestiti l√¨ non ci sono pi√π, sono andati"</em>. In realt√†, siccome la funzione mi ha restituito un pezzo di <code>v2</code> , il prestito su <code>v1</code> effettivamente non c'√® pi√π e quindi io a <code>v1</code> posso far fare quello che voglio (in questo caso non √® mutabile ma se lo mettessi mutabile lo potrei tranquillamente cambiare), ma <code>v2</code> invece non lo posso cambiare fintanto che il risultato che qui ho chiamato <code>r</code> √® vivo, e siccome uso il risultato ancora nell'ultima linea <code>print byte(r)</code> questo mi tiene in vita.</p>
<p><strong>Quindi la conoscenza della firma permette al codice</strong> che vede che quella funzione l√¨ √® usata, di capire come deve gestirsi i vincoli.</p>
<p>Quando invece il compilatore invece di concentrarsi su dove chiamo la funzione si sta concentrando sul <em>come genero il codice della funzione</em>, che avviene in un qualche altro momento il compilatore controlla che non faccia schifezze. Se tu mi hai dichiarato che il risultato ha tempo di vita <code>c</code>, che corrisponde a quello del secondo parametro, ma tu cerchi di assegnarmi come risultato un riferimento al primo che ha tempo di vita <code>b</code> , ti blocca. Quindi questa scrittura che noi facciamo in ogni caso √® validata dal fatto che effettivamente non combiniamo delle schifezze. Questo in qualche modo ci aiuta.</p>
<p><strong>Nel momento in cui l'invocazione avviene</strong> quello che il compilatore verifica √® che gli identificatori che noi abbiamo passato esistano almeno per il tempo minimo necessario affinch√® tutto abbia senso. Quindi non posso leggere il riferimento oltre il suo tempo di vita e non posso modificare la variabile finch√© il riferimento √® in uso.</p>
<h1 id="3-riferimenti-e-strutture-dati"><a class="header" href="#3-riferimenti-e-strutture-dati">3. Riferimenti e strutture dati</a></h1>
<p><img src="images/lifetime/image%207.png" alt="image.png" /></p>
<p><strong>Il problema non c'√® solo con le funzioni</strong> che possono smontare o prendere un pezzo di una cosa pi√π grande. Il problema si pone anche con le <strong>strutture dati</strong>.
Se io salvo un riferimento che necessariamente ha un tempo di vita dentro una struttura dati quella struttura dati l√¨ diventa anche lei <em>a rischio</em>, cio√® <em>eredita il tempo di vita <strong>pi√π breve</strong> di tutti i riferimenti che contiene al suo interno</em>. Quindi salvare il riferimento da qualche parte implica che il tempo di vita del riferimento, che √® un pezzo, si propaga al tutto.</p>
<p>Se io costruisco quest'aula ma c'√® un mattone che dopo tre mesi si sbriciola l'aula dopo tre mesi √® a rischio perch√© se quel mattone l√¨ viene meno potrebbe crollare tutta quanta. <strong>Quindi il pezzo dentro la struttura <em>implica</em> la durata massima di validit√† della struttura intera.</strong></p>
<p><em>Lo stesso vale se fate una torta.</em> Se ci mettete dentro delle cose che sono che hanno una conservazione limitata chiaramente il tempo minimo dell'ingrediente implica la validit√† di quello che andate a sintetizzare con la vostra cosa. Quindi tenete presente che tutto questo vale altrettanto.</p>
<p><strong>Ad esempio</strong> qui nella slide viene mostrato una struttura <code>User</code> che contiene un riferimento. Siccome questo √® un riferimento, e ha una durata, √® necessario che noi andiamo a dire che anche la struttura ha una durata, che √® almeno al massimo quella del suo riferimento. E se questa struttura diventa parte di una struttura pi√π grande (non come riferimento, ma semplicemente come parte di una struttura pi√π grande, com‚Äô√® mostrato poi nella struttura <code>Data</code>), anche la struttura pi√π grande si prende lo stesso vincolo.</p>
<p>Perch√© √® necessario garantire che solo del codice corretto possa essere scritto. <em>Non deve esistere nessuna situazione in cui io credo di poter accedere a un indirizzo di memoria quando in realt√† non posso farlo.</em></p>
<p>Questa cosa qua a sentirla raccontare fila.
Poi quando scrivete il codice non sapete da che parte mettere le mani. Quindi bisogna allenarsi. <strong>Per√≤ √® proprio la base</strong>, il motivo per cui il mondo sta sterzando verso Rust √® perch√© Rust ci d√† <strong>questo</strong> livello di garanzia.</p>
<p>N√® C, n√® C++ ce lo possono dare. Gli altri linguaggi, <em>Java, JavaScript, Python,</em> e compagnia bella, ci danno una garanzia sui tempi di vita.
Come? <strong>Prolungando l'esistenza in vita.</strong> Se io conosco il puntatore di un dato automaticamente quel dato dura fin tanto che io lo conosco. Che √® certamente una soluzione corretta. Non posso avere dei memory fault in questa maniera.</p>
<p><strong>Piccolo problema:</strong> il mio fabbisogno di memoria cresce tantissimo. Perch√© devo necessariamente prolungare la vita di oggetti e quindi tenerli allocati anche se non mi servirebbero pi√π. Non solo, ma siccome io posso prolungare la vita solo di cose sullo heap e non di cose sullo stack, perch√© lo stack si deve poter contrarre, questo implica che i linguaggi come Java, JavaScript, Python e compagnia bella non possono usare <strong>tipi valore</strong>, cio√® memorizzati nello stack.</p>
<p>Questo comporta un <em>aggravio delle prestazioni</em>. Perch√© tutte le volte in cui mi serve un nuovo valore io devo andare a cercare nello heap un posto grande a sufficienza per tenerlo e devo poi gestirmi questo rilascio in qualche maniera.</p>
<p>Da questo punto di vista C e C++ viceversa non hanno nessun problema a lasciarci costruire tipi valore, cio√® oggetti pi√π o meno complessi che esistono all'interno dello stack e che quindi hanno un costo di allocazione e rilascio molto basso. <strong>Il problema √® che</strong> non potendo verificare la liceit√† dei puntatori lasciano spazio agli <strong>undefined behavior</strong>, che sono poi la porta dei vari exploit che vengono usati dagli hacker, che sono la porta anche di tutti i malfunzionamenti che noi poi andiamo a verificare quotidianamente.</p>
<p>Rust, da questo punto di vista, ci permette senza problema di creare tipi valore, cio√® dichiarati sullo stack e quindi molto agili dal punto di vista della loro allocazione e del loro rilascio, garantendo al tempo stesso la correttezza del codice che andiamo a scrivere. Tutto al pi√π non compila. Questo √® un po' fonte di frustrazione per il programmatore, ma √® una frustrazione sana. <em>Non compila vuol dire che non hai capito abbastanza, ma √® meglio che te lo dica lui subito piuttosto che dopo.</em></p>
<h1 id="4-elisione-dei-tempi-di-vita"><a class="header" href="#4-elisione-dei-tempi-di-vita">4. Elisione dei tempi di vita</a></h1>
<p><img src="images/lifetime/image%208.png" alt="image.png" /></p>
<p>Se non mettiamo in modo esplicito un tempo di vita nelle strutture, cos√¨ come nelle funzioni, per Rust sono tempi di vita indipendenti, quindi l'eventuale struct <code>Point</code> che dichiariamo qua, che contiene due riferimenti, per il compilatore √® come se fossero due riferimenti completamente disgiunti. Se noi passiamo questa struct <code>Point</code> a una funzione che prende un'ulteriore variabile di tipo riferimento, quello √® ancora un tempo di vita disgiunto.</p>
<p>Quindi la funzione <code>scale</code>, nella parte bassa sinistra, che prende un riferimento <code>r</code> e il punto <code>p</code>, che implicitamente ha due tempi di vita disgiunti, di fatto per il compilatore √®, come vediamo nella parte destra, una funzione che opera su tre riferimenti che possono essere completamente indipendenti tra di loro. Quindi il tempo di vita di <code>r</code> √® indipendente dal tempo di vita del campo <code>x</code> della struttura point, che √® indipendente dal tempo di vita della struttura <code>y</code>, eccetera. E di conseguenza ci lascer√† solo fare operazioni compatibili con questa faccenda.</p>
<p>Se noi ci trovassimo a dover ritornare come valore un riferimento o fare delle assunzioni che non permettono di essere certi che i tre tempi di vita sono realmente indipendenti, il compilatore ci bloccherebbe e ci chiederebbe di esplicitare quale vincolo sia necessario.</p>
<p><img src="images/lifetime/image%209.png" alt="image.png" /></p>
<p>Quindi se una funzione restituisce un riferimento o restituisce un tipo che contiene direttamente o indirettamente un riferimento, bisogna far capire quanto dura questo riferimento.</p>
<p>Nel caso in cui la funzione avesse in ingresso un solo parametro dotato di tempo di vita, implicito e esplicito, Rust dice <em>"io assumo che il tempo di vita del risultato restituito sia lo stesso dell‚Äôunico parametro ricevuto".</em> Se invece ci sono pi√π parametri dotati di tempi di vita <em>diversi</em>, allora tocca al programmatore disambiguare.</p>
<p><em>Chi √® dotato di tempo di vita?</em>
I riferimenti hanno tutti un tempo di vita. Le strutture dati, qualunque esse siano, struct, enum o tuple, che hanno dentro di s√© dei riferimenti <em>acquisiscono</em> il tempo di vita del loro riferimento. Le strutture che contengono strutture che contengono riferimenti acquisiscono il tempo di vita del riferimento, eccetera. Se una struttura contiene pi√π oggetti che hanno un tempo di vita, quei tempi di vita devono coincidere, altrimenti non va bene, cio√® devono avere un'intersezione.</p>
<p>Questo √® il motivo per cui nell‚Äôesempio del vettore di slice mostrato all‚Äôinizio, abbiamo dovuto dire che la durata dello slice, non solo doveva essere almeno coincidente con quella del vettore, ma andavamo anche a dire che comunque dentro quel vettore l√¨ metteremo solo delle cose che durino almeno quanto il vettore stesso.</p>
<p>Se abbiamo un metodo (invece che una funzione esterna), ovvero all'interno di un blocco <code>impl</code>, che prende <code>&amp;self</code>, o <code>&amp;mut self</code>, il tempo di vita dell'eventuale risultato per il compilatore <strong>coincide</strong> col tempo di vita di <code>self</code>. Se non √® cos√¨, dobbiamo andarlo a dire in modo esplicito.</p>
<p><strong>Queste sono le regole di elisione</strong>, cio√® il motivo per cui nella maggior parte dei casi noi possiamo <em>non scrivere</em> in modo esplicito il tempo di vita. Ma non √® che non ci sia, <em>c'√®</em> e il compilatore ci risparmia l'onere di farlo vedere, anche se sarebbe un buon esercizio scriverlo in modo esplicito perch√© cos√¨ almeno lo capiamo, ne prendiamo pi√π consapevolezza.</p>
<p><em>Cos'√® il lifetime static?</em>
Il lifetime static √® un'eccezione: noi i lifetime li chiamiamo come ci pare.
L'unica cosa che non possiamo mettere come vogliamo √® <code>‚Äòstatic</code>, perch√© quello lo possiamo mettere ma ha un significato particolare. Una cosa ha lifetime static, se √® un riferimento, ed √® un riferimento che certamente dura quanto l'intero programma. Nel caso delle stringhe, delle slice, quando noi mettiamo una slice costante, <code>‚Äúciao‚Äù</code>, quello diventa un pezzo del sorgente del nostro programma. Viene allocato in una zona delle costanti e di conseguenza esiste da quando il nostro programma parte fino a quando il programma terminer√†, perch√© √® statico, √® messo l√¨ dentro. Quindi, la variabile <code>let s: &amp;str = ‚Äúciao‚Äù</code>, di fatto ha un tempo di vita <strong>static</strong>.</p>
<p><strong>Attenzione,</strong> <strong>il tempo di vita static non √® solo quello.</strong>
Se una variabile possiede interamente il suo valore, cio√® non ha riferimenti, quella variabile ha tempo di vita static. Quando io dichiaro <code>let i: i32 = 25</code>, <code>i</code> possiede il suo valore, e ha come tempo di vita static, che vuol dire che di per s√© lei possiede. Quindi se io faccio dei ragionamenti: fin tanto che <code>i</code> esiste, non √® soggetto a dipendenze di altri.</p>
<p>Nei riferimenti √® una cosa che dura per tutta la durata del programma.
Nei <em>non riferimenti</em> vuol dire che non ha pendenze legate al tempo, quindi √® totalmente padrone del suo valore.</p>
<p>Se invece una struct o una variabile contiene al suo interno qualcosa ‚Äî tipicamente una struct con campi che hanno un tempo di vita ‚Äî allora non √® pi√π static. Questo perch√©, anche se quella variabile possiede il suo valore, si tratta di un valore "ipotecato": una parte di esso non dura quanto vuole la variabile, ma dipende dalla durata di qualcos'altro, e quindi non pu√≤ essere static.</p>
<p>Quindi static sui riferimenti, sono quei riferimenti che possiamo garantire esistono dall'inizio fino alla fine del programma. Il caso pi√π pratico √® sulle slice costanti.
Viceversa, sulle restanti variabili, tempo di vita static √® quello di chi non ha ipoteche sul proprio valore.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chiusure---malnati-14-15"><a class="header" href="#chiusure---malnati-14-15">Chiusure - Malnati 14-15 <!-- omit in toc --></a></h1>
<h1 id="indice-9"><a class="header" href="#indice-9">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="10-chiusure.html#1-introduzione">1. Introduzione</a></li>
<li><a href="10-chiusure.html#2-programmazione-funzionale">2. Programmazione funzionale</a>
<ul>
<li><a href="10-chiusure.html#21-funzioni-di-ordine-superiore">2.1 Funzioni di ordine superiore</a>
<ul>
<li><a href="10-chiusure.html#211-in-c">2.1.1 ‚Ä¶in C</a></li>
<li><a href="10-chiusure.html#211-in-c-1">2.1.1 ‚Ä¶in C++</a></li>
<li><a href="10-chiusure.html#211-in-rust">2.1.1 ‚Ä¶in Rust</a></li>
</ul>
</li>
<li><a href="10-chiusure.html#22-oggetti-funzionali">2.2 Oggetti funzionali</a>
<ul>
<li><a href="10-chiusure.html#221-esempio-la-classe-accumulatore">2.2.1 Esempio: La Classe Accumulatore</a></li>
<li><a href="10-chiusure.html#222-sintassi-nei-diversi-linguaggi">2.2.2 Sintassi nei Diversi Linguaggi</a></li>
<li><a href="10-chiusure.html#223-variabili-libere">2.2.3 Variabili libere</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="10-chiusure.html#3-cattura-delle-variabili-in-rust">3. Cattura delle variabili in Rust</a>
<ul>
<li><a href="10-chiusure.html#31-esempi-pratici">3.1 Esempi pratici</a>
<ul>
<li><a href="10-chiusure.html#311-esempio-1">3.1.1 Esempio 1</a></li>
<li><a href="10-chiusure.html#311-esempio-2">3.1.1 Esempio 2</a></li>
</ul>
</li>
<li><a href="10-chiusure.html#32-la-parola-chiave-move">3.2 La parola chiave <strong><code>move</code></strong></a></li>
<li><a href="10-chiusure.html#33-tratti-funzionali">3.3 Tratti funzionali</a></li>
</ul>
</li>
<li><a href="10-chiusure.html#4-riferimenti">4. Riferimenti</a></li>
<li><a href="10-chiusure.html#5-applicazioni-pratiche">5. Applicazioni pratiche</a></li>
</ul>
<h1 id="1-introduzione-4"><a class="header" href="#1-introduzione-4">1. Introduzione</a></h1>
<p>Affrontiamo un altro capitoletto semplice, ma strano come minimo.
Vogliamo introdurre le <em><strong>chiusure</strong></em>, che vengono anche chiamate <em><strong>funzione lambda</strong></em>.</p>
<p><strong>Attenzione,</strong> il termine funzione lambda recentemente, negli ultimi anni, ha preso anche una seconda connotazione. Qui √® derivato dal <strong>calcolo lambda</strong>, nato almeno con il linguaggio Lisp negli anni '60, ma probabilmente il calcolo lambda come espressione matematica esiste almeno degli anni '20 del secolo scorso, quindi stiamo parlando di un secolo fa.</p>
<p>Il termine lambda √® stato usato dai signori di Amazon Web Service per rappresentare le cosiddette "<em><strong>serverless functions</strong></em>", ovvero dei blocchi di codice che possono essere eseguiti alla bisogna quando si verifica un qualche evento.
Quello √® un caso che per√≤ √® una semantica diversa, quindi se voi fate una ricerca su Google di "Rust lambda" rischiate di finire su come si fa una serverless function in AWS senza capire quello che invece qua ci interessa.</p>
<p>Il termine che noi qui usiamo per evitare questa ambiguit√† √® <strong>chiusura</strong>.</p>
<p><img src="images/chiusure/image.png" alt="image.png" /></p>
<p>Per dare un senso a questa cosa dobbiamo fare uno shift paradigmatico, cio√® noi sappiamo che la programmazione pu√≤ essere di tipo <strong>imperativo</strong>, dove cio√® ci basiamo sul fatto che facciamo delle azioni che hanno degli effetti collaterali, che si propagano su delle variabili. Queste variabili nel tempo mantengono il loro valore e di conseguenza possiamo immaginare che il nostro algoritmo √® fatto dell'azione 1, che fa qualcosa, dell'azione 2, che fa qualcos'altro, dell'azione 3, che combina quelle due cose l√¨ in un modo ulteriore, eccetera. Questo √® un modo di pensare la programmazione.</p>
<h1 id="2-programmazione-funzionale"><a class="header" href="#2-programmazione-funzionale">2. Programmazione funzionale</a></h1>
<p>C'√® un altro modo di pensare la programmazione, che √® l'approccio cosiddetto <em><strong>funzionale</strong></em>. L'approccio funzionale fondamentalmente mette le sue radici nella matematica.</p>
<p><em>Cos'√® una funzione in matematica?</em>
√à un modo di combinare pi√π valori. La <strong>funzione</strong>, in matematica, ha determinate caratteristiche.</p>
<ul>
<li>Dipende esclusivamente dai parametri che la funzione riceve</li>
<li>Non ha effetti collaterali</li>
</ul>
<p>Quanto fa 3+2? 5.
Se lo chiedo di nuovo, quanto fa 3+2? Sempre 5.
Se si mette a piovere, quanto fa 3+2? 5.
Pu√≤ il calcolo di 3+2 causare la pioggia? No.</p>
<p>Questo vuol dire funzione che non ha effetti collaterali.</p>
<p>Il fatto che non abbia effetti collaterali √® molto interessante, ma √® anche molto problematico. √à molto interessante perch√© io so che posso calcolarla tutte le volte che voglio, senza avere nessun problema. Pu√≤ succedere attorno di me pi√π o meno qualunque cosa, e 3+2 fa sempre 5. Grande.</p>
<p>Ma √® anche molto inutile. Proprio perch√© 3+2 fa sempre 5, chi se ne frega di calcolarlo?</p>
<p>Cent'anni fa, chi studiava ingegneria si comprava il tomo delle tabelle dei seni e dei coseni. Perch√© l'ingegnere del tempo aveva bisogno di fare i calcoli. Piccolo problema: quanto fa il seno di 37,5¬∞? Beh, calcolarlo a mano √® un po' dura, si puoi fare lo sviluppo di Taylor, ma non ti passa pi√π. Per cui venivano stampati, a beneficio degli allievi ingegneri, queste tabelle degli integrali, eccetera, che contenevano precalcolati tutta una serie di numeri. E andava benissimo, perch√© tanto il seno di 37,5 fa sempre quel numero l√¨. Non √® che cambia nel tempo.
Quindi, il fatto che le funzioni non dipendono da altre cose, consente di calcolarle in anticipo.</p>
<p>Questo √® un po' utile, e un po' inutile. Nella programmazione nostra, come lo calcoliamo il seno di 0,5? Tutte le volte che invochiamo seno di 0,5, parte un algoritmo che si mette l√¨ e sfruttando l'algoritmo di Taylor o qualunque altra approssimazione abbiano voluto, lo ricalcola.</p>
<p>Quello √® l'approccio standard della programmazione. Non √® particolarmente intelligente, ma √® come di fatto i nostri calcolatori funzionano. Cos√¨, quando fate la radice quadrata di 4, lui si mette l√¨ e si fa i suoi conticini. Per√≤ non sta inventando proprio niente.</p>
<h2 id="21-funzioni-di-ordine-superiore"><a class="header" href="#21-funzioni-di-ordine-superiore">2.1 Funzioni di ordine superiore</a></h2>
<p>I matematici per√≤, che sono bravi a creare astrazioni, hanno detto <em>"Vabb√®, una funzione mangia dei dati e produce un risultato".</em></p>
<p><em>Ma cosa sono questi dati e che cos'√® questo risultato?</em>
Beh, nella versione pi√π semplice i dati sono dei numeri e il risultato √® un numero. √à come vi hanno insegnato la matematica agli elementari, dove vi hanno spiegato che <code>3+2 = 5</code>. Questo √® molto conveniente perch√© ci consente di ragionare sul fatto che abbiamo quei numeri l√¨, possiamo trovare un risultato che ha innumerevoli applicazioni pratiche: andate al mercato e potete capire quanto spendete o cose del genere.</p>
<p>Poi per√≤ siete andati alla scuola media. Alla scuola media vi hanno insegnato il calcolo letterale. Cosa √® successo nel calcolo letterale? Beh, vi hanno insegnato che potevate scrivere <code>3+2</code> ma potevate anche scrivere <code>A+B</code>. E se potevate scrivere <code>A+B</code> diventava interessante perch√© si potevano dedurre delle propriet√†. Ad esempio che <code>A+B</code> √® uguale a <code>B+A</code>. E quindi quando vedete scritto <code>A+B</code> potete sostituirlo con <code>B+A</code> che tanto va bene lo stesso. Vi hanno insegnato che qualunque cosa per 0 fa 0 e questo vi ha abilitato a fare le semplificazioni. Vi hanno insegnato che un qualche cosa diviso se stesso, se non √® 0, fa 1. E questo vi ha abilitato a fare delle altre semplificazioni aggiungendo una dipendenza: il denominatore non deve essere 0. Interessante, per√≤ <code>A</code> e <code>B</code> erano solo delle sostituzioni per dei numeri.</p>
<p>Poi siete arrivati al liceo e li vi hanno insegnato le derivate. Le derivate sono interessanti perch√© la derivata √® una funzione, (√® un operatore, ma di fatto √® una funzione), che prende in ingresso una funzione e ne restituisce un'altra ‚Äî qual √® la derivata di <code>x¬≤</code>? <code>2x</code>.</p>
<p>Ma vi hanno insegnato anche gli integrali, che di nuovo prendono in ingresso una funzione e ne restituiscono un'altra. Anzi, ne restituiscono una famiglia, perch√© l'integrale di <code>x¬≤</code> √® <code>x¬≥/3 + k</code>. Dove <code>k</code> non √® noto. Quindi avete una famiglia di funzioni.</p>
<p>Questo genere di cose noi le chiamiamo <em><strong>funzioni di ordine superiore</strong></em>. La derivata e l'integrale sono funzioni di ordine superiore, perch√© sono funzioni che, invece di operare direttamente su valori, operano su altre funzioni.</p>
<p>Quest'idea qua, che vale in matematica e permette, ad esempio, di trovare il massimo e il minimo con pi√π agilit√†, sfruttando le caratteristiche dell'analisi e altre cose, ecco, si presta anche al calcolo nostro.</p>
<p>Noi possiamo cio√® immaginare di avere un programma che, invece di scrivere funzioni che mangiano dati e producono dati, possiamo avere un programma dove aggiungiamo, accanto a funzioni che mangiano dati e producono dati, delle altre funzioni che mangiano funzioni e producono funzioni. Questo ci abilita a guardare la nostra programmazione in un modo totalmente diverso. Il principio per poter fare questo √® che il linguaggio che usiamo ci consenta di scrivere all'interno delle variabili non solo dei valori elementari, come gli interi, i float, le stringhe, o cose del genere, ma ci consenta di <strong>salvare dentro una variabile una funzione</strong>.</p>
<p>Questa cosa qua si pu√≤ fare in <strong>C</strong>, si pu√≤ fare in <strong>C++</strong>, si pu√≤ fare in <strong>Rust</strong>, si pu√≤ fare in <strong>Java</strong>, si pu√≤ fare in <strong>Python</strong>, solo che tutti questi linguaggi lo fanno in modo diverso e con un'enfasi totalmente diversa. Quindi con facilitazioni sintattiche o con ostacoli sintattici grossi.</p>
<p>Allora, sfatiamo subito un problema: di per s√© la funzione √® un pezzo di codice eseguibile. Quindi, alla fine, quella roba l√¨ √® una sequenza di byte che vanno interpretati come codice macchina. <code>3b7f5942</code> ‚Äî Cosa vuol dire? Dipende dal processore. Il processore <strong>x86</strong> lo interpreta in un modo, l'<strong>arm</strong> lo interpreta in un altro.</p>
<p>Comunque, noi sappiamo che le funzioni sono quella cosa l√¨, possiamo mettere in una variabile una funzione. √à impegnativo mettere in una variabile una funzione, perch√© questa funzione qui pu√≤ essere <em>3 byte</em> o pu√≤ essere <em>3000 byte</em> o anche <em>3 mega</em>. Ma stante che quei byte l√¨ li ficchiamo in memoria da qualche parte, tra l'altro in una zona statica, precostruita dal compilatore a priori, quello che noi possiamo salvarci √® <strong>l'indirizzo del primo di questi byte</strong>, cio√® di dove bisogna fare la chiamata. E poi di l√¨ in avanti tutto bene.</p>
<p>Quindi, di per s√©, se √® lecito in una variabile tenere un puntatore a un dato, √® altrettanto lecito tenere il puntatore a una funzione. Solo che sul dato posso fare alcune cose: lo leggo, lo scrivo, lo incremento, lo sommo, lo sottraggo. Sulle funzioni ci posso fare solo una cosa: <strong>la chiamo</strong>. Ma salvo questa caratteristica, alla fine √® un dato come tanti altri.</p>
<p><em>Come si fa a rappresentare questo?</em></p>
<h3 id="211-in-c"><a class="header" href="#211-in-c">2.1.1 ‚Ä¶in C</a></h3>
<p>Allora, in C si pu√≤ tenere il puntatore a una funzione. Piccolo problema: la notazione per dichiarare quella cosa l√¨ √® un casino.
Guardate l'esempio a met√† della slide: <code>TipoRitornato (* v) (p1: Tipo1, ..., pn: Tipon);</code>.</p>
<p><em>Cosa vuol dire quella sintassi l√¨?</em> √à poco leggibile. Vuol dire che in quella riga sto dichiarando la variabile <code>v</code>. E questa variabile <code>v</code> √® destinata a contenere un puntatore, <code>* v</code>, che punta a una funzione che ha <em>n parametri</em>, di tipo <code>Tipo1</code>, <code>Tipo2</code>, <code>Tipon</code>, e che ritorna un <code>TipoRitornato</code>. Non √® proprio ovvio, per√≤ quello vuol dire.</p>
<p>Quindi quella sintassi l√¨ √® quella che si usa in C per poter esprimere il fatto che noi abbiamo una variabile <code>v</code> che punta a una funzione con una certa <em>signature</em>. Perch√© il discorso non √® solo puntare ad una funzione. La funzione l'unica cosa che posso fare √® chiamarla, si, ma devo chiamarla col numero giusto di parametri, con la sequenza giusta di parametri, e devo sapere cosa mi ritorna.</p>
<p>Quindi quello √® il modo con cui <strong>Kernighan e Ritchie</strong>, 45 anni fa, hanno trovato il modo di scrivere che c'erano i puntatori a funzione. Siccome √® una cosa rarissima, proprio da guru particolare, non √® che si siano curati di dargli una leggibilit√† particolare, e sono rimasti cos√¨.</p>
<h3 id="211-in-c-1"><a class="header" href="#211-in-c-1">2.1.1 ‚Ä¶in C++</a></h3>
<p>Una decina di anni dopo Bjorn Strostrup, nel pensare al linguaggio C++, si √® detto <em>"Caspita, ma magari possiamo migliorare un po'".</em>
E quindi si √® immaginato: siccome gli oggetti in C++ possono ridefinire il comportamento degli operatori, e quindi posso dire cosa succede quando io incremento un oggetto di tipo <code>T</code>, implementando il metodo <code>operator++</code>, posso dire come si confrontano due oggetti di tipo <code>T</code>, implementando il metodo chiamato <code>operator==</code>, eccetera, posso anche dire come si comporta il tipo <code>T</code> quando lo uso come fosse una funzione, a patto di implementare <code>operator()</code>. Questo ha reso un pochino pi√π utile la semantica delle funzioni.</p>
<p>Con un'aggiunta mica da poco. Quando io ho un oggetto che pu√≤ essere usato come funzione, beh, quell'oggetto l√¨, certamente, l'oggetto lo chiamo <code>o</code>, posso fare <code>o(p1, p2...)</code>, con i suoi parametri, e quello trita e mi d√† un risultato. Ma l'oggetto <code>o</code>, oltre ad avere il metodo <code>operator()</code>, pu√≤ avere dentro di s√© tutti i campi che gli pare. E il metodo <code>operator()</code> √® un metodo come tutti gli altri, al di l√† di avere un nome un po' strano, √® un metodo come tutti gli altri, e se in tutti gli altri metodi √® lecito fare <code>this.x += 1</code>, cio√® comunque manipolare lo stato dell'oggetto, anche <code>operator()</code> pu√≤ manipolare lo stato dell'oggetto.</p>
<p>Questo vuol dire che quella cosa l√¨ <em>sembra</em> una funzione, nel senso che √® chiamabile come funzione, ma √® molto diversa dalla radice quadrata, perch√© tutte le volte che io la invoco, pu√≤, se lo desidera, modificare lo stato dell'oggetto. O al contrario, se lo stato dell'oggetto viene modificato da qualcun altro, pu√≤ darmi, a parit√† di parametri, risultati diversi. Questo vuol dire che certe volte 3+2 fa 5 e certe volte 3+2 fa -2 ‚Äî which is interesting. √à un po' un mostro, ma √® potenzialmente molto interessante.</p>
<p>Anche perch√©, nella programmazione tradizionale, l'unica cosa che posso fare √® <em><strong>farla subito</strong></em>. Nella programmazione funzionale, io posso <strong>prepararmi le cose da fare e farle poi dopo</strong>. Vediamo di capire meglio.</p>
<h3 id="211-in-rust"><a class="header" href="#211-in-rust">2.1.1 ‚Ä¶in Rust</a></h3>
<p>In Rust c'√® un modo apposito per gestire questo. Io posso banalmente, se ho dichiarato la funzione <code>alpha</code> che fa un certo mestiere, dire <code>let f = alpha</code>.
"Alpha" da solo, senza parentesi. In questo caso, <code>f</code> diventa un puntatore alla funzione <code>alpha</code>.
E come era lecito prima scrivere <code>alpha(p1, p2, ‚Ä¶)</code>, dopo sar√† lecito scrivere <code>f(p1, p2, ‚Ä¶)</code>, e ottengo esattamente la stessa cosa di <code>alpha</code>. Cio√® <code>f</code> √® diventato semplicemente un alias di <code>alpha</code>.</p>
<p>Ma in quanto variabile, io posso assegnare a <code>f</code> in certi casi <code>alpha</code>, e in certi altri casi <code>beta</code>. Cio√® io posso avere un pezzo di codice che chiama <code>f</code>, che a seguito di cosa sia capitato prima, di fatto chiamer√† alternativamente <code>alpha</code> o <code>beta</code>. Questo mi ha permesso di <strong>trasformare completamente</strong> la struttura del mio codice.</p>
<p>Io prima avevo <code>if(someCondition) { alpha(p1, p2, ...) } else { beta(p1, p2, ...}</code>.
E quindi nel momento stesso in cui invoco la mia funzione, dovr√≤ decidere che cosa fare. Invece, potendo sfruttare una variabile di questo genere, io posso avere un algoritmo che a monte dentro <code>f</code> ci salva <code>alpha</code> oppure ci salva <code>beta</code>, che immaginiamo abbiano la stessa <em>firma</em>. Molto dopo, invocher√≤ <code>f</code>. A questo punto io non so pi√π qual era la condizione, <strong>non ha importanza</strong>. Prima ho preso la decisione che la cosa da fare era l'una o l'altra, ma non l'ho fatta, ho solo preso la decisione. Sfrutto il fatto che la mia variabile <code>f</code> contiene questa decisione e quindi la eseguo di conseguenza.</p>
<p>Per riuscire a sfruttare bene questa cosa qua, bisogna <strong>cambiare modo di pensare</strong>. Cominciare a ragionare in termini di <em>programmazione funzionale</em>. Quello che √® interessante √® che Rust non solo ci permette di assegnare una funzione pura a una variabile, ma ci permette anche di assegnare degli oggetti che implementano i <strong>tratti funzionali</strong>.
Ovvero ci sono tre tratti particolari che si chiamano <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>, che hanno la caratteristica di dare all'oggetto che li implementa il comportamento di una funzione. Senza togliergli altre cose. Quindi dandogli la possibilit√† di essere anche altro.</p>
<p>Allora vogliamo capire un po' meglio questo genere di cose qua.</p>
<p><img src="images/chiusure/image%201.png" alt="image.png" /></p>
<p>Vediamo di dare concretezza a quest'idea dei <strong>puntatori alla funzione</strong> e dei <strong>puntatori agli oggetti funzionali</strong> o degli <strong>oggetti funzionali</strong> in generale.</p>
<p>Di base, quando noi abbiamo un puntatore a funzione possiamo usare tale puntatore come fosse la funzione stessa.</p>
<p>Qui vediamo due esempi, uno in C++ (ma che di fatto usa la sintassi del C), e l'altro in Rust, a confronto. Nel primo pezzo in alto √® introdotta una funzione, la funzione <code>f1</code> che prende un intero e un double, e restituisce un double, in modo banalissimo. Subito sotto √® dichiarato il puntatore. Il puntatore lo posso assegnare.</p>
<p>La dichiarazione che si fa in C++ √® quella del C, cio√® <code>ptr</code> √® un puntatore a una funzione che prende un <code>int</code> e un <code>double</code> e restituisce un <code>double</code>. La dichiarazione che si fa in Rust √® pi√π semplice, si dice che <code>ptr</code> √® un valore di tipo <code>fn</code> che prende un <code>i32</code> e un <code>f64</code> e restituisce un <code>f64</code>. Questo rende un po' pi√π chiaro che cosa stiamo introducendo.</p>
<p>Dopodich√© lo dobbiamo inizializzare, l'inizializzazione √® identica, <code>ptr = f1</code> da una parte e dall'altra. A questo punto chiamare <code>ptr()</code> e chiamare <code>f1()</code> √® la stessa cosa. E quindi se io chiamo <code>ptr(2, 3.14)</code> ottengo <code>6,28</code> dall'una e dall'altra parte. Quindi io posso banalmente in una variabile assegnare il puntatore a una funzione. Una volta che ho assegnato un puntatore a una funzione, quella variabile per me contiene la funzione, la uso come fosse la funzione stessa. Questo √® un fatto puramente sintattico.</p>
<p>Per√≤ √® comodo, perch√© io potrei decidere che ho una funzione che si chiama <code>log</code>, che prende una stringa e tutte le volte che la invoco la scrive da qualche parte. Poi potrei avere una seconda funzione che chiamo <code>no_log</code>, che prende una stringa e non ci fa niente. Quando il mio programma parte potrei decidere che se ci trovo un flag o meno, nella variabile <code>l</code> ci assegno <code>log</code> oppure <code>no_log</code>. Ho preso una decisione, ho salvato nella mia variabile <code>l</code> una delle due.</p>
<p>Da l√¨ in avanti il resto del programma chiamer√† sempre <code>l</code> con quello che vorrebbe loggare. Se sono partito con la richiesta di loggare, la chiamata <code>l</code> finir√† sulla chiamata <code>log</code> che √® effettivamente scrivere qualcosa. Se no finir√† nella chiamata <code>no_log</code> che fa finta di niente, non fa nulla e torna. Questo mi permette invece di avere 10.000 <code>if</code> sparsi per il mio programma, che tutte le volte dicono "<em>ma come ero partito? Ero partito con la richiesta di loggare o meno?‚Äù</em> e fanno meno delle cose, di fregarmi altamente e dire io imposto un comportamento che a scelta √® di tipo x o di tipo y. E poi banalmente uso il comportamento, sapendo che il comportamento lo user√≤ coerentemente con tutto il resto.</p>
<p>Questo mi permette di non dovermi portare dietro il flag originale che mi diceva che cosa dovevo fare, ma semplicemente io ho una funzione da chiamare e quella chiamo. <strong>Questo approccio alla programmazione consente di fare un mucchio di cose interessanti.</strong></p>
<h2 id="22-oggetti-funzionali"><a class="header" href="#22-oggetti-funzionali">2.2 Oggetti funzionali</a></h2>
<p><img src="images/chiusure/image%202.png" alt="image.png" /></p>
<p>Il C++ oltre a permettermi di scrivere direttamente il puntatore a funzione, con la sintassi del C, mi d√† la possibilit√† quando introduco una classe, e in questo caso ho introdotto la classe che ho chiamato <code>FC</code> (<em>Functional Component</em>), di mettere tra i suoi metodi anche <code>operator()</code>. Notate, √® un metodo che ha una sintassi un po' strana, perch√© si chiama <code>operator()</code>, quello √® il suo nome, ma poi ha bisogno dei suoi parametri, in questo caso <code>int v</code>.</p>
<p><em>Che cosa fa questo metodo?</em>
Banalmente, in questo caso, prende il suo argomento e lo moltiplica per 2. Nella parte sinistra vediamo la definizione della classe, quindi ho introdotto questa classe che ha semplicemente questo metodo, nella parte di destra vediamo che quello che succede √® che posso dichiarare un oggetto di tipo <code>FC</code>, <code>FC fc;</code> significa creo un oggetto di tipo <code>FC</code> sullo stack, e poi lo posso usare come fosse una funzione, <code>fc(5)</code> ottengo <code>10</code>, <code>fc(2)</code> ottengo <code>4</code>, e cose del genere. Quindi ho creato una cosa che uso come fosse una funzione, senza che sia una funzione.</p>
<p><img src="images/chiusure/image%203.png" alt="image.png" /></p>
<p>Questo visto cos√¨ √® assolutamente poco utile, ma diventa molto pi√π interessante se comincio a considerare il fatto che la mia classe di definizioni di <code>operator()</code> ne pu√≤ contenere diverse, quindi supporta l'<strong>overloading</strong>, posso fare quella che prende un intero e mi restituisce un intero, posso fare quella che prende un double e mi restituisce un double, posso fare quella che prende una stringa e mi restituisce un'altra cosa, eccetera. Quindi la posso usare in varie maniere. E questo va bene, √® un vantaggio, ma potrei farmi 10 funzioni diverse e in qualche modo me la caverei.</p>
<p>Ma il vantaggio molto pi√π significativo √® che siccome √® una classe, oltre ad avere uno o pi√π metodi, pu√≤ avere degli attributi, dei campi interni. E questi campi interni sono accessibili all'interno della funzione <code>operator()</code>, perch√© quella √® una funzione membro a tutti gli effetti, quindi avr√† un <code>this</code> e potr√≤ accedere al suo contenuto. Queste variabili membro possono essere utilizzate per determinare il comportamento della mia funzione apparente.</p>
<p>Possono essere usate per ricordarsi le invocazioni e quindi trasformare quella che era una <strong>funzione pura</strong> (cio√® come quelle matematiche, che dati gli stessi dati in ingresso ti d√† sempre solo gli stessi dati in uscita) in una <strong>funzione impura</strong>, che nella terminologia del C++ si chiamano <em><strong>oggetti funzionali</strong></em>. Ovvero una cosa che <strong>ricorda la propria storia,</strong> <strong>ha uno stato.</strong></p>
<h3 id="221-esempio-la-classe-accumulatore"><a class="header" href="#221-esempio-la-classe-accumulatore">2.2.1 Esempio: La Classe Accumulatore</a></h3>
<p><img src="images/chiusure/image%204.png" alt="image.png" /></p>
<p>Qui √® introdotta un'ipotetica classe chiamata <code>accumulatore</code>, che ha dentro di s√© un unico parametro <code>totale</code>. Il costruttore della classe accumulatore setta <code>totale</code> a zero.</p>
<p>Quel <code>Accumulatore():totale(0){}</code> √® la sintassi del C++ per inizializzare il parametro <code>totale</code>.</p>
<p>All'interno contiene la definizione di <code>operator()</code>, che quando gli passiamo un valore lo prende e lo somma a <code>totale</code>. Vedete che dentro <code>operator()</code> c'√® scritto <code>totale += v</code>. Quindi io prendo atto che sono stato invocato e mi registro questa cosa. In questo caso ritorna <code>v</code>, ma potrei anche non ritornare niente, e andava bene lo stesso. Poi c'√® un ulteriore metodo chiamato <code>totale()</code>, che mi ritorna il valore <code>totale</code> stesso, che altrimenti sarebbe privato (e dunque inaccessibile altrimenti).</p>
<p>Dopodich√© nel <code>main</code> io dichiaro il mio oggetto <code>Accumulatore a</code>, e per <code>i</code> che vanno da 0 a 10 calcolo <code>a(i)</code>. Quindi fa:</p>
<ul>
<li><code>a(0)</code>: dentro <code>totale</code> rimane 0</li>
<li><code>a(1)</code>: dentro <code>totale</code> ci finisce 1</li>
<li><code>a(2)</code>: dentro <code>totale</code> ci finisce 3</li>
<li><code>a(3)</code>: ci finisce 6</li>
</ul>
<p>etc‚Ä¶</p>
<p>Finito il mio <code>for</code>, stampo quanto vale la variabile <code>totale</code> e ci vedo 45.</p>
<p><em>Cosa significa questo?</em> Ho la possibilit√† di chiamare una funzione che oltre eventualmente a ritornarmi un valore per i fatti suoi, e quindi essere usata come funzione, riesce a <strong>ricordarsi delle cose</strong>. In questo caso io mi limito a ricordarle. Potrei anche dire che io utilizzo lo stato, in questo caso la variabile <code>totale</code>, per cambiare il valore che ritorno. Cosa che sarebbe molto complicata da fare con una funzione semplice.</p>
<p>Ovvero, con una funzione semplice l'unico modo che avrei per avere un comportamento del genere √® appoggiarmi a una <strong>variabile globale</strong>. Con un vincolo per√≤: che io di variabile globale ne posso avere, per una data funzione, <em>una sola</em>. Io qui, se creo due oggetti di tipo <code>accumulatore</code>, ho ciascuno il suo stato. Il primo parte a zero, e il secondo parte a zero. Al primo chiamo tre volte <code>a(1), a(2), a(3)</code>, e lui somma, mentre l'altro sta ancora a zero. Poi comincio a chiamare sull'altro, l'altro sale, il primo sta fermo, e cos√¨ via.</p>
<p>Quindi posso portarmi pi√π storie in contemporanea. Mentre se io avessi usato una variabile globale, non c'era modo di distinguere un oggetto da un altro.</p>
<p>Questi sono gli oggetti funzionali. Quindi sono oggetti che come tutti gli oggetti hanno il loro stato; in Rust non parliamo di oggetti, quindi li chiameremmo struct, che hanno dei campi. Oltre ad avere dei campi, possono essere sintatticamente usati come fossero una funzione. E infatti io ci scrivo <code>a(i)</code>. Il problema √® che questa notazione √® un po' verbosa. E' il meglio che Bjorn Stroustrup √® riuscito a inventarsi alla fine degli anni '80, mentre si ragionava su questo genere di cose.</p>
<p>Per√≤ poi i programmatori si sono resi conto che questa idea qua era tutt'altra che peregrina, e aveva un mucchio di vantaggi. Solo che bisognava semplificarla, dare modo di scrivere pi√π facilmente un comportamento del genere. E qui le strade si sono sparpagliate. Nei vari linguaggi sono nate sintassi completamente diverse per rappresentare le stesse idee.</p>
<h3 id="222-sintassi-nei-diversi-linguaggi"><a class="header" href="#222-sintassi-nei-diversi-linguaggi">2.2.2 Sintassi nei Diversi Linguaggi</a></h3>
<p><img src="images/chiusure/image%205.png" alt="image.png" /></p>
<p><strong>JavaScript:</strong> potete introdurre una variabile <code>const f =</code> e a quel punto attribuite un letterale, ovvero un set di parametri tra tonde, freccia, e il body: quindi <code>const f = (v) =&gt; v + 1</code>.
Questo assegna a <code>f</code> un letterale che consuma un numero <code>v</code> e produce il numero incrementato di un'unit√†.</p>
<p><strong>Kotlin:</strong> Si √® adottato una sintassi diversa. La funzione √® scritta tutta tra graffe e comincia con la definizione dei parametri, poi freccia, e poi il suo body: <code>val f = { v: Int -&gt; v + 1}</code>.</p>
<p><strong>C++:</strong> Si usa quest'altra notazione: <code>[](int v) -&gt; int { return i+1 }</code>.</p>
<p><strong>Rust:</strong> Si pu√≤ fare cos√¨: <code>|v| v+1</code>, con o senza graffe.</p>
<p>Tutti dicono la stessa cosa, sto introducendo un letterale, una funzione espressa letterale. Diciamo che questo √® un po' quanto i linguaggi hanno trovato di meglio per rendere facile esprimere delle funzioni.</p>
<p><strong>Caratteristiche delle Funzioni Lambda</strong>
Sono funzioni che per√≤ <strong>non hanno un nome</strong>. Il nome lo prendono dalla variabile a cui sono assegnate. <code>let f =</code>, <code>const f =</code>, <code>val f =</code>, <code>auto f =</code>, questi sono i modi con cui nei vari linguaggi io le introduco. In questo caso la funzione √® particolare, il nome non ce l'aveva, prende il nome della variabile. Se questa variabile la assegno ad un'altra variabile, boh, diventeranno tutte e due la stessa cosa, non √® un problema.</p>
<p><strong>Origine del Nome</strong>
Vengono dette funzioni lambda perch√© nel calcolo dei matematici a un certo punto, negli anni venti, era nata questa filone della matematica teorica che introduceva l'idea delle funzioni di ordine superiore manipolate algebricamente e quindi avevano chiamato lambda una funzione priva di nome. Ed √® rimasto attraverso Lisp, fondamentalmente.</p>
<p><img src="images/chiusure/image%206.png" alt="image.png" /></p>
<p><strong>Uso Pratico</strong>
Quando definiamo una lambda usando la sintassi del linguaggio (nel nostro caso la barra verticale con i parametri seguita dal body), dobbiamo memorizzarla in una variabile per poterla utilizzare. Scrivere solo <code>|x| { x + 1 }</code> non serve a nulla. Invece, salvandola in una variabile con <code>let f = |x| { x + 1 }</code>, possiamo poi usarla. Per esempio, <code>f(25)</code> ci restituir√† 26.</p>
<p>√à <strong>interessante</strong> perch√© una cosa del genere posso passarla come argomento a una funzione, o al contrario posso riceverla come risultato di un'altra funzione. Il problema √® che la sintassi pu√≤ essere pi√π o meno chiara. Ad esempio qui nella slide stiamo stiamo definendo una funzione chiamata <code>ret_fan</code>, quindi una funzione che quando verr√† invocata non ha parametri e restituir√† una funzione. In questo caso si restituisce assolutamente sempre la stessa, ma potrebbe darci una tra diverse funzioni.</p>
<h3 id="223-variabili-libere"><a class="header" href="#223-variabili-libere">2.2.3 Variabili libere</a></h3>
<p><img src="images/chiusure/image%207.png" alt="image.png" /></p>
<p>L'aspetto interessante, e qui adesso ci stacchiamo dal problema puramente <strong>sintattico</strong> di <em>come si fa a scrivere questa cosa</em>, ed entriamo invece in un dominio pi√π <em><strong>semantico</strong></em>.
Nel corpo di questa funzione abbiamo certamente la possibilit√† di mettere delle costanti, abbiamo certamente la possibilit√† di mettere i parametri della funzione stessa (<code>|**x**| x + 1</code>), ma possiamo anche citare nel corpo della nostra funzione delle variabili che siano visibili nel punto in cui la definizione avviene.</p>
<p>Quindi noi stiamo <strong>congelando</strong> nel corpo della nostra funzione dei valori che prendiamo attorno a noi, nel punto in cui siamo stati definiti. E che cosa viene preso? Beh, a secondo dei casi prenderemo un riferimento, oppure prenderemo una copia, oppure prenderemo il possesso completo. E nei linguaggi diversi questa cosa prende forme leggermente diverse.</p>
<p>Questo insieme di variabili che compaiono nel corpo di una lambda e non sono parametri espliciti, vengono chiamate <strong>variabili libere</strong>, perch√© sono quelle che definiscono un comportamento <strong>contestuale</strong>.
Nel momento in cui io sono nato, io sono nato in Italia, quindi sono italiano. Potevo nascer altrove, sarei stato diverso. √à capitato cos√¨. Quando la lambda nasce pu√≤ acquisire dal suo ambiente di nascita dei valori che si porta dentro e <strong>gli rimangono</strong>.</p>
<p><em>Cosa succede quando scriviamo un'espressione del genere?</em>
Nei diversi linguaggi succedono cose leggermente diverse. Nel caso di <strong>C++</strong>, quando noi scriviamo una funzione lambda che cattura qualcosa dall'ambiente, cio√® ha delle variabili libere, C++ genera per noi un <em>oggetto funzionale</em> che ha come attributi interni, i valori che ha catturato. Tipicamente ha delle copie dei valori, oppure in certi casi (se glielo spieghiamo in modo esplicito) dei riferimenti.</p>
<p>Nel caso di <strong>Rust</strong>, viceversa, <strong>una lambda che abbia delle variabili libere diventa una <em>tupla</em>.</strong> Semplicemente una tupla. Che ha per√≤ il comportamento funzionale: pu√≤ essere usata come funzione. E a secondo di come usiamo la lambda e di come abbiamo catturato le variabili libere, potr√† implementare il tratto funzionale <code>FnOnce</code>, oppure potr√† implementare il tratto funzionale <code>FnMut</code>, oppure potr√† implementare il tratto funzionale <code>Fn</code>.</p>
<p>Adesso vogliamo capire cosa sono questi tratti funzionali e come ci stanno.</p>
<h1 id="3-cattura-delle-variabili-in-rust"><a class="header" href="#3-cattura-delle-variabili-in-rust">3. Cattura delle variabili in Rust</a></h1>
<p><img src="images/chiusure/image%208.png" alt="image.png" /></p>
<h2 id="31-esempi-pratici"><a class="header" href="#31-esempi-pratici">3.1 Esempi pratici</a></h2>
<h3 id="311-esempio-1"><a class="header" href="#311-esempio-1">3.1.1 Esempio 1</a></h3>
<p><img src="images/chiusure/image%209.png" alt="image.png" /></p>
<p>Per un po' di volte, dico che creo la funzione <code>f</code>, per il momento non la sto ancora usando, che prende un valore <code>v</code> e mi restituisce <code>v + i</code>. Quindi questa variabile, questa variabile <code>f</code> che sto creando, potr√† essere usata come funzione, potr√† essere usata come funzione che prende un numero e che restituisce un numero. Ma che cosa restituisce? Restituisce un numero che dipende da quanto vale <code>i</code>.</p>
<p>Quindi stiamo preparandoci via via delle <code>f</code> diverse.</p>
<p><img src="images/chiusure/image%2010.png" alt="image.png" /></p>
<p>Se io lo eseguo, e guardo un po' il codice che viene fuori, vedo che quando <code>i</code> vale 2, <code>f(1)</code> vale 2, <code>f(2)</code> vale 4. Cio√® la funzione moltiplica per 2.</p>
<p>Quando <code>i</code> vale 3, <code>f(1)</code> vale 3, <code>f(2)</code> vale 6. La funzione <code>f</code> moltiplica per 3.
Quando <code>i</code> vale 4, <code>f(1)</code> vale 4, <code>f(2)</code> vale 8. La funzione moltiplica per 4.</p>
<p><strong>Perch√©?</strong> Perch√© io ho definito la mia funzione in modo che catturasse dall'ambiente in cui era <code>i</code>. E se lo tenesse stretto.</p>
<p>Queste funzioni le potrei memorizzare da qualche parte, ad esempio in un array, un <code>Vec</code>. E poi in futuro utilizzarle. Queste funzioni automaticamente si ricorderebbero: la prima si ricorder√† che <code>i</code> vale 2 e se lo terr√† stretto. La seconda si ricorder√† che <code>i</code> vale 3.</p>
<p><em>Perch√© riescono a ricordarselo?</em>
Perch√© Rust, per noi, dietro questa espressione genera una <strong>tupla</strong>. In questo caso √® una tupla che contiene un solo campo: <code>i</code>. Cio√® nel campo 0 di quella tupla l√¨ c'√® <code>i</code>. E quindi se lo tiene dentro.</p>
<p>Se avessi usato pi√π pezzi avrei potuto fare una cosa pi√π complessa.</p>
<h3 id="311-esempio-2"><a class="header" href="#311-esempio-2">3.1.1 Esempio 2</a></h3>
<p><img src="images/chiusure/image%2011.png" alt="image.png" /></p>
<p>Qua introduco <code>gen</code> che sar√† una funzione destinata a crearmi qualcos'altro.</p>
<p>Quindi invocher√≤ <code>gen</code> in qualche modo e otterr√≤ in cambio una funzione. Questa funzione dentro di s√© posseder√† due cose. Posseder√† una <code>i</code>. E posseder√† <code>base</code>, che √® un slice di caratteri.</p>
<p>Tutte le volte che questa funzione verr√† invocata, <code>i</code> diventer√† pi√π grande di 1, e poi mi concatener√† <code>base</code> con <code>i</code> per ottenere un valore.</p>
<p>Proviamo ad  usarla.</p>
<p><img src="images/chiusure/image%2012.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2013.png" alt="image.png" /></p>
<p>A ogni invocazione di <code>f1</code> succedono delle cose.</p>
<p>Cosa capita quando io lo eseguo? Nel momento in cui io lo eseguo questa cosa qua mi stampa <code>"a1"</code>, <code>"a2"</code>, <code>"a3"</code>, <code>"a4"</code>. E se andassi avanti mi stamperebbe <code>"a5"</code>, <code>"a6"</code>, <code>"a7"</code>etc...</p>
<p><strong>Cio√® ho creato una funzione che non ha parametri ma che si ricorda di quante volte √® stata chiamata</strong>. E per ogni volta che viene chiamata non solo genera un nuovo valore ma si aggiorna internamente cos√¨ da permettermi di avere il risultato.</p>
<p>Questo internamente viene realizzato sul fatto che <code>f1</code> √® una <strong>tupla che ha due campi</strong>. Quindi se io andassi a decompilare questo codice vedrei che dentro <code>f1</code> c'√® una String con i suoi 24 byte, e un <code>i32</code> che occupa 4 byte. Questa cosa qui internamente contiene la sua informazione.</p>
<p>Quando io la invoco quello che succede √® che parte il codice che ho specificato sopra che quindi prende il campo <code>i</code>, che √® dentro la tupla, e gli somma 1. Poi prende la parte base che √® rappresentata dalla stringa, la concatena con <code>i</code> grazie alla macro <code>format!</code> e mi restituisce la stringa risultante.</p>
<p><img src="images/chiusure/image%2014.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2015.png" alt="image.png" /></p>
<p>Se io mi facessi una seconda variabile <code>f2</code> e poi stampassi un po' di volte <code>f2</code>, vedrei che <code>f1</code> va avanti con i suoi conteggi, ed <code>f2</code> √® completamente indipendente e va avanti con i suoi conteggi.</p>
<p><img src="images/chiusure/image%2016.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2017.png" alt="image.png" /></p>
<p>Se a questo punto aggiungessi ancora una stampa qua mettendoci un <code>f1</code> finale giusto per vedere cosa succede, mi accorgerei che prima ho <code>f1</code> che parte: <code>a1</code>, <code>a2</code>, <code>a3</code>, <code>a4</code>, poi ho <code>f2</code> che mi fa <code>b1</code>, <code>b2</code>, <code>b3</code>. Poi vado avanti, richiamo di nuovo <code>f1</code> e chiaramente questo mi stampa <code>a5</code> perch√© si √® ricordato il suo contenuto.</p>
<p>Quindi io ho creato all'interno di questa funzione chiamata <code>gen</code> una <strong>chiusura,</strong> ovvero una funzione lambda, perch√© l'ho creata con le barre che per√≤ oltre a prendere i suoi parametri (nessuno in questo caso), si prende in ausilio due dati che derivano dal suo contesto: un dato dal contesto stretto √® la <code>i</code> (se la porta dentro), l'altra <code>base</code> l'ha presa come parametro della funzione <code>gen</code>.</p>
<p>Quindi chi invoca <code>gen</code> mi d√† il prefisso che dovr√≤ mettere davanti ai miei simboli che generer√≤ e automaticamente a ogni invocazione io concatener√≤ il prefisso con il valore corrente di <code>i</code> per ottenere il mio risultato.</p>
<blockquote>
<p>üí° <strong>Keyword</strong> <strong><code>move</code></strong></p>
<p><img src="images/chiusure/image%2018.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2019.png" alt="image.png" /></p>
<p>Senza la parola chiave <strong><code>move</code></strong>, il compilatore blocca la compilazione.</p>
<p>Se rimuoviamo <code>move</code>, il compilatore segnala un errore perch√© la chiusura prenderebbe <code>i</code> come riferimento semplice invece di acquisirne il possesso. Per questo motivo dobbiamo aggiungere <code>move</code> davanti alla chiusura, cos√¨ da forzare la presa di possesso di <code>i</code>.</p>
<p>Altrimenti, la variabile <code>i</code> cesserebbe di esistere una volta usciti dallo scope della funzione <code>gen</code>, ma la chiusura vi farebbe ancora riferimento: problema!</p>
</blockquote>
<p>Con la chiusura ho avuto la possibilit√† di creare una funzione che √® <strong>semipermeabile</strong>, cio√® riesce a catturare delle cose.</p>
<p><em>Perch√©?</em>
Perch√© non viene generata solo una funzione: <strong>viene generata una</strong> <strong>tupla che implementa il <em>tratto funzionale</em></strong>.</p>
<p>Implementando il tratto funzionale pu√≤ essere chiamata, ma essendo una tupla ha anche uno stato, e questa implementazione automaticamente fa riferimento a <code>self</code>. Cio√® quando lui vede questo codice qua, quella <code>i</code> diventa <code>self.1</code> e quel <code>base</code> diventa <code>self.0</code>.</p>
<p>Allora quando noi creiamo questo genere di scrittura, quindi quando Rust vede comparire qualcosa come <code>| ... | { ... }</code>, automaticamente capisce che deve costruirsi silenziosamente una <strong>tupla</strong> che ha dentro di s√© tanti campi quante sono le <strong>variabili libere,</strong> cio√® va a guardare nel body di questa cosa quanti sono gli identificatori che non corrispondono a nessun parametro formale. Quelle sono le variabili libere quindi diventano il campo 0, 1, 2, 3, etc‚Ä¶ della tupla, quanti ne servono.</p>
<p>Internamente sostituisce nel corpo della funzione i nomi che abbiamo dato loro (<code>i</code>, <code>j</code>, <code>k</code>, <code>base</code>, quello che sia) con <code>self.0</code> <code>self.1</code>, <code>self.2</code> etc..</p>
<p>Poi fa s√¨ che questa tupla che cos√¨ lui ha definito, che non ha un nome specifico, implementi uno dei tratti funzionali <code>Fn</code>, piuttosto che <code>FnMut</code> piuttosto che <code>FnOnce</code>.
Dobbiamo ancora capire che differenza c'√® tra i tre, ma comunque la rendono <strong>chiamabile</strong>.</p>
<h2 id="32-la-parola-chiave-move"><a class="header" href="#32-la-parola-chiave-move">3.2 La parola chiave <strong><code>move</code></strong></a></h2>
<p><em>Cosa ci mette nei campi della tupla?</em>
Di default ci mette il <strong>reference semplice</strong> al dato, quindi se io passavo <code>i</code> lui ci metter√† il riferimento di <code>i</code>. Nel momento in cui passo il riferimento, il borrow checker, nell'andare a vedere il codice che viene generato, controlla che tutto sia lecito, cio√® che il tempo di vita sia giusto.</p>
<p>In alcuni casi ci basta esclusivamente che dentro la tupla ci finisca una reference al dato originale.
In alcuni casi invece noi vogliamo che il dato originale abbia un tempo di vita che sia diverso e allora dobbiamo governarlo in qualche altra maniera.
Il modo pi√π semplice √® aggiungere davanti, prima delle barre <code>| ‚Ä¶ |</code>, la parola chiave <code>move</code>. Quella parola chiave l√¨ dice <em>"non prendere il reference alla variabile, prendi proprio la variabile</em> <em>acquisiscine il possesso"</em>.</p>
<p>Vediamolo con un esempio.</p>
<p><img src="images/chiusure/image%2020.png" alt="image.png" /></p>
<p>Qui ho una variabile, sto introducendo <code>f1</code> che opera sul suo parametro formale chiamato <code>x</code> e nel body mi cita <code>x</code>, <code>y</code> e <code>z</code>. Questo vuol dire che <code>y</code> e <code>z</code> sono <em>variabili libere</em> - deve essere qualcosa che compare nel contesto. Se non compaiono nel contesto √® un errore di sintassi.</p>
<p>Se compaiono nel contesto lui genera una tupla che contiene dentro di s√© due riferimenti: il primo √® il riferimento a <code>y</code> che potr√† stare dove sta (cio√® se <code>y</code> era una variabile locale sar√† un riferimento allo stack, se <code>y</code> era una variabile che era sullo heap sar√† un riferimento sullo heap, non ha nessuna importanza), e analogamente l‚Äôaltro √® il riferimento a <code>z</code>. Quindi la mia tupla in questo caso sar√† grande 16 byte (8 byte per ciascun puntatore).</p>
<p>Qui ipoteticamente <code>y</code> √® pi√π grande, tanto per fare un esempio, <code>z</code> √® un po' pi√π piccolo, va benissimo.</p>
<p>Se invece di scrivere come mostrato a sinistra, scrivessimo come mostrato a destra (<code>let f2 = move ...</code>), quello che succede √® che invece di catturare il riferimento, nella tupla <strong>viene mosso quello che gli abbiamo indicato</strong>.</p>
<p>E quindi la variabile <code>y</code> da dov'era viene trasferita dentro lo stack dove noi la depositiamo nel campo 0 della tupla, e la variabile <code>z</code> viene mossa da dov‚Äôera e finisce sempre nello stack nel campo 1 della tupla. Quindi a questo punto <code>f2</code> ha preso possesso di <code>y</code> e <code>z</code>, sono diventate sue. Invocando <code>f2</code> quello che succede √® che avr√† possibilit√† di modificare <code>y</code> e <code>z</code> e di farci delle cose.</p>
<p><code>move</code> dice <em>"nel momento in cui mi crei questa cosa la sposti da dov'√® a dentro la tupla".</em>
Mettendo <code>move</code> chiaramente io perdo l'accesso ai valori catturati, a meno che quei valori l√¨ non siano <code>Copy</code> (in tal caso, potremmo continuare ad avere accesso ai valori catturati anche dopo aver creato la closure, dato che al suo interno ci finirebbe una copia ex novo di tali valori ‚Äî <em>la <strong>move</strong> di un <strong>valore Copy</strong>, √® la <strong>copy</strong></em>).</p>
<h2 id="33-tratti-funzionali"><a class="header" href="#33-tratti-funzionali">3.3 Tratti funzionali</a></h2>
<p><img src="images/chiusure/image%2021.png" alt="image.png" /></p>
<p>Abbiamo detto che ci sono tre tratti che si chiamano <code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code>.</p>
<p>Questi tre tratti sono progressivamente <strong>pi√π specifici</strong>, si <em>co-implicano</em>: per poter implementare <code>FnMut</code> bisogna anche implementare <code>FnOnce</code>, e per poter implementare <code>Fn</code> bisogna anche implementare <code>FnMut</code> e di conseguenza anche <code>FnOnce</code>.
Quindi <code>FnOnce</code> √® il pi√π generico, poi alcuni <code>FnOnce</code> sono anche <code>FnMut</code>, e poi alcuni <code>FnMut</code> sono <code>Fn</code>.</p>
<p><em><strong>Cos'√® la differenza tra i tre?</strong></em>
La differenza tra i tre √® legata a quante volte quella funzione lambda che sto scrivendo pu√≤ essere chiamata.</p>
<ul>
<li><strong>FnOnce</strong>
Chi implementa <code>FnOnce</code> sta dicendo che ha creato una <strong>chiusura</strong> che quando verr√† chiamata distrugge un suo pezzo e quindi potr√† essere chiamata <em>una volta sola</em>. Dopodich√© non esiste pi√π, perch√© il suo risultato √® stato ottenuto <strong>smontandola</strong>.
√à quello che succede quando dichiariamo in un metodo normale <code>self</code>, senza nessun <code>ref</code>: se ho all'interno di una struct un metodo che prende <code>self</code>, quel metodo l√¨ √® chiamabile una volta sola, perch√© dopo che l'ho chiamato su un certo oggetto il <code>self</code> non esiste pi√π ‚Äî mi ha preso il possesso e ha restituito qualcos'altro.</li>
<li><strong>FnMut</strong>
Se invece implemento <code>FnMut</code> √® come se scrivessi un metodo che riceve <code>&amp;mut self</code>, e quindi ha la possibilit√† di essere chiamato pi√π volte e ha la possibilit√† di modificare se stesso.</li>
<li><strong>Fn</strong>
Infine se implemento <code>Fn</code> √® come se avessi un metodo che prende <code>&amp;self</code>, quindi si guarda ma non si modifica, e di conseguenza pu√≤ essere chiamato tante volte senza effetti particolari.</li>
</ul>
<p>Quindi quale di questi tre tratti viene effettivamente implementato dipende da <em>cosa viene catturato e come viene catturato</em>. Una chiusura di fatto la scrivo sempre uguale ma se vado a vedere il tipo che il compilatore gli assegna vedr√≤ delle cose distinte:</p>
<p><img src="images/chiusure/image%2022.png" alt="image.png" /></p>
<p>Vediamo che <code>f1</code> implementa <code>FnMut</code>, in altri casi implementer√† altre cose.</p>
<blockquote>
<p>üí° <strong>Da ChatGPT</strong></p>
<p><img src="images/chiusure/image%2023.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2024.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/chiusure/image%2025.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2026.png" alt="image.png" /></p>
<p><strong>FnOnce</strong>
La lambda implementa <code>FnOnce</code> se <strong>consuma</strong> uno o pi√π valori nell'ambito della propria esecuzione. In questo caso sto introducendo <code>f</code> che ha catturato come variabile libera <code>range</code> (che √® un intervallo) e mi ritorna come risultato <code>range.count()</code>.
Allora per poter dire quante cose sono presenti in quell'intervallo, cio√® invocare <code>count()</code>, lui deve consumare <code>range</code> ‚Äî si mette l√¨, lo svuota e alla fine dentro <code>range</code> non c'√® pi√π niente per√≤ lui pu√≤ dirti <em>"guarda ho trovato dieci cose".</em></p>
<p>Questa √® <code>FnOnce</code>: la posso chiamare una volta e ottengo dieci. Se provassi a chiamarla una seconda volta il compilatore mi blocca perch√© ormai <code>range</code> si √® svuotata, non c'√® pi√π.</p>
<p><strong>FnMut</strong>
Viceversa una lambda implementa il tratto <code>FnMut</code> se ha catturato in modo <strong>esclusivo</strong> una o pi√π variabili. Nell‚Äôesempio in slide abbiamo scritto <code>let mut sum = 0</code>. Questa <code>sum</code> la sto usando per cambiarla, e lui capisce che per poterla cambiare, per io poter scrivere <code>sum += 0</code>, sono obbligato a prenderne un riferimento mutabile e di conseguenza me lo lascia fare e mi dice che implementa <code>FnMut</code>.</p>
<p>Questo fa s√¨ che posso chiamare <code>f(5)</code> e il risultato √® che dentro la variabile <code>sum</code> ci finisce <code>5</code>, poi posso chiamare <code>f(7)</code> e questo significa che dentro la variabile <code>sum</code> ci finisce <code>12</code>. Quindi ho possibilit√† di chiamare pi√π volte ma l'ambiente in cui la chiamata avviene si muta come conseguenza di questa cosa.</p>
<p><strong>Fn</strong>
Ed infine posso implementare il tratto <code>Fn</code> se accedo in <strong>sola lettura</strong> alle variabili libere o se ne prendo possesso. Se ne ho preso completamente il possesso va anche bene. Chiaramente se non ho preso possesso ma accedo tramite riferimento alle variabili libere, finch√© esiste la chiusura le variabili libere sono sotto ipoteca ‚Äî il loro tempo di vita √® legato al tempo di vita della funzione, non le posso modificare.</p>
<p>Nell‚Äôesempio della slide sto prendendo un riferimento semplice alla variabile <code>s</code>: <code>let f = | v | v &lt; s</code> confronta <code>v</code> con la variabile libera <code>s</code>, che contiene ‚Äúhello‚Äù, e mi ritorna <code>true</code> o <code>false</code> a seconda dei casi.
Nel momento in cui invoco <code>f</code> di "word" ‚Äî "word" √® pi√π piccolo di "hello"? No, e di conseguenza ottengo <code>false</code>.
"bye" √® pi√π piccolo di "hello"? S√¨ perch√© alfabeticamente viene prima e quindi mi ritorna <code>true</code>.</p>
<p>L'uso delle espressioni lambda che noi in Rust scriviamo con le <code>| |</code> (barre verticali) ci d√† la possibilit√† di descrivere in modo compatto delle funzioni.</p>
<p><img src="images/chiusure/image%2027.png" alt="image.png" /></p>
<p>La conseguenza di questo √® che possiamo implementare una funzione che accetta come parametro un'altra funzione. Ad esempio, ricorrendo alla <strong>programmazione generica</strong>, √® difficile dire che tipo ha la mia lambda: √® una tupla? S√¨, ma come, che tipo ha esattamente?
Il compilatore gli dar√† un nome incomprensibile.
<em>Come faccio a passarla a un'altra funzione?</em>
La posso passare solo se la chiamo col suo <strong>tratto</strong>, e quindi posso dire che a quell‚Äôaltra funzione passer√≤ un oggetto <code>T</code> che implementa il tratto <code>Fn</code>, <code>FnMut</code> o <code>FnOnce</code>.</p>
<p>Qui vediamo un esempio di <code>higher_order_function</code>: √® una funzione che prende <code>f</code> di tipo <code>F</code> a condizione che <code>F</code> grande implementi il tratto <code>Fn</code> che mangia il tipo <code>T</code> (<code>where F: Fn(T)</code>) e produce il valore <code>U</code> ( <code>-&gt; U</code>).</p>
<p>Questo ci d√† la possibilit√† di scrivere in modo molto generico delle cose.</p>
<blockquote>
<p>üí° <strong>Analisi firma</strong></p>
<p><img src="images/chiusure/image%2028.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2029.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/chiusure/image%2030.png" alt="image.png" /></p>
<p>In questo esempio, usando <code>move</code>, il possesso della variabile catturata (<code>v</code>) viene trasferito alla chiusura. Tuttavia, <strong>non serve <code>FnMut</code></strong> perch√© la variabile <strong>non viene modificata</strong>, ma solo letta tramite <code>.clone()</code>.</p>
<p>Anzi, se la chiusura <strong>non consuma</strong> la variabile catturata (non fa <code>return v</code>), allora <strong>pu√≤ tranquillamente implementare <code>Fn</code></strong>, il trait pi√π restrittivo.</p>
<p>Questo √® possibile proprio <strong>grazie a <code>move</code></strong>, che elimina qualsiasi legame tra la chiusura restituita e le variabili locali della funzione che la crea.</p>
<p><img src="images/chiusure/image%2031.png" alt="image.png" /></p>
<blockquote>
<p>üí° <strong>Descrizione dell‚Äôesempio AI Generated</strong></p>
<p>La chiusura <strong>cattura <code>i</code> in modo mutabile</strong> (perch√© lo incrementa) e <strong><code>b</code> per valore</strong> (una <code>String</code> derivata da <code>prefix</code>), quindi deve essere <strong><code>move</code></strong> per prendere possesso di entrambe. Questo √® necessario affinch√© la chiusura possa <strong>vivere anche dopo che <code>generator</code> √® terminata</strong>, mantenendo il proprio stato (<code>i</code>) tra una chiamata e l‚Äôaltra.</p>
<p>Anche se <code>b</code> √® catturata per valore, <strong>non viene consumata</strong>, perch√© viene solo <strong>letta</strong> (passata per riferimento a <code>format!</code>). Questo permette alla chiusura di <strong>riutilizzare <code>b</code></strong> a ogni invocazione senza diventare <code>FnOnce</code>.</p>
<p>Essendo la chiusura <strong>mutabile internamente</strong>, il valore <code>f</code> in main deve essere dichiarato <code>mut</code>.</p>
<p>Infatti, <strong>le chiusure in Rust vengono <em>desugared</em> in tuple</strong> che contengono i valori catturati come campi. Se uno di questi campi (come <code>i</code>) viene modificato, allora il metodo generato (<code>call_mut()</code>, che fa parte del tratto <code>FnMut</code>) richiede <strong><code>&amp;mut self</code></strong>. Per poter invocare <code>f()</code>, il compilatore deve quindi disporre di <code>f</code> come valore <strong>mutabile</strong>.</p>
<p>Ogni chiamata a <code>f()</code> restituisce un nuovo identificatore unico, sfruttando lo stato interno della chiusura.</p>
</blockquote>
<h1 id="4-riferimenti"><a class="header" href="#4-riferimenti">4. Riferimenti</a></h1>
<p><img src="images/chiusure/image%2032.png" alt="image.png" /></p>
<h1 id="5-applicazioni-pratiche"><a class="header" href="#5-applicazioni-pratiche">5. Applicazioni pratiche</a></h1>
<p>Vediamo delle applicazioni pratiche.</p>
<p><img src="images/chiusure/image%2033.png" alt="image.png" /></p>
<p>Torniamo a prendere un attimo il codice di prima: quando concretamente uso una cosa del genere?</p>
<p>Il generatore cos√¨ viene utile in un mucchio di situazioni. Spesso ci troviamo col bisogno di dover dare dei nomi a delle cose garantendo che questi nomi siano tutti diversi. Creare un generatore del genere √® comodissimo, perch√© sono sicuro che tutte le volte che mi serve un nome glielo chiedo e lui mi garantisce che viene diverso.</p>
<p>Se mi servono pi√π famiglie di nomi disgiunti, mi faccio dei generatori con basi distinte: uno lo chiamo <code>a_qualcosa</code>, l'altro <code>b_qualcosa</code>, e di nuovo mi vengono tutti tranquilli e distinti.</p>
<p>Ma vediamo degli usi pi√π semplici delle lambda, ma assolutamente comuni.</p>
<p>Uno di questi √®: spesso ci troviamo col bisogno di avere dei dati, ad esempio un vettore con dei valori, e dobbiamo farci delle cose sopra.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5, 6, 8, 9, 0];
<span class="boring">}</span></code></pre></pre>
<p>Ho il mio vettore e mi piacerebbe trasformare questo vettore in una serie di stringhe. Come posso fare una cosa del genere?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;String&gt; = v.iter().map(|n| format!("n_{}", n)).collect();
<span class="boring">}</span></code></pre></pre>
<p>Il metodo <code>map</code> non posso applicarlo direttamente sul vettore in quanto tale, devo dire <em>"dammi gli elementi uno a uno e fammi delle cose".</em>
A questo punto lui mi stampa "n1", "n2", "n3"... tutti quanti uno a uno mi ha preparato queste cose qua.</p>
<p><code>v.map</code> √® un modo per dire <em>"a tutti questi elementi di <code>v</code> voglio applicare una funzione".</em></p>
<p><em>E come faccio a dare la funzione?</em>
La scriviamo proprio qui! Qui chiamiamo l'elemento <code>n</code> e scriviamo <code>format!("{}", n)</code>.
Quindi con <code>v.map</code> ho fatto questo, ma questo non √® ancora un vettore ‚Äî perch√© diventi un vettore dobbiamo fare <code>.collect()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;String&gt; = v.iter()
												.filter(|n| **n &lt; 5) // Doppio * perch√® n in questo caso √® un doppio riferimento ( Vec --&gt; String --&gt; Data)
												.map(|n| format!("n_{}", n))
												.collect();
<span class="boring">}</span></code></pre></pre>
<p>Tra l'altro potrei farci delle cose ulteriori. Potrei dire che io non voglio tutti ma voglio soltanto quelli che sono pi√π piccoli di <code>5</code>. A questo punto lui mi stampa <code>n_1</code>, <code>n_2</code>, <code>n_3</code>, <code>n_4</code>, <code>n_0</code> perch√© sono i numeri che vanno bene.</p>
<p>Questo √® l'uso pi√π comune che si ha delle lambda: ho la possibilit√† di esprimere come voglio lavorare su delle mie collezioni, che poi √® lo stesso meccanismo che probabilmente vi hanno insegnato nello sviluppo di applicazioni web in Javascript per lavorare con i vettori e gli array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for i in 3..7 {
	let v1: Vec&lt;String&gt; = v.iter()
													.filter(|n| **n &lt; i) // Doppio * perch√® n in questo caso √® un doppio riferimento ( Vec --&gt; String --&gt; Data)
													.map(|n| format!("n_{}", n))
													.collect();
}
<span class="boring">}</span></code></pre></pre>
<p>Questo ci d√† la possibilit√† di fare delle operazioni, ma potrei essere pi√π sofisticato.
Ad esempio, potrei includere questo blocco dentro un <code>for i in 3..7</code> e dire che il concetto del filtro, invece di essere sempre <code>&lt; 5</code>, √® <code>&lt; i</code>. In questo caso questa √® diventata una <em>closure</em> che ha catturato il valore <code>i</code>. Quindi a una prima iterazione prender√≤ soltanto <code>1</code>, <code>2</code> e <code>0</code>, alla seconda iterazione prender√≤ <code>1</code>, <code>2</code>, <code>3</code>, <code>0</code> e cos√¨ via.</p>
<p>Ho la possibilit√† di <em>confezionarmi</em> delle lambda in vario modo.</p>
<p>Posso usare questa tecnica per prepararmi degli oggetti che user√≤ in futuro senza avere al momento bisogno di farli. Ad esempio, posso avere:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gen_vect(n: usize) -&gt; impl FnOnce() -&gt; Vec&lt;i32&gt; {
	return move || {
		println!("Sto per preparare il vettore con {} elementi", n);
    let mut v = vec![];
    for i in 0..n {
        v.push(0);
    }
    println!("Fatto!");
    return v;
	}
}

<span class="boring">}</span></code></pre></pre>
<p>Questa funzione <code>genvect</code> √® specializzata nel costruirmi una funzione che quando sar√† chiamata creer√† un vettore.</p>
<p>Questa funzione mi ritorna una funzione che quando verr√† invocata creer√† un vettore ‚Äî non lo crea subito! Creer√† un vettore della dimensione che gli d√≤ adesso. Gli dico: <em>"Preparati una funzione che sar√† capace, quando te lo chiedo, di farmi un vettore di <code>n</code> elementi".</em></p>
<p>A questo punto nel <code>main</code> facciamo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let f = gen_vect(4);
	println!("Preparata la funzione");
	let v = f();
}

/* OUTPUT */
// Preparata la funzione
// Sto per preparare il vettore con 4 elementi
// Fatto [0, 0, 0, 0]

// Process finished with exit code 0</code></pre></pre>
<p>A questo punto mi dice che ha <em>preparato la funzione</em> ‚Äî ho gi√† congelato il fatto che quello sar√† un vettore di 4, ma non l'ho ancora fatto! Mi sono preparato le condizioni per poterlo avere.</p>
<p>Quando mi servir√† davvero il vettore gli chiedo di farlo con <code>let v = f();</code>, e lui mi dice <em>"Sto per preparare il vettore con 4 elementi‚Äù</em>.</p>
<blockquote>
<p>‚ö†Ô∏è <strong><code>fn</code> al posto di <code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code></strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gen_vect(n: usize) -&gt; impl FnOnce() -&gt; Vec&lt;i32&gt; { 
  // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Se io ritorno <code>fn</code> semplice (dove c‚Äô√® scritto <code>impl FnOnce()</code>), non posso avere uno stato ‚Äî per poter essere una tupla mi serve essere uno dei tre tratti funzionali: <code>Fn</code>, <code>FnOnce</code>, <code>FnMut</code>.</p>
<p><img src="images/chiusure/image%2034.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2035.png" alt="image.png" /></p>
<p><img src="images/chiusure/image%2036.png" alt="image.png" /></p>
</blockquote>
<p>Questa tecnica in cui creo una funzione customizzata sul mio bisogno ‚Äî <em>ho preparato una funzione che quando la invocher√≤ mi dar√† un vettore di <code>n</code> elementi</em> ‚Äî non √® detto che mai mi serva. Se a un certo punto ne avr√≤ bisogno glielo chiedo, e non dovr√≤ ricordarmi quanti erano gli elementi perch√© lo sa lui. Questo √® un modo totalmente diverso di programmare, ma molto potente.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gestione-degli-errori---malnati-16"><a class="header" href="#gestione-degli-errori---malnati-16">Gestione degli errori - Malnati 16 <!-- omit in toc --></a></h1>
<h1 id="indice-10"><a class="header" href="#indice-10">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="11-gestione_degli_errori.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="11-gestione_degli_errori.html#11-due-tipi-di-errori">1.1 Due Tipi di Errori</a></li>
<li><a href="11-gestione_degli_errori.html#12-come-gestire-gli-errori">1.2 Come Gestire gli Errori</a></li>
<li><a href="11-gestione_degli_errori.html#13-strategie-di-ripristino">1.3 Strategie di Ripristino</a></li>
<li><a href="11-gestione_degli_errori.html#14-rilevamento-degli-errori">1.4 Rilevamento degli Errori</a></li>
<li><a href="11-gestione_degli_errori.html#15-result">1.5 <code>Result</code></a></li>
<li><a href="11-gestione_degli_errori.html#16-option">1.6 <code>Option</code></a></li>
<li><a href="11-gestione_degli_errori.html#17-panic">1.7 <code>panic!</code></a></li>
</ul>
</li>
<li><a href="11-gestione_degli_errori.html#2-supporto-sintattico-alla-gestione-degli-errori">2. Supporto sintattico alla gestione degli errori</a>
<ul>
<li><a href="11-gestione_degli_errori.html#21-eccezioni-in-c">2.1 Eccezioni in C++</a></li>
<li><a href="11-gestione_degli_errori.html#22-i-limiti-della-gestione-delle-eccezioni-in-c">2.2 I limiti della gestione delle eccezioni in C++</a></li>
</ul>
</li>
<li><a href="11-gestione_degli_errori.html#3-gestione-delle-eccezioni-in-rust">3. Gestione delle eccezioni in Rust</a>
<ul>
<li><a href="11-gestione_degli_errori.html#31-elaborare-i-risultati">3.1 Elaborare i risultati</a>
<ul>
<li><a href="11-gestione_degli_errori.html#311-is_ok-e-is_err">3.1.1 <code>.is_ok()</code> e <code>is_err()</code></a></li>
<li><a href="11-gestione_degli_errori.html#312-ok">3.1.2 <code>.ok()</code></a></li>
<li><a href="11-gestione_degli_errori.html#313-map">3.1.3 <code>.map()</code></a></li>
<li><a href="11-gestione_degli_errori.html#314-contains">3.1.4 <code>.contains()</code></a></li>
<li><a href="11-gestione_degli_errori.html#315-unwrap">3.1.5 <code>.unwrap()</code></a></li>
</ul>
</li>
<li><a href="11-gestione_degli_errori.html#32-la-macro-panic">3.2 La macro <code>panic!()</code></a></li>
<li><a href="11-gestione_degli_errori.html#33-ignorare-gli-errori">3.3 Ignorare gli errori</a></li>
<li><a href="11-gestione_degli_errori.html#34-propagare-gli-errori">3.4 Propagare gli errori</a></li>
<li><a href="11-gestione_degli_errori.html#35-propagare-errori-eterogenei">3.5 Propagare errori eterogenei</a>
<ul>
<li><a href="11-gestione_degli_errori.html#351-boxdyn-errorerror">3.5.1 <code>Box&lt;dyn error::Error&gt;</code></a></li>
<li><a href="11-gestione_degli_errori.html#352-enum-di-errore-custom">3.5.2 Enum di errore custom</a></li>
<li><a href="11-gestione_degli_errori.html#353-thiserror-e-anyhow">3.5.3 <code>thiserror</code> e <code>anyhow</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="11-gestione_degli_errori.html#4-riferimenti">4. Riferimenti</a></li>
<li><a href="11-gestione_degli_errori.html#5-live-coding-24042024">5. Live coding 24/04/2024</a>
<ul>
<li><a href="11-gestione_degli_errori.html#creiamo-una-funzione-che-pu%C3%B2-fallire">Creiamo una funzione che pu√≤ fallire</a></li>
<li><a href="11-gestione_degli_errori.html#modelliamo-lerrore">Modelliamo l'errore</a></li>
</ul>
</li>
</ul>
<h1 id="1-introduzione-5"><a class="header" href="#1-introduzione-5">1. Introduzione</a></h1>
<p>L'argomento √® relativamente facile dal punto di vista strettamente tecnico, perch√© sono due stupidaggini in croce, ma in realt√† √® complesso dal punto di vista operativo, perch√© affronta come gestire gli impossibili errori che si verificano durante lo svolgimento di un programma. Qui la difficolt√† non √® banalmente cosa faccio per segnalare l'errore o cosa faccio per farci delle cose, ma √®: <em>se il mio programma arriva a un punto e si blocca, che strategia metto in atto per farlo funzionare?</em></p>
<p>Che se volete √® un po' il problema che ha uno che parte per un viaggio e buca una gomma. E a quel punto l√¨ il viaggio non pu√≤ continuare subito. Deve decidere se quella gomma l√¨ la pu√≤ riparare, ammesso che abbia la ruota di scorta e quindi riesce a cambiarla, oppure se ha il kit per il gonfiaggio, che forse va bene, ma in quel caso l√¨ tiene finch√© il buco non si dilata e non si sgonfia di nuovo. Oppure la gomma √® cos√¨ lacerata che non c'√® verso, non √® sostituibile facilmente e quindi bisogna essere trainati via. Questo tipo di situazione che di per s√© si pu√≤ verificare richiede una gestione e quella gestione l√¨ non ha delle soluzioni preconfezionate facili.</p>
<p>Allora, la difficolt√† della gestione degli errori √® legata a <strong>capire cosa faccio quando capitano delle cose.</strong>
Poi chiaramente c'√® un pezzo di tecnicismo che adesso affronteremo e vediamo di sviscerare.</p>
<p>In generale noi sappiamo che una computazione, cio√® l'invocazione di una funzione, pu√≤ risultare con successo, e quindi dar origine al risultato della funzione stessa, oppure pu√≤ arrestarsi in qualche punto perch√© capita un evento inatteso. I diversi linguaggi offrono vari tipi di supporto per intervenire e innanzitutto segnalare che √® successo qualcosa di strano, e separatamente mettere in atto delle strategie di <em><strong>recovery</strong></em>, cio√® cerco di aggiustare le cose in qualche maniera.</p>
<p><img src="images/gestione_degli_errori/image.png" alt="image.png" /></p>
<p>Allora, il principio di fondo √® che di per s√© tutte le computazioni possono fallire. Il fatto che falliscano vuol dire che non solo non ci danno il risultato atteso (se quella √® una funzione che dovr√† calcolare un dato, beh, il dato non ce l'abbiamo perch√© mi son fermato prima), ma hanno un secondo problema.
Se questa computazione produceva degli effetti collaterali, ad esempio se stavo scrivendo un file sul disco, io so che se va tutto bene, e ho scritto la funzione in modo corretto, al termine della funzione il file √® sul disco, tutto intero. Ma se la funzione si blocca per qualche motivo, cio√® incontra una qualche difficolt√†, <em>cosa posso dire del file?</em> Di per s√© niente, dipende da dove si √® bloccata, magari prima ancora di crearlo e quindi non c'√® niente, magari mentre lo sta scrivendo e quindi quel file l√¨ √® incompleto, o magari si √® rotta dopo, quando quel file l√¨ √® gi√† tutto buono. Non so dire di per s√©, in assenza di contratti di qualche forma, cosa succeda.</p>
<p>Questo problema √® assolutamente presente, ad esempio, nel mondo dei database. I database correggono questo genere di situazione con il concetto di <em><strong>transazione</strong></em>.
<em>Cosa succede?</em> Se io devo fare delle operazioni su un database, posso demarcarle con una transazione. La transazione comincia, faccio le mie operazioni, che possono aver successo o fallire. Se falliscono, quello che succede √® che la transazione viene <em>rolled back</em>, viene annullata. L'effetto di annullare la transazione √® che nel database si mette in atto una qualche strategia che permette di buttare via le modifiche che sono state fatte dall'inizio di questa transazione fino al momento attuale e rimettere come minimo le cose come erano in origine. Che √® molto meglio che non lasciarle spaccate a met√†.</p>
<p>Questo per√≤ √® un concetto che nei sistemi operativi di base non esiste. Il fatto che voi iniziate a scrivere un file non √® compreso come pezzo di una transazione. E banalmente voi aprite il file, il sistema operativo ve lo apre, voi scrivete sul file, via via che scrivete, il sistema operativo ci aggiunge delle cose, a un certo punto dite che avete finito e chiudete il file, e va bene. Per√≤ il sistema operativo non ha nessuna consapevolezza del fatto che questo file sia in divenire, che sia parte di un'azione pi√π o meno lunga.
Quando per√≤ voi avete bisogno di garantire che quel file l√¨ o c'√® tutto o non c'√® per niente, allora bisogna mettere in atto qualche meccanismo. Chiaramente con uno sforzo in termini di progetto del vostro codice. Cio√® siete voi che dovete pensarci prima, perch√© n√© il sistema operativo n√© i linguaggi vi danno supporto per questa cosa.</p>
<p><em>Perch√© mai una computazione dovrebbe fallire?</em>
Le cause possono essere molto diverse. Alcune sono in qualche modo prevedibili. Nel senso che, se ad esempio l'utente √® coinvolto in un'operazione, banalmente perch√© l'utente deve inserirmi un dato, e quindi nell'ambito della mia operazione chiedo all'utente di darmi questo dato qui, l'utente potrebbe darmi un dato sbagliato. Ad esempio, quando gli chiedo un numero, lui potrebbe scrivere una cosa che non √® un numero. Quando cerco di leggerla come numero, l'operazione di parsing fallisce. Ci sta: errare √® umano, quindi ci sta, devo prevederlo e in qualche modo monter√≤ un loop che dice <em>"provo a leggere, se questa cosa qua non √® un numero ti dico che non √® un numero, e te lo chiedo di nuovo".</em> Che chiaramente ha un senso nel momento in cui sono sicuro che c'√® l'utente davvero davanti alla tastiera. Perch√© se il mio programma sar√† invece eseguito <code>qualcosa | mio_programma</code> (pipe), e quindi il mio programma non sta leggendo dalla tastiera, ma sta leggendo dall'output di qualche altro programma, perch√© l'ho montato cos√¨ con la pipe, e beh, lui potr√† anche dire "non √® un numero‚Äù, ma chi gli sta mandando i dati non √® che lo capisce. Quindi da l√¨ in avanti succedono dei mostri.</p>
<p>Quindi questi li posso in qualche modo immaginare e posso cercare di costruire il mio software affinch√© possa essere in qualche modo robusto. Altri invece no, cio√® possono anche essere immaginati, ma esattamente come ciascuno di noi ha presente che potrebbe morire tra un nanosecondo perch√© gli viene un coccolone, mediamente non agisce sulla base di questo. Il fatto che quella cosa sia di per s√© possibile non vuol dire che viviamo con un'angoscia di questa cosa.</p>
<p>Nel nostro contesto, <em>che cosa potrebbe capitare?</em>
Ad esempio, banalmente sto scrivendo sul disco e il disco si riempie.</p>
<p>Noi siamo abituati ormai ad avere dischi che sono molto grossi, per cui √® normalissimo, comprate un PC che ci sia un tera di disco, anche di pi√π. Ma nonostante questo ci troviamo a gestire spesso e volentieri montagne di dati. Un po' perch√© scarichiamo film a destra manca, un po' perch√© magari siamo appassionati di Big Data e tritiamo delle cose di qualche tipo, e quindi, nonostante il fatto che abbiamo dei dischi via via sempre pi√π grossi, li riempiamo facilmente.</p>
<p>A volte pu√≤ essere un problema magari di rete. Il mio programma tinge per una parte dei suoi dati da delle informazioni che arrivano dalla rete, in modo pi√π o meno conscio. Perch√© magari io sono convinto di leggere dal file che si chiama pippo.txt, ma quel file l√¨, pippo.txt, √® servito da un driver remoto. E cosa succede? Succede che magari la rete si interrompe. Qualcuno ha spento l'access point e all‚Äôimprovviso quello che mi sembrava essere un file locale, non c'√® pi√π. √à andato via. Oppure leggevo da una chiavetta USB e qualcuno l'ha tirata via. L√¨ non c'√® il recovery che tenga, non ci possiamo fare niente.</p>
<h3 id="11-due-tipi-di-errori"><a class="header" href="#11-due-tipi-di-errori">1.1 Due Tipi di Errori</a></h3>
<p>Indipendentemente dalla causa che ha prodotto questo errore, posso dividere i nostri errori in due famiglie:</p>
<ul>
<li><strong>Errori Recuperabili:</strong> quelli per i quali sono in grado di mettere in atto una strategia di ripristino. Ci posso fare qualcosa.</li>
<li><strong>Errori Irrecuperabili:</strong> quelli per cui non ci posso fare nulla.</li>
</ul>
<p>E se non ci posso fare nulla, l'unica alternativa che ho √® piantarla l√¨. Fermarmi. Perch√© qualunque cosa cercassi di fare di seguito, mancherebbe dei presupposti e quindi sarebbe potenzialmente anche dannosa.</p>
<p>"<em>Ex falso, sequitur quodlibet</em>" ‚Äî si pu√≤ dedurre qualsiasi cosa da premesse false. Per esempio, potrei dimostrarvi che 1=2 usando semplici passaggi matematici. Il problema √® che per farlo dovrei dividere per zero ‚Äî un'operazione matematicamente illecita. Questa manipolazione invalida tutto il ragionamento successivo. √à per questo che devo fermarmi: proseguire significherebbe solo produrre conclusioni prive di senso.</p>
<h3 id="12-come-gestire-gli-errori"><a class="header" href="#12-come-gestire-gli-errori">1.2 Come Gestire gli Errori</a></h3>
<p>La scelta di ci√≤ che √® recuperabile o irrecuperabile non pu√≤ derivare dal linguaggio, dal sistema operativo o dall'intelligenza artificiale. Pu√≤ nascere solo dal buonsenso di chi analizza attentamente il proprio problema, lo comprende a fondo e ne valuta tutte le possibili conseguenze.</p>
<p><img src="images/gestione_degli_errori/image%201.png" alt="image.png" /></p>
<p>In caso di errore irrecuperabile, l'azione tipica √® terminare il processo. Mi fermo, lasciando che qualcuno intervenga in seguito per risolvere il problema. La questione √® che la terminazione pu√≤ avvenire in due modi: brusca e immediata, oppure graduale, eseguendo una serie di operazioni per lasciare tutto in ordine prima di fermarsi.</p>
<h3 id="13-strategie-di-ripristino"><a class="header" href="#13-strategie-di-ripristino">1.3 Strategie di Ripristino</a></h3>
<p>Quando sono di fronte a errori che reputo di tipo recuperabile, allora posso provare una qualche strategia di ripristino.</p>
<p><em>Quali sono le strategie di ripristino?</em>
Alla buona ce ne sono quelle legate al <em>"ci provo ancora".</em> Alcuni mali si guariscono in questa maniera.</p>
<p>Esempi:</p>
<ul>
<li><strong>Retry con l'utente:</strong> L'utente ha scritto una cosa sbagliata, gli dico <em>"no, √® sbagliato, dimmelo di nuovo".</em> Se l√¨ davvero c'√® l'utente, pu√≤ dar s√¨ che ce la faccio.</li>
<li><strong>Retry di rete:</strong> Una connessione di rete andata in timeout. Posso sperare che la rete non sia definitivamente rotta, ma che sia stata solo parzialmente intasata. E quindi anche in questo caso posso riprovare, magari mettendoci una pausa in mezzo. Dico <em>"aspettiamo 10 secondi, poi ci riprovo".</em> Magari si ripiglia.</li>
</ul>
<p>Buona parte dei malfunzionamenti nascono in realt√† da congestioni temporanee o meccanismi che hanno un auto recovery indipendente da me, che fa s√¨ che se io riprovo la stessa azione dopo tempo, pu√≤ dar s√¨ che quella cosa l√¨ vada a posto.</p>
<p>In altri casi posso invece provare a invocare un amministratore, cio√® a coinvolgere un utente in qualche modo. Gli mando una mail dicendo <em>"attenzione, io mi devo fermare, magari invece che spegnermi mi blocco e non vado avanti fino a che tu, caro amministratore, non fai una certa cosa".</em></p>
<p>In alcuni casi posso provare a fare quella cosa che stavo facendo in un modo diverso. Se ce l'ho, magari per certi tipi di operazione ammettono due o pi√π approcci, uno dei quali efficiente, interessante, simpatico, che quindi normalmente scelgo, e uno brutto, noioso e lento, che per√≤ in mancanza d'altro va anche bene.</p>
<h3 id="14-rilevamento-degli-errori"><a class="header" href="#14-rilevamento-degli-errori">1.4 Rilevamento degli Errori</a></h3>
<p>Piccolo problema. <em>Dov'√® che mi accorgo che si √® rotto qualcosa?</em>
Tipicamente nel provare a fare una qualche operazione, dove √® coinvolto un pezzo di sistema che si pu√≤ rompere. Ad esempio, dove faccio qualche operazione di I/O, che normalmente √® embedded in una system call. Quel punto l√¨ preciso potrebbe non saperne a sufficienza di che cosa realmente sto facendo.</p>
<p>Supponiamo di scrivere su un file e che il disco sia pieno. L'operazione di scrittura sul file la fa il sistema operativo, che riceve la system call <code>write</code> che √® responsabile di andare e aggiungere nel file quello che sto scrivendo.</p>
<p><em>Chi √® che chiama questa system call?</em>
Non sono certo io programmatore applicativo. Io programmatore applicativo chiamo la libreria del linguaggio, che avr√† il metodo <code>write_file</code>, supponiamo, che √® responsabile di scrivere. Il metodo <code>write_file</code> chiama la system call, la system call dentro si accorge che c'√® qualcosa di rotto, restituisce un codice di errore, e poi il metodo <code>write_file</code> prende atto di questo codice d'errore, ma non sa che cosa farsene. Perch√© il metodo <code>write_file</code> √® genericissimo, me l'ha scritto qualcuno che ha fatto la libreria standard del linguaggio, qualunque esso sia, e non pu√≤ sapere minimamente che file sto scrivendo, perch√© lo sto scrivendo, che tipo di assunzioni ci voglio fare. E quindi, sebbene lui se ne sia accorto che c'√® stato un errore, non ci pu√≤ fare niente. E quindi deve passare questa informazione al suo chiamante.</p>
<p>Questo vuol dire che l'operazione <code>write_file</code> deve essere congegnata in modo tale che se il sistema operativo gli dice di no, supponendo che <code>write_file</code> debba fare pi√π pezzi, se in uno qualunque dei suoi passaggi si accorge che quel passaggio l√¨ non pu√≤ essere fatto, deve tornare al chiamante. <strong>Ma deve tornare al chiamante con l'indicazione che √® andato qualcosa storto.</strong></p>
<p>Il sistema operativo nelle system call definisce, in modo molto puntuale, come ritorna i codici di errore. Ogni system call √® documentata e ti dice "io ho un valore di ritorno", se ritorno un numero 0 vuol dire che √® andato bene, un numero diverso da 0 √® un codice d'errore, dove 35 vuol dire questo, -2 vuol dire quell'altro, e cos√¨ via. E quindi l√¨ c'√® un'interfaccia predefinita, ben fatta.</p>
<p>Se tu chiami la system call, non √® detto che quell'interfaccia l√¨ possa essere propagata cos√¨ com'√®, perch√© quello che ha senso a basso livello non ha necessariamente senso in contesti diversi. E quindi devo trovare un modo di segnalare al mio chiamante che si √® rotto qualcosa. Anzi, devo segnalare al mio chiamante <em>cosa</em> si √® rotto. Quindi non solo che si √® rotto qualcosa, ma possibilmente anche cosa si √® rotto, perch√© solo sapendo cosa si √® rotto il chiamante potr√† decidere se ha una strategia da mettere in atto oppure no.</p>
<p>Chiaramente noi potremmo usare un approccio simile a quello delle system call restituendo un numero. Un numero per√≤ √® un problematico, perch√© supponiamo che 27 voglia dire <em>"File not found".</em> <em>Quale</em> file non hai trovato? Io so solo "File not found", ma non so <em>quale</em> file. Al chiamante magari questa informazione gli potrebbe servire. Oppure potrei volergli dire <em>"non ho scritto tutto".</em> Ma <em>quanto</em> hai scritto? Mi servono dei dettagli. Ogni errore viene con delle informazioni, possibilmente aggiuntive, che fanno capire al chiamante che cosa possa essere successo.</p>
<p><em>Come trasporto queste informazioni aggiuntive?</em>
Questo pu√≤ dare origine a strategie diverse, e qui nella storia dei linguaggi di programmazione sono successe cose varie, dove abbiamo assistito a un movimento prima in un senso, poi nel senso opposto. In ogni caso, val la pena rendersi conto che qualunque cosa io faccio, il mio programma si complica tantissimo.</p>
<p>Se prima ho una semplice operazione che legge dal file 1, riempie un buffer, scrive sul file 2 e chiude entrambi i file ‚Äî quindi una funzione basilare con <code>read</code>, <code>write</code>, <code>close</code>, <code>close</code> ‚Äî nel momento in cui tutte e quattro queste funzioni possono fallire, il mio codice si trasforma in "<em>if</em> fallisce read, fai questo, <em>else if</em> fallisce write, fai quello, <em>else if</em> fallisce la prima close, fai quest'altro, <em>else if</em> fallisce l'altra close, fai quell'altro ancora, <em>else</em> finalmente tutto √® andato bene, ritorna il successo". E cos√¨ quel programma, che prima era chiarissimo da leggere, √® diventato un gineprario.</p>
<p>Perch√© si hanno "if" annidati uno dentro l'altro, e se le azioni invece di essere quattro fossero 40 ‚Äî cosa del tutto plausibile ‚Äî il codice diventa illeggibile. Se poi queste azioni sono dentro un loop, √® un vero disastro: diventa impossibile da mantenere. Chi lo legge si mette le mani nei capelli, e rischia di fare anche danni nel tentativo di modificarlo, perch√© perde completamente il filo della logica.</p>
<p>Se poi qualche programmatore un po' creativo, a volte dice <em>"if √® andato bene‚Äù</em>, e altre volte dice <em>"if √® andato male‚Äù</em>, l√¨ √® la disperazione. Perch√© quello che prima almeno in un caso aveva una struttura standard, e quindi avevo sempre il ramo del "then" che mi indicava una condizione sbagliata, e sempre il ramo dell‚Äô "else" che mi indicava una condizione giusta, o viceversa, se io comincio a fare certe volte il check positivo, certe volte il check negativo, non so pi√π qual √® il ramo giusto su cui devo muovermi. Disastro.</p>
<p>Per questo motivo, a un certo punto nella storia, si √® iniziato a mettere in discussione l'approccio in cui le funzioni restituivano semplicemente un codice d'errore, senza regole chiare sul suo significato. Poteva essere un numero, un booleano o una stringa, ma come si potevano comunicare dettagli aggiuntivi sull'errore? Nel linguaggio C, storicamente, non esisteva alcun meccanismo per farlo.</p>
<p>Se voi prendete la definizione di Windows, che √® pure un sistema operativo che ha i suoi 30 anni di storia, e andate a guardare come Windows segnala i suoi errori, allora Windows non vi lascia accedere alle system calls. Le system calls di Windows sono tutte schermate da funzioni, scritte in C, esportate dal file che si chiama <code>system.dll</code>, piuttosto che <code>gdi.dll</code>, piuttosto che <code>user.dll</code>. Quindi voi accedete alle system calls solo chiamando funzioni di quel tipo l√¨, contenute in quelle dll l√¨.</p>
<p>Quelle funzioni sono funzioni tipo <code>create_file</code>, questa prende 27 parametri e ti restituisce qualche cosa, per dire se l'ha creato o meno. Un'altra √® <code>write_file</code>.</p>
<p>Come sono congegnate queste funzioni? Disperazione: alcune tornano un booleano. Di solito con la convenzione che se √® true l'operazione √® andata bene, se √® false √® andata male. E se √® andata male, <em>come</em> √® andata male? Boh.</p>
<p>Altre funzioni ritornano un intero, con la convenzione che zero indica successo, mentre altri valori indicano errori. <em>E come si interpreta questo codice?</em> Si esamina il bit pi√π significativo: se √® 1, indica un errore del kernel. Se √® 0, si controlla il secondo bit pi√π significativo: se √® 1, significa che l'errore √® avvenuto nel wrapper tra il codice utente e il kernel. Se entrambi i bit sono 0, si tratta di un errore applicativo che il programmatore deve gestire autonomamente. I bit rimanenti specificano il tipo specifico di errore verificatosi.</p>
<p>Ma √® anche possibile che la funzione restituisca non un numero ma un handle, definito come <code>void*</code>, quindi un puntatore, con la convenzione che se non √® <code>NULL</code> l'operazione √® andata bene, mentre se √® <code>NULL</code> √® fallita. Siamo alla convenzione opposta di prima ‚Äî un vero disastro! Il programmatore che deve scrivere codice per Windows si trova quindi completamente disorientato.</p>
<p><strong>√à difficilissimo capire</strong>, data una funzione, che tra l'altro non sai neanche bene che √® di sistema, perch√© si maschera, siccome non √® una system call ben definita, cio√® che ha una sua cosa, ma √® semplicemente il nome di una funzione che sai a memoria che <code>create_file</code> te la d√† il sistema operativo, ma nessuno ti impedirebbe di fartene tu una che si chiama <code>create_file</code>, cio√® non ha una evidenza del suo comportamento. E devi andare a cercare tu, il tapino che l'ha inventata, quale strana idea si √® messo in testa come logica di gestione degli errori.</p>
<p>Per questo motivo a un certo punto nella storia la gente ha cominciato a rifletterci e dire bisogna che il linguaggio mi dia un modo preciso per distinguere i comportamenti corretti dai comportamenti non corretti. E cos√¨ √® nata l'idea delle <em><strong>eccezioni</strong></em>.</p>
<p>Le eccezioni sono state introdotte in C++ e sono state abbracciate da Java che le ha poi propagate quasi come un'infezione alla maggior parte dei linguaggi moderni. Per cui trovate le eccezioni in JavaScript, trovate le eccezioni in Python, trovate le eccezioni da altre parti. <strong>Disastro.</strong></p>
<p><em>Perch√© √® disastro?</em> Perch√© il concetto di eccezione, su cui vale la pena di spenderci due minuti per la sua onnipresenza nella maggior parte dei linguaggi e per il fatto che spesso e volentieri i programmatori, soprattutto quelli junior, non ci riflettono abbastanza, nascondono una serie di problemi.</p>
<p>I signori che hanno progettato Rust avendo imparato la lezione che le eccezioni <strong>non sono la soluzione migliore</strong>, hanno fatto un mezzo passo indietro, tornando all'idea dei codici di ritorno, ma con un'importantissima differenza, dicendo "<em>non √® che lo definisce il programmatore a caso, a volte true, a volte false, a volte uno, a volte zero, o cose del genere. Guarda, io ti metto a disposizione <strong>nel linguaggio</strong> una struttura dati, una <strong>enum</strong> fatta apposta, col quale descrivi se la tua cosa √® andata bene o √® andata male. Se √® andata bene mi descrivi il suo <strong>risultato</strong>, se √® andata male mi descrivi <strong>perch√©</strong></em>".</p>
<h3 id="15-result"><a class="header" href="#15-result">1.5 <code>Result</code></a></h3>
<p>Questa enum si chiama <strong><code>Result</code></strong>, ed √® un tipo generico perch√© dipende da due sottotipi. <code>T</code>, che √® il tipo che descrive se la cosa √® andata bene qual √® il vero risultato della funzione. Per cui posso avere funzioni che ritornano <code>String</code>, e quello l√¨ sar√† un <strong><code>Result&lt;String, E&gt;</code></strong>. O delle funzioni che ritornano dei booleani, e quello l√¨ sar√† un <code>Result&lt;Boolean, E&gt;</code>.</p>
<p>Quindi il primo parametro di Result serve a descrivere quella particolare funzione, che cosa ritorna se va bene. Il secondo parametro di <code>Result</code> serve a dirmi se quella funzione invece ritorna perch√© qualcosa √® andato storto, che cosa mi devo aspettare? Ed √® il tipo <code>E</code>. Tipo <code>E</code> che pu√≤ essere di per s√© qualunque cosa, proprio come il tipo <code>T</code>, ma che normalmente si sceglie che sia un tipo che implementa il tratto <code>Error</code>. Perch√© implementando il tratto <code>Error</code> ci d√† alcune garanzie sulla describilit√† e sulla utilizzabilit√† dell' <code>Error</code> stesso. Dopodich√© non c'√® un vincolo che sia un oggetto che implementa il tratto <code>Error</code>. Ma √® molto conveniente se gli facciamo implementare il tratto <code>Error</code>.</p>
<p>In alcuni casi io posso semplicemente dire che non ho potuto fare quanto atteso, e quindi √® possibile, in alternativa a usare <strong><code>Result</code></strong>, segnalare gli errori con il concetto di <strong><code>Option</code></strong>.</p>
<h3 id="16-option"><a class="header" href="#16-option">1.6 <code>Option</code></a></h3>
<p><code>Option</code> vuol dire: pu√≤ darsi che ti dia il tuo risultato; se per qualche motivo non riesco a calcolarlo sappi che ti ritorno <code>None</code>.
<code>None</code> ti fa capire che il risultato non ce l'hai, ma non <em>perch√©</em> non l'hai avuto. Va bene in quelle situazioni pi√π semplici in cui in fondo non ci importa sapere perch√© non √® stato possibile, ci basta sapere che non √® stato possibile.</p>
<h3 id="17-panic"><a class="header" href="#17-panic">1.7 <code>panic!</code></a></h3>
<p>E poi ci d√† ancora un altro pezzo che √® la macro <code>panic</code> che abbiamo in qualche modo gi√† incrociato nel codice che abbiamo scritto.</p>
<h1 id="2-supporto-sintattico-alla-gestione-degli-errori"><a class="header" href="#2-supporto-sintattico-alla-gestione-degli-errori">2. Supporto sintattico alla gestione degli errori</a></h1>
<p><img src="images/gestione_degli_errori/image%202.png" alt="image.png" /></p>
<p>Prima di vedere per√≤ i dettagli di cosa ci d√† Rust facciamo uno zoom sui costrutti che sono presenti nella maggior parte degli altri linguaggi che si chiamano <code>try</code>, <code>catch</code>, <code>throw</code> e in alcuni casi <code>finally</code>. Nel senso che <code>finally</code> non √® presente ovunque, ma √® presente uniformemente dalle varie parti.</p>
<h2 id="21-eccezioni-in-c"><a class="header" href="#21-eccezioni-in-c">2.1 Eccezioni in C++</a></h2>
<p><img src="images/gestione_degli_errori/image%203.png" alt="image.png" /></p>
<p>Allora, detto che il C come linguaggio non vi d√† nessun supporto ‚Äî quindi n√© modi per indicare che cosa √® andato bene e che cosa √® andato male (lo scegliete voi a vostro piacimento) n√© modi per forzare una terminazione avanzata se non l'istruzione <code>return</code> in quanto tale, il C++ invece ha cominciato a introdurre il concetto di <strong>eccezione</strong>.</p>
<p>In C++ un'eccezione √® un dato qualunque: potete usare un numero, potete usare una stringa, potete usare la classe <code>std::exception</code> o una sua derivata, potete usare una lista, potete usare quello che vi pare. Dovete scegliere un tipo di dato per descrivere cosa si √® rotto.</p>
<p>Dopodich√© una funzione al suo interno pu√≤ contenere, in mezzo alle altre istruzioni, l'istruzione <code>throw</code>.</p>
<p><em>Cosa fa l'istruzione</em> <code>throw</code><em>?</em> Quando viene eseguita prende il suo parametro (che pu√≤ essere un dato qualunque), se lo segna e forza il ritorno dalla funzione stessa. Quindi per certi aspetti assomiglia a un <code>return</code>: smetto in questo momento di eseguire questa funzione.</p>
<p>Con una differenza per√≤ importante: il <code>return</code> pu√≤ solo prendere come parametro un dato che abbia come tipo il tipo di ritorno della funzione stessa: se ho dichiarato che questa funzione mi ritornava dei numeri, <code>return</code> pu√≤ solo prendere un numero. Invece con <code>throw</code>, nel contesto di una funzione che ritorna numeri posso fare <code>throw "ciao"</code>.
Quindi si slega completamente il tipo ritornato che √® noto come firma (quindi il chiamante sa cosa aspettarsi se va tutto bene nel chiamare quella funzione) dal tipo usato per descrivere qualche errore.</p>
<p>Questa √® la <strong>prima grande differenza</strong>: il chiamante non sa nel caso in cui si verifica un errore come quell'errore sar√† descritto. Non lo pu√≤ sapere, <strong>la firma della funzione non lo codifica</strong>.</p>
<p><strong>Secondo differenza importantissima</strong>, <code>return</code> mi fa tornare alla riga dove c'era la call. Anzi, alla riga successiva. <code>throw</code> mi fa passare da quella riga l√¨, quindi atterro nella funzione che mi ha chiamato e mi guardo intorno dicendo <em>‚Äúquesto punto in cui √® avvenuta la chiamata era chiuso in un blocco di tipo</em> <strong><code>try</code></strong><em>?‚Äù</em>, se s√¨ salto tutte le istruzioni che vengono dopo di me fino a raggiungere la fine del blocco <code>try</code> e guardo le sezioni che seguono <code>try</code>, che si chiamano <strong><code>catch</code></strong> e guardo se per caso il tipo dell'errore che √® stato lanciato corrisponde a qualcuno dei <code>catch</code> che sono indicati.</p>
<p>Se √® cos√¨, eseguo il codice contenuto nel <code>catch</code>, dopodich√© dico <em>‚Äúa posto, allarme cessato‚Äù</em>. Notate che ho <strong>saltato completamente tutte le righe che venivano dal punto in cui ho fatto la chiamata del posto in cui si √® rotto</strong>, quindi le cose che dovevo ancora fare <strong>non</strong> le faccio, atterro sul <code>catch</code>, e se il <code>catch</code> corrisponde faccio quello che c'√® scritto dentro il <code>catch</code>, che deve prendersi la briga di rimettere a posto. Tutto quello che potrebbe essersi rotto nella funzione che ha segnato l'errore e anche tutto quello che non ho fatto, perch√© non c'√® verso di rifarlo. E poi proseguo da l√¨ in avanti, quello che viene dopo viene dopo. Quindi, mettendo non poca complessit√† nella gestione.</p>
<p>Per√≤ potrebbe anche darsi che quando io faccio <code>throw</code> in una funzione, torno al mio chiamante, ma il mio chiamante non abbia racchiuso l'invocazione dentro un blocco try-catch, e quindi non posso fermarmi l√¨, quindi torno al chiamante del chiamante e di nuovo mi guardo intorno. Sono caduto dentro un try-catch? No, allora torno al chiamante del chiamante del chiamante, e cos√¨ via. Pu√≤ darsi che in questa storia, io torno indietro, e indietro, e indietro fino all'inizio del thread. <strong>Se torno fino all'inizio del thread, in C++ il programma si arresta.</strong></p>
<p>Tipicamente un blocco try-catch ha una struttura come quella in slide:</p>
<ul>
<li><code>try</code> che racchiude un certo numero di istruzioni che possono fallire loro direttamente o che possono chiamare qualcuno che fallisce a cascata</li>
<li>uno o pi√π blocchi <code>catch</code> che introducono il tipo possibile di eccezione e racchiudono le cose da fare se quel tipo di eccezione si verifica</li>
</ul>
<p>Questo mi d√† dei <strong>vantaggi</strong>, sicuramente rispetto al niente del C. Mi d√† un <strong>modo pulito</strong> di interrompere l'esecuzione, non solo della funzione corrente, ma anche della sua chiamante, della chiamante della chiamante e cos√¨ via, perch√© devo atterrare in un blocco catch, quindi evito di andare avanti a fare cose strane.</p>
<p>Mi d√† anche un modo di poter veicolare dei <strong>dettagli maggiori</strong>, proprio perch√© l'eccezione pu√≤ essere una cosa qualunque, quindi certamente posso usare un numero, posso usare una stringa, ma posso anche usare una classe, una struttura con tanti campi, dentro cui mi segno tutti i dettagli che mi possono interessare. Mi sono rotto scrivendo un file e ci posso descrivere dentro che file stavo scrivendo, fin dove l'ho scritto, che tipo di rottura si √® verificata, eccetera eccetera.</p>
<p>Questo permette al blocco <code>catch</code> di avere una migliore comprensione dell'errore. Inoltre, evita la frustrazione di dover consultare interminabili tabelle di codici (come capire che 0xfffffDC significa "File not found"). √à molto pi√π pratico! In questo modo la gestione degli errori diventa pi√π semplice.</p>
<p><strong>Per√≤ ha delle turbe</strong>. Prima di tutto, la funzione che chiama qualcun altro non ha la possibilit√† di sapere se questo qualcun altro pu√≤ solo andar bene oppure pu√≤ rompersi. Non c'√® nella firma di una funzione l'indicazione di una possibile rottura. Per questo motivo, a un certo punto, nel C++ hanno aggiunto un modificatore. Al termine del nome di una funzione, dove la definisco, posso aggiungere la parola chiave <code>noexception</code>.</p>
<p><code>noexception</code> vuol dire <em>"io mi impegno a non lanciare eccezioni e a chiamare solo altre funzioni che a loro volta sono</em> <code>noexception</code><em>".</em> In questo modo so almeno che l√¨ un'eccezione non nasce. Ma tutte quelle che non hanno la clausola <code>noexception</code> potrebbero lanciare eccezioni. Quali? Non lo sappiamo.</p>
<p>I signori di Java, 1993-94, ci riflettono un po' su e dicono <em>"troppo casino, il fatto che uno possa lanciare cose a caso non va bene"</em>. Java, gerarchia di classi ben definita, tutto nasce da <code>Object</code>, facciamo una classe comoda per descrivere le eccezioni. E sotto <code>Object</code> mettono <code>Throwable</code>. Dopodich√© dicono <em>"le eccezioni sono di due famiglie"</em>. Sotto <code>Throwable</code> mettono due ulteriori sottoclasse <code>Error</code> e <code>Exception</code>.</p>
<p><code>Error</code> serve in tutte quelle situazioni in cui <strong>non c'√® altro da fare che morire</strong>. StackOverflow, OutOfHeap, tutti quei problemi legati alla macchina virtuale interna che ha raggiunto uno stato instabile etc... Quelle cose l√¨ non posso fare altro che fermarmi. Quindi se mai viene lanciato un <code>Error</code>, non c'√® niente da fare. Si muore e basta.</p>
<p><code>Exception</code> lo uso invece per descrivere tutte quelle cose in cui posso pensare di farci qualcosa.
E mettono in un <strong>vincolo:</strong> se una funzione pu√≤ lanciare un'eccezione, <strong>deve dichiararla</strong>. Per cui ad esempio le operazioni sul file system di Java, nella classe <code>j[ava.io](http://java.io/)</code>, sono tutte operazioni che nella loro firma contengono <code>throws IOEexception</code>.</p>
<p>Con una fregatura in pi√π: non solo quelle funzioni sono obbligate a dire che lanciano un'eccezione, ma chi le chiama √® obbligato o a dire che anche lui pu√≤ lanciare quell'eccezione, oppure deve costruire un blocco try-catch. Posso solo chiamarti dentro un try-catch. E bisogna che il <code>catch</code> contenga l'eccezione che prendi, altrimenti non va bene.</p>
<p><strong>Questa cosa qua</strong> che sembrava pulire meglio concettualmente la cosa per cui il programmatore diventava conscio che stava chiamando un pezzo che poteva rompersi e quindi doveva gestire le eventuali rotture, o segnalare che lui stesso di conseguenza si sarebbe potuto rompere, ha portato per√≤ alla scrittura di codice immantenibile. Perch√© √® diventato un <em>coacervo di try-catch, catch</em>, di vario tipo. <strong>Ingestibilissimo</strong>.</p>
<p>In realt√† i signori di Java avevano detto <em>"</em><code>Exception</code><em>, se lanci exception o una sua sottoclasse, devi dichiararlo. E chi ti chiama deve farlo in un blocco try-catch‚Äù.</em></p>
<p>Ma c'√® una sottoclasse di <code>Exception</code>, che si chiama <code>RuntimeException</code>, che √® esentata. Perch√© √® esentata? Perch√© se no il codice diventerebbe ingestibile. Poich√© in Java <strong>tutti i puntatori possono essere nulli</strong>, <code>NullPointerException</code> ti pu√≤ saltare fuori dovunque. Ma se tutte le volte che tu scrivi qualcosa, punto, qualcos'altro, dovessi farlo in un blocco tra i catch, il tuo codice diventa inscrivibile. E quindi la <code>NullPointerException</code> √® in realt√† una sottoclasse di <code>RuntimeException</code>.</p>
<p><strong>Quello che doveva diventare un'eccezione alla regola generale, per√≤ √® diventata la regola</strong>. Perch√© i programmatori ne avevano le scatole piene di mettersi l√¨ a scrivere blocchi try-catch, e compagnia bella. E quindi hanno cominciato a modellare esclusivamente le loro eccezioni come <code>RuntimeException</code>. Il risultato √® che si √® perso tutto il valore della cosa. Altri linguaggi hanno fatto scelte diverse, ma non troppo dissimili.</p>
<p>Java aveva un'altra differenza importante rispetto al C++. Il blocco <code>try-catch</code> poteva terminare con <code>finally</code>. In C++ <code>finally</code> non esiste. A cosa serve <code>finally</code>? Serve a dire, ‚Äú<em>comunque sia andata sta roba, bene o male, al termine esegui quello che c'√® scritto dentro</em> <code>finally</code><em>‚Äù</em>.</p>
<p>Questo √® utile per implementare i concetti simili alle transazioni di database. Cio√® io voglio avere un punto di controllo da cui comunque passo. Questo per√≤ di fatto ha voluto dire che la maggior parte del codice, ad esempio, che trattava la IO in Java, √® diventato un codice del tipo <code>try-catch</code>, che chiama un <code>try-finally</code>, che chiama effettivamente la cosa. <strong>Confusionario</strong>.</p>
<p><img src="images/gestione_degli_errori/image%204.png" alt="image.png" /></p>
<p>C++ non ha il <code>finally</code>. Ha solo i <code>catch</code>.</p>
<p>Vediamo cosa succede. Abbiamo un esempio della funzione <code>f1</code> che chiama la funzione <code>f2</code>, la quale potrebbe fallire. Quando <code>f1</code> viene invocata, C++ ha dovuto implementare un meccanismo speciale per gestire il ritorno. Ha stabilito che <em>"nello stack non metter√≤ solo le variabili locali e l'indirizzo di ritorno, ma anche un dato aggiuntivo: l'ultimo blocco try attraverso cui sono passato"</em>. Nella <strong>ABI</strong> (Binary Interface) √® stato specificato che <em>"il processore deve dedicare un registro specifico per ricordare dove si trova questo punto di passaggio"</em>. Questo viene chiamato <strong>Exception Context</strong>.</p>
<p>Nel caso degli x86 c'√® uno dei registri estesi che √® <strong>dedicato a tenere questa exception</strong>.</p>
<p><img src="images/gestione_degli_errori/image%205.png" alt="image.png" /></p>
<p>Quando entro in un ulteriore blocco try, nello stack viene inserito un nuovo Exception Context che viene fatto puntare all'Exception Context precedente. Dopodich√© il registro dedicato viene aggiornato. In questo modo sono sicuro che nel registro dedicato ho sempre il pi√π recente Exception Context, mantenendo anche il resto.</p>
<p>Una volta entrato nel blocco try, <em>cosa contiene l'Exception Context?</em> <strong>Mi segno dove comincia la parte dei catch che mi riguardano</strong>. Cos√¨ posso trovarla facilmente, evitando confusione sulla posizione del catch.</p>
<p><img src="images/gestione_degli_errori/image%206.png" alt="image.png" /></p>
<p>A questo punto chiamo la funzione <code>f2</code>. La chiamata avviene normalmente: salvo nello stack l'indirizzo di ritorno per quando tutto andr√† bene.</p>
<p><img src="images/gestione_degli_errori/image%207.png" alt="image.png" /></p>
<p><code>f2</code> esegue le sue operazioni, in questo caso crea <code>i</code>, che va anche lui nello stack.</p>
<p><img src="images/gestione_degli_errori/image%208.png" alt="image.png" /></p>
<p>Dopo aver eseguito tutte le operazioni necessarie, <code>f2</code> valuta se il risultato √® corretto. Supponiamo che qualcosa non vada bene ‚Äî ho rilevato un problema che comprometter√† l'esecuzione. <strong>Come segnalo questo errore?</strong> Uso <code>throw</code> e lancio un'eccezione.</p>
<p>In questo esempio si usa una delle classi predefinite del C++. Queste sono solo consigliate, non obbligatorie (a differenza di Java dove si possono lanciare solo <code>Throwable</code>). In C++ si pu√≤ lanciare qualsiasi cosa, ma √® consigliato usare classi derivate da <code>std::exception</code>. <code>std::logic_error</code>, che deriva da <code>std::exception</code>, serve a descrivere possibili problemi logici del programma. Accetta una stringa come parametro per includere dettagli sull'errore.</p>
<p><em>Cosa succede quando lanciamo</em> <code>logic_error</code><em>?</em> <strong>Le istruzioni seguenti di <code>f2</code> vengono ignorate</strong>. Non torno semplicemente al chiamante ‚Äî faccio di pi√π: comincio a svuotare lo stack. Invoco tutti i distruttori degli oggetti che incontro finch√© lo stack non raggiunge l'Exception Context pi√π recente (la cui posizione √® salvata nel registro dedicato). Quindi, finch√© lo stack pointer √® diverso dal registro dell'Exception Context, continuo a rimuovere e distruggere elementi: la variabile <code>i</code> viene rimossa, l'indirizzo di ritorno viene rimosso, fino ad arrivare all'Exception Context.</p>
<p><img src="images/gestione_degli_errori/image%209.png" alt="image.png" /></p>
<p><strong>Una volta raggiunto l'exception context</strong>, il programma salta al primo blocco <code>catch</code> per verificarne la compatibilit√†. Il blocco <code>catch</code> controlla se il tipo dell'eccezione lanciata (salvato in un registro del processore) coincide con il tipo specificato. Se c'√® corrispondenza, viene eseguito il blocco <code>catch</code>.</p>
<p>Quando si entra nel blocco <code>catch</code>, il codice al suo interno dovrebbe teoricamente sistemare gli errori riscontrati. <em>Se questo non avviene, i problemi persistono</em>, anche se per il programma tutto appare normale. √à come ignorare un allarme antincendio dicendo <em>"ma si, √® solo un test"</em> ‚Äî se poi l'edificio brucia, le conseguenze sono nostre per non aver prestato attenzione.</p>
<p>Nel blocco catch abbiamo la <strong>responsabilit√† di risolvere il problema</strong>. Se siamo capaci di "spegnere l'incendio", allora possiamo procedere ‚Äî ma dobbiamo essere certi che sia davvero risolto, altrimenti il problema potrebbe ripresentarsi.</p>
<p><img src="images/gestione_degli_errori/image%2010.png" alt="image.png" /></p>
<p>Se tutto va bene, l'Exception Context viene consumato dopo aver gestito l'errore. Il programma prosegue normalmente fino alla fine della funzione <code>f1</code>, che termina senza segnalare problemi.</p>
<p>Se invece l'eccezione non corrisponde a nessuno dei blocchi catch disponibili, il programma li esamina tutti, verifica che non ci sono corrispondenze, e utilizza il riferimento all'exception context precedente per continuare lo svuotamento dello stack (<em>"svuota e distruggi"</em>) fino a raggiungere il context precedente, ripetendo poi il processo.</p>
<p>Questo meccanismo funziona perch√© <strong>ogni thread viene creato con un exception context iniziale</strong>. Sia il thread principale (con la sua particolare genesi) che i thread secondari nascono con un blocco try-catch, garantendo che tutto il codice che scriviamo abbia sempre un try a monte.</p>
<p>Il blocco catch alla ‚Äúbase‚Äù, che troviamo alla radice dello stack ha un comportamento speciale: per il thread principale esegue una <code>exit</code>, mentre per i thread secondari esegue una <code>terminate</code>. La differenza sta nel codice di <strong>errore restituito</strong>, ma in entrambi i casi il processo termina.</p>
<p><img src="images/gestione_degli_errori/image%2011.png" alt="image.png" /></p>
<p>Lo svuotamento automatico dello stack dopo un <code>throw</code> (il meccanismo di "svuota e distruggi") √® alla base del pattern <strong>"RAII" (Resource Acquisition Is Initialization)</strong>, che permette di utilizzare i distruttori degli oggetti come meccanismo per sistemare le risorse.</p>
<p>L'abbiamo gi√† incontrato quando abbiamo parlato di <code>Box</code> e di <code>Vec</code>: il distruttore di <code>Vec</code> rilascia l'array che lui ha allocato sullo heap. Questo vuol dire che, se il <code>Vec</code> viene distrutto normalmente perch√© la funzione che l'ha dichiarato finisce, lui rilascia la memoria. Ma anche se dovesse finire abnormalmente, a seguito di un arresto anomalo, <strong>il fatto che lo stack venga svuotato con questo meccanismo fa s√¨ che verr√† invocato il distruttore del <code>Vec</code> e la memoria sar√† effettivamente rilasciata</strong>. Non c'√® leakage.</p>
<p>Questo meccanismo lo possiamo usare a nostro beneficio anche in altre situazioni. Ad esempio, possiamo creare un oggetto che ha solo un costruttore e un distruttore. Nel caso di <strong>Rust</strong>, avr√† il metodo <code>new</code> e poi implementa il tratto <code>Drop</code>, dandoci quindi il metodo <code>drop</code>. Questi due metodi saranno congegnati in modo tale da garantirci un comportamento duale: <em>se tutto va bene o se tutto va male, in ogni caso, sono sicuro che le azioni del distruttore vengano eseguite</em>. Questo supplisce il problema del non avere il <code>finally</code>.</p>
<h2 id="22-i-limiti-della-gestione-delle-eccezioni-in-c"><a class="header" href="#22-i-limiti-della-gestione-delle-eccezioni-in-c">2.2 I limiti della gestione delle eccezioni in C++</a></h2>
<p><img src="images/gestione_degli_errori/image%2012.png" alt="image.png" /></p>
<p>Il problema legato al C++, ma in generale a tutti i linguaggi che hanno le eccezioni, √® che <strong>il compilatore non √® in grado di identificare <em>dove</em> vengano restituite eccezioni</strong>. In C++ specifico, ho solo il <code>nothrow</code>, che mi dice <em>"sono certo che questo non lancia"</em>. Tutte le altre possono lanciare, e siccome tutte possono lanciare, non c'√® obbligo di chiamare dentro <code>try-catch</code>. In Java sarebbe un po' meglio, ma per via del meccanismo delle <code>RuntimeException</code>, tutti le usano e quindi il compilatore di nuovo non forza i controlli.</p>
<p>In secondo luogo, l'eccezione che lancio √® una sola. A volte per√≤ mi trovo nella situazione di lanciare un'eccezione in conseguenza di un'altra eccezione. In Java questo viene risolto perch√© la classe <code>Exception</code> ha dentro di s√© un puntatore (che pu√≤ essere nullo) ad un'altra eccezione chiamata <code>cause</code> (causa). Questo permette di risalire alla causa dell'eccezione.</p>
<p>Per esempio, l'eccezione <em>"non ho creato il file, perch√®? Perch√© il disco √® pieno"</em> non richiede necessariamente di notificare che il disco √® pieno - al programma √® utile sapere che il file non √® stato creato, e <strong>separatamente</strong> il motivo. Questo √® diverso dal caso <em>"non l'ho creato perch√© non ho i diritti di scrittura"</em>. L'effetto √® lo stesso (il file non c'√®), ma la causa √® distinta. <strong>Sapere la causa mi permette di correggere l'errore</strong>.</p>
<p>Se io non riesco a distinguere il caso per cui non l'ho creato perch√© il disco era pieno, dove l'eventuale cura √® <em>"faccio spazio su disco"</em>, rispetto al <em>"non ho i diritti"</em> dove la cura √® <em>"devo fare privilege escalation e acquisirli"</em>, non potr√≤ mai aggiustarlo questo tipo di errore.</p>
<p><strong>Se un errore pu√≤ essere generato in tanti posti diversi, ma viene gestito solo centralmente, in alto</strong>, chi gestisce l'errore potrebbe avere difficolt√† a scegliere la contromisura appropriata senza tutti i dettagli necessari. Inoltre, quando l'errore viene catturato in alto, viene saltata l'esecuzione di molto codice sottostante. Se l'errore si verifica in un punto, non vengono eseguite certe operazioni; se si verifica in un altro punto, ne vengono saltate altre. Anche se riesco a gestire l'errore, non ho modo di sapere quali operazioni specifiche sono state saltate nei diversi scenari possibili.</p>
<p><strong>Ultimo, ma non ultimo</strong>, il fatto che per poter gestire questa cosa, C++ (come anche Java e altri), √® obbligato a sporcarmi lo stack, cio√® a dire che nello stack ci stanno anche gli exception context. Questo √® un problema, ed √® il motivo per cui <strong>non si pu√≤ usare C++ nel kernel di Linux</strong>. Perch√© altrimenti il kernel di Linux, che non √® costruito sull'assunzione che i thread hanno comunque uno stack che comincia con un exception context, non possono convivere agilmente con questa cosa qui, perch√© nel kernel i thread si scambiano gli stack con una certa facilit√†, avvengono delle cose poco belle a vedersi, ma estremamente efficaci dal punto di vista pratico. Ma la presenza di questo exception context rompe le scatole. E quindi nello kernel di Linux non si mette il C++.</p>
<h1 id="3-gestione-delle-eccezioni-in-rust"><a class="header" href="#3-gestione-delle-eccezioni-in-rust">3. Gestione delle eccezioni in Rust</a></h1>
<p><img src="images/gestione_degli_errori/image%2013.png" alt="image.png" /></p>
<p><strong>Come si fanno le cose in Rust?</strong>
Rust ci mette a disposizione un costrutto specifico e ci dice <em>‚Äúse devi gestire qualcosa che pu√≤ fallire, non inventare niente, usa</em> <code>Result</code><em>"</em>.</p>
<p><code>Result</code> √® un tipo sufficientemente versatile che va bene per tutte le situazioni di cui abbiamo bisogno. <code>Result</code> accetta il tipo che descrive cosa ritorniamo se va bene e accetta il tipo che descrive cosa ritorniamo se va male. Diremo semplicemente che la nostra funzione, se pu√≤ fallire, ritorna un <code>Result</code>.</p>
<p>Nell‚Äôesempio in slide abbiamo <code>read_file</code> che riceve una stringa col nome del file da leggere e deve ritornarci delle cose.
<em>Come √® fatta?</em> Comincia a fare <code>File::open</code>, di cui non abbiamo ancora visto i dettagli, ma comunque <code>File::open</code> ritorna un <code>Result</code>.</p>
<p>Pu√≤ darsi che quel nome l√¨ esista e quindi apre il file. E quindi nella parte, diciamo, positiva, io avr√≤ un <code>Ok</code> con la handle di quel file l√¨.
Oppure pu√≤ darsi che quel file non esista e allora avr√≤ un <code>Error</code> che mi dir√† <em>"File not found"</em> o qualcosa di simile. Oppure pu√≤ darsi che il file esista ma io non abbia i diritti per leggerlo e allora mi dir√† <em>"Permission denied".</em></p>
<p>A questo punto, dopo aver chiamato la funzione per aprire il file, devo leggerlo. Usando <code>match r1 { ... }</code>, verifico il risultato.
Se √® un <code>Error</code>, all'interno troviamo il motivo <code>why</code>, quindi processo questo caso e restituisco semplicemente un messaggio che indica che non sono riuscito a leggere il file, spiegando il motivo dell'interruzione. Se invece l'operazione va a buon fine, nell' <code>Ok</code> trovo la handle del file, che mi segno.</p>
<p>A questo punto creo una <code>String</code> e provo a leggere il contenuto del file mettendolo dentro questa stringa usando <code>file.read_to_string(&amp;mut s)</code>.
Di nuovo, questa operazione pu√≤ andare a buon fine oppure no. Usando <code>match r2 { ... }</code>, se non sono riuscito, ritorno il motivo. Se sono riuscito, ritorno <code>Ok</code> e passo la stringa stessa che contiene quello che volevo. Questa √® l'idea base. Si potrebbe dire che questo approccio √® verboso, ma i signori di Rust, per fortuna, ci danno una serie di cose. Adesso, tra un attimo, le vediamo.</p>
<h2 id="31-elaborare-i-risultati"><a class="header" href="#31-elaborare-i-risultati">3.1 Elaborare i risultati</a></h2>
<p><img src="images/gestione_degli_errori/image%2014.png" alt="image.png" /></p>
<p>Prima diciamo due cose. Questo <code>Result</code> che noi torniamo √® un oggetto ricco di metodi che rende facile la vita per chi ne ha uno tra le mani a fare dei ragionamenti. Certamente noi possiamo guardare cosa c'√® in un <code>Result</code> usando <code>match</code> e andando a chiedere se match ha <code>Ok</code> di qualcosa o <code>Err</code> di qualcos'altro.</p>
<h3 id="311-is_ok-e-is_err"><a class="header" href="#311-is_ok-e-is_err">3.1.1 <code>.is_ok()</code> e <code>is_err()</code></a></h3>
<p>Ma possiamo anche andare sull'oggetto <code>r</code>, di tipo <code>Result</code>, e chiedere <code>if r.is_ok()</code> e in questo caso avr√† successo se lui contiene il dato buono oppure <code>if r.is_err()</code> in questo caso ritorner√† <code>true</code> se invece racchiude un errore, senza dirci quale errore, ma semplicemente ci permette di capirlo in fretta.</p>
<h3 id="312-ok"><a class="header" href="#312-ok">3.1.2 <code>.ok()</code></a></h3>
<p><code>r.ok()</code> <em>sbriciola</em> il <code>Result</code> ‚Äî vedete: prende <code>self</code>, quindi consuma l'oggetto.
<code>r.ok()</code> mi ritorna un <code>Option</code>  ‚Äî se il risultato non √® <code>Ok</code> mi ritorna <code>None</code>, se invece va bene mi ritorna un <code>Some&lt;T&gt;</code>.</p>
<h3 id="313-map"><a class="header" href="#313-map">3.1.3 <code>.map()</code></a></h3>
<p><code>map()</code> √® utile, viceversa, per quelle situazioni in cui io voglio dire <em>‚Äúse c'era un dato buono, trasformamelo in quest'altra maniera‚Äù</em>. Quindi se ad esempio mi aspettavo una stringa, posso fare <code>r.map(|s| s.to_uppercase())</code>. Se la lettura del file √® andata a buon fine, la funzione specificata dentro map viene applicata. Se invece c'√® un errore non fa niente, perch√© non c'√® bisogno di mappare. Questo mi permette di descrivere cosa voglio fare senza doverlo fare subito.</p>
<h3 id="314-contains"><a class="header" href="#314-contains">3.1.4 <code>.contains()</code></a></h3>
<p><code>.contains()</code> mi permette di controllare se per caso all'interno c'√® qualcosa che matcha il parametro che gli sto passando.</p>
<h3 id="315-unwrap"><a class="header" href="#315-unwrap">3.1.5 <code>.unwrap()</code></a></h3>
<p>Infine <code>unwrap()</code> mi permette di dire <em>‚Äúio assumo che questo risultato sia buono‚Äù</em>.
Se non √® buono panica, che vuol dire mi arresto e la pianto l√¨. Se invece √® buono allora prendo il contenuto, il <code>Result</code> viene sbriciolato e mi prendo direttamente il suo contenuto.</p>
<h2 id="32-la-macro-panic"><a class="header" href="#32-la-macro-panic">3.2 La macro <code>panic!()</code></a></h2>
<p><img src="images/gestione_degli_errori/image%2015.png" alt="image.png" /></p>
<p><strong>Perch√© viene chiamato "panic"?</strong> Perch√© smettere brutalmente un programma √® pi√π complicato di quel che sembra. Nel momento in cui io scopro che un'operazione che ho fatto √® andata male e il <em>tipo di male</em> che si √® verificato √® di quelli <em>"unrecoverable",</em> allora devo smettere. Ma smettere potrei farlo con <code>exit()</code> (<code>std::process::exit</code>). Il problema √® che smetterei di botto lasciando tutte le cose a caso. In alcuni casi non √® detto che questo approccio vada bene. Quindi sarebbe meglio cercare di terminare <strong>disfacendo quello che si pu√≤ ancora disfare</strong>, quindi <strong>eseguendo i distruttori</strong>.</p>
<p>Se io invoco <code>process::exit()</code> smetto su due punti. √à come quando viene il coccolone, non avete possibilit√† di fare altro. Bang!</p>
<p><code>panic!()</code> viceversa forza il ritorno al chiamante, al chiamante, al chiamante, e cos√¨ via fino ad esaurire lo stack. Facendo questo, se ci sono dei distruttori pendenti che avevano segnato delle azioni per disfare qualcosa, questi verranno eseguiti.</p>
<blockquote>
<p>üí° <strong>Distruttori e ritorno al chiamante</strong></p>
<p>Ricorda che i distruttori vengono invocati quando la corrispondente variabile associata arriva alla fine del suo scope. Quindi, forzando il ritorno al chiamante (e quindi forzando ad uscire dallo scope corrente), i distruttori vengono chiamati.
E continuando a forzare il ritorno al chiamante fino ad esaurire lo stack possiamo invocare i distruttori di tutto ci√≤ che avevamo allocato.</p>
</blockquote>
<p>In pi√π, se il thread che ha invocato <code>panic!()</code> √® il thread principale, il processo cessa, indipendentemente da quanti altri thread secondari ci siano. Se il thread che ha invocato <code>panic!()</code> √® un thread secondario, di quelli che avete creato voi, solo lui termina. Gli altri continuano a fare quello che dovevano.</p>
<p>Per questo motivo, la scelta generale di tutte le API √® usare <code>panic!()</code> e non fare <code>exit</code>.</p>
<p><img src="images/gestione_degli_errori/image%2016.png" alt="image.png" /></p>
<p><strong>Panic √® una macro</strong> che accetta degli argomenti simili a <code>println!()</code> e quindi voi potete mettere, con la stessa sintassi di <code>println!</code> ad esempio <code>panic!("Panic, error: {}", err)</code>, quindi potete creare dei messaggi d'errore.</p>
<p><em>Perch√© potete passargli un messaggio d'errore?</em> Perch√© quel thread l√¨ si svuoter√† e quando lo stack sar√† vuoto stamper√† quel messaggino che gli avete messo. Che √® utile perch√© in questo modo potete comunicare in modo pi√π strutturato all'utente o potenzialmente a un altro programma (se siete connessi tramite pipe o qualcosa del genere) cosa √® andato male.</p>
<h2 id="33-ignorare-gli-errori"><a class="header" href="#33-ignorare-gli-errori">3.3 Ignorare gli errori</a></h2>
<p><img src="images/gestione_degli_errori/image%2017.png" alt="image.png" /></p>
<p>A volte noi vogliamo scrivere un programma veloce dove sappiamo che anche se la funzione nominalmente potrebbe fallire non ci importa troppo che fallisca, cio√® diamo per buono che non fallir√†. <strong>Attenzione, questo va fatto con molta attenzione</strong>.</p>
<p>Per questo motivo il tipo <code>Result</code> offre <code>unwrap</code>. Il metodo <code>unwrap</code> forza a dire <em>"ma io sono praticamente certo che √® andato bene quindi prendi‚Äù</em>, se non c'era un <code>Ok</code> dentro quel <code>Result</code> panica. <strong>Il problema √® che panica dandoci un messaggio anonimo.</strong></p>
<p>Per questo motivo <code>Result</code> ci offre anche <code>expect</code> che √® come <code>unwrap</code> ma accetta un parametro simile a quello che possiamo dare a <code>panic!</code>, che √® una descrizione, dice <em>"prendilo, ma se non riesci a prenderlo stampa questa cosa",</em> almeno se l‚Äôoperazione √® andata storta capiamo qualcosa.</p>
<p>Quindi, sostanzialmente <code>expect</code> ci permette di <em>customizzare</em> la stringa di errore che viene stampata nel caso in cui non ci sia ci√≤ che vogliamo.</p>
<h2 id="34-propagare-gli-errori"><a class="header" href="#34-propagare-gli-errori">3.4 Propagare gli errori</a></h2>
<p><img src="images/gestione_degli_errori/image%2018.png" alt="image.png" /></p>
<p>Nell'esempio che abbiamo visto prima il codice di <code>read_file</code> non √® proprio bello.</p>
<p><img src="images/gestione_degli_errori/image%2019.png" alt="image.png" /></p>
<p>Perch√© di fatto noi qui dobbiamo fare due operazioni: <code>open</code> e <code>read_to_string</code>, ma le abbiamo dovuto mettere dentro due match. √à un po' una seccatura.</p>
<p>I creatori di Rust ci dicono <em>"s√¨, hai ragione. Ti diamo una soluzione pi√π elegante".</em>
Se hai una funzione che ritorna un <code>Result</code> (quindi la funzione deve avere come tipo di ritorno <code>Result</code> o eventualmente un <code>Option</code>) e vuoi evitare di scrivere quel codice verboso di prima, puoi fare cos√¨: aggiungi semplicemente un punto interrogativo dopo le singole righe che possono fallire.</p>
<p><strong>Cosa vuol dire quel punto interrogativo messo al fondo?</strong>
Per esempio, con <code>File::open(name)?</code>, viene chiamata la <code>open</code> e internamente viene verificato il risultato: se <code>open</code> ha restituito <code>Ok</code>, viene estratto e restituito il contenuto; se invece ha dato un errore, quell'errore viene propagato.
La notazione con il punto interrogativo dopo uno statement significa quindi "se il risultato √® di tipo <code>Error</code>, propaga quell'<code>Error</code>".</p>
<blockquote>
<p>üí° <strong>Riassunto</strong></p>
<p><img src="images/gestione_degli_errori/image%2020.png" alt="image.png" /></p>
<p><img src="images/gestione_degli_errori/image%2021.png" alt="image.png" /></p>
</blockquote>
<p><strong>Il vincolo</strong> per√≤ perch√© questa cosa funzioni √® che la funzione che contiene i punti interrogativi ritorni un <code>Result</code>, perch√© se non ritorna un <code>Result</code> non va bene: quel punto interrogativo l√¨ non sa che cosa ritornare.
Non solo, ma deve ritornare un <code>Result</code> che abbia come <code>Error</code> lo stesso <code>Error</code> che si √® verificato: se io ho chiamato <code>File::open</code>, che mi ritorna un errore di tipo <code>io::Error</code>, non posso dire che la mia funzione ritorna un <code>Result</code> che nel caso di errore ci mette una <code>String</code>, perch√© non va bene ‚Äî non matchano i tipi.</p>
<p>Quindi nel caso specifico dell‚Äôesempio, in effetti la funzione <code>read_file</code> annuncia che se va bene mi d√† una <code>String</code>, e se va male mi da un <code>io::Error</code>.</p>
<blockquote>
<p>üí° <strong>Ok(s)</strong></p>
<p><img src="images/gestione_degli_errori/image%2022.png" alt="image.png" /></p>
<p><img src="images/gestione_degli_errori/image%2023.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/gestione_degli_errori/image%2024.png" alt="image.png" /></p>
<p>In alcuni casi potrei anche dire se non mi interessa il dettaglio del perch√© √® non √® andata bene, e mi basta dire che non √® andata bene, potrei dire che ritorna <code>Option</code> e il punto interrogativo fa la conversione automatica e riesce a gestirsela.</p>
<h2 id="35-propagare-errori-eterogenei"><a class="header" href="#35-propagare-errori-eterogenei">3.5 Propagare errori eterogenei</a></h2>
<h3 id="351-boxdyn-errorerror"><a class="header" href="#351-boxdyn-errorerror">3.5.1 <code>Box&lt;dyn error::Error&gt;</code></a></h3>
<p><img src="images/gestione_degli_errori/image%2025.png" alt="image.png" /></p>
<p>A volte per√≤ mi trovo nella situazione di dover ritornare errori diversi tra di loro, ad esempio quel file l√¨ che legge la stringa potrebbe immaginare che dentro la stringa ci sia un numero, ad esempio √® la chiave di un algoritmo di crittografia.</p>
<p>Pu√≤ darsi che quel file l√¨ contenga veramente il numero, ma pu√≤ anche darsi che non ci sia un numero e quindi nel momento in cui cerco di passarlo come numero venga fuori un errore. Peccato che l'errore √® un <code>parse::Error</code>, non un <code>io::Error</code> ‚Äî √® un'altra cosa!</p>
<p>Quindi la mia funzione si pu√≤ rompere con due tipologie: si pu√≤ rompere dicendo <code>io::Error</code> perch√© il file non esiste e non lo posso leggere, o si pu√≤ rompere con <code>parse::Error</code> perch√© il file pur esistendo non contiene un numero.</p>
<p><em>Ma io non riesco a tornare una cosa che √® contemporaneamente</em> <code>parse::Error</code> <em>e</em> <code>io::Error</code><em>?</em>
Se sia <code>parse::Error</code> che <code>io::Error</code> implementano il tratto <code>Error</code> ‚Äî e in questo caso √® cos√¨ ‚Äî posso dire che la mia funzione esterna ritorna un <code>Box&lt;dyn error::Error&gt;</code>.</p>
<p>Questo fa s√¨ che il valore ritornato, in caso di errore, √® automaticamente trasferito sullo heap e io restituisco il puntatore a questa cosa.
<em>Questo perch√©?</em> Perch√© pu√≤ darsi che <code>io::Error</code> sia grande 30 byte e <code>parse::Error</code> sia grande 12, quindi non posso tornare due cose che sono di dimensioni diverse. Viceversa se io dico che torno un <code>Box</code>, il <code>Box</code> √® sempre solo un puntatore 8 byte, quindi va benissimo!</p>
<p>Un <code>Box</code> ha che cosa? Un <code>Box</code> ha un oggetto tratto <code>dyn</code>, in questo caso, di <code>Error</code> perch√© quell'oggetto l√¨ implementa il tratto <code>Error</code>.</p>
<p><img src="images/gestione_degli_errori/image%2026.png" alt="image.png" /></p>
<p><em>E com'√® fatto il tratto</em> <code>Error</code><em>?</em>
Il tratto <code>Error</code> √® un tratto sostanzialmente che ha alcuni vincoli: deve essere stampabile quindi implementa sia <code>Debug</code> che <code>Display</code> e in pi√π ha una serie di <code>from</code> ‚Äî riesce ad essere convertito da un tipo a un altro.</p>
<p>Quindi qui vediamo un esempio della funzione <code>sum_file</code> dove in alto c'√® scritto che ritorno un <code>Box&lt;dyn error:Error&gt;</code>.</p>
<p>Poi faccio la <code>File::open(path)?</code> con il <strong>punto interrogativo</strong>: quel punto interrogativo automaticamente fa s√¨ che il mio <code>io::Error</code>, se mai si √® verificato, viene boxato.</p>
<p>Poi vado avanti e faccio <code>read_to_string(&amp;mut contents)?</code> di nuovo con <strong>punto interrogativo</strong>: quel punto interrogativo fa s√¨ che l'eventuale altro <code>io::Error</code> diventi un <code>Box&lt;dyn error::Error&gt;</code>.</p>
<p>Poi pi√π avanti ancora faccio <code>parse</code> della mia linea o qualcosa del genere per decodificare il numero che c'era scritto dentro ‚Äî se mi viene un <code>ParseIntError</code> (che l'errore √® che segnala che non era un numero) anche lui viene boxato e quindi la cosa funziona e va tutto bene!</p>
<p><strong>Il chiamante come fa a discernere le cose?</strong>
Lo vediamo nel blocco sotto: prova a chiamare questa cosa qua. Se ha bisogno di mettere in atto una strategia di qualche tipo (anche solo per spiegare all'utente che cosa ha fatto o meno), nel caso <code>Ok</code> fa una stampa, e tutto va bene.</p>
<p>Nel caso si √® verificato un <code>Error</code>, per dare dei messaggi significativi deve distinguere.
E allora usa il meccanismo del <code>downcast_ref</code> e va a chiedersi: <em>"per caso il particolare</em> <code>Error</code> <em>che si √® verificato √® di tipo</em> <code>io::Error</code><em>?".</em>
Se √® cos√¨ allora do un messaggio opportuno, oppure vado a pescare dentro l'<code>io::Error</code> i dettagli del perch√©.</p>
<p>Se invece <code>downcast_ref</code> posso ridurlo a un <code>ParseIntError</code> allora dar√≤ un altro messaggio d'errore, altrimenti <code>unreachable</code>.</p>
<p><strong>Unreachable perch√©?</strong>
L‚Äô <code>else</code> dobbiamo metterlo per coprire tutte le possibilit√† del match, dentro mettiamo <code>unreachable</code> che √® una macro che dice <em>"se arrivi qua rompiti"</em> perch√© vuol dire che non ho aggiornato il mio codice correttamente. Cio√® al momento io vedo che la funzione <code>sum_file</code> pu√≤ solo generarmi quei due tipi di errore ‚Äî se mi esce un terzo tipo c'√® un problema: qualcuno ha toccato e non ha messo a posto dove doveva. Quindi quell'<code>unreachable</code> l√¨ va proprio bene, mi aiuta tantissimo perch√© mi garantisce che nel tempo il mio codice rimarr√† coerente.</p>
<h3 id="352-enum-di-errore-custom"><a class="header" href="#352-enum-di-errore-custom">3.5.2 Enum di errore custom</a></h3>
<p><img src="images/gestione_degli_errori/image%2027.png" alt="image.png" /></p>
<p>In alternativa potrei dire che prendo, creo un <code>enum</code> che racchiude sia <code>io::Error</code> che <code>parse::Error</code> e quindi mi creo un mio tipo che pu√≤ contenere due variazioni se √® verificato l'errore tipo IO o l'errore tipo parse che racchiudono le varie informazioni.</p>
<p>Questo va anche bene, ha solo una fregatura: bisogna che se voglio gestirmi questa cosa bene il mio tipo custom implementi il tratto <code>Error</code>. Ma implementare il tratto <code>Error</code> √® una seccatura.</p>
<p><img src="images/gestione_degli_errori/image%2028.png" alt="image.png" /></p>
<p>Per implementare il tratto <code>Error</code> devo implementare tutti i pezzi che mi mancano: devo implementare <code>From&lt;io::Error&gt;</code>, devo implementare <code>From&lt;ParseIntError&gt;</code>, devo implementare <code>Display</code>, devo implementare <code>error::Error</code> ‚Äî ok vedete che viene una strafilata di cose, faticosissimo!</p>
<p><img src="images/gestione_degli_errori/image%2029.png" alt="image.png" /></p>
<p>E c'√® poi qui vediamo il codice sotto che matcha questo approccio.</p>
<h3 id="353-thiserror-e-anyhow"><a class="header" href="#353-thiserror-e-anyhow">3.5.3 <code>thiserror</code> e <code>anyhow</code></a></h3>
<p><img src="images/gestione_degli_errori/image%2030.png" alt="image.png" /></p>
<p>In realt√† le librerie ci vengono in aiuto: ci sono due librerie fondamentali, una si chiama <strong>thiserror</strong> e l'altra si chiama <strong>anyhow.</strong></p>
<p>Si possono usare in congiunzione o separatamente.</p>
<p><strong>thiserror</strong> serve a implementare in modo semplice il tratto <code>Error</code> ‚Äî prevalentemente viene usato da chi crea librerie. Si fa una <code>enum</code> che contiene <code>error1</code>, <code>error2</code>, <code>error3</code>, <code>error27</code> tutte le cose che possono capitare e poi, incorporando la libreria <strong>thiserror,</strong> si riesce a generare in automatico il tratto <code>Error</code> tramite la macro <code>derive</code>.
Implemento <code>Error</code>, faccio implementare anche <code>Debug</code> dalla <code>derive</code> e poi mi resterebbe <code>Display</code> ma di nuovo il meccanismo <code>#[error]</code> permette di implementare facilmente il <code>Display</code> relativo.</p>
<p><img src="images/gestione_degli_errori/image%2031.png" alt="image.png" /></p>
<p>E qui vedete degli esempi.
<code>#[from]</code> mi genera in automatico il <code>from</code> l√¨ dentro.</p>
<p>Quindi per descrivere cosa pu√≤ succedere nella mia funzione dico: "guarda, nella mia funzione possono succedere due problemi ‚Äî ho un errore di I/O che includo nell'opzione I/O, e ho un errore di parsing che includo nell'opzione di parsing." Faccio derivare automaticamente il tratto <code>Error</code> e il tratto <code>Debug</code>, il tratto <code>Display</code> lo implemento con <code>#[error]</code>, e il tratto <code>from</code> lo implemento mettendo <code>#[from]</code> nei relativi casi. Con poco sforzo documento tutto quello che mi serve!</p>
<p><img src="images/gestione_degli_errori/image%2032.png" alt="image.png" /></p>
<p><strong>Anyhow</strong> per contro permette di gestire in modo pi√π semplice la gestione degli errori come? Andando a dire che una funzione genera semplicemente un <code>anyhow::Result</code>.</p>
<p><img src="images/gestione_degli_errori/image%2033.png" alt="image.png" /></p>
<p><strong>Anyhow</strong> √® capace di convertirsi una serie di cose che mi d√† la possibilit√† di aggiungere dei contesti. Quindi <code>file_open.with_context()</code> cosa succede? Se verr√† mai generato un errore questo errore verr√† sostituito da una stringa che contiene "missing path" e poi il path specifico che non riuscivamo a mettere.</p>
<p>Se per qualche motivo non riesco a leggere la stringa generer√≤ l'errore con <code>file read error</code>, se non riesco a fare il parsing dico <em>"mi hai passato questa schifezza che non √® un numero".</em></p>
<p>Le due librerie possono essere usati insieme o separatamente, in ogni caso semplificano la vita tantissimo.</p>
<h1 id="4-riferimenti-1"><a class="header" href="#4-riferimenti-1">4. Riferimenti</a></h1>
<p><img src="images/gestione_degli_errori/image%2034.png" alt="image.png" /></p>
<h1 id="5-live-coding-24042024"><a class="header" href="#5-live-coding-24042024">5. Live coding 24/04/2024</a></h1>
<p><img src="images/gestione_degli_errori/image%2035.png" alt="image.png" /></p>
<p>Prima di tutto ho creato un progetto nuovo, apro <code>Cargo.toml</code> e mi aggiungo tra le dipendenze <strong>thiserror</strong>.</p>
<p>Qui mi propone la versione 1.0.59, ma per evitare di essere legato a questa particolare sottoversione, la 0.59, <strong>siccome viene usato il semantic versioning</strong> mi limito a dire che a me basta thiserror 1.0, perch√© se dopodomani esce la versione 1.0.60, automaticamente questa verr√† incorporata, sapendo che mediamente chi rilascia nuove librerie, quando tocca soltanto il minor number, fa delle modifiche che sono retrocompatibili, e sono tendenzialmente solo migliorative di quello che esiste.</p>
<p><img src="images/gestione_degli_errori/image%2036.png" alt="image.png" /></p>
<p>Quindi √® conveniente lasciare soltanto 1.0. Avendo aggiunto questa cosa, a questo punto lui dovrebbe avere a disposizione thiserror e quindi lo possiamo dare per disponibile.</p>
<h3 id="creiamo-una-funzione-che-pu√≤-fallire"><a class="header" href="#creiamo-una-funzione-che-pu√≤-fallire">Creiamo una funzione che pu√≤ fallire</a></h3>
<p><img src="images/gestione_degli_errori/image%2037.png" alt="image.png" /></p>
<p>Facciamo un'ipotetica funzione <code>leggi_file</code>, che non legger√† nessun file, ma ci serve per poter dire che ogni tanto fallisce. Questa funzione prender√† in ingresso un <code>filename: &amp;str</code>, e dovr√† ritornarci un <code>Result&lt;String, FileError&gt;</code>, in cui <strong><code>FileError</code></strong> al momento non esiste.</p>
<h3 id="modelliamo-lerrore"><a class="header" href="#modelliamo-lerrore">Modelliamo l'errore</a></h3>
<p>Allora modelliamo <code>FileError</code>.</p>
<p><img src="images/gestione_degli_errori/image%2038.png" alt="image.png" /></p>
<p>Questa cosa qua accetta una stringa costante come descrizione, per farla semplice. Detto cos√¨, √® un possibile errore, ma non c'√® evidenza che sia un errore, s√¨ c'√® scritto ‚ÄúError‚Äù nel nome del tipo, ma non √® molto utile. Affinch√® sia ragionevolmente usabile e comprensibile da altri programmatori, √® bene che questa cosa qua implementi il tratto <code>Error</code>.</p>
<p><img src="images/gestione_degli_errori/image%2039.png" alt="image.png" /></p>
<p>Implementare il tratto <code>Error</code> a mano per√≤ √® faticoso, da questo punto di vista il crate <code>thiserror</code> √® particolarmente conveniente, perch√© ci ha aggiunto magicamente la possibilit√† di derivare <code>Error</code> tramite la macro <code>derive</code>, e noi vogliamo derivare anche <code>Debug</code>.</p>
<p>In pi√π, per essere completo, ci serve che implementi anche il tratto <code>Display</code>.</p>
<p><img src="images/gestione_degli_errori/image%2040.png" alt="image.png" /></p>
<p>Il tratto <code>Display</code> lo andiamo ad aggiungere qua con <code>#[error]</code> ‚Äî il tratto <code>display</code> stampa una stringa, <em>"Problema con il file: {0}"</em>, e qua gli mettiamo 0, <em>perch√©?</em></p>
<p>Perch√© <code>FileError</code> √® una struct di tipo tupla, vedete che i campi non hanno un nome, e quindi hanno al loro posto un indice, il messaggio che descrive il dettaglio di che cosa si √® verificato √® il campo 0 dentro cui c'√® la descrizione di questa cosa.</p>
<p><img src="images/gestione_degli_errori/image%2041.png" alt="image.png" /></p>
<p>A questo punto la nostra funzione <code>leggi_file</code> la possiamo implementare. Ovviamente la implementiamo alla buona, dicendo che:</p>
<ul>
<li>Se <code>filename.len</code> √® minore di 3, ritorniamo un <code>FileError</code> con messaggio "Nome troppo corto"</li>
<li>Altrimenti, ritorniamo una <code>String</code> contenente il contenuto del file</li>
</ul>
<p>Nel nostro <code>main</code> possiamo verificare se la funzione <code>leggi_file</code> funziona:</p>
<p><img src="images/gestione_degli_errori/image%2042.png" alt="image.png" /></p>
<p>Proviamo a eseguirlo e vediamo che:</p>
<ul>
<li>Con il file "abcd": funziona correttamente</li>
<li>Con il file "a": otteniamo l'errore <code>C‚Äô√® stato un problema: Problema col file: Nome troppo corto</code></li>
</ul>
<p>Notiamo che il tratto <code>Display</code> √® stato implementato automaticamente, permettendoci di usare <code>{}</code> per la stampa. Se invece usiamo <code>:?</code>, otteniamo la stampa di debug che mostra <code>C‚Äô√® stato un problema: FileError("Nome troppo corto")</code> .</p>
<p>La nostra struttura implementa quindi tre tratti fondamentali:</p>
<ul>
<li>Il tratto <code>Error</code> (derivato automaticamente)</li>
<li>Il tratto <code>Debug</code> (verificato con la stampa <code>:?</code>)</li>
<li>Il tratto <code>Display</code> (verificato con la stampa <code>{}</code>)</li>
</ul>
<p><img src="images/gestione_degli_errori/image%2043.png" alt="image.png" /></p>
<p>Potremmo complicare la logica aggiungendo un altro caso: se <code>filename.len</code> √® maggiore di 5, ritorniamo un <code>FileError</code> "Nome troppo lungo".</p>
<p>Finch√© i tipi di errori sono riconducibili a questa struttura, il nostro <code>FileError</code> funziona bene per rappresentare l‚Äôerrore.</p>
<p>La struct potrebbe essere resa pi√π complessa aggiungendo, ad esempio:</p>
<ul>
<li>Il nome del file problematico</li>
<li>Un codice d'errore univoco per migliore gestione nel <code>match</code></li>
</ul>
<p>Ma anche cos√¨ risulta molto agevole da gestire.</p>
<p><img src="images/gestione_degli_errori/image%2044.png" alt="image.png" /></p>
<p>Adesso supponiamo di avere bisogno di costruire un'altra funzione che si chiama <code>elabora_contenuto</code>. Questa prende in ingresso una <code>String</code> e anche questa di per s√© pu√≤ fallire, pu√≤ fallire in vari modi e quindi ritorna un <code>Result</code>: se va bene mi d√† un <code>i32</code>, se va male invece mi vuol dare un errore di altro tipo ‚Äî lo chiamerei invece che <code>FileError</code> un errore di <code>ContentError</code>.</p>
<p><code>ContentError</code> al momento non esiste.</p>
<p><img src="images/gestione_degli_errori/image%2045.png" alt="image.png" /></p>
<p>Posso crearmelo allo stesso modo: <code>ContentError</code> mi porta dentro di s√© altri tipi di informazione. <code>ContentError</code> √® fatto di un paio di campi: un campo √® di tipo <code>content: String</code> e l'altro campo √® <code>code: i32</code>. Sono due pezzi di informazione, gli ho dato un nome cos√¨ mi viene facile gestirli. Anche questo voglio che derivi <code>Error</code>, <code>Debug</code>, e anche qua vorrei mettermi un'indicazione che implementa <code>Display</code>.</p>
<p>In realt√† anche in questo caso vorrei gestire dei possibili errori, e quindi nella funzione potrei scrivere:</p>
<p><img src="images/gestione_degli_errori/image%2046.png" alt="image.png" /></p>
<p>Quindi nel mio <code>main</code>, dopo <code>match leggi_file</code>, potrei scrivere:</p>
<p><img src="images/gestione_degli_errori/image%2047.png" alt="image.png" /></p>
<p>Output: <code>Problema: Contenuto non adatto: 1</code></p>
<p>Quindi a questo punto abbiamo creato due descrizioni possibili di errore, ognuno che si porta dati diversi per i fatti suoi.</p>
<p>Queste sono due operazioni disgiunte, ma tendenzialmente noi vogliamo una funzione vera che elabora il nostro file: prima lo legge poi lo elabora, quindi vogliamo che faccia in cascata delle cose.</p>
<p><img src="images/gestione_degli_errori/image%2048.png" alt="image.png" /></p>
<p>Dunque probabilmente noi vogliamo una funzione principale <code>fn combina_azioni</code> che prende in ingresso il nome di un file <code>filename: &amp;str</code> e ci deve ritornare un <code>Result</code>.</p>
<p>La funzione <code>combinazioni</code> prima legge il file. Se il file va bene, quello che ha letto dentro il file lo passa a <code>elabora_contenuto</code>. Se <code>elabora_contenuto</code> va bene, ci restituisce il valore finale. <code>elabora_contenuto</code> alla fine, se tutto va bene, ci d√† un intero, quindi questo qui √® un <code>Result&amp;lt;i32&amp;gt;</code>.</p>
<p>Che tipo di errore pu√≤ succedere? Ne possono succedere due:</p>
<ul>
<li>Se √® andato male <code>FileError</code> (non sono riuscito a leggere il file), mi deve dare l'errore su <code>FileError</code></li>
<li>Se il file l'ho letto ma nell'elaborarmi il contenuto non mi andava bene, devo dare un <code>ContentError</code></li>
</ul>
<p>Quindi qui sono un po' in difficolt√†: <em>che cosa scrivo nel campo Error del Result da ritornare?</em></p>
<p>Allora qui mi devo inventare una classe ulteriore, un qualcosa che al momento non ho ancora presentato. Come lo faccio? Con un <code>enum</code>!</p>
<p><img src="images/gestione_degli_errori/image%2049.png" alt="image.png" /></p>
<p>Diamo un nome a questa cosa ‚Äî questo √® un <code>ProcessingError</code> che ha dentro di s√© due campi possibili:</p>
<ul>
<li>Un campo <code>File</code> che contiene un <code>FileError</code></li>
<li>Un campo <code>Content</code> che contiene un <code>ContentError</code></li>
</ul>
<p>Sono le due alternative possibili.</p>
<p><img src="images/gestione_degli_errori/image%2050.png" alt="image.png" /></p>
<p>Piccolo problema: <code>ProcessingError</code> non √® noto che sia un errore. Anche qua mi viene in aiuto <code>thiserror</code>: <code>#[derive(Error, Debug)]</code>. E poi devo dare dei messaggi di qualche tipo ‚Äî <code>#[error("Errore di elaborazione")]</code>.</p>
<p>Cosa scriviamo dentro <code>combina_azioni</code>?</p>
<p><img src="images/gestione_degli_errori/image%2051.png" alt="image.png" /></p>
<p>Allora qui di fatto, se io scrivessi <code>let c = leggi_file(filename)</code>, dentro quel <code>c</code> avrei un <code>Result</code>. Per gestirlo dovrei fare <code>match</code> eccetera, ma abbiamo visto ieri che posso usare il punto interrogativo.</p>
<p>Per√≤ questa cosa qui potrebbe darmi un errore. Il problema √® che l'errore che mi d√†, se viene, √® un errore di tipo <code>FileError</code>, ma questa dice che mi d√† un <code>ProcessingError</code>.</p>
<p><em>Come converto il</em> <code>FileError</code> <em>in un</em> <code>ProcessingError</code><em>?</em></p>
<p><img src="images/gestione_degli_errori/image%2052.png" alt="image.png" /></p>
<p>Allora, nella <code>enum</code> io ho la possibilit√† di aggiungermi ancora un'altra annotazione che dice <code>from</code>. Questa annotazione serve a dire: <em>"se per caso ti passa tra le mani un</em> <code>FileError</code> <em>e hai bisogno di creare un</em> <code>ProcessingError</code><em>, guarda, √® facilissimo: quel</em> <code>FileError</code> <em>diventa un</em> <code>ProcessingError</code> <em>creando un</em> <code>ProcessingError</code> <em>che ha come valore dell'enum il campo <code>file</code>".</em> E analogamente posso dire: <em>"Se hai bisogno di creare un</em> <code>ProcessingError</code> <em>a partire da un</em> <code>ContentError</code><em>, fai quest'altra cosa".</em> E quindi ci rimetto <code>from</code>.</p>
<p><img src="images/gestione_degli_errori/image%2053.png" alt="image.png" /></p>
<p>Quindi il mio <code>combina_azioni</code> al momento dice: prova a leggere il contenuto. Se ci riesci va bene, se non ci riesci <code>?</code> ritorna (ovvero l'errore che <code>leggi_contenuto</code> genererebbe, che √® un <code>FileError</code>, lo converte automaticamente in un <code>ProcessingError</code> creandomi l'opportuno tratto <code>from</code>). Se invece √® andato bene, io dentro <code>c</code> ho gi√† la stringa. A questo punto posso passare questa stringa al <code>let r = elabora_contenuto(c)</code>. Anche qua <code>elabora_contenuto</code> pu√≤ andare bene o male, di nuovo ci metto il <code>?</code>. Questo <code>?</code> automaticamente fa s√¨ che se mi venisse un errore di tipo <code>ProcessingError</code>, lo genererebbe. Se tutto va bene ho il risultato, e a questo punto lo ritorno con <code>Ok(r)</code>.</p>
<p><img src="images/gestione_degli_errori/image%2054.png" alt="image.png" /></p>
<p>Vediamo cosa succede nel momento in cui io lo chiamo: invece di chiamare <code>match leggi_file(a)</code> faccio <code>match combina_azioni(a)</code> e tolgo il pezzo sotto.</p>
<p>Quindi a questo punto lui prover√† ad aprire il file chiamato <code>a</code>. Se ci riesce, prover√† a elaborare il contenuto.</p>
<p>In questo modo io ho potuto facilmente combinare errori molto diversi, ognuno dei quali si portava dietro le informazioni che ritenevo opportuno. Li ho modellati semplicemente con una <code>struct</code> in cui ho messo i pezzi che ritenevo interessanti per far capire che cosa √® successo l√¨ dentro. Ciascuno di questi l‚Äôho marcato, gli ho fatto implementare il tratto <code>Error</code> tramite la macro <code>derive</code> grazie al crate <code>thiserror</code>, e gli ho fatto implementare anche il tratto <code>Display</code> corrispondente cos√¨ li posso stampare.</p>
<p>Poi, dovendo creare una funzione che chiama altre funzioni (ciascuna delle quali fallisce per modi distinti), ho preparato un <code>enum</code> che me li metteva insieme. Questo <code>enum</code> √® anche lei un <code>enum</code> che descrive un errore, quindi gli ho fatto implementare il tratto <code>Error</code>, il tratto <code>Debug</code> e il tratto <code>Display</code> in modo opportuno. Ho detto che delle varie alternative erano del tipo 1, del tipo 2, del tipo 3, dandogli anche un nome (File e Content). E poi per√≤ ho dovuto dare istruzioni su come passare dall'errore specifico (che potrebbe essere un <code>FileError</code> o un <code>ContentError</code>) all'errore generico (quello che ne comprendeva potenzialmente tanti). E l‚Äôho fatto aggiungendo questa annotazione <code>from</code> che ha fatto s√¨ che dove usavo il <code>?</code> lui dicesse <em>"aspetta, qui potrebbe andar male, ho bisogno di tornare".</em> Se il risultato √® <code>is_error</code> (cio√® conteneva qualcosa che non andava bene) devo ritornare, ma non posso ritornare direttamente il <code>FileError</code> perch√© questa vuole il <code>ProcessingError</code>. Ma grazie alla macro <code>from</code> lui mi sa estendere: partendo dal <code>FileError</code> mi sa generare il <code>ProcessingError</code> relativo e quindi il codice diventa smooth.</p>
<p>Quindi questa soluzione √® assolutamente facile se uno sa dove mettere le mani ‚Äî si riesce a costruirsi una cosa che √® al tempo stesso <strong>descrittiva a sufficienza</strong>. In ciascuna classe di errore mi posso portare dietro tutti i dettagli necessari per permettere un recovery di qualche tipo. Al momento non abbiamo fatto nessun recovery, ma potenzialmente ci siamo scritti tutto quello che √® andato male, dandoci gli estremi per mettere in atto una strategia.</p>
<p>√à facile perch√© posso arricchire la mia situazione a piacimento. Contemporaneamente posso gestirla agevolmente perch√© la sintassi del punto interrogativo mi d√† la possibilit√† di avere uno shortcut. Quindi il metodo <code>combina_azioni</code> resta sostanzialmente leggibile: leggi file, processa contenuto e ritorna il risultato. √à agevole da leggere, senza strani accumuli di <code>if</code>, <code>match</code> o costrutti simili.</p>
<p>La strada prediletta ‚Äî quella dove tutto va bene ‚Äî √® quella che leggo. Tutte le altre sono strade potenzialmente storte che provocano una <em>uscita rapida</em> grazie al punto interrogativo. Questa uscita rapida mi garantisce di non perdere dettaglio, mantenendo il livello di dettaglio che avevo semplicemente racchiudendolo dentro una struttura un pochino pi√π grande.</p>
<p>Nel <code>main</code> sono in grado di provare le mie strategie di qualche tipo. Qua di strategia non ne provo nessuna ‚Äî mi limito a verificare se le cose sono andate bene. Se le cose sono andate male, dico perch√© e poi la pianto l√¨.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteratori---malnati-17"><a class="header" href="#iteratori---malnati-17">Iteratori - Malnati 17 <!-- omit in toc --></a></h1>
<h1 id="indice-11"><a class="header" href="#indice-11">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="12-iteratori.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="12-iteratori.html#11-iteratori-in-c20">1.1 Iteratori in C++20</a></li>
</ul>
</li>
<li><a href="12-iteratori.html#2-iteratori-in-rust">2. Iteratori in Rust</a>
<ul>
<li><a href="12-iteratori.html#21-esempio">2.1 Esempio</a></li>
<li><a href="12-iteratori.html#22-adattatori">2.2 Adattatori</a></li>
<li><a href="12-iteratori.html#23-consumatori">2.3 Consumatori</a></li>
</ul>
</li>
</ul>
<h1 id="1-introduzione-6"><a class="header" href="#1-introduzione-6">1. Introduzione</a></h1>
<p><img src="images/iteratori/image.png" alt="image.png" /></p>
<p>Un iteratore √® una struttura dati che √® specializzata nell'offrirci un metodo <code>next</code> che ci permette di sapere se c'√® qualcosa ancora da leggere oppure no.</p>
<p>Quindi una struttura dati che ci aiuta a visitare una collezione tirando fuori gli elementi uno alla volta.</p>
<p>Quella collezione l√¨, di solito, l'iteratore <strong>non la possiede</strong> ‚Äî la guarda e quindi ci ritorna un reference ai suoi contenuti.
In alcuni casi l'iteratore <strong>pu√≤ prendere possesso</strong> della collezione smontandola, e ce la smonta non tutta di colpo ma ce la smonta un pezzettino alla volta finch√® non l'abbiamo visitata tutta.</p>
<p>Quindi l'iteratore √® una <strong>struttura dotata di stato.</strong></p>
<p>Tipicamente un iteratore prende questi valori che tira fuori uno alla volta da un contenitore, in alcuni casi potrebbe prenderli in realt√† da una funzione che li genera di volta in volta.</p>
<p>Normalmente da un punto di vista concettuale l'iteratore deve permettermi di sapere <em>se ce ne sono ancora</em>, cio√® prima di chiederti qual √® il prossimo ti chiedo <em>‚Äúma ce l'hai un prossimo?‚Äù</em> e questa √® una domanda che ha risposta s√¨ o no. Nel caso in cui tu mi dica no √® inutile che ti chieda altro, nel caso in cui tu invece mi dica s√¨ allora ti chiedo anche qual √®, e a quel punto ho un secondo metodo, <code>next</code>, che mi permette di estrarlo.</p>
<p>A secondo di che cos'era la collezione da cui sto partendo <code>next</code> mi pu√≤ ritornare un numero, una stringa, etc‚Ä¶</p>
<p>Diversi linguaggi implementano questa cosa in modo vario. In <strong>Java</strong>, esiste l'interfaccia del package <code>java.util.Iterator</code> che contiene tre metodi:</p>
<ul>
<li><code>hasNext()</code> che ritorna un booleano</li>
<li><code>next()</code> che ritorna il tipo dell'iteratore</li>
<li>un metodo per cancellare l'elemento corrente</li>
</ul>
<p>In <strong>Rust</strong>, i due metodi sono combinati: c'√® un unico metodo <code>next()</code> che ritorna una <code>Option</code>. Se l' <code>Option</code> contiene <code>Some</code>, vuol dire che un altro elemento c'era (e dentro <code>Some</code> c'√® anche scritto qual √®). Se l' <code>Option</code> √® <code>None</code>, vuol dire che non ce ne sono pi√π. Puoi chiamare <code>next()</code> infinite volte, ma dopo <code>None</code> riceverai sempre <code>None</code>.</p>
<p>A partire da un iteratore possiamo creare altri iteratori. Possiamo:</p>
<ul>
<li>Concatenare iteratori in sequenza</li>
<li>Filtrare elementi con certe caratteristiche</li>
<li>Trasformare gli elementi in qualcos'altro</li>
</ul>
<p>Questo concetto √® presente in tutti i linguaggi moderni.</p>
<p>Un esempio pratico: quando scriviamo un ciclo <code>for</code> in Rust stiamo usando un iteratore (il compilatore trasforma il ciclo for in uso di iteratore). Ad esempio:</p>
<ul>
<li>Abbiamo un vettore <code>v1</code> con numeri da 1 a 6</li>
<li>Un vettore <code>v2</code> destinato a contenere stringhe</li>
<li>Un ciclo for che itera su <code>v1.len()</code>, controlla se ogni elemento √® multiplo di 2, e se lo √® inserisce una stringa derivata in <code>v2</code></li>
</ul>
<p>Il risultato: <code>v2</code> contiene tre stringhe: "a2", "a4", "a6".</p>
<p><strong>Questa stessa cosa</strong> √® scritta in modo imperativo, con una serie di comandi che accedono al vettore tramite le parentesi quadre con l'indice <code>i</code>. Questo approccio funziona, ma presenta dei rischi: se per errore assegnassimo a <code>i</code> un valore fuori range, il programma potrebbe andare in panic. Anche se questo codice √® semplice e intuitivo, possiamo scriverlo in un modo alternativo ed equivalente.</p>
<p>Vediamo cosa potremmo inserire in <code>v2</code>. Dentro <code>v2</code> ci metto <code>v1.iter</code>, ovvero vado da <code>v1</code> e dico ‚Äú<em>senti me li dai i tuoi numeri uno alla volta?‚Äù</em>. <code>v1.iter</code> si prepara a dare i numeri uno alla volta ma non fa niente a parte prepararsi.</p>
<p>Poi gli dico ‚Äú<em>guarda una volta che avremo questi numeri uno alla volta, guardaci dentro e passami avanti solo quelli pari‚Äù</em> ‚Äî <code>.filter</code> ‚Äî e qui ti passo una lambda per fare questa cosa.</p>
<p><code>.filter</code> accetta una lambda che ritorna un booleano: se quel booleano √® <strong>true</strong> lo tengo, se il booleano √® <strong>false</strong> lo butto.</p>
<p>E quindi se <code>v1.iter</code> voleva dire "dammeli tutti", <code>v1.iter.filter</code> vuol dire <em>"dammi solo alcuni, quelli che mi piacciono".</em> Va bene, ma ancora non ha fatto assolutamente niente, si √® solo preparato.</p>
<p>Successivamente consideriamo: se qualcosa esce dal filter (anche se non √® garantito), cosa ne facciamo? Abbiamo un numero, ma ci serve una stringa! La soluzione √® <em>mappare</em> ogni elemento che esce usando una lambda che trasforma il numero in stringa. Come? La lambda prende il numero e usa <code>format</code> per creare una stringa che combina "a" con il numero stesso.</p>
<p>E poi c'√® quello che veramente fa partire la macchina, la mette in moto: <strong>collect</strong>!
<code>collect</code> dice <em>"ok parti e raccogli il tutto, raccoglilo e mettilo nel risultato, cio√®</em> <code>v2</code><em>"</em>.</p>
<p><code>collect</code> si comporta diversamente in base a dove deve mettere le cose: se devi metterlo dentro un <code>Vec</code> far√† certe operazioni, se deve metterlo dentro una <code>VecDeque</code> (che non sappiamo ancora cos'√® ma lo scopriamo tra breve) ne far√† degli altri, se deve metterlo dentro una linked list ne fa delle altre ancora ‚Äî quindi sulla base di dove deve inserire i suoi risultati, agisce.</p>
<p><code>collect</code> inizia a chiamare chi sta a monte: si rivolge a <code>map</code> e chiede "Hai qualcosa?". <code>map</code> risponde "Aspetta, devo chiedere" e va da <code>filter</code>. <code>filter</code> a sua volta chiede a <code>iter</code>: "Hai qualcosa?". <code>iter</code> risponde "S√¨, dovrei avere 6 elementi in <code>v1</code>".</p>
<p>Quindi <code>iter</code> comincia a restituire 1. <code>filter</code> lo esamina e dice <em>"No, √® dispari, non mi piace".</em> <code>iter</code> passa al successivo, 2. "Bello, questo 2 mi piace!" e lo passa a <code>map</code>. <code>map</code> dice "Ok, devo trasformarlo in stringa: 'a2'" e lo passa a <code>collect</code>. <code>collect</code> lo salva nel risultato, dentro <code>v2</code>.</p>
<p>Si torna da <code>map</code>: <em>"Altri elementi?".</em>
Arriva 3: <em>"No, √® dispari".</em>
Poi 4: <em>"S√¨, √® pari, mi piace!".</em> "a4" viene salvato.
Avanti col prossimo... 5, 6...
<em>"Altri elementi?". "No, non ce ne sono pi√π"</em>
Fine. Questa √® la storia dell'iteratore.</p>
<p>L'iteratore <strong>non fa niente</strong> se al fondo non ci attacco qualcosa che <strong>consuma</strong>. Questo √® molto diverso da quello che succede in JavaScript: se voi in JavaScript avete un array <code>[1,2,3,4,5,6]</code> e fate <code>[1,2,3,4,5,6].filter().map()</code>, <strong>immediatamente parte il filter</strong> che da quell'array lungo 6 ne crea subito uno lungo 3. Immediatamente dopo che filter ha creato il suo array lungo 3, parte map, che fa le stringhe "a2", "a4", "a6", e poi quello viene salvato come risultato.</p>
<p>Quindi abbiamo tre concetti fondamentali:</p>
<ul>
<li>Gli iteratori sono un modo per <strong>navigare una collezione</strong> facendoci dare quello che c'√® dentro un pezzo alla volta</li>
<li>Gli iteratori sono <strong>pigri</strong> ‚Äî da soli non fanno niente, aspettano che qualcuno gli chieda <em>"ce l'hai il prossimo?"</em> ‚Äî se nessuno glielo chiede, non succede nulla</li>
<li>Un iteratore pu√≤ essere attaccato in cascata a un altro iteratore (modificatore) per arricchire la selezione</li>
</ul>
<p>Lo possiamo fare con una serie di operatori ‚Äî qui ne abbiamo visti due fondamentali:</p>
<ul>
<li><code>filter</code>: quando non tutti gli elementi mi interessano</li>
<li><code>map</code>: quando ho bisogno di una derivazione del valore, lo mappo/trasformo in qualcos'altro</li>
</ul>
<p><img src="images/iteratori/image%201.png" alt="image.png" /></p>
<p>Quindi di base noi usiamo gli iteratori perch√© sono <strong>versatili</strong>: siamo partiti da un vettore che conteneva <code>[1,3,4,5,6]</code>, ma fossimo partiti da una lista il codice era lo stesso, se fossimo partiti da un range <code>1..=6</code> il codice restava uguale (a parte il pezzo iniziale da dove prendiamo le cose). Indipendentemente dalla sorgente, noi usiamo l'iteratore per farci dare uno alla volta che cosa c'√® l√¨ dentro. Da questo punto di vista ci aiuta a scrivere del codice pi√π semplice: non abbiamo bisogno di sapere troppi dettagli di <em>come</em> √® fatta quella sorgente ‚Äî l'iteratore ce li prende uno alla volta.</p>
<p>Gli operatori sono <strong>pigri</strong> ‚Äî gli iteratori sono pigri solo se noi gli chiediamo. Se non glielo chiediamo non fanno assolutamente niente.</p>
<p>Potenzialmente gli iteratori possono operare in <strong>parallelo</strong> ‚Äî notate che bisogna chiederlo in modo esplicito. Noi adesso qui stiamo operando in modo strettamente sequenziale: <em>"dammi il prossimo, dammi il prossimo, dammi il prossimo".</em> In alcune situazioni noi possiamo dirgli <em>"dammi tutti i prossimi che riesci in contemporanea".</em> Poich√© possiamo derivare da un iteratore un altro iteratore applicandogli le funzioni (come <code>filter</code>, <code>map</code>, <code>reduce</code>, <code>fold</code>, <code>first</code>, <code>last</code>, <code>reverse</code> eccetera), il nostro codice diventa molto pi√π flessibile perch√© possiamo aggiustare un mucchio di cose facilmente.</p>
<p><img src="images/iteratori/image%202.png" alt="image.png" /></p>
<p>Gli iteratori esistono in tutti i linguaggi, anche in C++, solo che in C++ sono stati modellati con un'idea un po' cos√¨ ‚Äî piuttosto che un approccio funzionale come abbiamo visto in Rust basato sulla <em>monade</em> <code>Option</code> che contiene <code>Some</code> con un valore, o <code>None</code>, e quindi mi permette con un singolo metodo <code>next</code> di governare tutto, in C++ sono stati modellati pensando ai puntatori e all'aritmetica dei puntatori, che √® un disastro.</p>
<p>Per cui di fatto quello che succede √® che in C++ gli iteratori viaggiano sempre in coppia <code>begin</code>/<code>end</code> e vanno confrontati l'uno con l'altro. Non abbiamo troppo tempo da dedicarci, sappiate per√≤ che questo √® un grosso problema del C++ che √® stato un po' aggiustato solo nel 2020 con l'introduzione dei <code>range</code>. Un range in realt√† in C++ √® un oggetto che dentro di s√© contiene i due iteratori ma ti d√† un'interfaccia pulita simile a quella di Rust o degli altri linguaggi, altrimenti era un grosso casino.</p>
<h2 id="11-iteratori-in-c20"><a class="header" href="#11-iteratori-in-c20">1.1 Iteratori in C++20</a></h2>
<p><img src="images/iteratori/image%203.png" alt="image.png" /></p>
<p>C'√® un altro problema degli iteratori in C++. √à legato al fatto che alcuni iteratori hanno <strong>capacit√† pi√π grandi di altre</strong> che dipendono sostanzialmente dal posto dove sono stati acquisiti. Di conseguenza c'√® tutta una gerarchia concettuale:</p>
<ul>
<li>Iteratori di <strong>ingresso</strong>: capaci di leggere un valore</li>
<li>Iteratori di <strong>uscita</strong>: capaci di scrivere un valore</li>
<li>Iteratori <strong>forward</strong>: leggono solo in avanti, dall'inizio alla fine</li>
<li>Iteratori <strong>bidirectional</strong>: permettono di andare anche all'indietro, dal fondo all'inizio</li>
<li>Iteratori <strong>ra ndom access</strong>: consentono di saltellare avanti e indietro di n posizioni</li>
<li>Iteratori <strong>contiguous</strong>: assumono che i dati siano adiacenti in memoria, trattandoli come array</li>
</ul>
<p>Tutto questo per√≤ rende l'uso degli iteratori complicato. √à vero che la standard library del C++ √® tutta basata sull'uso degli iteratori e offre metodi che ti consentono, data una coppia di iteratori, di farci operazioni sopra.</p>
<p>Ad esempio, la funzione <code>sort</code> permette di ordinare un contenitore sotto certe condizioni. Il problema √® che alcune funzioni della standard library presuppongono che l'iteratore sia di una particolare categoria ‚Äî se ne passate uno pi√π generico, si spacca dando errori di compilazione illegibili.</p>
<p>Il grande sforzo fatto nel C++20 con l'introduzione dei <code>concept</code> √® stato quello di fare in modo che questa cosa (nonostante si spacchi sempre), dia un errore leggibile: <em>"Non posso ordinare questa cosa perch√© non √® ordinabile, in quanto l'iteratore non √® quello buono"</em>. Ad esempio, una linked list non √® sortabile perch√© ha i suoi pezzi sparpagliati in memoria.</p>
<h1 id="2-iteratori-in-rust"><a class="header" href="#2-iteratori-in-rust">2. Iteratori in Rust</a></h1>
<p><img src="images/iteratori/image%204.png" alt="image.png" /></p>
<p>Vediamo invece cosa succede in Rust, che √® quello che ci interessa.</p>
<p>Gli iteratori in Rust sono <strong>molto semplici</strong>: sono oggetti qualunque (struct, enum o tuple) che implementano il trait <code>Iterator</code>. Il trait <code>Iterator</code> ha:</p>
<ul>
<li>Due componenti <strong>essenziali</strong>:
<ul>
<li>Il tipo di dato (<code>Item</code>) che l'iteratore produce</li>
<li>Il metodo <code>next</code> che restituisce una <code>Option&lt;Self::Item&gt;</code></li>
</ul>
</li>
</ul>
<p>Oltre al metodo obbligatorio <code>next</code>, l'iteratore ha una trentina di metodi ulteriori con implementazione di default.
Questi metodi ci consentono di derivare <code>filter</code>, <code>map</code>, <code>reduce</code>, <code>fold</code>, <code>reverse</code> e cos√¨ via.</p>
<p>Se un tipo permette di essere esplorato elemento per elemento, implementa il trait <code>Iterator</code>. Se il contenitore di partenza aveva delle stringhe, l'iterator ci d√† dei riferimenti alle stringhe ‚Äî cio√® permette di guardare dentro senza modificare, ritornando normalmente il reference non mutabile al dato contenuto.</p>
<p>Un tipo per√≤ potrebbe anche dire <em>"guarda io ho dei dati miei e sono pronto a sbriciolarmi per dare uno alla volta i miei dati a chi gli interessa‚Äù</em>. In questo caso non implementer√† il tratto <code>Iterator</code> o non implementer√† solo il tratto <code>Iterator</code>, ma implementer√† il tratto <code>IntoIterator</code>.</p>
<p>Il tratto <code>IntoIterator</code> fondamentalmente prende possesso della sua sorgente, e quindi non d√† il reference ai singoli dati che la sorgente contiene, ma d√† i dati che la sorgente contiene, perch√© quando l'iteratore sar√† stato eseguito (anche solo parzialmente) l'intera struttura originale verr√† sbriciolata.
Il tratto <code>IntoIterator</code> sostanzialmente ha un'unica funzione che √® <code>into_iter</code> che trasforma quella cosa l√¨.</p>
<p>Gli iteratori non hanno niente di magico dentro di s√©, si limitano a contenere qualcosa ‚Äî sono degli oggetti che hanno quello che gli serve per ricordarsi a che punto sono arrivati. Se io dovessi iterare su un vettore, com‚Äô√® fatto l'iteratore che √® capace di iterare su un vettore? Ricorda un indice! Ricorda il riferimento al vettore a cui pu√≤ chiedere delle cose, un indice, e dice <em>"fintanto che il mio indice √® minore del size del vettore, alla richiesta di un nuovo elemento gli rispondo s√¨ e d√≤ l'elemento i-esimo, e poi incremento l'indice.‚Äù</em></p>
<p><img src="images/iteratori/image%205.png" alt="image.png" /></p>
<p>Qui c'√® l'esempio di un iteratore che permette di iterare su un range in modo bidirezionale, ovvero una struttura <code>MyRange</code> con due limiti. Il range pu√≤ andare, ad esempio, da 7 a 25, oppure da 25 a 7. Nel caso di un range da 7 a 25, l'iteratore restituisce in sequenza 7, 8, 9,‚Ä¶, 24 (l'ultimo numero √® escluso). Nel caso inverso, da 25 a 7, l'iteratore restituisce in sequenza 25, 24, 23,‚Ä¶,8.</p>
<p><em>Come funziona questa cosa?</em>
Banalmente dichiaro la struttura <code>MyRange</code> che prenderebbe come parametro del template direttamente gli estremi, quindi di per s√© non ha bisogno, in quanto range, di contenere niente altro perch√© sigillo nel tipo i suoi estremi che sono costanti. Dopodich√© posso dire che questa struttura implementa il tratto <code>IntoIterator</code> per esempio, <em>e cosa fa?</em> Banalmente tiene traccia di s√©, di un contatore.</p>
<p><img src="images/iteratori/image%206.png" alt="image.png" /></p>
<p>Restituisco un <code>MyRangeIterator</code> da <code>FROM</code> a <code>TO</code>, e questo <code>MyRangeIterator</code> contiene un solo valore numerico. Quando viene richiesto il prossimo elemento, restituisco il valore di <code>self.val</code>. Se sto procedendo in ordine crescente, poi incremento <code>self.val</code> di 1; se in ordine decrescente, lo decremento di 1. Questo meccanismo mi permette di esplorare l'intero range. Quando raggiungo la fine, restituisco <code>None</code> e l'iterazione termina. Questo √® il funzionamento essenziale dell'iteratore.</p>
<p>Se questo invece di essere un oggetto che parte da due estremi costanti fosse legato a un vettore, avrebbe avuto dentro di s√© banalmente il riferimento al vettore, aveva lo stesso indice e si ricordava banalmente se a che punto era arrivato. La risposta a <em>"c'√® il prossimo?"</em> √® s√¨, fin tanto che il mio indice √® pi√π piccolo del vettore.</p>
<p><img src="images/iteratori/image%207.png" alt="image.png" /></p>
<p>Notate che quando noi scriviamo un ciclo <code>for</code>, il compilatore ci espande il nostro ciclo for con gli iteratori.</p>
<p>Cosa succede se noi andiamo a vedere questa cosa qua in una delle tante versioni del compilatore? Pu√≤ darsi che quella che usiamo oggi sia diventata un po' diversa, perch√© ogni volta che viene rilasciato un nuovo compilatore questi migliorano e affinano il codice generato perch√© sia pi√π robusto, pi√π efficiente. etc‚Ä¶ Comunque in una delle <em>n</em> versioni che ha avuto questa cosa qui, questo √® quello che veniva generato: quindi si prendeva in questo caso <code>values</code> che era trasformato in un <code>IntoIter</code> e quindi io lo sbriciolo il mio vettore perch√© <code>for x in values</code> vuol dire che io li tiro fuori direttamente tutti.</p>
<p><em>E che cosa faccio?</em>
Ciclo finch√© ce n'√® un prossimo, e questo prossimo contiene <code>Some</code> di qualcosa, assegno a <code>next</code> il valore e poi uso questo valore per legarlo a <code>x</code>. Dopodich√©, dopo averlo legato a <code>x</code>, eseguo l'azione che era contenuta dentro il <code>for</code> e proseguo in questo modo finch√© ce n'√®. Quando arrivo a vedere che dall'iteratore non mi esce pi√π niente, <code>break</code>: esco da questo ciclo infinito e me ne vado.</p>
<p>Ok, √® un po' illegibile scritto cos√¨ il codice ma √® come una delle tante versioni del compilatore ha deciso di farlo. Quello che ci interessa √® che noi scriviamo <code>for x in values</code> e l√¨ abbiamo chiaro cosa vuol dire. Poi il fatto che lui generi questo o meno √® utile da sapere semplicemente perch√© alla base di tutto il funzionamento di Rust ci sono gli iteratori: sono degli elementi fondanti.</p>
<p><img src="images/iteratori/image%208.png" alt="image.png" /></p>
<p>Tutti i contenitori presenti nella libreria standard ci mettono a disposizione una serie di metodi.</p>
<p>Ce ne sono tre fondamentali che hanno a che fare con gli iteratori:</p>
<ul>
<li>**<code>iter**</code>
Ci d√† un iteratore che guarda e ci restituisce un riferimento a ci√≤ che √® contenuto, quindi un riferimento <strong>non mutabile</strong>.
Noi possiamo sapere che dentro quella cosa l√¨ c'√® un certo dato: uno alla volta ne abbiamo un riferimento, lo possiamo leggere, non lo possiamo modificare. <code>iter</code> <strong>prende a prestito la struttura</strong>, quindi fin tanto che iteriamo sulla struttura la struttura non √® modificabile.</li>
<li><strong><code>iter_mut</code></strong>
√à simile a <code>iter</code>, ma prende a prestito il dato mutabile, quindi mi lascia non solo esplorare cosa c'√® dentro ma quello che mi d√† √® un riferimento mutabile quindi io posso cambiarlo.
Potrei fare <code>for x in v.iter_mut</code>, a questo punto potrei dire <code>x += 1</code>: il mio vettore che conteneva inizialmente <code>[1,2,3,4,5]</code> dopo un ciclo del genere contiene <code>[2,3,4,5,6]</code>. Cio√® mentre esploravo ho avuto la possibilit√† di cambiare i singoli pezzi uno per volta. I pezzi sono rimasti di propriet√† del vettore originale, ma siccome lui me li ha dati in modalit√† mutabile io ho avuto la possibilit√† di cambiarli.</li>
<li><strong><code>into_iter</code></strong>
√à la versione dell'iteratore che prende possesso della struttura, la sbriciola. Quindi al termine dell'esecuzione di <code>into_iter</code> la struttura non c'√® pi√π. In compenso io ho preso possesso delle singole parti. Questo mi ha dato la possibilit√† ad esempio di salvarle altrove, senza doverne fare una copia.</li>
</ul>
<p>Tipicamente questi tre metodi sono coadiuvati da un dall'implementazione del tratto <code>IntoIterator</code>. Noi possiamo scrivere <code>for x in v</code> perch√© in realt√† <code>v</code> ‚Äî che non √® un iteratore √® un contenitore ‚Äî implementa il tratto <code>IntoIterator</code>.</p>
<p><code>for x in v</code> vuol dire: <em>"prendi</em> <code>v</code><em>, derivami un iteratore e per tutti gli elementi che questo iteratore restituisce assegnali a</em> <code>x</code><em>, fai delle cose".</em></p>
<p>Tipicamente ci sono <strong>tre implementazioni del tratto</strong> <code>IntoIterator</code>.
Se io lo faccio su <code>v</code>, <code>for x in v</code> sto chiamando <code>v.into_iter()</code>, che sbriciola <code>v</code>.
Se faccio <code>for x in &amp;v</code> sto dicendo <em>"fammi leggere il contenuto di</em> <code>v</code> <em>e dammi dei riferimenti non mutabili al suo contenuto‚Äù</em>.
Se io faccio <code>for x in &amp;mut v</code> gli chiedo <em>"dammi accesso alle parti con possibilit√† di modificare".</em></p>
<h2 id="21-esempio"><a class="header" href="#21-esempio">2.1 Esempio</a></h2>
<p><img src="images/iteratori/image%209.png" alt="image.png" /></p>
<p><img src="images/iteratori/image%2010.png" alt="image.png" /></p>
<p>Provando ad eseguire, il compilatore ci segnala un errore. <strong>Perch√©?</strong> Perch√© avviene un "move" del vettore di <code>i32</code>, che non implementa il tratto <code>Copy</code>. Quando scriviamo "<code>for x in v</code>", <code>v</code> viene consumato da <code>IntoIterator</code> e di conseguenza viene sbriciolato. Al termine dell'iterazione <code>v</code> non esiste pi√π, quindi le istruzioni successive che tentano di accedere a <code>v</code> non possono funzionare.</p>
<p><em>Come possiamo correggerlo?</em>
Non scrivendo <code>for x in v</code>, ma <code>for x in &amp;v</code>!</p>
<p>In questo modo quello che riceviamo sono dei riferimenti. Infatti vedete che qui <code>x</code> √® <code>&amp;i32</code> - ottengo riferimenti alle parti che <code>v</code> contiene. Se scrivessi <code>for x in &amp;v</code>, <code>x</code> diventa un riferimento a <code>i32</code>.</p>
<p><img src="images/iteratori/image%2011.png" alt="image.png" /></p>
<p>Se scrivo <code>for x in &amp;mut v</code>, <code>x</code> diventa <code>&amp;mut i32</code>. Chiaramente per poter usare <code>mut</code> devo dichiarare che <code>v</code> √® mutabile, altrimenti non funziona. A questo punto, invece che stampare <code>x</code>, potrei fare <code>*x = 2</code>.</p>
<p>Se eseguo questo codice mi stamper√† <code>[2,4,6,8,10,12]</code>.</p>
<p>Questo dimostra che posso non solo iterare e leggere il contenuto, ma se ottengo una versione mutabile (un riferimento mutabile) ho la possibilit√† di modificare la struttura di <code>v</code>.
<strong>Non posso per√≤ rimuovere elementi da <code>v</code>.</strong></p>
<p><img src="images/iteratori/image%2012.png" alt="image.png" /></p>
<p><strong>Notate</strong> ancora una cosa: se <code>x &gt; 4</code>, allora <code>break</code> ‚Äî questo significa che ottengo l'1 che diventa 2, ottengo il 2 che diventa 4, ottengo il 3 che diventa 6 e poi mi fermo.
Ho parzialmente svuotato <code>v</code> ‚Äî ho consumato solo i primi 3 elementi perch√© poi mi sono fermato.</p>
<p><img src="images/iteratori/image%2013.png" alt="image.png" /></p>
<p>Cosa contiene <code>v</code>? Niente: lo stesso problema persiste anche se non ho estratto tutti gli elementi da <code>v</code> ‚Äî siccome ho iniziato a prenderli (√® come se avessi tolto 2-3 mattoni da un muro), il compilatore ci dice <em>"No no,</em> <code>v</code> <em>non √® pi√π valido, va eliminato".</em></p>
<p>Per capire meglio, creiamo una struttura <code>P</code> che implementa il tratto <code>Drop</code>.</p>
<p><img src="images/iteratori/image%2014.png" alt="image.png" /></p>
<p><img src="images/iteratori/image%2015.png" alt="image.png" /></p>
<p>Vediamo cosa succede.</p>
<p><img src="images/iteratori/image%2016.png" alt="image.png" /></p>
<p>Eseguendo, vedremo "Consuming P(1)" ‚Äî ho iniziato il <code>for</code>, ho estratto il primo elemento e stampo correttamente. Controllo l'<code>if</code> ‚Äî non √® soddisfatto, devo ottenere il prossimo. Questa <code>x</code> non serve pi√π, va eliminata, quindi "Dropping P(1)". L'ho rimosso dal vettore, l'ho usato e lo elimino. Ottengo il prossimo: "Consuming P(2)", lo controllo, non serve, lo elimino. "Consuming P(3)", lo controllo ‚Äî √® troppo grande, <code>break</code>!</p>
<p>A questo punto sembrerebbe che ho finito. Certo, ho ancora questo <code>x</code> che non serve e che elimino (quindi "Dropping P(3)"). Nel vettore dovrebbero esserci ancora 4, 5, 6. Cosa succede per√≤? Prima che il <code>break</code> mi porti alla prossima istruzione, il compilatore vede che ho iniziato a smontare il vettore e dice <em>"non puoi andartene lasciandomelo mezzo fatto, quindi anche se non ti interessa, smonto tutto perch√© hai iniziato a smontarlo.‚Äù</em></p>
<p>Quando esco, <code>v</code> non esiste pi√π.</p>
<p><img src="images/iteratori/image%2017.png" alt="image.png" /></p>
<p><img src="images/iteratori/image%2018.png" alt="image.png" /></p>
<p>Se invece avessi iterato <code>for p in &amp;v</code>, non succederebbe nulla di tutto ci√≤.
Estraggo il riferimento al primo, lo controllo ‚Äî ok, "Consuming P(1)".
Estraggo il secondo, lo controllo, "Consuming P(2)".
Estraggo il terzo, lo controllo, mi fermo. Perfetto, non ho eliminato nulla.</p>
<p><code>v</code> continua ad esistere. Dopo aver fatto tutto, arrivo alla fine del <code>main</code> ‚Äî a questo punto devo eliminare il vettore, quindi lo svuoto completamente.</p>
<p>Quindi gli iteratori ci permettono di muoverci all'interno dei contenitori in diversi modi:</p>
<ul>
<li><code>for x in contenitore</code>: smonto il contenitore</li>
<li><code>for x in &amp;contenitore</code>: leggo il contenuto senza modificarlo, e mentre lo leggo nessuno pu√≤ modificarlo (ho un prestito sul contenitore)</li>
<li><code>for x in &amp;mut contenitore</code>: prendo in prestito temporaneamente ogni elemento come mutabile, quindi posso modificarlo. Mentre ci lavoro, nessuno pu√≤ accedere al contenitore in alcun modo. Quando ho finito, il contenitore contiene ancora gli stessi elementi, possibilmente modificati.</li>
</ul>
<p><img src="images/iteratori/image%2019.png" alt="image.png" /></p>
<p>Notate che non solo posso scrivere <code>for x in v</code> (dove <code>v</code> √® un vettore, un <code>Vec</code> che ha <code>Iterator</code>), ma potrei anche scrivere <code>for x in v.iter()</code>. Posso utilizzare un <code>for</code> direttamente su un iteratore perch√© tra i metodi di default che tutti gli iteratori gi√† implementano, c'√® anche il metodo <code>into_iter</code>.</p>
<p>Questo dice che se hai gi√† un iteratore e vuoi usarlo in un <code>for</code>, non devi fare nulla ‚Äî hai gi√† l'iteratore pronto. Questo mi permette di scrivere in modo pi√π esplicito: al posto di usare <code>for x in v</code>, posso scrivere <code>for x in v.iter()</code>, <code>for x in v.iter_mut()</code>, o <code>for x in v.into_iter()</code>. Questo √® un modo pi√π esplicito per capire cosa sta succedendo.</p>
<h2 id="22-adattatori"><a class="header" href="#22-adattatori">2.2 Adattatori</a></h2>
<p><img src="images/iteratori/image%2020.png" alt="image.png" /></p>
<p>E poi c'√® una <strong>carrellata di adattatori</strong>.</p>
<p><em>Cosa sono gli adattatori?</em>
Sono queste funzioni ulteriori che noi possiamo applicare in cascata a un iteratore per derivarci delle cose: <code>filter</code>, <code>map</code>, <code>sum</code>.</p>
<p>Gli adattatori sono fatti di un certo numero di cose intermedie fino ad arrivare a dei <strong>terminali</strong> ‚Äî solo il terminale fa scattare le cose.</p>
<p>In generale tutti gli adattatori sono <em>pigri</em> e non fanno nient'altro che rivolgersi a <em>chi hanno alla propria sinistra</em>, a monte, per dire <em>"mi dai il prossimo?"</em> e ci fanno eventualmente qualcosa se questo prossimo esiste. Se il prossimo non c'√® pi√π dicono a loro volta <em>"non c'√® pi√π niente".</em></p>
<p><img src="images/iteratori/image%2021.png" alt="image.png" /></p>
<p><img src="images/iteratori/image%2022.png" alt="image.png" /></p>
<p><img src="images/iteratori/image%2023.png" alt="image.png" /></p>
<p>Sono tantissimi ma li citiamo soltanto perch√© poi li si imparano usandoli:</p>
<ul>
<li><strong><code>map</code></strong>: trasforma una cosa in un'altra</li>
<li><strong><code>filter</code></strong>: permette di capire se questa cosa che ho ricevuto tra le mani mi piace oppure meno
<ul>
<li>Vuole una lambda che ritorna <code>true</code> se voglio far passare l'elemento, <code>false</code> se non voglio farlo passare</li>
</ul>
</li>
<li><strong><code>filter_map</code></strong>: mette insieme le due cose ‚Äî prima di tutto guarda se gli piace e poi, nel caso gli piaccia, mappa anche. Questo permette di ridurre un po' le chiamate.</li>
<li><strong><code>flatten</code></strong> permette di "spiaccicare" delle cose: io prendo in ingresso qualcosa che √® iterabile e do in uscita i singoli pezzi. Per esempio, se ho un vettore che contiene due vettori di numeri e faccio <code>iter.flatten()</code>, (di fatto il vettore esterno avrebbe due soli pezzi: vettore 1 e vettore 2) facendo flatten, lui fa passare vettore 1, che viene <em>flattened</em> (quindi lo spezzo nei suoi elementi costituenti) e quindi alla fine mi viene una sequenza appiattita.</li>
<li><strong><code>flat_map</code></strong> fa contemporaneamente <code>flatten</code> e <code>map</code>, prima applica map, e se map ritorna una lista o qualcosa di iterabile, viene appiattita.</li>
<li><strong><code>take</code></strong>: mi permette di dire <em>"anche se potenzialmente la sorgente contiene tot cose, tu dopo che ne hai fatte passare n dici che non ce n'√® pi√π"</em></li>
<li><strong><code>take_while</code></strong>: fa passare le cose fin tanto che la lambda che gli do ritorna true</li>
<li><strong><code>skip</code></strong>: il contrario di <code>take</code> ‚Äî <em>‚Äúi primi n li salti‚Äù</em></li>
<li><strong><code>skip_while</code></strong>: duale di take_while</li>
<li><strong><code>peekable</code></strong> consente sostanzialmente di guardare l'elemento senza consumarlo</li>
<li><strong><code>fuse</code></strong> permette di dire <em>"guarda cominci a chiedere a priori"</em></li>
<li><strong><code>rev</code></strong> √® un operatore che dice <em>"dammi gli elementi al contrario"</em></li>
</ul>
<p><em>Nota importante</em>: tutti questi adattatori non fanno nulla, o meglio fanno solo delle cose se qualcuno a valle gliele chiede. Ne possiamo mettere quanti ne vogliamo, sapendo che non succeder√† nulla finch√© a valle dell'ultimo adattatore non attacchiamo un <em><strong>consumatore</strong></em>.</p>
<h2 id="23-consumatori"><a class="header" href="#23-consumatori">2.3 Consumatori</a></h2>
<p><img src="images/iteratori/image%2024.png" alt="image.png" /></p>
<p>Ce ne sono una serie:</p>
<ul>
<li><strong><code>for_each</code></strong>: per ciascuno di quelli che ti passa chiama questa funzione</li>
<li><strong><code>try_for_each</code></strong>: prova a chiamare questa funzione, non appena questa funzione, che ritorna <code>Result</code>, ti d√† un <code>Error</code>, fermati</li>
<li><strong><code>collect</code></strong>: chiedigli tutti quelli che ha e inseriscili nella destinazione ‚Äî √® quello che abbiamo usato prima
<ul>
<li>cosa fa collect esattamente dipende da destinazione:
<ul>
<li>se la destinazione un <code>Vec</code> fa dei push dentro quel <code>Vec</code></li>
<li>se la destinazione √® una mappa cerca di inserire dentro la mappa</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>nth</code></strong>: sono interessato solo al <em>n-esimo</em> valore, tutti gli altri non li voglio</li>
<li><strong><code>all</code></strong> √® una funzione terminale che prova ad applicare una lambda a tutti gli elementi, e se a tutti quanti la lambda ritorna true, anche <code>all</code> ritorna true. Quindi verifica che tutti gli elementi su cui itera soddisfino quel predicato, e non appena ne incontra uno che non lo soddisfa si ferma e dice false</li>
<li><strong><code>any</code></strong> prova ad applicare la lambda, e se almeno uno gli d√† true si ferma e ritorna true</li>
<li><strong><code>find</code></strong> applica la lambda e ritorna il primo elemento per cui la lambda ritorna true, permettendoci di cercare un elemento specifico nella sequenza.</li>
<li><strong><code>count</code></strong> conta tutti gli elementi nell'iteratore e ritorna il totale.</li>
<li><strong><code>sum</code></strong> calcola la somma di tutti gli elementi numerici nell'iteratore.</li>
<li><strong><code>product</code></strong> calcola il prodotto di tutti gli elementi numerici nell'iteratore.</li>
<li><strong><code>max</code></strong> ritorna il valore massimo come <code>Option</code> (<code>None</code> se l'iteratore √® vuoto).</li>
<li><strong><code>max_by</code></strong> accetta una funzione di confronto personalizzata invece dell'operatore di comparazione standard, permettendo di specificare una chiave di confronto.</li>
<li><strong><code>min</code></strong>, <strong><code>min_by</code></strong> funzionano analogamente a <code>max</code> e <code>max_by</code>, ma cercano il valore minimo.</li>
<li><strong><code>position</code></strong> ritorna l'indice del primo elemento che soddisfa il predicato dato.</li>
<li><strong><code>reverse_position</code></strong> ritorna la posizione a partire dalla fine dell'iteratore.</li>
<li><strong><code>fold</code></strong> (noto anche come reduce) combina gli elementi usando un valore di accumulazione: parte da un valore iniziale, lo combina col primo elemento, poi combina il risultato col secondo elemento e cos√¨ via, riducendo la sequenza a un unico valore finale.</li>
</ul>
<p>Altri metodi: <strong><code>last</code></strong>, <strong><code>find_map</code></strong>, <strong><code>partition</code></strong>, <strong><code>reduce</code></strong>, <strong><code>compare</code></strong> eccetera‚Ä¶
Unico modo di conoscerli: provare ad usarli!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collezioni-di-dati---malnati-18"><a class="header" href="#collezioni-di-dati---malnati-18">Collezioni di dati - Malnati 18 <!-- omit in toc --></a></h1>
<h1 id="indice-12"><a class="header" href="#indice-12">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="13-collezioni_di_dati.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="13-collezioni_di_dati.html#11-strutture-dati-standard">1.1 Strutture Dati Standard</a>
<ul>
<li><a href="13-collezioni_di_dati.html#111-differenze-operative">1.1.1 Differenze Operative</a></li>
<li><a href="13-collezioni_di_dati.html#112-tipi-fondamentali-di-contenitori">1.1.2 Tipi Fondamentali di Contenitori</a></li>
<li><a href="13-collezioni_di_dati.html#113-implementazioni-multiple">1.1.3 Implementazioni Multiple</a></li>
<li><a href="13-collezioni_di_dati.html#114-scelta-della-struttura-dati">1.1.4 Scelta della Struttura Dati</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="13-collezioni_di_dati.html#2-tipi-di-contenitori">2. Tipi di contenitori</a>
<ul>
<li><a href="13-collezioni_di_dati.html#21-array-dinamico">2.1 Array Dinamico</a></li>
<li><a href="13-collezioni_di_dati.html#22-coda-a-doppia-entrata-o-deque">2.2 Coda a doppia entrata (o deque)</a></li>
<li><a href="13-collezioni_di_dati.html#23-lista-doppiamente-collegata">2.3 Lista doppiamente collegata</a></li>
<li><a href="13-collezioni_di_dati.html#24-coda-a-priorit%C3%A0">2.4 Coda a priorit√†</a></li>
<li><a href="13-collezioni_di_dati.html#25-mappe">2.5 Mappe</a></li>
</ul>
</li>
<li><a href="13-collezioni_di_dati.html#3-caratteristiche-delle-strutture-dati">3. Caratteristiche delle Strutture Dati</a>
<ul>
<li><a href="13-collezioni_di_dati.html#31-complessit%C3%A0-computazionale">3.1 Complessit√† Computazionale</a></li>
</ul>
</li>
<li><a href="13-collezioni_di_dati.html#4-vec">4. Vec</a></li>
<li><a href="13-collezioni_di_dati.html#5-vecdeque">5. VecDeque</a></li>
<li><a href="13-collezioni_di_dati.html#6-linkedlist">6. LinkedList</a></li>
<li><a href="13-collezioni_di_dati.html#7-mappe">7. Mappe</a>
<ul>
<li><a href="13-collezioni_di_dati.html#71-api-delle-mappe-in-rust">7.1 API delle Mappe in Rust</a>
<ul>
<li><a href="13-collezioni_di_dati.html#711-esempio-pratico">7.1.1 Esempio Pratico</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="13-collezioni_di_dati.html#8-insiemi">8. Insiemi</a></li>
<li><a href="13-collezioni_di_dati.html#9-binaryheap-priority-queue">9. BinaryHeap (Priority Queue)</a></li>
<li><a href="13-collezioni_di_dati.html#10-riferimenti">10. Riferimenti</a></li>
</ul>
<h1 id="1-introduzione-7"><a class="header" href="#1-introduzione-7">1. Introduzione</a></h1>
<h2 id="11-strutture-dati-standard"><a class="header" href="#11-strutture-dati-standard">1.1 Strutture Dati Standard</a></h2>
<p>Vogliamo concentrarci un attimo sui tipi standard di contenitori che ci vengono messi a disposizione da Rust e sugli algoritmi connessi per poterli gestire. La maggior parte di questi tipi li conoscete, tutti quanti avete fatto l'esame di algoritmi e programmazione avanzata e l√¨ vi hanno abbondantemente trattato per farvi capire una serie di cose. Tra le cose che vi dovrebbero essere riusciti a inculcare nella testa √® il concetto di <strong>complessit√† degli algoritmi</strong>.</p>
<h3 id="111-differenze-operative"><a class="header" href="#111-differenze-operative">1.1.1 Differenze Operative</a></h3>
<p>Perch√©? Perch√© a parit√† di problema io posso trovare delle soluzioni diverse che <em><strong>funzionalmente</strong></em> sono equivalenti ma <em><strong>operazionalmente</strong></em> non lo sono. Io posso tenere una sequenza di informazioni dentro un <code>Vec</code> o dentro una <code>linked list</code>. Entrambi sono dinamici, sono capaci di automaticamente allungarsi quanto serve per tenerne altri, sono capaci di contrarsi nel caso in cui serve, entrambi mi permettono di inserire all'inizio, a met√†, e al fondo, ma il <strong>costo di queste operazioni √® sostanzialmente diverso</strong>.</p>
<p>La scelta dell'uno piuttosto che dell'altro non √® dettata da problemi funzionali, perch√© tutti hanno la stessa esatta identica funzionalit√†: permettono di gestire sequenze unbounded nei limiti della memoria disponibile.
La scelta la faccio in funzione del <strong>tipo di accesso</strong>. Se prevalentemente devo inserire in mezzo, il <code>Vec</code> non mi conviene, perch√© mi fa fare un mucchio di operazioni inutili, la linked list molto di pi√π. Se in media devo accedere all'<em>i-esimo</em> elemento dove <code>i</code> non √® noto a priori, il <code>Vec</code> √® molto meglio, perch√© tenendo gli elementi compatti il costo di accedere al primo, al secondo, al centesimo elemento √® sempre lo stesso ‚Äî √® quello semplicemente di calcolare l'offset rispetto all'inizio.
Mentre nella linked list io posso raggiungere il centesimo elemento solo camminando 100 volte, seguendo 100 jump dal primo, al secondo, al terzo, al quarto, fino al centesimo. E chiaramente quell'operazione l√¨ dopo un po' mi sfianca, cio√® perdo una montagna di tempo nell'andare in giro.</p>
<h3 id="112-tipi-fondamentali-di-contenitori"><a class="header" href="#112-tipi-fondamentali-di-contenitori">1.1.2 Tipi Fondamentali di Contenitori</a></h3>
<p><img src="images/collezioni_di_dati/image.png" alt="image.png" /></p>
<p>Adesso ci concentriamo su questa cosa qua.</p>
<p>Di base tutti i linguaggi hanno questi tre fondamentali tipi:</p>
<ul>
<li><strong>Liste ordinate</strong>: contenitori capaci di mantenere in modo ordinato una sequenza di cose</li>
<li><strong>Insiemi</strong>: contenitori disordinati che possono contenere un dato valore <em>una volta sola</em></li>
<li><strong>Mappe</strong>: consentono di associare ad una chiave univoca un valore</li>
</ul>
<h3 id="113-implementazioni-multiple"><a class="header" href="#113-implementazioni-multiple">1.1.3 Implementazioni Multiple</a></h3>
<p>Ciascuno di queste tre categorie grosse di cose (poi ci sono ulteriori derivazioni, quando le vedremo: le deque, piuttosto che le queue, piuttosto che gli stack etc‚Ä¶) hanno possibilit√† di essere implementate in vario modo. Ad esempio, nel caso degli elementi ordinati, dei contenitori ordinati, io posso scegliere:</p>
<ul>
<li>Un <strong>algoritmo simile al <code>Vec</code></strong>: alloca blocchi contigui con elementi uno a fianco all'altro</li>
<li>Una <strong>linked list</strong>: elementi sparpagliati con puntatori al next e al previous</li>
</ul>
<h3 id="114-scelta-della-struttura-dati"><a class="header" href="#114-scelta-della-struttura-dati">1.1.4 Scelta della Struttura Dati</a></h3>
<p>Tocca al programmatore capire la complessit√† degli algoritmi associati alle strutture dati che sta usando e capire quando gli conviene usarne uno o quando gli conviene usarne l'altro. In Java voi avete la <code>LinkedList</code> e l'<code>ArrayList</code>. Tutti e due implementano l'interfaccia <code>java.util.List</code>, quindi sono identici dal punto di vista funzionale: hanno esattamente gli stessi metodi.</p>
<p>Il problema √® che non hanno lo stesso comportamento a runtime, in termini di prestazioni. In certi algoritmi conviene molto la linked list, in altri conviene l'array list.</p>
<h1 id="2-tipi-di-contenitori"><a class="header" href="#2-tipi-di-contenitori">2. Tipi di contenitori</a></h1>
<p><img src="images/collezioni_di_dati/image%201.png" alt="image.png" /></p>
<h2 id="21-array-dinamico"><a class="header" href="#21-array-dinamico">2.1 Array Dinamico</a></h2>
<p>√à un oggetto che, come un array, contiene un certo numero di elementi. Questi elementi sono contigui e sono garantiti a restare contigui. Si chiama dinamico perch√©, a differenza dell'array normale, che richiede al momento della sua creazione la definizione del numero di elementi che contiene (e il numero di elementi che contiene sar√† sempre solo quello), l'array dinamico <strong>permette di avere un numero di elementi che cambia nel tempo</strong>, per cui lo posso allargare o lo posso contrarre.</p>
<p>Questa struttura ha delle caratteristiche fondamentali.</p>
<p><strong>La prima</strong>, <strong>permette di inserire in coda a costo costante, a costo ammortizzato costante</strong>, perch√©?
Perch√© il principio √® che lui alloca un certo blocco, fin tanto che io cerco di inserire, questo blocco √® solo parzialmente in uso e quindi l'inserimento costa zero (perch√© sposto solo un puntatore o incremento un numero o una cosa del genere), e quando arrivassi a saturarlo la prossima allocazione mi fa duplicare lo spazio, quindi io ho a un certo punto un saltino: il costo √® <em>basso, basso, basso, ‚Ä¶, saltino, basso, basso, basso ‚Ä¶</em></p>
<p>Qui la tecnica √® che quando mi allargo <strong>raddoppio di dimensione</strong>, per cui i saltini all'inizio sono non tanto alti, perch√© ho poca roba da copiare, ma abbastanza frequenti e progressivamente via via che mi allargo sempre meno frequenti, i salti diventano sempre pi√π alti perch√© quando passo da 1024 a 2048 devo spostare 1024 cose e quindi chiaramente mi costa di pi√π che spostarne 16, in compenso poi per altri 1024 non mi costa pi√π niente, poi arrivato a 2048 duplico di nuovo, quindi un salto ancora pi√π alto, ma poi torno a stare tranquillo per altri 2048 elementi etc‚Ä¶ e <strong>questo fa s√¨ che il costo ammortizzato sia costante</strong>.</p>
<h2 id="22-coda-a-doppia-entrata-o-deque"><a class="header" href="#22-coda-a-doppia-entrata-o-deque">2.2 Coda a doppia entrata (o deque)</a></h2>
<p>Le <strong>code a doppia entrata</strong> sono degli oggetti che permettono a <strong>ammortizzato costo costante</strong> di inserire in testa o in coda.</p>
<p>Nel <code>Vec</code> normale se io inserisco alla posizione 0 √® costosissimo, perch√© li devo spostare tutti ‚Äî immaginate di avere una pila di piatti alta alta: quanto vi costa aggiungerne uno in cima? Poco. Quanta fatica vi costa infilarlo sotto? Devo tirare su tutta la pila e farci entrare quell'altro ‚Äî tanta fatica!</p>
<p>Nelle <code>VecDeque</code> quello che succede √® che i piatti invece di tenerli in pila verticalmente, li metto orizzontalmente e quindi mi costa poco aggiungere da entrambi i lati, perch√© ho le estremit√† libere. Se devo inserire a met√† ho sempre difficolt√† perch√© li devo spostare. Questa struttura si chiama in modo diverso: in Rust si chiama <code>VecDeque</code>, in C si chiama <code>deque</code>, in Java si chiama <code>ArrayDeque</code> e in Python √® un caso particolare della Package Collection che si chiama <code>deque</code>.</p>
<h2 id="23-lista-doppiamente-collegata"><a class="header" href="#23-lista-doppiamente-collegata">2.3 Lista doppiamente collegata</a></h2>
<p>Le <strong>liste doppiamente collegate</strong> hanno un puntatore al <em>next</em> e al <em>previous</em> per ogni elemento. L'oggetto lista che fa da testa contiene il <code>first</code> e il <code>last</code>, permettendo rapidi inserimenti. Costa poco inserire a met√† perch√© dovete solo sganciare due puntatori, inserire una cosa e riagganciarli. Facile, basta farlo nel modo giusto.</p>
<p>Viceversa, accedere all'<em>i-esimo</em> elemento dall'inizio vi costa attraversare tutti gli elementi precedenti. Questo esiste in Rust come <code>LinkedList</code>, in C++ come <code>list</code>, in Java come <code>LinkedList</code>, mentre in Python non esiste nella libreria standard.</p>
<h2 id="24-coda-a-priorit√†"><a class="header" href="#24-coda-a-priorit√†">2.4 Coda a priorit√†</a></h2>
<p>Le <strong>code a priorit√†</strong> (<em>Priority Queue</em>) sono strutture in cui, quando aggiungo un elemento, questo "galleggia" automaticamente verso l'uscita in base alla sua priorit√†. Questo serve quando devo ordinare elementi non per ordine di inserimento, ma per contenuto!</p>
<p>Pensate al pronto soccorso: le persone arrivano nel tempo ma non sono curate nell'ordine di arrivo, bens√¨ in base alla gravit√† ‚Äî chi sta per morire ha precedenza su chi ha un taglietto. Al triage vi assegnano un codice (bianco, verde, giallo, rosso) che determina l'urgenza.</p>
<p>Questo in Rust si chiama <code>BinaryHeap</code>, in C e Java <code>PriorityQueue</code>, in Python <code>heapq</code>.</p>
<p>Queste sono tutte <strong>strutture lineari</strong>, funzionalmente diverse. Solo le liste doppiamente collegate e i <code>Vec</code> si sovrappongono funzionalmente, gli altri hanno metodi aggiuntivi.</p>
<h2 id="25-mappe"><a class="header" href="#25-mappe">2.5 Mappe</a></h2>
<p>Le <strong>mappe</strong> sono collezioni di chiavi univoche associate a valori. Le chiavi devono essere:</p>
<ul>
<li><strong>immutabili</strong></li>
<li><strong>confrontabili</strong> (per determinare l'uguaglianza)</li>
<li>a seconda dell'implementazione: <em>ordinabili</em> o <em>hashable</em></li>
</ul>
<p>Ci sono due modi principali di implementare le mappe:</p>
<ul>
<li>Con <strong>tabelle hash</strong>, sfruttando chiavi hashable</li>
<li>Con <strong>binary tree</strong> ‚Äî alberi bilanciati dove ogni nodo ha due figli:
<ul>
<li>Il figlio sinistro ha chiavi minori della chiave del nodo</li>
<li>Il figlio destro ha chiavi maggiori della chiave del nodo</li>
</ul>
</li>
</ul>
<p>I B-tree si mantengono sempre il pi√π bilanciati possibile: se un ramo diventa troppo pesante, l'albero si riorganizza per bilanciare il peso dei rami. Questo rende il costo della ricerca omogeneo indipendentemente dal percorso seguito.</p>
<p>Questo fa s√¨ che gli inserimenti nei B-tree siano una cosa complicata, perch√© portano alla ristrutturazione dell'albero. Altrimenti se io inserisco le cose tutte ordinate a partire dal pi√π piccolo, partirei inizialmente dall'albero vuoto, il primo elemento che metto √® la radice, il secondo glielo appendo da un lato, poi appendo dallo stesso lato, poi ancora dallo stesso lato, e cos√¨ via, e questa cosa diventerebbe inefficientissima, perch√© si trasforma in una lista.</p>
<p>Di conseguenza, appena arrivo ad inserire il terzo, quell'albero mi fa un pezzo di giro, si ribalta e sceglie come radice non pi√π l'elemento che ho inserito per il primo, ma il secondo, e a quel punto l√¨ il secondo ne ha uno a destra e uno a sinistra, e va meglio.</p>
<p>Se vado avanti ad inserire ancora sempre uno che starebbe sempre dalla destra, lui dopo un po' si ribalta di nuovo e va avanti in questo modo per garantirmi una lettura pi√π o meno uniforme. Quindi quell'algoritmo l√¨ √® complicato da implementare. Mi garantisce un tempo di accesso alla chiave <em>i-esima</em> pari al <strong>logaritmo in base 2</strong> del numero di chiavi presenti. Mentre quando scelgo l'algoritmo di hashing, l'accesso all'<em>i-esimo</em> elemento √® <strong>circa costante</strong>, circa, dipende da quanti conflitti di hash ho.</p>
<p>Di base la <strong>tabella hash</strong> ha associato a ciascuna chiave un valore. I <strong>set</strong> sono semplicemente delle tabelle hash o dei B-tree dove non c'√® il valore, dove l'unica cosa che guardo √® la chiave. La chiave, se c'√®, √® presente una volta sola. Quindi gli hash sono, in tutti i linguaggi, implementati in questa maniera qua, come delle hash map il cui valore non √® presente.</p>
<p>Le <strong>hash map</strong> esistono in Java, in C, in C++ con nomi diversi, si chiamano <code>HashMap</code> in Rust, <code>unordered_map</code> in C++, <code>HashMap</code> in Java, <code>dict</code> in Python.
Le <strong>mappe binarie basate sui B-tree</strong>, in Rust si chiamano <code>BTreeMap</code>, in C++ si chiamano <code>map</code> semplicemente, in Java si chiamano <code>TreeMap</code>, in Python non esistono nella libreria standard.</p>
<p>Ed infine gli <strong>insiemi hash</strong> si chiamano <code>HashSet</code> su Rust, <code>unordered_set</code> su C++, <code>HashSet</code> in Java, <code>set</code> in Python, e di nuovo il corrispondente basato sui B-tree, <code>BTreeSet</code> in Rust, <code>set</code> in C++ e <code>TreeSet</code> in Java.</p>
<h1 id="3-caratteristiche-delle-strutture-dati"><a class="header" href="#3-caratteristiche-delle-strutture-dati">3. Caratteristiche delle Strutture Dati</a></h1>
<p><img src="images/collezioni_di_dati/image%202.png" alt="image.png" /></p>
<p>Qui sono segnato <strong>quattro operazioni fondamentali</strong>:</p>
<ul>
<li>Quanto costa <strong>accedere</strong> all'<em>i-esimo</em> elemento</li>
<li>Quanto costa <strong>cercare</strong> se √® presente un certo elemento</li>
<li>Quanto costa <strong>inserire</strong></li>
<li>Quanto costa <strong>cancellare</strong></li>
</ul>
<p>Adesso inserire √® un po' una fregatura, perch√© dipende da dove inserisco. I numeri che qua sono riportati considerano l'inserimento in una posizione <em>non ottimale</em>. Chiaro che l‚Äôarrray dinamico se l'inserisco in coda √® <strong>O(1)</strong>. Qui consideriamo l'inserimento in una posizione arbitraria.</p>
<p>Allora vediamo che ci sono degli aspetti duali: l‚Äôarray dinamico ha <strong>costo di accesso O(1)</strong> in una posizione arbitraria, perch√© siccome gli elementi sono contigui, io vado direttamente a quella posizione l√¨ e sono tranquillo, mentre la lista doppiamente collegata a <strong>costo O(n)</strong>, se devo raggiungere la posizione <em>n-esima</em>.</p>
<p>Al contrario, se sono gi√† nella posizione <em>n-esima</em> e devo inserire, l‚Äôinserimento mi costa <strong>O(1)</strong> nella lista doppiamente collegata, perch√© sono gi√† l√¨: smonto, attacco i puntatori e li riaggancio.
Nell‚Äôarray dinamico invece devo prendere tutti quelli che mi seguono e spostarli avanti di un passo. E questo pu√≤ essere pi√π o meno oneroso.</p>
<p>Nelle code a doppia entrata io ho dei <strong>costi unitari</strong> in cima e al fondo e ho dei <strong>costi O(n)</strong> quando inserisco a met√†, perch√© devo fare un po' di spazio a destra o a sinistra, a secondo di come viene meglio.</p>
<p>Le tabelle hash mediamente hanno <strong>costo unitario</strong>, in modo amortizzato. Gli algoritmi di hash dipendono da quante collisioni si verificano. Se l'algoritmo di hashing √® molto buono, mi spande su un range molto grande e quindi rende le collisioni poco probabili. Nel momento in cui l'algoritmo di hash fosse fatto male, ad esempio se io implemento come algoritmo di hash una costante, tutti i valori hanno come hash code sempre 3 e tutti confliggono e quindi le tabelle di hash diventano delle liste ordinate, costosissime.</p>
<h2 id="31-complessit√†-computazionale"><a class="header" href="#31-complessit√†-computazionale">3.1 Complessit√† Computazionale</a></h2>
<p><img src="images/collezioni_di_dati/image%203.png" alt="image.png" /></p>
<p>Quando diciamo che certe cose sono <strong>O(1)</strong>, <strong>O(n)</strong>, o <strong>O(log n)</strong>, cosa vogliamo dire?
Vogliamo dire che al crescere della dimensione dei dati io avr√≤ dei costi progressivamente pi√π grandi. Ma grandi come?</p>
<ul>
<li><strong>O(1)</strong>: costo costante</li>
<li><strong>O(log n)</strong>: cresce lentamente</li>
<li><strong>O(n)</strong>: cresce con pendenza costante</li>
<li><strong>O(n log n)</strong>: sale pi√π di n, ma non verticalmente</li>
<li><strong>O(n¬≤)</strong>: parabola</li>
<li><strong>O(n¬≥)</strong>: parabola ancora pi√π stretta</li>
</ul>
<p>Gi√† solo vedere l'algoritmo quadratico, <strong>O(n¬≤)</strong>, ci fa capire molto in fretta che se noi abbiamo scritto un algoritmo quadratico quella roba l√¨ diventa rapidamente inusabile. Perch√© per poco che aumentiamo la dimensione dei nostri dati, i tempi schizzano e diventano inaccettabili. Quindi bisogna fare molta attenzione a come noi scriviamo le cose.</p>
<p>Se mi chiedo quali sono gli elementi del gruppo <strong>A</strong> che sono anche presenti nel gruppo <strong>B</strong> e mi metto a confrontare tutti gli <strong>A</strong> con tutti i <strong>B</strong>, faccio necessariamente un <strong>algoritmo quadratico</strong>. Perch√© devo prendere tutti gli <strong>A</strong> uno alla volta e mi chiedo: <em>‚Äútu sei uguale al primo dei <strong>B</strong>?‚Äù</em>, <em>‚Äúsei uguale al secondo?‚Äù</em>, <em>‚Äúsei uguale al terzo?‚Äù</em>, e cos√¨ via‚Ä¶ Poi prendo il secondo degli <strong>A</strong>, e riparto: chiedo <em>‚Äúsei uguale al primo dei <strong>B</strong>?‚Äù</em> etc‚Ä¶ un algoritmo del genere viene quadratico.</p>
<p>Finch√© quei due insiemi sono piccolini chi se ne frega, ma quando quei due insiemi cominciano a diventare cento da una parte e cento dall'altra il prodotto fa <strong>diecimila</strong>. Se sono mille di qua e mille di l√† diventa un <strong>milione</strong>. Capite che i tempi si allungano in fretta e diventano ingestibili.</p>
<p>Per questo usiamo le <strong>strutture dati</strong>. Le strutture dati sono pensate per permetterci degli accessi opportuni. In certe situazioni noi teniamo le stesse informazioni rappresentate in tredici modi diversi.</p>
<p><em>Perch√©?</em> Perch√© ci serve una <strong>mappa</strong> per accedere in fretta al dato se conosco una certa cosa. Ci serve una <strong>lista</strong> per poter accedere in fretta se conosco la sua posizione. Ci serve magari una <strong>priority queue</strong> per trovare quali di questi √® quello pi√π importante in un certo momento.</p>
<p>Quindi pu√≤ essere conveniente in certi casi, per evitare di far diventare l'algoritmo ingestibile, dire che io <strong>moltiplico le rappresentazioni</strong> del mio dato. Lo tengo in contenitori diversi. Ovviamente lo devo tenere allineato: tutte le volte che aggiungo un nuovo pezzettino lo devo aggiungere in <em>tutti</em> i contenitori, tutte le volte che cancello un pezzettino lo devo cancellare da <em>tutti</em> i contenitori. Perch√© la struttura deve rimanere coerente. Cos√¨ sono tranquillo che posso trovare le mie informazioni.</p>
<p><img src="images/collezioni_di_dati/image%204.png" alt="image.png" /></p>
<p>Limitandoci a Rust, tutte le diverse strutture dati (quindi <code>Vec</code>, <code>LinkedList</code>, <code>HashMap</code>, <code>HashSet</code> etc‚Ä¶) hanno una serie di metodi che condividono, che rendono l'uso di queste strutture facile. Tutte contengono <code>new</code> che dice <em>"crea una nuova collezione vuota"</em>.
Tutte hanno <code>len</code> che mi dice quanti elementi sono presenti in questa collezione.
Tutte hanno <code>clear</code> che dice <em>"qualunque cosa ci sia dentro buttala via e parti vuota"</em>.
<code>is_empty</code> √® l'equivalente di <code>len == 0</code> (cio√® <em>‚Äúla collezione √® vuota?‚Äù</em> ‚Äî <code>is_empty</code> restituisce <em>true</em> se non c'√® niente, <em>false</em> se c'√® qualcosa).
Tutte hanno <code>iter</code>, cio√® la possibilit√† di esplorare quello che c'√® dentro.</p>
<p>Notate che non tutte hanno <code>into_iter</code> perch√© mentre io posso sbriciolare un array non posso sbriciolare una mappa. Perch√© per come la mappa √® implementata in Rust, sbriciolarla sarebbe un grosso problema, la <code>HashMap</code> soprattutto.</p>
<p>Dopodich√© tutte quante hanno i tratti <code>IntoIterator</code> e <code>FromIterator</code>.
Il tratto <code>IntoIterator</code> mi permette, data una collezione, di ricavare l'iteratore relativo.
Il <code>FromIterator</code> al contrario dice: dato un iteratore, riempi questa collezione con i dati che vengono.</p>
<h1 id="4-vec-1"><a class="header" href="#4-vec-1">4. Vec</a></h1>
<p><img src="images/collezioni_di_dati/image%205.png" alt="image.png" /></p>
<p><code>Vec</code> √® il tipo assolutamente pi√π fondamentale da usare in Rust, lo abbiamo usato tante volte, √® il cavallo da lavoro di Rust. Tutto Rust √® stato progettato attorno a <code>Vec</code>, <code>Vec</code> √® estremamente ottimizzato, le scelte che sono state fatte al suo interno tendono a essere il meglio possibile perch√© sostituisce completamente il concetto di <em><strong>allocatore</strong></em> ‚Äî in Rust non abbiamo l'equivalente della <code>malloc</code>, almeno nel Rust safe (nell'unsafe certamente s√¨), ma di base se ci serve allocare della memoria l'unico metodo pi√π efficace possibile che √® stato limato in tutti i modi nei vari sistemi operativi eccetera, √® creare un <code>Vec</code>!</p>
<p>E quel <code>Vec</code> l√¨ √® capace di allocare un blocco di una certa dimensione.</p>
<p>Posso creare un <code>Vec</code> in tanti modi: certamente con il <code>new</code>, <code>Vec::new</code> me ne crea uno vuoto.
Posso usare la macro <code>vec![...]</code> e mi genera un vettore che √® pre-inizializzato con quella cosa l√¨.
Posso creare un <code>Vec</code> con i costruttori derivati, con un <code>with_capacity</code>, ad esempio questo mi prepara un <code>Vec</code> che ha preallocato un array di una certa dimensione.</p>
<p>Il <code>Vec with_capacity</code> √® quello che mi permette di sostituire sostanzialmente la <code>malloc</code> perch√© mi d√† accesso a un blocco che posso dire grande quanto mi pare.</p>
<p>Internamente abbiamo gi√† visto un <code>Vec</code> ha tre valori privati: c'√® un puntatore sullo heap che pu√≤ essere nullo nel momento in cui il <code>Vec</code> √® completamente vuoto; se non √® nullo punta un blocco la cui dimensione √® specificato dal campo <code>capacity</code> che √® privato, e di quel campo <code>capacity</code> <code>size</code> elementi (con <code>size</code> minore o uguale a <code>capacity</code>) sono in uso, e la parte restante √® libera, pronta a essere usata.</p>
<p>Questo √® il principale strumento per la gestione dei dati.</p>
<p><img src="images/collezioni_di_dati/image%206.png" alt="image.png" /></p>
<p>Posso inserire degli elementi dentro il vettore facilmente con il metodo <code>push</code> che inserisce al fondo.</p>
<p>Ci sono anche dei metodi che mi permettono di inserire a una posizione che non sia il fondo.
<strong>Attenzione:</strong> se io gli indico di inserire ad una posizione che attualmente non √® dell'array (e quindi gli dico l'array ha tre elementi e io chiedo di inserire alla posizione 7) i metodi panicano.</p>
<p>Quello che lui sa √® che se io cerco di aggiungere al fondo finch√© la <code>capacity</code> glielo consente occupa un pezzo dello spazio che si √® gi√† preso. Nel momento in cui si trovasse ad aver riempito tutto lo spazio che avevamo richiesto e non gli basta pi√π, internamente fa partire un processo di riallocazione ‚Äî quindi chiede al sistema operativo un blocco grosso il doppio dell'originale, muove tutto quello che ha nel nuovo blocco, libera il vecchio blocco e aggiunge l'elemento aggiuntivo nel primo spazio libero che si √® venuto a creare.</p>
<p>Possiamo usare la notazione con le <code>[]</code> per accedere all'<em>i-esimo</em> elemento e farci dare un reference l√¨ dentro, oppure possiamo usare i metodi <code>get</code> e <code>get_mut</code> che ci danno rispettivamente un reference all'<em>i-esimo</em> e un reference mutabile.
<strong>Nota:</strong> <code>get</code> e <code>get_mut</code> ci danno un <code>Option</code>, nel senso che se l'indice <code>i</code> che indichiamo √® farlocco ci danno <code>None</code>. Viceversa se l'indice <code>i</code> √® buono ci danno <code>Some</code> e all'interno di <code>Some</code> c'√® scritto il riferimento vero e proprio. Mentre se usiamo le parentesi quadre, come anticipato prima, queste danno <code>panic</code> se l‚Äôindice non √® valido.</p>
<p><img src="images/collezioni_di_dati/image%207.png" alt="image.png" /></p>
<p>Qui c'√® una lista di metodi che <code>Vec</code> offre, pi√π o meno li conosciamo gi√† tutti:</p>
<ul>
<li><code>with_capacity</code>: alloca un vettore con una certa capacit√†</li>
<li><code>capacity</code>: ci dice qual √® la capacit√† corrente del nostro vettore</li>
<li><code>push</code>: aggiunge al fondo</li>
<li><code>pop</code>: torna l'ultimo elemento sotto forma di <code>Option</code> che pu√≤ essere <code>Some</code> di qualcosa se il nostro vettore aveva un ultimo elemento, <code>None</code> se il nostro vettore era vuoto</li>
<li><code>insert</code>: cerca di inserire alla posizione indicata il valore (se la posizione indicata √® illecita panica)</li>
<li><code>remove</code>: cerca di togliere l'elemento dalla posizione indicata (se anche questa non va, panica)</li>
<li><code>first</code>/<code>last</code>: ci permettono di avere un riferimento al primo/ultimo elemento</li>
<li><code>get</code>: ci permette anche una versione che accetta come parametro un range (es: da 1 a 7), cerca di prendere lo slice, ci restituisce il riferimento allo slice l√¨ dentro sotto forma di <code>Option</code></li>
</ul>
<p><img src="images/collezioni_di_dati/image%208.png" alt="image.png" /></p>
<p>Il <strong>vincolo</strong> per creare un <code>Vec</code> √® che i dati contenuti al suo interno devono essere dello stesso tipo: noi creiamo dei <code>Vec</code> di <code>i32</code>, dei <code>Vec</code> di <code>String</code>, dei <code>Vec</code> di qualcos'altro, ma c'√® <em>omogeneit√†</em> ‚Äî il tipo √® <code>Vec&lt;T&gt;</code>, quindi tutto deve essere pari al tipo <code>T</code>.</p>
<h1 id="5-vecdeque"><a class="header" href="#5-vecdeque">5. VecDeque</a></h1>
<p><img src="images/collezioni_di_dati/image%209.png" alt="image.png" /></p>
<p>Il tipo <code>VecDeque</code> √® un tipo che merita un secondo di ragionamento, perch√© l'implementazione che √® stata fatta dentro Rust, pur garantendo lo stesso comportamento funzionale, √® sostanzialmente diverso da quello che √® stato fatto in C++.</p>
<p>Un <code>VecDeque</code>, in C++, lo possiamo immaginare come una LinkedList di Vector, quindi io ho un buffer di una certa dimensione che ha un puntatore a quello che viene dopo e un puntatore a quello che viene prima.</p>
<p>Ho questa catena di buffer pi√π o meno grande, e se devo inserire vado sull'ultimo e inserisco nel buffer, se posso. Se invece lui ha gi√† raggiunto il massimo della sua capacit√†, ne alloco uno ulteriore a valle. Se devo inserire in testa guardo il primo della mia catena: se ha spazio in testa inserisco direttamente l√¨, se no ne alloco uno precedente e estendo ulteriormente il <code>VecDeque</code>. Cos√¨ √® come funzionano le cose in C++.</p>
<p>La scelta di Rust √® stata un'altra completamente ‚Äî quella cosa l√¨ √® complicata da far funzionare bene in modo safe per darsi garanzie delle cose e quindi <strong>Rust riduce il VecDeque a un Vec</strong>. Quindi internamente √® un <code>Vec</code>, solo che invece di popolarlo dall'indice 0 a crescere fino all'n, lo tratta come un <em><strong>buffer circolare</strong></em>.</p>
<p>Inizialmente abbiamo un buffer vuoto con una capacit√† di 32 elementi. Quando inseriamo il primo elemento, lo mettiamo in posizione 0, e quando ne aggiungiamo un altro in coda, va in posizione 1. Se dobbiamo inserire un elemento in testa ‚Äî mentre un <code>Vec</code> normale dovrebbe spostare i due elementi esistenti di una posizione per fare spazio ‚Äî il <em>buffer circolare</em> lo gestisce diversamente: avendo un elemento in 0 e uno in 1, mette il nuovo elemento in posizione 31, che diventa l'inizio. Un altro elemento in testa? Va in posizione 30. A questo punto abbiamo libere le posizioni dalla 2 alla 29 ‚Äî se aggiungiamo in coda, usiamo la posizione 2, poi la 3 e cos√¨ via.</p>
<p>Ad un certo punto questi due estremi si toccano, non mi sta pi√π n√© in testa n√© in coda, <em>che faccio?</em> <strong>Duplico</strong> ‚Äî prima era lungo 32, ne alloco uno da 64 e a quel punto me li piazzo comodi, quindi me li sposto tutti quanti in modo che comincino da 1 a 32 e ripeto cos√¨.</p>
<p>Quindi il <code>VecDeque</code> internamente √® di fatto un <code>Vec</code>, semplicemente che questo <code>Vec</code> invece di assumere che comincia sempre alla posizione 0, pu√≤ cominciare a una posizione qualunque perch√© √® trattato da <em>buffer circolare</em>.
Di fatto quindi ha un indice in pi√π, infatti da questo punto di vista ha un campo interno in pi√π rispetto all'altro, perch√© gli dice <code>first</code> e <code>last</code>, che gli permette di capire se c'√® ancora spazio. Nel momento in cui non c'√® pi√π spazio perch√© i due indici sono arrivati a toccarsi, si rialloca, ne prende uno pi√π grande e lo spazio si crea automaticamente.</p>
<p>Ci garantisce che gli elementi sono collettivamente tutti nel suo buffer, ma non sono necessariamente contigui, perch√© io ne posso avere una parte all'inizio e una parte sul fondo. C'√® un metodo che possiamo chiamare, che lui chiama automaticamente quando si allarga, che √® <code>make_contiguous</code>, che se √® diviso in due parti prima e dopo sposta in modo da appiccicarli.</p>
<h1 id="6-linkedlist"><a class="header" href="#6-linkedlist">6. LinkedList</a></h1>
<p><img src="images/collezioni_di_dati/image%2010.png" alt="image.png" /></p>
<p><strong>LinkedList</strong> √® ottimale in quelle situazioni in cui abbiamo bisogno di mantenere un ordine e inserire a met√†. Inserire tipicamente nel contesto di qualche iterazione. I metodi che LinkedList offre sono scarsi, non √® un granch√©, i signori di Rust non hanno fatto grossi sforzi per implementare LinkedList e ci dicono <em>"guarda, se puoi evitala".</em> Perch√© mentre Vec √® il massimo dell'ottimizzazione, LinkedList √® una schifezza, quindi in termini prestazionali √® assai bassa.</p>
<h1 id="7-mappe"><a class="header" href="#7-mappe">7. Mappe</a></h1>
<p><img src="images/collezioni_di_dati/image%2011.png" alt="image.png" /></p>
<p>Due implementazioni possibili, <strong><code>HashMap</code></strong> e <strong><code>BTreeMap</code></strong>.</p>
<p><strong>HashMap</strong></p>
<ul>
<li>costo costante di accesso</li>
<li>richiede che la chiave abbia un algoritmo di hash associato</li>
</ul>
<p>Quindi la chiave, il tipo <code>K</code> che noi usiamo per rappresentare la chiave, deve avere il tratto <code>Hash</code> e anche il tratto <code>Eq</code>.
<em>Perch√©?</em> Perch√© se io ho due oggetti che mi danno lo stesso hash code, devo poter chiedermi se sono anche uguali tra di loro oppure no, per decidere se √® una collisione oppure se ho beccato l'elemento giusto.</p>
<p><strong>BTreeMap</strong>
Nel momento in cui so di avere chiavi che hanno un ordine naturale, pu√≤ essere conveniente usare una <strong><code>BTreeMap</code></strong>. Questo pu√≤ essere utile se come chiavi ad esempio ho delle stringhe, o a volte i numeri, perch√© per certi aspetti posso avere alcune facilitazioni. In ogni caso la chiave deve essere univoca e immutabile. Non va bene avere una chiave che possa cambiare perch√© spaccherebbe tutti gli algoritmi.</p>
<h2 id="71-api-delle-mappe-in-rust"><a class="header" href="#71-api-delle-mappe-in-rust">7.1 API delle Mappe in Rust</a></h2>
<p><img src="images/collezioni_di_dati/image%2012.png" alt="image.png" /></p>
<p>Attenzione, le mappe in Rust hanno un API che √® totalmente diversa dalla implementazione che √® presente altrove. La mappa possiede sia le chiavi che i valori. Siccome capire dove andare a mettere un'eventuale chiave se ancora non ce l'ho √® un'operazione delicata, Map mi offre un API che √® ottimizzata per far s√¨ che se io cerco di inserire qualcosa che non c'√®, lui questa ricerca la faccia una volta sola. Ma non √® ovvio com'√® fatta, quindi ci spendiamo due parole sopra per andare a vedere.</p>
<p><img src="images/collezioni_di_dati/image%2013.png" alt="image.png" /></p>
<p>Di base io posso chiedermi se un elemento c'√® o non c'√® attraverso il metodo <code>entry</code>.
<code>entry</code> prende una chiave e mi restituisce un oggetto di tipo "<code>Entry</code>" con la E maiuscola.</p>
<p>Pu√≤ darsi che quella chiave l√¨ nella mappa ci sia oppure che non ci sia. Di conseguenza l'oggetto <code>Entry</code> mi offre due metodi. <code>and_modify</code> che dice <em>"nel caso in cui ce l'ho ti lascio fare dei cambiamenti, nel caso in cui io non ce l'abbia te lo faccio cambiare".</em></p>
<h3 id="711-esempio-pratico"><a class="header" href="#711-esempio-pratico">7.1.1 Esempio Pratico</a></h3>
<p>Qui c'√® l'esempio banale in cui voglio contare quante volte una certa parola compare in un certo testo. Per sapere quante volte una parola compare in un certo testo, parto con una mappa che √® inizialmente vuota. Questa mappa avr√† come chiavi le singole parole e come valori dei numeri. Inizialmente la mappa √® vuota.</p>
<p>Nel momento in cui io comincio a leggere il mio testo, prendo la prima parola e mi chiedo <em>"questa qua c'√® nella mappa?".</em></p>
<p>Allora, nei linguaggi Java, Python, e altri, quello che farei √® un'operazione del tipo <code>if map.getKey(myWord) map[key] += 1</code> ‚Üí Cio√® mi chiedo <em>"ce l'ho questa chiave? S√¨".</em> Allora accedo al valore e lo incremento.
<code>else map(key)=1</code> ‚Üí Non ce l'ho, allora creo una entry.</p>
<p>Questo mi permette di popolare la mappa.</p>
<p>Piccolo problema: fatto cos√¨, io nei due casi rischio in due volte di andarmi a cercare qual √® la chiave su cui devo operare.</p>
<p>Invece, vediamo che in Rust, come da slide, <code>.entry</code> dice <em>"vai a vedere se questa cosa c'√®" ‚Äî</em> se la trovi, a questo punto puoi modificarla col metodo <code>and_modify</code> o inserirla con <code>insert</code>. <code>and_modify</code> prende una lambda che mi permette di ricevere il valore e mi permette di descrivere come aggiorno il valore (In questo caso <code>*v+=1</code>. Prendo un <code>ref_mut</code> al valore). Altrimenti, <code>insert</code> mi d√† la possibilit√† di dire cosa mettere, quindi la chiave verr√† inserita l√¨ dentro.</p>
<p><img src="images/collezioni_di_dati/image%2014.png" alt="image.png" /></p>
<p><strong>√à importante capire questo concetto.</strong></p>
<p>Le mappe le posso creare a partire da tuple. <code>HashMap::from</code> prende in questo caso un array di tuple dove il primo elemento della tupla √® la <em>chiave</em> e il secondo elemento √® il <em>valore</em>. Dopodich√© io qui vado a cercare se c'√® una certa chiave di cui voglio modificare il valore.</p>
<p>Notate che non sono obbligato a fare, dato una <code>entry</code>, sempre sia l'<code>and_modify</code> che lo <code>insert</code>. Ad esempio qui all‚Äôistruzione <code>scores.entry("Carol").and_modify()</code> ‚Äî se per caso ho "Carol" tra i miei valori, cambio qualcosa. Se non ce l'ho non faccio niente, va tutto bene.</p>
<p>Ho la possibilit√† di trasformare la mia mappa in qualcos'altro. In <code>into_iter()</code>  ‚Äî la sbriciolo e <code>collect()</code>.
Poi ordino per valore, <code>sort_by_key()</code>, perch√© a questo punto io ho trasformato il mio vettore in tuple.</p>
<p>Le mappe non si possono ordinare direttamente, poich√© la mappa gestisce la propria struttura interna in modo autonomo. Quando si itera su una mappa, gli elementi vengono restituiti nell'ordine determinato dall'algoritmo interno della mappa, che non corrisponde necessariamente all'ordine di inserimento. Per esempio, se inseriamo gli elementi con chiave 1, chiave 2, chiave 3, potremmo ottenere chiave 3, chiave 1, chiave 2, in base alla funzione di hash utilizzata.</p>
<h1 id="8-insiemi"><a class="header" href="#8-insiemi">8. Insiemi</a></h1>
<p><img src="images/collezioni_di_dati/image%2015.png" alt="image.png" /></p>
<p><strong>Gli insiemi (Sets)</strong> sono abbastanza simili alle mappe: sono proprio implementati come mappe in cui non c'√® il valore, c'√® solo la chiave.</p>
<h1 id="9-binaryheap-priority-queue"><a class="header" href="#9-binaryheap-priority-queue">9. BinaryHeap (Priority Queue)</a></h1>
<p><img src="images/collezioni_di_dati/image%2016.png" alt="image.png" /></p>
<p><strong>Priority queue</strong>, qui si chiamano <code>BinaryHeap</code>.</p>
<p>Binary heap ammette soltanto oggetti che siano ordinabili e li tiene dal pi√π grande al pi√π piccolo. Chiaramente qui conviene mettere degli oggetti in cui si implementa il tratto <code>Ord</code> in modo coerente con il concetto di priorit√† che vogliamo dare. In prima posizione c'√® sempre il pi√π grande e a seguire quelli via via pi√π piccoli. Possiamo guardare che cosa c'√® all'interno con <code>peek()</code> e cose del genere.</p>
<h1 id="10-riferimenti-1"><a class="header" href="#10-riferimenti-1">10. Riferimenti</a></h1>
<p><img src="images/collezioni_di_dati/image%2017.png" alt="image.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-e-io---malnati-19"><a class="header" href="#file-e-io---malnati-19">File e I/O - Malnati 19 <!-- omit in toc --></a></h1>
<h1 id="indice-13"><a class="header" href="#indice-13">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="14-file_io.html#1-introduzione">1. Introduzione</a></li>
<li><a href="14-file_io.html#2-percorsi--path-e-pathbuf">2. Percorsi ‚Äî <code>Path</code> e <code>PathBuf</code></a></li>
<li><a href="14-file_io.html#3-navigare-il-file-system">3. Navigare il file system</a></li>
<li><a href="14-file_io.html#4-manipolare-i-file-nel-file-system">4. Manipolare i file nel file system</a></li>
<li><a href="14-file_io.html#5-i-tratti-relativi-a-io">5. I tratti relativi a I/O</a>
<ul>
<li><a href="14-file_io.html#51-il-tratto-read">5.1 Il tratto <code>Read</code></a></li>
<li><a href="14-file_io.html#52-il-tratto-bufread">5.2 Il tratto BufRead</a>
<ul>
<li><a href="14-file_io.html#521-esempio">5.2.1 Esempio</a></li>
</ul>
</li>
<li><a href="14-file_io.html#53-il-metodo-write">5.3 Il metodo <code>Write</code></a></li>
<li><a href="14-file_io.html#54-il-tratto-seek">5.4 Il tratto <code>Seek</code></a></li>
</ul>
</li>
<li><a href="14-file_io.html#6-il-framework-serde">6. Il framework <code>Serde</code></a></li>
</ul>
<h1 id="1-introduzione-8"><a class="header" href="#1-introduzione-8">1. Introduzione</a></h1>
<p>Spessissimo le nostre applicazioni hanno l'<strong>esigenza di mantenere nel tempo</strong> delle informazioni.</p>
<p>Il modo base con cui i sistemi operativi offrono l'approccio alla persistenza √® tramite il <strong>concetto di file</strong> e <strong>Rust</strong>, di conseguenza, attraverso la sua libreria standard, ci offre meccanismi per poter accedere ai file system.</p>
<p>Sapendo che i file system, pur concettualmente essendo presenti in <em>tutti i sistemi operativi</em>, sono praticamente diversi nelle loro varie installazioni.</p>
<p>Per cui, ad esempio, nel mondo <strong>Windows</strong> esistono molteplici file system che convivono parallelamente, per cui voi avete per ciascun volume in realt√† una cartella radice che rappresenta quel disco, quindi i due punti, i due punti, ecc. ‚Äî Sono in qualche modo separati.</p>
<p>Nel mondo <strong>Unix</strong>, viceversa, l'intero file system viene ricondotto a un'unica radice su cui eventualmente sono montati all'interno di particolari cartelle degli altri volumi, che per√≤ diventano parte di un'unica gerarchia.</p>
<p>Le notazioni usate nei file system sono simili ma diverse, banalmente i separatori di cartella nel mondo Unix sono basati sullo <code>/</code> (slash), in avanti nel mondo Windows sono basati sul <code>\</code> (backslash).</p>
<p>La natura dei nomi dei file nel tempo ha avuto delle manifestazioni.</p>
<p>Questi sono gli elementi <em>macroscopici</em> del file system, poi ci sono tutta una serie di dettagli ulteriori.</p>
<p>I singoli file all'interno del file system dispongono di <strong>metadati</strong>.</p>
<p>Esiste un <strong>owner</strong> di quel file l√¨, cio√® quell'utente che √® possessore del file stesso e che pu√≤ avere, in quanto owner, certi <em>diritti di lettura, di scrittura, di esecuzione.</em></p>
<p>Nel mondo Unix si aggiunge il concetto di <em><strong>gruppo</strong></em>.
Quell'unico file l√¨ appartiene anche a un certo gruppo, e di conseguenza tutti gli utenti che fanno parte del medesimo gruppo possono avere permessi dettagliati.</p>
<p>Poi ci sono tutti gli utenti che non sono n√© owner, n√© quelli che appartengono al gruppo di cui √® dichiarato appartenere il file. Questi sono genericamente gli <em><strong>others</strong></em>, che hanno ulteriori caratteristiche.</p>
<p><em>Nel mondo Windows questa distinzione √® molto pi√π complessa, perch√©?</em>
Sebbene ci sia ancora l‚Äôowner, i privilegi di accesso ai file sono molto pi√π complessi in quanto io posso aggiungere regole ad hoc che dicono <em>"Questo file lo vedono tutti tranne tizio"</em> oppure tranne quelli che hanno <em>certe caratteristiche</em>.
Quindi andando a dare delle espressioni molto pi√π articolate rispetto a quelle del sistema Unix e Unix-like.</p>
<p>Poi ci sono i <em>finti file</em>, ovvero delle cose che <em>appaiono</em> come elementi del file system, ma in realt√† non sono dei veri file che risiedono sul disco, ma vengono fatti apparire come tali.
Ad esempio se avete una mattina Linux avete una cartella che si chiama <code>/proc</code>. Le cartelle presenti all'interno di <code>/proc</code> non sono veri file. I loro nomi sono numeri e corrispondono agli id dei processi in questo momento in funzione.</p>
<p>Per cui <code>/proc/3274</code> contiene degli altri finti file che danno informazioni ulteriori circa quello che sta facendo il processo 3274. Quindi ci trovate la mappa ad esempio della sua memoria, ci trovate i consumi che vengono fatti della CPU, tutta una serie di informazioni...
Se andiamo a guardare dentro il disco non c'√® quella cartella, nel momento in cui il processo 3274 finisce, quella cartella svanisce.</p>
<p>Ci sono poi i file speciali. Di nuovo, il mondo Unix √® pieno di queste cose qua:</p>
<ul>
<li>Alcuni file sono quelli presenti nella cartella <code>/dev</code>, ad esempio <code>/dev/tty</code> per esempio sembra un file ma in realt√† mappa sulla porta seriale 1. Fisicamente se voi scrivete dei byte l√¨ sopra e collegaste un dispositivo alla porta seriale vedreste i bit che salgono e scendono in concomitanza delle vostre scritture. Al contrario se cercate di leggere da quel file, leggete solo se qualcuno sta mandando dei byte a quella porta seriale altrimenti non ci leggete niente</li>
<li>Poi ci sono i symbolic link, ovvero io posso dire che c'√® nella cartella <code>alfa/beta</code> il file <code>gamma</code> che in realt√† non √® lui ma √® un symbolic link al file che sta nella cartella <code>omega/zeta</code> e quindi tutte le volte che apro <code>alfa/beta/gamma</code> in realt√† sto aprendo <code>omega/zeta</code>, questo per√≤ permette in certe situazioni di far sembrare una cosa che in realt√† √® un'altra</li>
</ul>
<p>Questo ci d√† l'idea che il concetto di file system e l'accesso alla persistenza √® qualcosa di molto pi√π elaborato di quanto normalmente possiamo pensare.</p>
<p><em>Allora, Rust come ci d√† accesso a queste cose qua?</em></p>
<p><img src="images/file_io/Untitled.png" alt="Untitled" /></p>
<p>Di base l'idea di file √® una pura astrazione che i sistemi operativi ci mettono a disposizione dicendo <em>"Io posso associare a un nome, pi√π o meno articolato, un insieme di byte".</em></p>
<p><em>Questo insieme di byte non rimane fisso nel tempo: ti fornisco degli strumenti per modificarlo in vari modi ‚Äî sostituendolo completamente, aggiungendo contenuto alla fine, o modificando parti specifiche al suo interno.</em> E ti permetto anche di leggere questo insieme di byte</p>
<p>Quindi il file system sostanzialmente ci d√† l'astrazione per poter, dato un nome articolato (lo chiamiamo path) che ci permette di riconoscere la sua posizione, accedere a questo blocco di byte che pu√≤ avere una dimensione arbitraria molto pi√π grande della massima quantit√† di spazio allocabile all'interno del processo ‚Äî ci√≤ che caratterizza i file √® che tendenzialmente sono strutturati per poter contenere una quantit√† grande di informazione, che vuol dire che spesso e volentieri il nostro accesso al file avviene in una modalit√† di <em><strong>streaming,</strong></em> ovvero ne leggiamo un pezzo per volta e piano piano ne elaboriamo il contenuto.</p>
<p>Concettualmente i sistemi operativi ci permettono di raggruppare i file in cartelle e alle cartelle danno un meccanismo di accesso per cui io posso creare dei cammini per accedere a tali files, con alcune convenzioni che sono abbastanza standard.</p>
<p>Ad ogni file sono associati i vincoli di sicurezza che dicono <em>‚ÄúNon tutti gli utenti della macchina possono accedere a questo file ma solo alcuni‚Äù</em> ‚Äî <em>come?</em> I dettagli qua differiscono molto..</p>
<p>Tendenzialmente l'accesso al file system √® uno di quelle zone che per prima ha avuto, nei vari linguaggi di programmazione, un meccanismo standardizzato multi piattaforma, per cui se voi in C dovete aprire un file usate la funzione <code>fopen</code> , se voi lo dovete fare in Java create un oggetto di tipo <code>FileInputStream</code> se lo leggete o <code>FileOutputStream</code> se lo volete scrivere e cos√¨ via..</p>
<p>Ogni linguaggio ha trovato delle astrazioni che sono ragionevolmente indipendenti della piattaforma.
Anche Rust l‚Äôha fatto e ci ha messo a disposizione sostanzialmente tutto un create che √® <code>std::fs</code>.</p>
<p>All‚Äôinterno di <code>std::fs</code> ci sono alcune astrazioni principali: una delle principali astrazioni che troviamo √® l'astrazione che si chiama <strong><code>std::fs::File</code></strong> , che modella il concetto di file presente sul disco nel suo accesso sia in lettura che in scrittura.</p>
<p>Notate che mentre il singolo file √® una cosa che standard lo √® stata fin dall'inizio, il concetto di cartella e di accesso alla cartella <em>manco per idea.</em>
Nel caso del C non c'√® un bel niente: <em>come faccio a sapere quali file sono presenti in una cartella?</em>
Il C non mi da nessuna funzione sua standard della libreria per poterlo sapere, perch√© in Windows io devo cominciare a fare <code>FindFirstFile</code> e poi <code>FindFirstNext</code> tante altre volte finch√© non mi dice non ce ne sono altri, in Unix ho un altra api e cos√¨ via‚Ä¶ quindi i singoli stream operativi hanno delle funzioni che permettono di enumerare i file ma queste nel caso del C non sono state portate nella libreria standard.</p>
<p>Nel caso del C++ sono entrati nella libreria standard a partire dalla versione 17, quindi pochi anni fa. Viceversa, altrove fortunatamente, in Java ad esempio la classe <code>File</code> del package <code>java.utils</code> fin dalla versione 1.0 di Java aveva permesso di lavorare decentemente con le cartelle, per cui in Java la classe <code>java.utils.File</code> non modella i dati del file, ma modella l'entit√† file col suo nome e ci offre metodi come <strong><code>exists</code></strong> (per sapere se a quel nome ha associato o meno un file), ci offre il metodo <strong><code>erase</code></strong> (che ci consente di cancellarlo), ci permette di usare il metodo <strong><code>mkdir</code></strong> (che ci consente, se quel file non esiste gi√†, di creare una cartella nella posizione indicata dal file con quel particolare nome) e cos√¨ via..</p>
<p>Nel caso di di Rust noi abbiamo tutta una serie di classi che fanno parte di <strong><code>std::fs</code></strong> che ci aiutano.</p>
<h1 id="2-percorsi--path-e-pathbuf"><a class="header" href="#2-percorsi--path-e-pathbuf">2. Percorsi ‚Äî <code>Path</code> e <code>PathBuf</code></a></h1>
<p><img src="images/file_io/Untitled%201.png" alt="Untitled" /></p>
<p>Siccome Rust pone tanta attenzione sulla <strong>indipendenza dalla piattaforma</strong> introduce un paio di classi che si chiamano <strong><code>Path</code></strong> e <strong><code>PathBuf</code></strong> che sono sostanzialmente analoghi per tante caratteristiche a <code>&amp;str</code> (uno slice di caratteri) e un oggetto <code>String</code>.
L'oggetto <code>Path</code> rappresenta un cammino all'interno del file system che √® accessibile in sola lettura, perch√© non lo possediamo.
Viceversa l'oggetto <code>PathBuf</code>, come <code>String</code>, rappresenta un cammino di cui abbiamo il possesso come contenuto e quindi lo possiamo modificare.</p>
<p><em>Perch√© allora non sono stati usati</em> <code>&amp;str</code> <em>e</em> <code>String</code><em>?</em>
Sostanzialmente perch√© rispetto ad una stringa, che ha certe caratteristiche (una stringa ci offre i metodi tipo l‚Äô <code>.upperCase</code> che sono molto generali e adatti a trattare il testo in quanto tale), gli oggetti di tipo <strong><code>Path</code></strong> e <strong><code>PathBuf</code></strong> ci offrono invece dei metodi che sono funzionali a navigare nelle cartelle.</p>
<p>Quindi:</p>
<ul>
<li><strong><code>Path</code></strong>, analogamente a <code>&amp;str</code>, √® un oggetto <em><strong>unsized:</strong></em> quindi di cui noi possediamo uno slice sostanzialmente e lo possiamo vedere solo in lettura</li>
<li><strong><code>PathBuf</code></strong> invece possediamo il contenuto e lo possiamo in qualche modo modificare.</li>
</ul>
<p>Un oggetto di tipo file si distingue da una stringa anche per il fatto che noi concateniamo elementi in modo differente in base al sistema operativo: cio√® col back slash piuttosto che col forward slash.</p>
<p>All'interno sono conservati una serie di metadati che di nuovo dipendono in qualche misura dal sistema operativo: tra i metadati importanti c'√® l'<em><strong>owner</strong></em>, c'√® la <em><strong>data di creazione</strong></em> ed <em><strong>ultima modifica.</strong></em></p>
<p>Questi ultimi due fattori sono molto interessanti nel contesto soprattutto della <em><strong>system integration</strong></em> cio√® quando noi ci troviamo ad avere un pezzo di software che gi√† esiste (che ha scritto qualcun altro e che fa delle cose) e abbiamo bisogno di fare in modo che <em>inter-operi</em> in qualche modo con un altro pezzo di software che ha scritto qualcun altro ancora che ha delle sue caratteristiche.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Spesso e volentieri i file sono un modo plausibile di ottenere una forma di system integration, perch√© se abbiamo, ad esempio, Word che crea i file .docx ‚Äî io non so manipolare i file .docx, non so come word li generi eccetera.. per√≤ posso immaginare che mi metto a osservare una certa cartella e tutte le volte che vedo comparire un nuovo file .docx all'interno potrei decidere che quel file potrebbe magari servirmi da un'altra parte.
Quindi magari scrivo un programmino che me lo prende e lo copia su un disco, una cosa che sembra una cartella locale ma in realt√† √® google drive e quindi che ne so ho fatto l'archiviazione automatica dei miei file .docx.</p>
<p>Chiaramente in questo genere di operazioni sapere quando quel file √® stato creato e quando √® stato modificato √® molto interessante perch√© pur non capendo niente della logica di come word aggiorna il file .docx, ma limitandomi a guardare l'oggetto file e monitorare la data di ultima modifica posso cercare di capire se quel file l√¨ lo devo anche ricopiare da un'altra parte perch√© voglio farne il backup automatico oppure no.</p>
</blockquote>
<p>Posso sapere anche che tipo di file ho in questione: un <em><strong>file semplice</strong></em> (cio√® √® associato ad un array di bytes di qualche genere), o se c'√® un nome che rappresenta una <em><strong>cartella</strong></em> quindi un raggruppamento di altri file, o se √® un <em><strong>collegamento simbolico</strong></em> (ovvero √® un nome che in realt√† √® un alias di un file che √® per√≤ da un'altra parte) etc‚Ä¶</p>
<h1 id="3-navigare-il-file-system"><a class="header" href="#3-navigare-il-file-system">3. Navigare il file system</a></h1>
<p><img src="images/file_io/Untitled%202.png" alt="Untitled" /></p>
<p><em>Come facciamo a usare il sistema il file system?</em></p>
<p>Ci sono una serie di funzioni base che ci vengono esposte all'interno del crate <code>std::fs</code> che ci consentono di fare la maggior parte delle operazioni.</p>
<ul>
<li><strong><code>read_dir</code></strong>
Accetta un riferimento a <code>Path</code>, e ci restituisce un iteratore a tutti file contenuti in una certa cartella. Siccome noi passiamo un <code>Path</code> e quel <code>Path</code> potrebbe anche non corrispondere a nulla (magari passiamo il percorso di una cartella che non esiste), la funzione non ci restituisce direttamente l‚Äôiteratore, ma ci restituisce un <strong><code>Result</code></strong> di un iteratore (in particolare un <code>io::Result</code>, una cosa che ci pu√≤ dire <em>‚ÄúPath not found‚Äù</em>).</li>
<li><strong><code>create_dir</code></strong>
Cerca di creare una nuova cartella nel Path che gli specifichiamo, e ritorna anche lei un <code>Result</code>.</li>
<li><strong><code>remove_dir</code></strong>
Cerca di eliminare una cartella tramite il <code>Path</code> che gli specifichiamo, e ritorna anche lei un <code>Result</code>.</li>
</ul>
<p>Per poter eliminare una cartella, questa deve essere vuota e in pi√π dobbiamo avere i diritti necessari, cio√® dovremo essere noi gli <strong>owner</strong> della cartella stessa o avere i diritti di scrittura sulla cartella, altrimenti la funzione fallisce.
Lo stesso vale per la creazione e anche per la lettura: la cartella potrebbe benissimo esistere ma noi non abbiamo i diritti di leggerla.</p>
<h1 id="4-manipolare-i-file-nel-file-system"><a class="header" href="#4-manipolare-i-file-nel-file-system">4. Manipolare i file nel file system</a></h1>
<p><img src="images/file_io/Untitled%203.png" alt="Untitled" /></p>
<p>Ci sono poi altre funzioni che facilitano proprio i concetti di system integration, in particolare la funzione <strong><code>copy</code></strong> che ci permette di copiare il file da un certo path ad un altro, se ci riesce ci dice quanti byte sono stati fisicamente copiati.</p>
<p>La funzione <strong><code>rename</code></strong> viceversa sposta un file da una posizione a un'altra ‚Äî a seconda dei sistemi operativi questo concetto di spostamento varia dal semplice <em>‚ÄúModifico alcune informazioni in una cartella‚Äù</em> al <em>‚ÄúLo copio fisicamente‚Äù.</em></p>
<p>In particolare, quando operiamo all'interno dello stesso file system, nella maggior parte dei casi viene semplicemente eliminata l'entry del file dalla cartella di partenza (ma il file rimane nella sua posizione con il suo inode e tutte le informazioni associate) e viene creata una nuova entry nella cartella di destinazione. Per questo motivo, l'operazione di <em><strong>rename</strong></em> all'interno dello stesso file system ha un costo computazionale molto basso.</p>
<p>Analogamente, se io lo rinomino nella stessa cartella, e da <code>/alpha/beta</code> lo voglio chiamare <code>/alpha/gamma</code> devo semplicemente cambiare la entry nella cartella <code>alpha</code> e cambiare da <code>beta</code> a <code>gamma</code>.</p>
<p>Se invece io volessi spostare da <code>C:/alfa/beta</code> in <code>D:/gamma</code>, siccome <code>C:</code> e <code>D:</code> sono fisicamente due volumi disgiunti, √® vero che faccio un rename ma quello equivale alla copia e poi alla cancellazione.</p>
<p>La funzione <code>remove_file</code> cerca di eliminare il file specificato tramite il path passato come parametro.</p>
<p><img src="images/file_io/Untitled%204.png" alt="Untitled" /></p>
<p><em>Come facciamo a leggere e manipolare dei file?</em>
Nel momento in cui siamo interessati al contenuto del file (quindi non al file in quanto contenitore di byte generico che vogliamo spostare da una parte all'altra ma concentrandoci su un singolo file siamo interessati al contenuto) abbiamo vari meccanismi che ci consentono di accedere al contenuto del file o di cambiare il contenuto del file.</p>
<p>Di base c'√® una struct che si chiama <strong><code>File</code></strong> che ci offre due metodi per essere istanziato:</p>
<ul>
<li><strong><code>open</code></strong> che prende un path in ingresso e restituisce un‚Äôistanza della struct <code>File</code> che corrisponde a un file che deve essere gi√† presente all'interno del file system. Quindi serve fondamentalmente in quelle situazioni in cui noi vogliamo accedere a un file che esiste (prevalentemente per leggerlo ma in alcuni casi per scriverlo o per appendere)</li>
<li><strong><code>create</code></strong> che viceversa assume che quel file non ci sia e prova a crearne uno di dimensione zero, anche in questo caso con l'obiettivo di scriverlo. Se il file gi√† esiste <code>create</code> butta via tutto quello che c'era dentro e quindi inizia con una <em>truncate</em>, quindi riporta il suo size a zero e da l√¨ in avanti ci lascia operare</li>
</ul>
<p>Di solito <strong><code>open</code></strong> ci d√† la possibilit√† di aprire <strong>in lettura</strong>, ma possiamo cambiare queste cose attraverso la struct <strong><code>OpenOption</code></strong> che ci d√† la possibilit√† di definire quale path vogliamo e quale modalit√† vogliamo usare.</p>
<p><img src="images/file_io/Untitled%205.png" alt="Untitled" /></p>
<p>Creare la struct <code>File</code> ci serve in quelle situazioni in cui pensiamo di dover lavorare col contenuto del file non <em>‚Äútutto d'un colpo‚Äù</em> ma <em>‚Äúa pezzi‚Äù.</em>
Ad esempio, se questo file √® molto grosso devo immaginare di poter aprirlo e leggerne un po‚Äô, farci delle cose, poi leggerne un altro po‚Äô, farci delle cose ecc..</p>
<p>Quando il file √® piccolo (es. 100MB in un sistema desktop, non embedded dove gi√† 100MB √® ‚Äúpesante‚Äù), allora magari √® di una dimensione compatibile con lo spazio che posso allocare all'interno del mio processo.
In questo caso ho due funzioni che mi fanno la vita molto comoda:</p>
<ul>
<li><strong><code>read_to_string</code></strong> prende il file e mi restituisce il suo contenuto sotto forma di stringa</li>
<li><strong><code>write</code></strong> prende uno slice di byte (<code>&amp;u8</code>) e lo scrive dentro il file, quindi quello che c'era nel file va perduto e viene sostituito dal blocco che io gli passo</li>
</ul>
<p>Quindi in quelle situazioni in cui io so a priori che le cose che devo trattare stanno probabilmente nel mio spazio indirizzamento, con questi due metodi ho tutto quello che mi serve ed √® molto pi√π agile poi lavorare direttamente su una stringa o su uno slice di byte piuttosto che operare a pezzi su blocchi che devo capire come li segmento, come li congiungo e cos√¨ via‚Ä¶</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Nell‚Äôesempio in slide, vediamo che <strong><code>read_to_string</code></strong> prende come argomento una variabile <strong><code>filename</code></strong> , che deve essere di tipo <code>&amp;Path</code>.
Noi potremmo passarvi anche una stringa, ad esempio <strong><code>"C:/alpha/beta"</code></strong> perch√® i <code>&amp;str</code> (slice di caratteri) sono riconducibili ad un <code>Path</code>, perch√® implementano il tratto <strong><code>From</code></strong> e quindi possiamo convertirli in automatico.</p>
</blockquote>
<p><img src="images/file_io/Untitled%206.png" alt="Untitled" /></p>
<p>Nelle situazioni invece in cui vogliamo scriverlo pian piano, posso popolare questo file in vari modi.</p>
<p>In questo esempio parto da un nome di un file <code>path = "lines.txt"</code>.
Questo √® un <code>&amp;str</code> normalissimo. Lo passo alla funzione <code>file::create</code>.</p>
<p>La funzione <code>file_create</code> mi restituisce un file aperto <strong>in scrittura</strong>. L'oggetto <code>output</code> √® di tipo <code>File</code>, ed √® <code>mut</code> perch√© devo avere la possibilit√† di modificarne il contenuto.</p>
<p><em>Come faccio a scrivere dentro questo file?</em>
Io posso scrivere, ad esempio, con la macro <code>write!</code>.</p>
<p><code>write!</code> √® molto simile a <code>println!</code>, ha un parametro in pi√π iniziale, che √® l'oggetto <code>File</code> su cui devo fare la scrittura. Quindi <code>write!(output, ...)</code>, e poi ci metto una stringa, che potrebbe contenere delle graffe, con gli indicatori e dei parametri ulteriori, proprio come farei con la <code>println!</code>.</p>
<p>Fatto cos√¨, ho creato un file che ha esattamente quel contenuto. Ci sono anche altri modi di fare questa cosa.</p>
<p>Se io lo volessi leggere a questo punto, probabilmente potrei usare la <code>read_to_string</code>, oppure posso cercare di leggerlo a pezzettini.</p>
<p>Un modo per leggerlo a pezzettini √® usare un <code>BufReader</code>.
<code>BufReader</code> √® un particolare oggetto, un tipo di struttura, che mi permette di leggere un file <strong>riga per riga</strong>.</p>
<p>In questo caso apro il file in lettura con <strong><code>File::open(path)?;</code></strong> (punto interrogativo perch√© quell'operazione potrebbe fallire), e a partire da questo oggetto <code>File</code> creo l'oggetto <code>BufReader</code> che √® specializzato nel leggere da un file che gli passo al lato della costruzione e mi offre meccanismi per andarci all'interno.</p>
<p>Tra i meccanismi che mi offre c'√® l‚Äôiteratore <strong><code>.lines()</code></strong>, metodo che mi d√† le singole righe presenti all'interno e a questo punto, avendo <strong><code>for line in bufferd.lines()</code>,</strong> per ciascuna riga presente all'interno faccio la stampa.</p>
<p>Va detto che la lettura della singola riga potrebbe sempre fallire cos√¨ come anche l‚Äôiteratore che che mi fa vedere tutti file della cartella che gli ho specificato e cose del genere ‚Äî sono tutti iteratori che ritornano un <code>Result</code>.</p>
<p>Siccome <strong><code>File</code></strong> implementa la strategia RAII <em>(Resource Acquisition Is Initialization)</em> automaticamente, quando la variabile esce di scope il file viene chiuso e quindi non mi devo occupare di chiudere il file esplicitamente.</p>
<p>Se ho bisogno posso anticipare la sua uscita di scope facendo in modo esplicito il <code>drop</code> del mio oggetto file cos√¨ che il suo distruttore viene invocato.</p>
<h1 id="5-i-tratti-relativi-a-io"><a class="header" href="#5-i-tratti-relativi-a-io">5. I tratti relativi a I/O</a></h1>
<p><img src="images/file_io/Untitled%207.png" alt="Untitled" /></p>
<p>Esistono alcuni tratti fondamentali che semplificano l'implementazione e consentono di gestire le operazioni di I/O in modo analogo alle operazioni sulla memoria normale.
Quattro tratti in particolare sono essenziali: il tratto <code>Read</code>, il tratto <code>BufRead</code>, il tratto <code>Write</code> e il tratto <code>Seek</code>.</p>
<p>Questi tratti fanno parte del <strong>preludio</strong>, ma non del preludio standard completo. Di conseguenza, sono disponibili automaticamente se includiamo il preludio, altrimenti dobbiamo importarli separatamente.</p>
<p>In tutti i vari casi le operazioni che questi 4 tratti fanno restituiscono dei <code>Result</code>, che se sono positivi contengono di volta in volta un numero (quanti byte ho fisicamente letto/scritto piuttosto che un <code>void()</code> per dirmi che non c'era nessun risultato particolare o altro) nel caso di errore mi arriva un errore che √® definito dalla struct <strong><code>ErrorKind</code></strong> .</p>
<p>Alcuni degli errori presenti in <strong><code>ErrorKind</code></strong> sono ingestibili, cio√® posso solo arrendermi (es. il file non esiste). Ce n'√® uno in particolare che √® <strong><code>Interrupted</code></strong> che invece denota una situazione <em><strong>transitoria,</strong></em> cio√® se il risultato √® <code>Interrupted</code> potrebbe valer la pena metter in atto la strategia di riprovarci dopo un po‚Äô.</p>
<p>Va detto che nella maggior parte delle situazioni la strategia di riprovarci √® un bagno di sangue perch√© devo capire cosa devo riprovare e come lo riprovo, quindi anche se in linea di principio sarebbe gestibile, nella maggior parte delle situazioni non si gestisce e si preferisce lasciar perdere.</p>
<p><img src="images/file_io/Untitled%208.png" alt="Untitled" /></p>
<p><em>Chi √® che implementa il tratto</em> <strong><code>Read</code></strong> <em>?</em>
Il tratto <code>Read</code> √® implementato da tre cose che sono molto diverse tra di loro: <strong><code>File</code></strong> implementa il tratto <code>Read</code> (posso leggere un blocco binario di dati da un file, ma anche dei caratteri, o delle stringhe etc...).</p>
<p><code>Read</code> √® implementato anche dalla struttura che si chiama <strong><code>Stdin</code></strong> che rappresenta il <strong>flusso di default di ingresso</strong> di un processo. Normalmente se noi non facciamo niente di particolare quel flusso di ingresso corrisponde con la tastiera e quindi quello che l'utente pu√≤ digitare. Noi sappiamo per√≤ che quando attiviamo un processo possiamo ridirigere il suo standard input usando i comandi che la shell ci offre quindi con <code>&gt;</code> con <code>|</code> o cose del genere per fargli entrare in ingresso altre cose.</p>
<p>Un altro oggetto che implementa lo stesso tratto <code>Read</code> √® l'oggetto <strong><code>TcpStream</code></strong> che rappresenta invece una connessione di tipo TCP con un host. Notiamo che <code>TcpStream</code> rappresenta uno dei due endpoint ‚Äî non sta dicendo n√® che siamo server n√® che siamo client perch√© una volta che la connessione TCP √® stata stabilita, non c'√® pi√π nessuna differenza tra il server e client: la connessione √® completamente bidirezionale. L'oggetto <code>TcpStream</code> rappresenta una connessione che √® stata messa in piedi e a questo punto su questa connessione io posso leggere.</p>
<p>La lettura qua √® una lettura che va a fare una system call (quindi interpella il sistema operativo) ogni volta che gli chiedo qualcosa; questo in alcuni casi va benissimo, in alcuni casi √® un grosso problema: se ricordate in precedenza abbiamo parlato di come funzionano le cose abbiamo detto che io chiamo l'API del sistema operativo attraverso una funzione particolare (la system call) che mi innalza di privilegio e che in generale √® un'operazione costosa ‚Äî es. su un x86 la call normale costa 5 cicli macchina, mentre la system call ne costa 500.
Allora se io leggo un byte alla volta (perch√© sto leggendo tipo da tastiera), la lettura di quel byte mi costa 500. Ma io potrei piuttosto dire <em>‚ÄúLeggimene all'ingrosso 500 e tieniteli l√¨ in pancia, poi te li chiedo uno alla volta‚Äù.</em> In questo modo l'interazione col sistema operativo avviene molto pi√π raramente: tutte le volte il sistema operativo dice <em>‚ÄúDammi i prossimi 500 byte se ce li hai, me li porto in pancia e poi al mio client (cio√® il pezzo di sotto che ne ha bisogno) ne d√≤ quelli che mi sta chiedendo‚Äù.</em>
Questo √® fatto dal tratto <strong><code>BufRead</code></strong>, che dice <em>‚ÄúTra i dati che tu mi chiedi e quelli che io mia volta chiedo al sistema operativo interpongo un buffer‚Äù.</em></p>
<p><em>Quali sono le struct che implementano il tratto <strong><code>BufRead</code></strong> ?</em>
La struct <strong><code>BufReader</code></strong> √® specializzata nel leggere da un file a <strong>chunk grossi</strong> dando poi i dati uno alla volta per come sono, perch√© vedete che <strong><code>BufRead</code></strong> √® una specializzazione di <strong><code>Read</code></strong>, quindi ha <strong>tutti i metodi</strong> di <code>Read</code> e ci aggiunge i propri.</p>
<p><code>BufReader</code> offre funzionalit√† aggiuntive oltre ai metodi generali, come l'iteratore <code>.lines()</code>. Poich√© carica molti dati in memoria in un colpo solo, pu√≤ implementare efficacemente questo iteratore scorrendo il suo buffer interno. Quando trova un carattere di fine riga, restituisce la riga completa immediatamente. Alla richiesta successiva di <code>next()</code>, continuer√† la ricerca dal punto in cui si era fermato. Se esaurisce i dati nel buffer, richieder√† automaticamente altri dati al sistema operativo per riempire nuovamente il buffer.</p>
<p>C'√® anche un altro oggetto che implementa <code>BufRead</code>: √® <strong><code>Cursor</code></strong>, un oggetto un po‚Äô particolare che mi permette di muovermi all'interno di uno slice di byte, che pu√≤ essere fatto in vari modi.</p>
<p>E poi c'√® <strong><code>StdinLock</code>.</strong>
Da <code>Stdin</code> normale io leggo un byte alla volta i singoli caratteri che digito (<em>c i a o</em>) e se se fossimo in due a leggere io magari leggo (<em>c i</em>) e l'altro legge (<em>a o</em>) della parola <em>ciao,</em> perch√© nel momento in cui io chiedo il prossimo disponibile, questo viene <strong>consumato.</strong> Se io volessi leggere una sequenza devo prendere possesso di <code>Stdin</code>, e quindi <strong><code>StdinLock</code></strong> serve proprio a dire <em>‚ÄúHo preso in modo esclusivo l'accesso a standard input e adesso posso leggere, ce l'ho a blocchi e quindi posso fare read line‚Äù.</em></p>
<p>Poi c'√® invece il tratto <strong><code>Write</code></strong> che √® implementato da tutta una serie di altre struct: la struct <strong><code>Stdout</code></strong> rappresenta il flusso di uscita standard di un processo (questo di solito coincide col terminale nell'applicazione basata su terminali ma pu√≤ essere ridiretto verso un file, verso un altro processo e cos√¨ via).
<strong><code>Stderr</code></strong> rappresenta il flusso di errore di un file.
Anche la struct <strong><code>File</code></strong> implementa <code>Write</code> proprio perch√© io ho la possibilit√† di mandare un byte o un chunk di byte verso un file.
Anche la struct <strong><code>TcpStream</code></strong> implementa <code>Write</code>, perch√© <code>TcpStream</code> √® bidirezionale (posso leggere e posso scriverci).
Anche <strong><code>Vec&lt;u8&gt;</code></strong> implementa <code>Write</code>: posso trattare un vettore come il destinatario di un file ‚Äî come tratterei un file in scrittura, cio√® posso buttare l√¨ dentro esclusivamente un vettore di byte.
Infine <strong><code>BufWriter</code></strong> √® una specializzazione del tratto <code>Write</code> e mi aggiunge la capacit√† di dire che <em>‚Äúi singoli byte che mi dai non li passo subito al sistema operativo come fanno normalmente tutti gli altri, ma me li tengo in pancia finch√© non ne ho abbastanza e quando ne ho abbastanza te li scrivo‚Äù</em> cos√¨ da far s√¨ che questa barriera tra il codice utente e il codice del kernel sia attraversata ogni tanto e non per ogni byte o cose del genere, che altrimenti diventa costosissimo.</p>
<h2 id="51-il-tratto-read"><a class="header" href="#51-il-tratto-read">5.1 Il tratto <code>Read</code></a></h2>
<p><img src="images/file_io/Untitled%209.png" alt="Untitled" /></p>
<p>Il tratto <code>Read</code> √® implementato da tutti coloro i quali permettono di leggere, un byte alla volta o un chunk di byte alla volta. Di base l'operazione elementare che il tratto <code>Read</code> offre √® il metodo <strong><code>read()</code></strong> che accetta un <code>&amp;mut [u8]</code> (cio√® un riferimento mutabile ad uno slice di byte) e mi d√† la possibilit√† di leggere al suo interno sapendo che se quel buffer che ho passato contiene 100 byte lui prover√† a leggerne 100 ma potrebbe riuscire a leggerene solo 32, o 27, o anche 0, e quindi come risultato mi d√† un <code>Result</code> che contiene nel caso di <code>Ok</code> il numero di byte che ha effettivamente letto.</p>
<p>All'interno del tratto <code>Read</code> ci sono tanti altri metodi che sono definiti tutti quanti con una implementazione di default, e l'implementazione di default che √® fornita di questi altri metodi √® basata sul metodo <code>read()</code>, quindi se noi avessimo bisogno di implementare il tratto <code>Read</code> per una nostra struttura particolare l'unico vero bisogno che abbiamo √® implementare il metodo <code>read()</code>.</p>
<p>Poi ovviamente potremmo decidere di implementare anche qualche altro metodo, se avessimo per il nostro caso particolare delle ottimizzazioni possibili rispetto alla funzione di default, ma in termini strettamente funzionali non sarebbe necessario.</p>
<p>In generale, il metodo <code>read()</code> restituisce un risultato che, se negativo, contiene la descrizione dell'errore. Se positivo, il valore varia tra 0 e la lunghezza massima del buffer.</p>
<p>√à importante capire che quando leggiamo e otteniamo <strong><code>Ok(0)</code></strong>, questo pu√≤ verificarsi in due situazioni:</p>
<ul>
<li>La pi√π frequente √® quando raggiungiamo l'<strong>end of file</strong>.
Questo accade solo se il buffer ha dimensione maggiore di 0.</li>
<li>Quando il buffer passato ha dimensione 0.</li>
</ul>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Se passiamo uno slice di size 0 (cosa possibile), otterremo necessariamente <code>Ok(0)</code>, semplicemente perch√© non c'√® spazio per leggere: in pratica ci dice <em>"ho letto 0 byte".</em></p>
</blockquote>
<p>Ogni volta che chiamiamo <code>read()</code>, viene effettuata una system call che comporta un cambio di contesto (questo accade nella maggior parte dei casi). Questa system call √® costosa, richiedendo 500 cicli macchina.</p>
<p><img src="images/file_io/Untitled%2010.png" alt="Untitled" /></p>
<p><em>Quali sono tutti gli altri metodi che il tratto</em> <code>Read</code> <em>mi offre (e che di conseguenza trovo dentro</em> <code>File</code>, **<code>Stdin</code><em>,</em> <code>TcpStream</code> <em>etc...)?</em> ****</p>
<p><strong><code>read_to_end</code></strong> ‚Üí gli passo un <code>Vec&lt;u8&gt;</code> e lui mi riempie questo vettore col contenuto di tutto il file; chiaramente questo lo devo fare facendo attenzione che la dimensione del file sia compatibile con la memoria allocabile del vettore: se quel file l√¨ √® 200 giga non √® detto che io riesca allocare 200 giga nel mio spazio di indirizzamento.</p>
<p><strong><code>read_to_string</code></strong> ‚Üí metodo che in questo caso prende come parametro un variabile tipo <code>String</code> e fa il medesimo giro con un controllo in pi√π: mentre nella <code>read_to_end</code> i byte cos√¨ come sono vanno bene (qualunque questi byte fossero), nel caso di <code>read_to_string</code> viene fatto il controllo che quei byte formino una stringa utf-8 ben formata e quindi nel caso in cui ci fossero sequenze impossibili mi generano un errore.</p>
<p><strong><code>read_exact</code></strong> ‚Üí molto simile a <code>read()</code> ma prova a leggere esattamente quel numero di byte di cui abbiamo passato il buffer; quindi io ho passato un buffer da 100 byte e lui cerca di riempirmeli tutti quanti; se non riesce a riempirmeli tutti quanti mi d√† errore <em><strong>‚ÄúUnexpected end of file‚Äù</strong></em>.</p>
<p><strong><code>bytes</code></strong> ‚Üí mi restituisce un iteratore che mi permette di tirare fuori i byte uno alla volta; questi byte mi escono non come singoli byte ma come <code>Result</code> dove in <code>Ok</code> ho un byte e nel caso contrario ho un <strong><code>io::Error</code></strong> di un qualche tipo.</p>
<p><strong><code>chain</code></strong> ‚Üí interessante perch√© mi permette di attaccare un <code>Read</code> a un altro <code>Read</code>, ad esempio io so che ho spaccato un file grosso in tre pezzi e ho messo l'inizio in file 1 la met√† in file 2 e il resto in file 3 e quindi posso creare un oggetto <code>Read</code>, quindi apro per esempio un file col metodo <code>open</code> , su quel file li faccio <strong><code>.chain(file2).chain(file3)</code></strong> e a questo punto ho creato una struttura che √® la concatenazione di tutto. Quando comincer√≤ a farmi dare dei contenuti questi verranno prelevati da file 1 finch√© ce n'√®, quando arrivo al fondo di file 1 verranno presi da file 2 finch√© ce n'√®, e poi verranno presi da file 3 finch√© ce n‚Äô√®.</p>
<p><strong><code>take</code></strong> ‚Üí mi d√† un iteratore che prende al massimo il numero di byte che io gli dico, quindi mi permette di porre un limite a priori sulla quantit√† di byte che voglio andare a prendere.</p>
<h2 id="52-il-tratto-bufread"><a class="header" href="#52-il-tratto-bufread">5.2 Il tratto BufRead</a></h2>
<p><img src="images/file_io/Untitled%2011.png" alt="Untitled" /></p>
<p><em>Cosa mi aggiunge <strong><code>BufRead</code></strong>?</em></p>
<p>Gli oggetti che implementano il tratto <code>BufRead</code> (quindi <code>BufReader</code> oppure <code>StdinLock</code> ecc..) mi danno alcuni metodi ulteriori: in generale internamente si basa su due metodi fondamentali che sono <strong><code>fill_buf</code></strong> e <strong><code>consume</code></strong> .
Sono metodi che lui usa per implementare gli altri metodi, e che noi di solito non chiamiamo in modo esplicito, perch√© ci interessano molto di pi√π tutti gli altri che offre tra i quali c'√® <strong><code>read_line</code></strong> che legge una singola riga di testo fino allo <code>/n</code>, o <strong><code>lines</code></strong> che ci d√† l‚Äôiteratore che ci permette di prendere le righe una alla volta.</p>
<h3 id="521-esempio-1"><a class="header" href="#521-esempio-1">5.2.1 Esempio</a></h3>
<p><img src="images/file_io/Untitled%2012.png" alt="Untitled" /></p>
<p>Qui vediamo un esempio d'uso: prendo uno stdin, faccio <code>stdin.lock</code> e a questo punto trasforma il mio oggetto <code>stdin</code> che potrebbe essere usato da altri in contemporanea in un oggetto che appartiene solo a me e su cui ho il tratto <strong><code>BufRead</code></strong> . A questo punto posso usarlo per farci delle cose.
Con <strong><code>handle.fill_buf().unwrap();</code></strong> stiamo chiedendo di prendere tutto quello che riesce all'interno del buffer che internamente lui si √® allocato, lo stampo, mi chiedo anche quanto √® grande e a questo punto quello l‚Äôho consumato. Questo √® il meccanismo che internamente i vari metodi implementati da <code>BufRead</code> usano per gestirsi le cose. Noi di solito queste chiamate per√≤ non le facciamo cos√¨ perch√© √® una seccatura; noi quando creiamo gli oggetti <code>BufRead</code> chiamiamo <strong><code>read_line()</code></strong> piuttosto che <strong><code>lines()</code></strong> che √® molto pi√π comodo.</p>
<h2 id="53-il-metodo-write"><a class="header" href="#53-il-metodo-write">5.3 Il metodo <code>Write</code></a></h2>
<p><img src="images/file_io/Untitled%2013.png" alt="Untitled" /></p>
<p>Il tratto <strong><code>Write</code></strong> √® implementato da varie strutture (<code>File</code>, <code>Stdout</code>, <code>Stder</code> e cos√¨ via..) e all'interno contiene due metodi:</p>
<ul>
<li><strong><code>write()</code></strong> che affida al sistema operativo un blocco e il sistema operativo sapr√† che dovr√† recapitarlo al dispositivo di io corrispondente, ma non √® obbligato a farlo subito</li>
<li><strong><code>flush()</code></strong> che viceversa √® responsabile di garantire che il sistema operativo prende tutto quello che ha tenuto e fisicamente lo trasferisca fino in fondo cos√¨ che se qualcuno va ad accedere sul device ci trova esattamente quello che io penso di averci messo</li>
</ul>
<p>Oltre a questi due metodi ce ne sono altri qui che vale la pena di citare: <strong><code>write_all</code></strong> si prende uno slice come argomento, e garantisce che lo trasferisce per intero. Essenzialmente fa <code>write</code> e <code>flush</code> in un colpo solo.</p>
<h2 id="54-il-tratto-seek"><a class="header" href="#54-il-tratto-seek">5.4 Il tratto <code>Seek</code></a></h2>
<p><img src="images/file_io/Untitled%2014.png" alt="Untitled" /></p>
<p>Fino ad adesso abbiamo visto i file come oggetti di tipo <em><strong>stream</strong></em>, cio√® oggetti in cui scriviamo aggiungendo sempre alla fine o da cui leggiamo i contenuti nell'ordine in cui sono stati scritti, dal primo all'ultimo byte. In questo modo manteniamo l'ordine sequenziale sia in scrittura che in lettura.</p>
<p>Ma in realt√† un file √® semplicemente un array di byte, e nulla ci impedisce di muoverci liberamente al suo interno. Questo funziona in modo diverso a seconda del tipo di file: su disco, dove il file √® effettivamente un array di byte, ha senso spostarsi in modo casuale e dire <em>"alla posizione 32 scrivo questo, poi torno alla posizione 0 e scrivo quest'altro, poi vado alla posizione 150 e scrivo quest'altro"</em>.</p>
<p>Il file inteso come <em><strong>porta seriale</strong></em>, invece, non pu√≤ essere trattato in questo modo: anche se ci appare come un file, non √® <em>seekable</em>. Questo perch√© la porta seriale √®, come dice il nome, seriale, e i byte che vi inseriamo <em>"vanno a casa di qualcun altro"</em>. Non possiamo dire <em>"no scusa, torno indietro"</em>: il tempo scorre in una sola direzione.</p>
<p>Quindi di tutte quelle cose che a noi sembrano files, alcune sono <em><strong>seekable</strong></em>, altre non lo sono.
Per quelle che sono seekable per√≤ abbiamo la possibilit√† di farci delle operazioni abbastanza interessanti: abbiamo la possibilit√† di dire che noi leggiamo i contenuti di questo grosso byte array che il file modella, in un qualche ordine che possiamo andare a definire ‚Äî di base l'operazione <code>read</code> o l'operazione <code>write</code> avviene su quella che √® la <em><strong>posizione corrente del file.</strong></em></p>
<p>La posizione corrente √® stabilita al lato dell'apertura: quando apriamo un file nella modalit√† read o nella modalit√† write, la posizione iniziale √® zero e quindi <code>read</code> legge il primo, secondo, il terzo o quarto byte, nel <code>write</code> scrivo il primo, il secondo, il terzo o quarto byte. Quando apriamo un file nella modalit√† <strong>append</strong> la posizione iniziale √® al fondo, e quindi <code>append</code> √® una modalit√† di scrittura dove invece di sovrascrivere quello che c'√® aggiungo dei pezzi.</p>
<p>Noi per√≤ possiamo muoverci anche tornando indietro ecc.. il tratto <strong><code>Seek</code></strong> ci consente fondamentalmente di muoverci dall'inizio, dalla fine o dalla posizione corrente di un certo <em><strong>delta</strong></em>.</p>
<p>Quindi ad esempio <strong><code>SeekFrom::Start</code></strong> diciamo <em>‚Äúa partire dalla posizione zero del file porta la posizione corrente avanti di tot posti‚Äù,</em> oppure dall'end invece <strong><code>SeekFrom::End</code></strong> partendo dal fondo del file torna indietro di tanti altri oppure <strong><code>SeekFrom::Current</code></strong> dice <em>‚Äúda dove sei adesso vai avanti o indietro di una certa quantit√†‚Äù.</em></p>
<p>Notate che <code>SeekFrom::End</code> prende un numero <strong>con segno</strong> perch√© io potrei cercare di tornare indietro oppure potrei voler andare comunque avanti per allungare il file. <strong><code>SeekFrom::Start</code></strong> prende un <code>u64</code> perch√© dall'inizio non posso andare a ‚Äúprima dell‚Äôinizio del file‚Äù.</p>
<p>Ci sono tre metodi fondamentali che chi implementa il tratto <strong><code>Seek</code></strong> ci mette a disposizione: il metodo <strong><code>seek()</code></strong> stesso che mi permette di cambiare qual √® la produzione corrente da cui vado a fare le letture o su cui vado a fare le scritture, <strong><code>rewind()</code></strong> che mi permette fondamentalmente di ritornare all'inizio del flusso (quindi equivale a <strong><code>SeekFrom::Start(0)</code></strong>) e infine c'√® il metodo <strong><code>stream_position()</code></strong> che mi ritorn√† qual √® l'attuale posizione di questo file.</p>
<p><img src="images/file_io/Untitled%2015.png" alt="Untitled" /></p>
<p><em>Come facciamo a leggere dei dati binari di qualche tipo?</em></p>
<p>Supponiamo volessimo aprire un <strong>pdf</strong>, che √® un file che ha un formato binario al suo interno: certo ci sono anche delle parti stringa, ma ci sono anche <em>immagini</em>, <em>codici di formattazione</em>, <em>cose strane</em> etc.</p>
<p>Per cui di per s√© non abbiamo la garanzia che contenga dell'<code>utf-8</code> quindi dobbiamo leggere come array di byte. Qua proviamo a farlo: nell'esempio in realt√† leggo (nel caso di Linux) dal device che si chiama <em><strong>urandom</strong></em>, un particolare device che viene montato. √à un finto file (infatti sta nella cartella <code>/dev</code>) che quando lo leggo mi genera dei byte a caso appoggiandosi a una qualche periferica che, attraverso un fenomeno fisico di qualche genere, prova a generare dei numeri che siano robustamente casuali.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Un modo per generare dei numeri robustamente casuali √® fare lavorare un diodo zener in corrispondenza del punto di gomito della sua curva tensione corrente, che √® una zona di grande aleatoriet√† dove, tenendo in quella posizione li, a volte leggo uno a volte leggo zero in un modo non controllabile.
Siccome √® un fenomeno fisico che dipende da tutta una serie di cose realmente random, quella √® una buona sorgente di variabilit√† e di conseguenza pu√≤ essere messo all'interno della nostra CPU un chip che internamente fa questo mestiere, e quando leggiamo da <em><strong>urandom</strong></em> in realt√† andiamo a interrogare questo chip che ci genera dei byte a caso.</p>
<p>In altre situazioni si usano dei sensori (dei muoni piuttosto che di altre particelle che ci arrivano dai raggi cosmici sostanzialmente) che di nuovo sono abbastanza impredicibili e tra l'altro sono rilevabili anche negli ambienti interni perch√© attraversano una serie di situazioni e quindi questi sono tutti fenomeni difficilmente caratterizzabili.</p>
<p>Perch√© √® importante essere difficilmente caratterizzabile?
I numeri random noi li possiamo usare per scopi molto diversi: li possiamo usare banalmente per pseudo simulazioni ‚Äî fate un giochino, c'√® il mostriciattolo che vi insegue che a volte gira destra e a volte gira a sinistra, va bene chi se ne frega.
Ma se invece di fare il giochino o la simulazione di qualcos'altro stiamo facendo la crittografia per proteggere una transazione bancaria, se l‚Äôalgoritmo non √® un vero random ma √® uno pseudo random (che di fatto √® assolutamente predicibile: qualcuno potrebbe aver studiato un po‚Äô di bit precedenti e fare un <em><strong>educated guess</strong></em> su quali saranno i bit a venire) questo sarebbe rischiosissimo. Per questo motivo ci serve avere un generatore di numeri casuali che sia legato a fenomeni fuori dal controllo.</p>
</blockquote>
<p>In questo caso qui apriamo il device che si chiama <code>dev/urandom</code> e in questo caso noi sappiamo che questo ci d√† un 32 bit, quindi prepariamo un buffer di 4 byte <code>let mut buff = [0;4]</code> ‚Äî quello l√¨ √® un buff di 4 byte inizialmente tutti i posti a 0. E poi chiamiamo <code>f.read_exact(&amp;mut buff)</code> , cio√® riempimi questi 4 byte con il contenuto del file urandom. Se qualcosa va storto ritorna l'errore, dopo di che se invece non √® un errore all'interno dell‚Äôarray buff ho i 4 byte completamente random e quindi vado a vedere cosa succede e vedo: se in questo caso ne trovo uno tutto a 0 la pianto l√¨ subito dicendo ok altrimenti provo a trasformare questo numero in un intero 32 bit e ci faccio qualcosa in questo caso lo stampo.</p>
<p><img src="images/file_io/Untitled%2016.png" alt="Untitled" /></p>
<p>Altre volte, invece di leggere brutalmente un blocco di byte cos√¨ com‚Äô√® nel disco o code del genere, io ho bisogno di leggere dei dati che so essere strutturati: ad esempio un file csv che contiene qualche milionata di numeri.
Posso farmi questa lettura a mano: faccio open, ci creo un BufReader sopra, a questo punto punto con .lines ho la linea, quella linea l√¨ la devo spezzettare, faccio .split sulla virgola ottengo i singoli chunk, devo ricordarmi che il primo vuol dire una certa cosa, il secondo vuol dire un‚Äôaltra cosa etc..</p>
<p>Si pu√≤ fare, per√≤ √® una seccatura: il giorno che quelli che hanno generato il .csv cambiano il formato e mi dicono devo mettermi l√¨ e paccioccare ed essere sicuro di farlo bene.
Mi farebbe molto pi√π comodo poter descrivere quelli che sono i campi e poi mi farebbe piacere avere qualcosa che me li trasforma per i fatti suoi, e qui ci viene in aiuto un crate che possiamo includere all'interno delle nostre progetti che si chiama <strong><code>Serde</code></strong> .</p>
<p><em><strong>Serde</strong></em> sta per <em><strong>serialization e deserialization</strong></em>.
Serialization √® l'operazione di trasformare il dato dal formato interno di Rust a un formato esterno, e deserialization √® l'operazione di trasformare dal formato esterno in quello interno di Rust.</p>
<p>In realt√† di formati esterni ce ne sono 20 mila possibili, .csv √® solo uno di questi. Serde √® un crate che definisce un framework generale e poi ha una serie di sottocrates che ne specializzano il comportamento in un modo o nell'altro.
Di suo Serde ci offre due tratti: <strong><code>Serialize</code></strong> e <strong><code>Deserialize</code></strong>.
Perch√® sia utile, possiamo includere la macro derive che ci d√† la possibilit√† di creare in automatico le funzioni serialize e deserialize per le strutture dati che andiamo a definire per i fatti nostri.</p>
<h1 id="6-il-framework-serde"><a class="header" href="#6-il-framework-serde">6. Il framework <code>Serde</code></a></h1>
<p><img src="images/file_io/Untitled%2017.png" alt="Untitled" /></p>
<p><img src="images/file_io/Untitled%2018.png" alt="Untitled" /></p>
<p>Includendo serde nel Cargo.toml abbiamo ora disponibili il framework serde e la macro derive. Ma il framework serde √® un framework di serializzazione generico: sa serializzare, ma cosa ci serve serializzare?
Allora dobbiamo includere le ‚Äúspecializzazioni‚Äù, dunque includiamo anche <code>serde_json</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointer---malnati-20-21"><a class="header" href="#smart-pointer---malnati-20-21">Smart Pointer - Malnati 20-21 <!-- omit in toc --></a></h1>
<h1 id="indice-14"><a class="header" href="#indice-14">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="15-smart_pointer.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="15-smart_pointer.html#11-smart-pointer-in-c">1.1 Smart pointer in C++</a>
<ul>
<li><a href="15-smart_pointer.html#111-unique_ptr">1.1.1 <code>unique_ptr</code></a></li>
<li><a href="15-smart_pointer.html#112-shared_ptr">1.1.2 <code>shared_ptr</code></a></li>
<li><a href="15-smart_pointer.html#113-dettagli-implementativi-di-unique_ptr">1.1.3 Dettagli implementativi di <code>unique_ptr</code></a></li>
<li><a href="15-smart_pointer.html#114-esempio-unique_ptr">1.1.4 Esempio <code>unique_ptr</code></a></li>
<li><a href="15-smart_pointer.html#115-dettagli-implementativi-di-shared_ptr">1.1.5 Dettagli implementativi di <code>shared_ptr</code></a></li>
<li><a href="15-smart_pointer.html#116-esempio-shared_ptr">1.1.6 Esempio <code>shared_ptr</code></a></li>
<li><a href="15-smart_pointer.html#117-dipendenze-cicliche">1.1.7 Dipendenze cicliche</a></li>
<li><a href="15-smart_pointer.html#118-weak_ptr">1.1.8 <code>weak_ptr</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="15-smart_pointer.html#2-smart-pointer-in-rust">2. Smart pointer in Rust</a>
<ul>
<li><a href="15-smart_pointer.html#21-i-tratti-deref-e-derefmut">2.1 I tratti <code>Deref</code> e <code>DerefMut</code></a></li>
<li><a href="15-smart_pointer.html#22-box">2.2 Box</a>
<ul>
<li><a href="15-smart_pointer.html#221-esempio">2.2.1 Esempio</a></li>
</ul>
</li>
<li><a href="15-smart_pointer.html#23-rc">2.3 <code>Rc</code></a>
<ul>
<li><a href="15-smart_pointer.html#231-esempio">2.3.1 Esempio</a></li>
<li><a href="15-smart_pointer.html#232-esempio-weak">2.3.2 Esempio <code>Weak</code></a></li>
</ul>
</li>
<li><a href="15-smart_pointer.html#33-cell">3.3 <code>Cell</code></a>
<ul>
<li><a href="15-smart_pointer.html#331-esempio">3.3.1 Esempio</a></li>
<li><a href="15-smart_pointer.html#332-metodi-offerti-da-cell">3.3.2 Metodi offerti da <code>Cell</code></a></li>
</ul>
</li>
<li><a href="15-smart_pointer.html#24-refcell">2.4 RefCell</a>
<ul>
<li><a href="15-smart_pointer.html#241-esempio">2.4.1 Esempio</a></li>
</ul>
</li>
<li><a href="15-smart_pointer.html#25-cow">2.5 <code>Cow</code></a></li>
</ul>
</li>
<li><a href="15-smart_pointer.html#3-smart-pointer-e-metodi">3. Smart pointer e metodi</a></li>
<li><a href="15-smart_pointer.html#4-tabella-riassuntiva">4. Tabella riassuntiva</a></li>
<li><a href="15-smart_pointer.html#5-riferimenti">5. Riferimenti</a></li>
</ul>
<h1 id="1-introduzione-9"><a class="header" href="#1-introduzione-9">1. Introduzione</a></h1>
<p>L'argomento che adesso introduciamo √® un po‚Äô pi√π complesso ‚Äî non √® complessissimo, ma in realt√† ha alcune caratteristiche che rendono la programmazione in C++ (dove per primo √® stato introdotto) e in Rust particolarmente diverso da quello che succede altrove. Ed √® alla base di moltissimi dei comportamenti che ci interessano, perch√© danno una correttezza semantica alle operazioni che andiamo a svolgere, lasciandoci la libert√† di poter usare il concetto di puntatore in tutte le situazioni in cui ci serve.</p>
<p>Vediamo di capire di cosa stiamo parlando.</p>
<p><img src="images/smart_pointer/image.png" alt="image.png" /></p>
<p>Noi sappiamo che i dati su cui lavoriamo sono memorizzati nel contesto dello spazio di indirizzamento del nostro processo. In generale noi possiamo fare riferimento a questi dati se sono posseduti direttamente dalle variabili che li posseggono. Alternativamente abbiamo un modo efficiente in Rust, che √® quello dell'uso dei <strong>reference</strong> o dei <strong>refmut</strong>, per poter accedere a un dato di cui non abbiamo il possesso, ma di cui otteniamo temporaneamente la possibilit√† di leggere o di scrivere.</p>
<p>Tuttavia, questo vale in Rust, vale in C, vale in C++. A differenza di quello che succede in C e C++, dove √® sempre possibile recuperare il puntatore a un valore, anche quando quel valore potenzialmente non esiste pi√π e cos√¨ via, dando origine a una serie di problemi, in Rust abbiamo che il <strong>borrow checker</strong> ci garantisce che noi possiamo dereferenziare un riferimento solo quando lui √® in grado di dimostrare logicamente (quindi attraverso un processo logico-matematico) che non c'√® rischio ad accedere a quel particolare riferimento.</p>
<p>Questa √® la ragione principale della salvezza, nel senso che ci garantisce una correttezza di accessi e ci elimina tutti quei vari casi di <em>undefined behavior</em> che nascono nell'utilizzo del C e del C++.</p>
<p>Tuttavia, in alcuni casi, questo restringimento, questa forma di restrizione operata dal borrow checker, pu√≤ essere pi√π stringente di quello che noi vorremmo.</p>
<p><em>Perch√©?</em> Perch√© ci sono casi leciti in cui, a seguito di una serie di cose che il compilatore non riesce a dimostrare per i fatti suoi, noi potremmo comunque dereferenziare certi valori, ma lui non capisce e quindi ce lo proibirebbe.</p>
<p>In generale, noi sappiamo che se disponiamo di un puntatore, noi possiamo eseguire l'operazione chiamata <strong>dereferenza</strong>, o <em>risoluzione del riferimento</em>, applicandogli un asterisco.
L'operatore asterisco applicato di fronte a un puntatore ci permette di accedere al contenuto della o delle celle, a cui quel puntatore fa riferimento.</p>
<p>Nel caso di Rust si usa asterisco e basta, nel caso del C o del C++, a secondo della sintassi usiamo <code>*</code> oppure <code>-&gt;</code>. Freccia √® un modo condensato per dire ‚Äúdereferenza e offset‚Äù.
Asterisco sostanzialmente si usa nel contesto di un campo, per cui <code>p-&gt;b</code>, se <code>b</code> √® un campo all'interno di una certa struttura allora si trova ad un certo offset dal suo inizio, per cui <code>p-&gt;b</code> √® uguale a <code>*p + offest_di_b</code> .</p>
<p><img src="images/smart_pointer/image%201.png" alt="image.png" /></p>
<p>Tipicamente, se noi usiamo l'operatore asterisco nei confronti di un dato che √® un puntatore, il compilatore fa per noi questo lavoro, generando l'istruzione assembler corrispondente a fare questo tipo di cosa. Tuttavia, sia in Rust sia in C++, noi abbiamo la possibilit√† di insegnare al compilatore che ci sono degli altri tipi che non sono di natura loro puntatori ‚Äî sono tipi, che per√≤ noi vogliamo far sembrare puntatori.</p>
<p>Notate che questo meccanismo l'abbiamo gi√† scoperto con le funzioni. Gli oggetti funzionali in C++ sono cose che non sono funzioni, ma siccome definiscono <code>operator()</code>, li possiamo usare come funzioni, con una serie di vantaggi aggiunti, perch√© avendo dei campi, all'interno di questi campi io posso conservare uno stato e quindi quelle funzioni che implementano si ricordano di quello che √® capitato.</p>
<p>La stessa tecnica la posso utilizzare con i puntatori. Facendo <strong>overload</strong>, nel caso del C++, dell'<strong>operatore asterisco</strong> e dell'<strong>operatore freccia</strong>, che sono solo due variazioni sintattiche dello stesso concetto, io ho la possibilit√† di insegnare al compilatore che un certo mio dato si comporta sintatticamente come si comporterebbe un puntatore, ma dal punto di vista semantico pu√≤ fare delle cose in pi√π che un puntatore semplice non sarebbe in grado di fare.</p>
<p>E queste cose in pi√π che mi possono dare sono, ad esempio, la <strong>garanzia di inizializzazione</strong> o di <strong>rilascio</strong>. Quando io ho una variabile in C, di tipo <code>int*</code>, non posso dire se √® stata inizializzata, posso guardare se √® uguale a <code>null</code> o a zero, ma supponendo che contenga un numero diverso da zero, io non so dire se quel numero diverso da zero √® un indirizzo valido o √® semplicemente del garbage, della spazzatura che √® rimasta dentro perch√© nessuno gli ha attribuito qualche cosa.</p>
<p>Viceversa, uno <strong>smart pointer</strong>, un oggetto che <em>si veste da puntatore</em>, pu√≤ garantirmi questo, ad esempio attraverso il fatto che io lo posso solo costruire attraverso un suo <em>costruttore</em> o una sua <em>funzione di inizializzazione</em> e questa si prende la briga di metterci dentro delle cose sensate. Cos√¨ come posso garantire il rilascio, proprio perch√© quella struttura l√¨ potr√† avere un <em>distruttore</em> e di conseguenza il distruttore pu√≤ prendersi la briga di garantirmi che il rilascio viene fatto.</p>
<p>Oppure potrei implementare delle politiche pi√π sofisticate, come quelle di <strong>conteggio dei riferimenti</strong> che adesso vediamo. Oppure potrebbe garantirmi l'<strong>accesso condiviso</strong> da pi√π parti ma mutuamente esclusivo nel tempo, ovvero io posso avere due o pi√π che vogliono usare questo puntatore ma mai insieme, <em>perch√©?</em> Perch√© se cercassero di farlo insieme uno dei due sarebbe obbligato ad aspettare e passerebbe prima l'altro e solo quando l'altro avesse finito, allora chi si presenta dopo potrebbe entrare.</p>
<p>Quindi esistono diversi comportamenti possibili quando una struttura dati, oltre all'indirizzo di memoria (che √® semplicemente un numero a <code>32</code> o <code>64</code> bit, a seconda dell'architettura), contiene anche altre informazioni. Queste informazioni aggiuntive vengono utilizzate per modificare il comportamento della struttura quando si comporta come puntatore.</p>
<p>Ragionando su queste cose qui, ad un certo punto nella storia del C++ √® nata l'idea degli <strong>smart pointer</strong>. Rust l'ha fatta sua profondamente e ai tre smart pointer presenti nel C++ moderno ne ha aggiunti una serie che oggi vogliamo scoprire. Questi smart pointer sono utilissimi perch√© ci risolvono una serie di problemi. Va detto che nel C++ moderno c'√® una delle regole fondamentali √® proprio quella di dire ‚Äú<em>non usare mai puntatori nativi ma usa solo smart pointer, che sono gli unici che ti danno garanzia‚Äù</em>.</p>
<p>Rust prende una strada pi√π diretta: non espone i puntatori normali (accessibili solo in modalit√† unsafe) e offre invece i <strong>reference</strong> e i <strong>refmut</strong>. Questi sono garantiti corretti grazie a un uso limitato ai casi dimostrabili dal compilatore. In alternativa, Rust fornisce gli smart pointer che risolvono quelle situazioni dove i reference semplici non basterebbero, mantenendo comunque la correttezza dell'algoritmo.</p>
<p><img src="images/smart_pointer/image%202.png" alt="image.png" /></p>
<p><strong>Perch√© ci interessano i puntatori?</strong>
I puntatori ci interessano assolutamente perch√© se non avessimo i puntatori, certe strutture dati non le potremmo implementare in nessun modo.
Una <em>linked list</em> non pu√≤ esistere senza i puntatori, ma anche una <em>hash map</em> non riesce a esistere senza puntatori, e tante altre‚Ä¶ Un <em>grafo</em> non lo posso rappresentare senza i puntatori perch√© il grafo √® fatto di vertici e archi, e l'arco √® proprio il puntatore che va da un vertice a un altro vertice.</p>
<p>Allora, i puntatori sono quindi <strong>potentissimi</strong> e sono alla base della maggior parte degli algoritmi che noi andiamo a utilizzare, per√≤ noi abbiamo abbondantemente detto e ripetuto che l'abuso dei puntatori √® la fonte principale di disastro dei programmi e quindi dobbiamo trovare un modo plausibile di gestirlo.</p>
<p>Vediamo di introdurre prima nel C++ perch√© √® pi√π semplice e in qualche modo risponde a una storia anche che ci spiega perch√© sono nate alcune cose e poi ritroviamo questi concetti dall'altra parte in Rust.</p>
<h2 id="11-smart-pointer-in-c"><a class="header" href="#11-smart-pointer-in-c">1.1 Smart pointer in C++</a></h2>
<p><img src="images/smart_pointer/image%203.png" alt="image.png" /></p>
<p>Il C++ fin dalle origini aveva un'idea, un oggetto strano nella sua libreria che si chiamava <code>std::auto_ptr</code>. √à stato l'embrione della storia degli smart pointer ma <code>auto_ptr</code> soffriva di un problema enorme. Quando voi lo copiavate faceva delle cose strampalate che uno non si aspettava a fronte di una copia. Per questo motivo, cose che avevano la loro razionalit√† ma erano sufficientemente strane da mettere in motivo, quando nel 2011 √® uscito il C++ moderno, contestualmente si √® detto <code>auto_ptr</code> √® bannato, e sono stati piuttosto introdotti tre oggetti che si chiamano <code>unique_ptr</code>, <code>shared_ptr</code> e <code>weak_ptr</code> che sono invece congruenti tra di loro, hanno una semantica sensata e ci danno una serie di garanzie.</p>
<h3 id="111-unique_ptr"><a class="header" href="#111-unique_ptr">1.1.1 <code>unique_ptr</code></a></h3>
<p>Il primo, <code>unique_ptr</code>, dice <em>‚Äúio sono un puntatore che non pu√≤ essere copiato‚Äù</em>, esiste in un'unica copia. Questo non √® molto diverso dai <code>refmut</code>, il <code>refmut</code> esiste in un'unica copia, tu lo puoi cedere a un altro perdendolo tu. Io non posso avere lo stesso <code>refmut</code> salvato in due variabili diverse.
<code>unique_ptr</code> ha la stessa caratteristica, proprio come <code>refmut</code> √® un puntatore, cio√® se io vado a guardare quanto spazio consuma, consuma <code>4 byte</code> sull'architettura 32 bit, <code>8 byte</code> sull'architettura a 64, ma il compilatore del C++, proprio come fa Rust con il <code>refmut</code>, si fa garante che non venga copiato.</p>
<p>Piccolo problema, in Rust naturalmente l'assegnazione √® un movimento, per cui quando io faccio <code>a = b</code>, a meno che la struttura dati goda del tratto <code>Copy</code>, <code>a = b</code> vuol dire prendi quello che c'√® dentro <code>b</code>, copialo dentro <code>a</code>, ma <code>b</code> non √® pi√π accessibile.
In C++ il concetto di movimento esiste, ma √® esplicito. Allora, io non posso in C++ scrivere con unique_ptr <code>ptr1 = ptr2</code>, perch√© il compilatore me lo blocca, ma devo scrivere <code>ptr1 = std::move(ptr2)</code>, cio√® devo in modo esplicito dire <em>‚Äúmuovimelo‚Äù</em>.</p>
<p><em>Muovimelo</em> esattamente come succede in Rust, non √® nient'altro che <em>‚Äúcopialo e rendi l'originale inadeguato‚Äù</em>.
Il modo che il C++ ha per rendere l'originale inadeguato, siccome non ha tutti i controlli del compilatore di Rust, √® metterci un <code>null</code> dentro. Quindi quello l√¨ perde il suo riferimento alla memoria e lo cede a quell'altro.</p>
<p><code>unique_ptr</code> √® un oggetto che pu√≤ essere costruito in <strong>due modi</strong>:</p>
<ul>
<li>con l'operatore <code>new</code>, come tutti gli oggetti del C++, a partire da un puntatore semplice di cui prende il possesso</li>
<li>tramite una funzione di creazione <code>make_unique</code> (<code>std::make_unique</code>), simile a quello che succede in Rust quando scriviamo <code>struct::new</code></li>
</ul>
<p>La funzione alloca sullo heap un blocco grande quanto serve, di cui l‚Äôoggetto √® il possessore. Se verr√† passato come parametro, dovr√† cedere questo possesso usando <code>std::move</code> per indicare esplicitamente il trasferimento, diventando nullo.</p>
<p>Quindi <code>unique_ptr</code>, come dice il nome, √® un puntatore che √® <strong>posseduto in un posto solo</strong>. Quando esce di scope, viene chiamato il suo distruttore che rilascia la memoria allocata, garantendo il rilascio. Fa overload di <code>operator*</code> e <code>operator-&gt;</code>, permettendo di usarlo come un normale puntatore, ma con garanzie aggiuntive. Non potendo essere copiato, ce n'√® uno e uno solo ‚Äî al massimo pu√≤ essere ceduto.</p>
<h3 id="112-shared_ptr"><a class="header" href="#112-shared_ptr">1.1.2 <code>shared_ptr</code></a></h3>
<p>In molte situazioni questo va benissimo. Ci sono casi per√≤ in cui serve che pi√π riferimenti puntino allo stesso dato. Pensate a un <em>grafo</em>: un nodo deve poter essere, ad esempio, punto di arrivo di due archi diversi. Con <code>unique_ptr</code> questo non sarebbe possibile, perch√© un nodo conosciuto da un puntatore non potrebbe essere conosciuto da un altro.</p>
<p>Per questo √® stata introdotta la seconda struttura: lo <code>shared_ptr</code>. √à pi√π complessa perch√© √® "fat", proprio come in Rust. Gli slice e gli oggetti tratto in Rust sono "fat" ‚Äî sembrano puntatori ma sono doppi: gli slice contengono puntatore e size, gli oggetti tratto contengono due puntatori.</p>
<p>Uno <code>shared_ptr</code> √® un <strong>puntatore doppio</strong>:</p>
<ul>
<li>Da un lato punta al dato</li>
<li>Dall'altro punta a una struttura di controllo contenente un contatore</li>
</ul>
<p>Alla costruzione, vengono allocati dato e struttura di controllo, inizializzando il contatore a 1. Quando lo <code>shared_ptr</code> viene copiato (<code>ptr1 = ptr2</code>), si creano due puntatori che puntano agli stessi elementi, incrementando il contatore da 1 a 2. Per questo si chiama "shared" - √® condiviso e tiene traccia delle condivisioni.</p>
<p>Nel momento in cui uno di questi due shared pointer dovesse morire, perch√© raggiunge la fine del suo scope, passa al suo distruttore, e il distruttore <em>che cosa fa?</em> Va sulla struttura di controllo e decrementa, quindi da 2 scende a 1.
Siccome il risultato non √® 0, dice <em>‚Äúok, io ho decrementato, non c‚Äô√® altro da fare‚Äù</em>.</p>
<p>Quando anche quell'altro morir√†, anche lui andr√† sulla struttura di controllo, decrementer√† (e da 1 diventa 0), e vedendo che il risultato √® 0 dice, <em>‚Äúah, ma questa cosa √® finita, ero l'ultimo che la conosceva, quindi dealloco anche la memoria‚Äù</em>.
Quindi uso la prima parte del puntatore per liberare la memoria.</p>
<p>In questo modo possiamo essere <strong>abbastanza sicuri</strong> che anche con 50 puntatori che fanno riferimento allo stesso dato, il contatore sar√† 50. I puntatori possono essere distrutti in qualsiasi ordine ‚Äî non ha importanza, poich√© ognuno decrementando il contatore fa la sua parte. Quando l'ultimo viene deallocato, il contatore arriva a 0 e solo allora il blocco di memoria viene liberato.</p>
<p>In questa maniera io ho la <strong>certezza</strong> che quella memoria non diventer√† mai dangling, cio√® il puntatore che ho a quel blocco di memoria non sar√† mai dangling, perch√© finch√© c'√® almeno uno che lo conosce vado bene.</p>
<p><strong>Creazione degli shared_ptr</strong>
Anche questi, il modo preferenziale √® attraverso la funzione <code>make_shared</code> ‚Äî √® una funzione base, quindi non √® il metodo di un oggetto, ma √® una funzione e basta che prende i parametri con cui voglio creare un oggetto, alloca questo oggetto sullo heap, passando al suo costruttore i parametri che diamo a <code>make_shared</code>.
√à una funzione generica e quindi ci d√† la possibilit√† di specificare come andiamo a inizializzarla.</p>
<h3 id="113-dettagli-implementativi-di-unique_ptr"><a class="header" href="#113-dettagli-implementativi-di-unique_ptr">1.1.3 Dettagli implementativi di <code>unique_ptr</code></a></h3>
<p><img src="images/smart_pointer/image%204.png" alt="image.png" /></p>
<p>Quindi di per s√© <code>unique pointer</code> √® banalissimo: √® implementato di fatto come puntatore semplice. L'unica vera faccenda √® che <strong>non pu√≤ essere copiato</strong>. Siccome √® stato definito come <code>deleted</code> l'operatore uguale, se io cercassi di assegnarlo a un altro puntatore o di passarlo come parametro, il compilatore mi blocca con un errore, non si pu√≤ fare.</p>
<p>Al contrario, √® presente l'implementazione dell'operatore di <em><strong>assegnazione per movimento</strong></em>, che nella sintassi del C++ si esprime come <code>operator=(value reference &amp;&amp; T)</code>.</p>
<p><em>Cosa accade durante il movimento?</em> Il dato della sorgente viene copiato nella destinazione ‚Äî in pratica, <em>"quel puntatore che aveva lei ora lo prendo io"</em> ‚Äî mentre nella sorgente viene scritto <code>null</code>.</p>
<p>Questo era la base del comportamento di <code>auto_ptr</code>, solo che in <code>auto_ptr</code>, nel C++ che precedeva la versione 11, il concetto di movimento non c'era, e quindi l√¨ c'era un'assegnazione che modificava l'originale, che √® un casino.
Nel movimento invece questo √® ovvio, io muovo proprio perch√© mi prendo i suoi dati e lascio il vuoto dall'altra parte.</p>
<p>In <strong>Rust</strong> non c'√® la responsabilit√† di riempire il buco, perch√© Rust si fa garante che quello da cui ho mosso non potr√† pi√π essere acceduto, cio√® se io provo ad andarci a leggere dentro, il borrow checker mi blocca, dice <em>"no, qui non puoi toccare, perch√© quello ormai l'hai mosso"</em>. E quindi chi se ne frega che sia rimasta spazzatura l√¨ dentro. In C++ questa capacit√† del compilatore non c'√® e di conseguenza occorre garantire che io lascio l'originale pulito mettendoci dentro un <code>null</code>.</p>
<p>Il distruttore di <code>unique_ptr</code> si occupa di rilasciare il blocco che vive sull‚Äôheap.</p>
<p>Vediamo un esempio.</p>
<h3 id="114-esempio-unique_ptr"><a class="header" href="#114-esempio-unique_ptr">1.1.4 Esempio <code>unique_ptr</code></a></h3>
<p><img src="images/smart_pointer/image%205.png" alt="image.png" /></p>
<p>Qui abbiamo un blocco dove dichiaro un puntatore <code>p</code> di tipo <code>std::unique_ptr</code>, e lo inizializzo con <code>make_unique</code> di 5.</p>
<p><em>Cosa succede?</em>
Il momento in cui eseguo questa cosa qua, <code>p</code> esiste sullo stack, l'esecuzione di <code>make_unique</code> va sull'heap, alloca un blocco grande quanto mi serve per tenere un intero (32 bit), ci mette dentro 5, prende il puntatore, e lo salva dentro <code>p</code>.</p>
<p><img src="images/smart_pointer/image%206.png" alt="image.png" /></p>
<p>Pi√π avanti dico <code>int i = *p</code>, quindi accedo a <code>p</code> come un puntatore normalissimo, bene, prendo quel 5 che stava sull'heap, lo copio dentro la variabile <code>i</code> che sta sullo stack, questo non mi d√† nessun fastidio.</p>
<p><img src="images/smart_pointer/image%207.png" alt="image.png" /></p>
<p>Posso scriverci <code>*p = 7</code>, benissimo. Uso <code>p</code> come puntatore, vado nella zona in cui punta, cambio il suo contenuto, ci metto 7, e va benissimo.</p>
<p><img src="images/smart_pointer/image%208.png" alt="image.png" /></p>
<p><strong>Chiusa graffa.</strong>
Chiusa graffa comporta la contrazione dello stack. <code>i</code> va via, senza side effect, <code>p</code> va via, ma prima di andar via chiama il distruttore.</p>
<p><em>Cosa fa il distruttore?</em> <strong>Rilascia</strong>.
E quindi l‚Äôheap resta pulito. Se quella cosa l√¨ invece di essere un <code>make_unique</code> fosse stato un <code>int*</code>, il codice andava ancora bene perfettamente, ma l'effetto sarebbe stato che senza un'esplicita <code>delete</code> io sarei arrivato al chiusa graffa e nell'heap mi restava il 7, che invece usando <code>unique_ptr</code> √® andato via.</p>
<p>Quindi <code>unique_ptr</code> mi d√† questa garanzia, che √® molto comoda. Non ho bisogno di ricordarmi.</p>
<p>Se per caso invece di buttare via <code>p</code> l'avessi ritornato, se quindi questa funzione avesse fatto <code>return p</code>, <em>cosa sarebbe successo?</em>
Beh il mio <code>p</code> locale veniva mosso nel valore di ritorno, quindi dentro il mio <code>p</code> ci finiva un <code>null</code> e il distruttore non avrebbe fatto niente, ma la copia del puntatore era nel valore di ritorno che quindi restava vivo, chi lo riceveva ci faceva delle cose e quando chi l'avesse ricevuto fosse morto, fosse uscito dal suo scope, l'avrebbe automaticamente rilasciato.
Cio√® non c'√® rischio con <code>unique_ptr</code> che quella memoria l√¨ non venga rilasciata.
E parimenti, se io ho fatto bene le cose, ho inizializzato il mio <code>unique_ptr</code>, contiene un dato e posso dereferenziarlo.</p>
<h3 id="115-dettagli-implementativi-di-shared_ptr"><a class="header" href="#115-dettagli-implementativi-di-shared_ptr">1.1.5 Dettagli implementativi di <code>shared_ptr</code></a></h3>
<p><img src="images/smart_pointer/image%209.png" alt="image.png" /></p>
<p><strong><code>shared_ptr</code></strong>, come dicevamo prima, √® <strong>fat</strong>.</p>
<p>Mentre uno <code>unique_ptr</code> a tutti gli effetti √® proprio solo un puntatore, uno <code>shared_ptr</code> √® una struttura un po' pi√π grossa, che si usa come un puntatore (quindi con asterisco, o con freccia), ma dentro di s√© ha due puntatori:</p>
<ul>
<li>ha il dato, che pu√≤ essere grande a piacere</li>
<li>ha la struttura di controllo</li>
</ul>
<p>La struttura di controllo in realt√† √® un pelino pi√π complessa di come accennato prima.
Cio√® non contiene soltanto il conteggio dei riferimenti.</p>
<p><em><strong>Perch√©?</strong></em>
Perch√© il sistema del conteggio dei riferimenti ha un <strong>buco logico gravissimo</strong>. Immaginate di aver creato una semplicissima <code>LinkedList</code> (una lista doppiamente collegata), di quelle dove ciascun elemento punta in avanti e punta all'indietro.</p>
<p>Inizialmente la vostra LinkedList contiene un solo elemento, quindi il suo puntatore in avanti √® <code>null</code>, il suo puntatore all'indietro √® <code>null</code>. E questo elemento qui √® puntato dall'oggetto che conosce la lista.</p>
<p>A un certo punto, su questa lista aggiungete qualcosa, mettiamolo al fondo, ma non cambierebbe nulla.</p>
<p><em>Cosa succede?</em>
Adesso il punto d'inizio √® conosciuto dalla vostra variabilina che conosce l'inizio, dentro di s√© avrebbe il back sempre a <code>null</code>, e il next al nuovo elemento che avete aggiunto.</p>
<p>Ma il nuovo elemento che avete aggiunto punterebbe anche all'indietro, a quello che c'era gi√† prima, che a questo punto avrebbe due riferimenti:</p>
<ul>
<li>la lista stessa che gli dice <em>"inizi qua"</em></li>
<li>l'elemento che segue che punta all'indietro</li>
</ul>
<p>L'elemento che viene dopo avrebbe un next <code>null</code>.
Quindi il primo elemento ha un contatore pari a <strong>2</strong> e il secondo elemento ha un contatore pari a <strong>1</strong>.</p>
<p><strong>Ora, la testa della lista esce di scope. <em>Cosa succede?</em></strong>
Lo smart pointer che punterebbe al primo degli elementi va sul blocco di controllo e lo decrementa, scende a 1. La testa della lista viene tolta dai piedi, ma il primo elemento non viene comunque dellocato, perch√© vale 1 il contatore.
Il problema √® che andando via la testa adesso mi ritrovo in una situazione in cui il primo elemento punta al secondo e lo tiene in vita, il secondo elemento punta al primo e lo tiene in vita, ma pi√π nessuno conosce nel primo e nel secondo. Ho fatto un <em>buco nero</em>.
E' un buco nero piccolino perch√© ci sono solo due cose, ma quella memoria l√¨ non la liberer√† mai pi√π nessuno. Non c'√® modo di liberarla.</p>
<p>Se per caso invece di essere una lista di due fosse stata una lista di <strong>20.000 elementi</strong>, ciascuno teneva in vita quello successivo e viceversa, perch√© tutti si conoscono a coppie. Ma nessuno sa pi√π dove sono, e quindi io ho perso in un colpo solo una cosa enorme.</p>
<p>Quindi il concetto di <code>shared_ptr</code> √® molto bello, <em>fin tanto che non ho dei cicli</em>.
La difficolt√† della lista √® che, avendo il puntatore in avanti e anche all'indietro, crea dei cicli. Le strutture cicliche tendono a tenersi, con l'uso dei contatori e del conteggio dei riferimenti, si tengono in vita. Non c'√® modo di liberarle. <strong>Bisogna spaccare questo ciclo.</strong></p>
<p>Per questo motivo c'√® un terzo tipo di puntatore che si chiama <code>weak_ptr</code>, che serve a chiudere i cicli, cio√® a evitare che queste cose qua restino vive per l'eternit√†.
Per questo motivo il blocco di controllo √® un pochino pi√π sofisticato. All'interno del blocco di controllo ci sono tre cose:</p>
<ul>
<li><strong>il contatore dei riferimenti <em>hard</em></strong>
Quanti altri <code>shared_ptr</code> conoscono il dato condiviso?</li>
<li><strong>il contatore dei riferimenti <em>weak</em></strong>
Quanti <code>weak_ptr</code> conoscono il dato condiviso e chiudono eventuali cicli?</li>
<li><strong>il puntatore al dato condiviso</strong>
Serve per poter rilasciare le cose nel momento giusto</li>
</ul>
<p>Solo quando entrambi i due contatori scenderanno a zero, il contatore hard e il contatore weak, il blocco di controllo sar√† liberabile.</p>
<p>Vediamo com'√® fatta questa cosa.</p>
<h3 id="116-esempio-shared_ptr"><a class="header" href="#116-esempio-shared_ptr">1.1.6 Esempio <code>shared_ptr</code></a></h3>
<p><img src="images/smart_pointer/image%2010.png" alt="image.png" /></p>
<p>Io qui sto creando uno <code>shared_ptr p</code>.
Vedete che lo <code>shared_ptr p</code> √® un oggetto che sta sullo stack, in questo caso punta al dato che √® <code>5</code>. L'oggetto <code>p</code> dentro di s√© √® <strong>fat,</strong> ha due pezzi: un primo puntatore al blocco di controllo che √® fatto di <em>tre caselline</em>, e un secondo pezzo che √® il puntatore al dato vero e proprio, che contiene in questo caso il numero <code>5</code>.</p>
<p>Inizialmente il blocco di controllo √® fatto cos√¨: dice c'√® un contatore <em>hard</em>, io so che c'√® uno <code>shared_ptr</code> che conosce questo dato, √® l'unico che ho messo. Zero <em>weak</em>, non c'√® nessun altro, non c'√® nessun <code>weak_ptr</code> che mi chiude eventuali cicli, benissimo. E dentro il blocco di controllo mi tengo anche il puntatore al dato stesso, che in questo caso √® <code>5</code>.</p>
<p><img src="images/smart_pointer/image%2011.png" alt="image.png" /></p>
<p><em>Cosa succede nel momento in cui creo un secondo smart pointer?</em>
<code>auto</code> √® un modo che il C++ mi d√† per fare la <em>type inference</em>, dice <em>‚Äúcapisci da solo il tipo a partire da quello che ti metto dentro‚Äù.</em></p>
<p>Quindi <code>q</code> √® un altro <code>shared_ptr</code> di <code>int</code>.
In quanto altro <code>shared_ptr</code> di <code>int</code> √® anche lui una cosa grossa, due singoli puntatori, che condividono il puntare sia al blocco di controllo sia il puntare al dato.
Dentro <code>q</code>, guardando il lato del dato finisco sul numero <code>5</code>, guardando il lato del blocco di controllo finisco sulla stessa struttura di controllo di prima.</p>
<p>Solo che nel momento in cui ho fatto <code>q = p</code> non ho solo duplicato i puntatori alle due parti, nel blocco di controllo ho incrementato il conteggio. Adesso ho <strong>due</strong> <em><strong>hard link</strong></em> e <strong>zero</strong> <em><strong>weak link</strong></em>.</p>
<p><img src="images/smart_pointer/image%2012.png" alt="image.png" /></p>
<p>Usando <code>q</code> accedo al dato puntato e lo cambio: <code>*q = 3</code>. Questo √® lecito, quindi uso <code>q</code> come puntatore, lo seguo, vado nella zona del dato e questo mi dice <em>"butta via quello che c'era prima, il 5, cambialo con 3"</em> ‚Äî perfetto. Il blocco di controllo in questa operazione qua non ha nessun effetto.</p>
<p>Questo √® scritto dentro un'aperta graffa che mi riduce il tempo di vita di <code>q</code> fino alla chiusa graffa corrispondente.</p>
<p><img src="images/smart_pointer/image%2013.png" alt="image.png" /></p>
<p>Quando arrivo alla chiusa graffa corrispondente cosa succede? Beh, che quel <code>q</code> l√¨ esce di scope, viene distrutto, quindi deve contrarsi lo stack. Ma prima che lo stack possa contrarsi, gira il suo distruttore.</p>
<p><em>Cosa fa il distruttore dello</em> <code>shared_ptr</code><em>?</em>
Cos√¨ come durante la costruzione ha incrementato il contatore, cos√¨ al momento della distruzione lo decrementa. Se il risultato non √® zero, finisce l√¨
E in effetti il risultato non √® zero, era <code>2</code> ed √® sceso a <code>1</code>.</p>
<p><img src="images/smart_pointer/image%2014.png" alt="image.png" /></p>
<p><code>p</code> continua a avere accesso, quindi posso usare <code>p</code>: <code>*p = 7</code>. Vado, seguo il ramo del dato, vado su quella casella l√¨, ci scrivo <code>7</code> ‚Äî nessun problema.</p>
<p><img src="images/smart_pointer/image%2015.png" alt="image.png" /></p>
<p>E poi arrivo alla chiusa graffa finale.</p>
<p><em>Cosa succede a questo punto?</em>
Devo distruggere <code>p</code>. Quando il suo distruttore viene eseguito, controlla il blocco di controllo e decrementa il <strong>contatore degli hard link</strong>. Se questo arriva a 0, il dato viene distrutto.
A questo punto il distruttore controlla anche il <strong>contatore dei weak link</strong> ‚Äî se anche questo √® a 0, viene distrutto il blocco di controllo. Se invece i weak link non fossero a <code>0</code>, il blocco di controllo rimarrebbe intatto.</p>
<p>In questo caso, quindi il distruttore ha <strong>decrementato il numero degli hard link</strong>, ha visto che era <code>0</code>, ha <em>liberato il dato</em>, ha verificato che i weaklink erano <code>0</code> anche loro, e quindi ha <em>liberato anche il blocco di controllo</em>. Esco da questa procedura e sullo heap non c'√® pi√π niente, e anche lo stack chiaramente si √® svuotato.</p>
<p>Se per qualche motivo io avessi registrato il puntatore <code>p</code> dentro una struct di qualcun altro, l'avessi salvato dentro un vettore, avessi fatto delle cose, quello l√¨ avrebbe mantenuto alto il conteggio dei riferimenti e quindi il mio dato sarebbe rimasto vivo. Quando l'ultimo a conoscere questo dato andr√† via dai piedi, non importa chi sia, a quel punto il dato sar√† rilasciato.</p>
<p><img src="images/smart_pointer/image%2016.png" alt="image.png" /></p>
<p>Quindi, un altro modo di vedere la struttura dello <code>shared_ptr</code>.</p>
<p>Gli shared pointer sono <strong>fat pointer</strong> composti di due sottocampi:</p>
<ul>
<li>il puntatore al valore</li>
<li>il puntatore ai metadati (o blocco di controllo)</li>
</ul>
<p>Se ho pi√π copie dello stesso shared pointer, tutte le copie sono apparentemente identiche, contengono lo stesso puntatore al dato o lo stesso puntatore al blocco di controllo. Quello che cambia √® che quando aggiungo una copia il contatore nel blocco di controllo sale, quando rimuovo una copia il puntatore nel blocco di controllo diminuisce.</p>
<h3 id="117-dipendenze-cicliche"><a class="header" href="#117-dipendenze-cicliche">1.1.7 Dipendenze cicliche</a></h3>
<p><img src="images/smart_pointer/image%2017.png" alt="image.png" /></p>
<p>Per√≤ questo diventa problematico quando si crea una <strong>dipendenza ciclica</strong>. In presenza di un ciclo, la struttura si mantiene in vita da sola e diventa impossibile liberare la memoria.</p>
<p><em>Come possiamo risolvere?</em>
Non esiste una soluzione automatica ‚Äî √® impossibile rilevare questi cicli, poich√© possono essere di lunghezza <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, o ancora pi√π complessi. Quando un puntatore indica un blocco che contiene un altro puntatore che torna indietro, la struttura diventa difficile da analizzare. <em>Solo il programmatore pu√≤ individuare e gestire queste situazioni.</em></p>
<p>E quindi il programmatore deve scegliere come gestirla. Il programmatore, quando si trova a dover costruire una struttura ciclica ‚Äî ad esempio la <code>LinkedList</code>, oppure un albero in cui ho il padre che punta ai figli, ma anche i figli che mi puntano indietro al padre, perch√© hanno bisogno di poter risalire lungo la catena ‚Äî ha la responsabilit√† di decidere qual √® il cammino principale che implementa con uno <code>shared_ptr</code> e qual √® il cammino di ritorno che implementa con un <code>weak_ptr</code>.</p>
<p>In base a come √® fatto il mio algoritmo mi converr√† avere, ad esempio, il padre che punta in modo <em>hard</em> ai figli e i figli in modo <em>weak</em> al padre o viceversa. Per√≤ io devo fare una scelta e organizzarmi per essere coerente di conseguenza.</p>
<h3 id="118-weak_ptr"><a class="header" href="#118-weak_ptr">1.1.8 <code>weak_ptr</code></a></h3>
<p><img src="images/smart_pointer/image%2018.png" alt="image.png" /></p>
<p>L'oggetto <code>weak_ptr</code> √® fatto cos√¨. Serve a creare delle dipendenze cicliche che non vanno a incrementare il conteggio <em>hard</em>, ma incrementano l'altro campo, il conteggio <em>weak</em>.</p>
<p><strong>Io creo uno <code>weak_ptr</code> a partire da uno <code>shared_ptr</code>.</strong>
Quindi io so che ho una struttura dati che √® puntata da un certo shared pointer e gli dico <em>"ok, adesso dammi un altro puntatore a te, ma di tipo weak"</em>.</p>
<p><em>Cosa succede?</em>
Questo puntatore weak, che √® un puntatore <em>semplice</em>, punta solo al blocco di controllo in cui il conteggio dei weak viene aumentato.</p>
<p>Quel puntatore weak l√¨, quindi un puntatore semplice che non crea grosso problema, per√≤ non pu√≤ essere usato direttamente: <strong>richiede una promozione.</strong>
Quindi il weak pointer √® una cosa che <em>potenzialmente</em> mi fa accedere, ma di suo arriva solo al blocco di controllo. Il blocco di controllo √® sigillato, √® tutto privato l√¨ dentro, io quindi non posso direttamente usarlo per farci cose.</p>
<p><strong>Quando un weak pointer viene distrutto</strong>, accede al suo blocco di controllo per decrementare il conteggio dei weak. Se <em>entrambi</em> i conteggi (weak e hard) sono a 0, il blocco di controllo viene deallocato. Altrimenti, se uno dei due conteggi non √® 0, il weak pointer viene semplicemente rimosso.</p>
<p>Una caratteristica importante del weak pointer √® la sua capacit√† di essere <strong>promosso a shared pointer</strong>. √à un'operazione che pu√≤ fallire e che in Rust implementeremo con un <code>Option</code>.
Durante la promozione, il weak pointer verifica nel blocco di controllo se il dato esiste ancora (controllando il contatore degli hard). Se il dato √® ancora valido, viene creato temporaneamente uno shared pointer che mantiene sia il puntatore al blocco di controllo che il puntatore al dato, quest'ultimo recuperato dal blocco di controllo stesso.</p>
<p>Questo spiega perch√© il blocco di controllo deve mantenere il puntatore al dato: √® <em>essenziale</em> per la promozione da weak a shared. Durante questa promozione, il conteggio degli hard viene temporaneamente incrementato.</p>
<p>Per esempio, in una linked list, se dobbiamo navigare all'indietro dall'elemento i-esimo usando un weak pointer, dobbiamo: <strong>1)</strong> promuoverlo temporaneamente a shared, <strong>2)</strong> navigare indietro, <strong>3)</strong> eliminare lo shared pointer temporaneo.
Questo meccanismo di promozione √® fondamentale.</p>
<p>Questo concetto √® stato introdotto nel 2011 con la prima versione del C++ moderno. Sebbene sia stato raffinato negli anni successivi con miglioramenti nell'overloading e maggiore flessibilit√† d'uso, l'idea di base √® rimasta invariata ‚Äî <em>cos√¨ solida e efficace</em> che anche i creatori di Rust hanno deciso di adottarla.</p>
<h1 id="2-smart-pointer-in-rust"><a class="header" href="#2-smart-pointer-in-rust">2. Smart pointer in Rust</a></h1>
<p><img src="images/smart_pointer/image%2019.png" alt="image.png" /></p>
<p><strong>In Rust</strong>, gli sviluppatori hanno detto <em>"questa idea ci piace cos√¨ tanto, che di smart pointer ne facciamo ben di pi√π!"</em>, per cui ne abbiamo tre che assomigliano ai tre del C++:</p>
<ul>
<li><strong><code>Box</code></strong> √® il corrispettivo di <code>unique_ptr</code></li>
<li><strong><code>Rc</code></strong> (<em><strong>resource count</strong></em>) √® l'equivalente di <code>shared_ptr</code></li>
<li><strong><code>Weak</code></strong> √® l'equivalente di <code>weak_ptr</code></li>
</ul>
<p>Queste sono i tre base che copiano tale quale il C++.</p>
<p>In realt√† <strong><code>Rc</code></strong> esiste in due forme: esiste <strong><code>Rc</code></strong> ed esiste <strong><code>Arc</code></strong>.</p>
<p><code>Arc</code> <em>si usa multi-threaded</em>, perch√© incrementare quel conteggio dei riferimenti, se io lo faccio con un'operazione di increment semplice, in un contesto multi-threaded rischio di dire delle stupidaggini. Su due thread che in contemporanea cercano di fare <code>++</code> su un dato, il risultato √® <strong>unknown</strong>. Escono numeri a caso.</p>
<p>Quindi non lo posso fare cos√¨, e allora devo usare <strong>atomic increment</strong>, solo che atomic increment costa un po' di pi√π. Se increment normale mi costa 4 cicli su un x86, atomic increment me ne costa una trentina.</p>
<p>E di conseguenza Rust dice <em>"Stai scrivendo un programma single thread? Perfetto,</em> <code>Rc</code> <em>fa per te</em>. <em>Stai scrivendo un programma multi-thread? Allora devi usare</em> <code>Arc</code><em>, perch√© se usi <code>Rc</code> con i thread ti blocco.‚Äù</em></p>
<p>E di conseguenza di weak ce ne sono due: c'√® il <code>Weak</code> di <code>Rc</code> e il <code>Weak</code> di <code>Arc</code>.
Si chiamano tutti e due <code>weak</code>, ma il loro namespace √® diverso: uno si chiama <code>std::sync::Weak</code> e l'altro si chiama <code>std::rc::Weak</code>.</p>
<p><strong>Questi smart pointer sono quelli base.</strong></p>
<p>Poi **ce ne sono altri che sono un po' particolari.</p>
<p>Uno si chiama <strong><code>Cell</code></strong> ed ha la mutabilit√† interna, l'altro si chiama <strong><code>RefCell</code></strong> ed ha una forma di mutabilit√† interna che sostanzialmente permette di dire <em>"ci sono casi in cui in un programma non concorrente,</em> <code>Cell</code> <em>e</em> <code>RefCell</code> <em>mi permettono di avere un ref semplice ad un dato che pu√≤ cambiare"</em>.</p>
<p>V√¨ola un po' quello che sembrerebbe essere il principio fondamentale che abbiamo visto: se io ho un <code>ref</code>, sono certo che punto un dato, ma quel dato √® immutabile. Piuttosto se ho un <code>ref mut</code>, io so che quel dato √® mutabile, ma c'√® uno solo che muta.
Invece, nel caso di <code>Cell</code> e <code>RefCell</code>:</p>
<ul>
<li><code>Cell</code> mi d√† un dato che conosco tramite un riferimento immutabile, ma ho la possibilit√† di cambiarlo con un meccanismo che adesso vediamo: lo posso sostituire con qualcos'altro</li>
<li><code>RefCell</code> mi d√† la possibilit√† di avere due ref mut a condizione di non usarli insieme. Dove, se io cerco di usarne uno mentre sto usando l'altro, il programma mi fa panic</li>
</ul>
<p>Questi per√≤ mi aiutano perch√© mi risolvono <em>alcune</em> delle situazioni nelle quali di per s√© io so che potrei scrivere un algoritmo giusto, ma il borrow checker √® cos√¨ restrittivo che me lo impedisce e quindi mi danno una soluzione per questo genere di casi senza compromettere il principio di fondo che √® l'assenza di <em>undefined behavior</em>.
Perch√© quello che succede √® che se io faccio delle cose fuori dallo spazio giusto, loro panicano. Che √® un po' meno bello di essere bloccati in fase di compilazione, ma almeno il programma pu√≤ eseguire.
Ed √® sicuramente pi√π bello panicare piuttosto che andare avanti facendo finta di nulla seminando mine che poi scoppiano dopo, che √® quello che succede in C e C++.</p>
<p>Ci sono anche altri smart pointer specifici per la <strong>programmazione concorrente</strong>: <code>Mutex</code> e <code>RwLock</code>.</p>
<p><code>Mutex</code>, in modo analogo a <code>RefCell</code>, permette di trasformare un riferimento in sola lettura in uno mutabile. Ma questa volta uno alla volta, senza panicare, ma se due thread cercano di accedere contemporaneamente, il primo entra e fa le sue operazioni mentre l'altro aspetta. √à come quando andate in bagno: se √® occupato, aspettate fuori finch√© non si libera.
Questo garantisce l'accesso esclusivo alle risorse condivise, e quell‚Äôaccesso l√¨ √® un accesso mutabile.</p>
<p><code>RwLock</code> √® simile ma pi√π sofisticato: distingue tra accessi in lettura e scrittura. Se vuoi leggere mentre qualcun altro sta gi√† leggendo, puoi entrare ‚Äî come due persone che usano il bagno contemporaneamente per lavarsi le mani e i denti. Le operazioni sono compatibili. Per altre operazioni, dovrai aspettare fuori.</p>
<p><code>RwLock</code> quindi implementa un meccanismo dove <strong>pi√π lettori possono accedere contemporaneamente</strong>, ma <strong>un solo scrittore pu√≤ operare alla volta</strong>. Durante una scrittura, nessun altro thread pu√≤ n√© leggere n√© scrivere. Al termine, il prossimo thread potr√† entrare in base al tipo di accesso richiesto (da solo se in scrittura, insieme ad altri thread se in lettura).</p>
<p>Esiste anche <code>Cow</code> (<em><strong>Copy on Write</strong></em>), che gestisce intelligentemente i dati decidendo quando fare una copia e quando riutilizzare quella esistente. Questo permette ottimizzazioni automatiche, liberandoci dal dover gestire manualmente quando duplicare i dati.</p>
<p>Tutti questi sono <strong>oggetti smart pointer</strong> che, oltre ai puntatori interni, contengono informazioni aggiuntive. Sono utilizzabili grazie all'implementazione dei tratti <code>Deref</code> e <code>DerefMut</code>.
<code>Deref</code> permette di usare una struttura come puntatore a dati condivisi, mentre <code>DerefMut</code> come puntatore a dati mutabili.</p>
<h2 id="21-i-tratti-deref-e-derefmut"><a class="header" href="#21-i-tratti-deref-e-derefmut">2.1 I tratti <code>Deref</code> e <code>DerefMut</code></a></h2>
<p><img src="images/smart_pointer/image%2020.png" alt="image.png" /></p>
<p>I due tratti fondamentali sono:</p>
<ul>
<li><code>Deref</code>: un singolo metodo che restituisce un <code>ref</code> a <code>Self::Target</code></li>
<li><code>DerefMut</code>: restituisce un <code>ref mut</code> a  <code>Self::Target</code></li>
</ul>
<h2 id="22-box"><a class="header" href="#22-box">2.2 Box</a></h2>
<p><img src="images/smart_pointer/image%2021.png" alt="image.png" /></p>
<p>Il pi√π semplice della famiglia √® <code>std::Box</code>.
√à l'equivalente di <code>unique_ptr</code> in C++: di fatto implementato come un singolo puntatore che punta necessariamente allo heap. Infatti, l'unico modo per crearlo √® attraverso il costruttore <code>new</code>, che alloca spazio sullo heap per un valore e lo sposta nella posizione allocata.</p>
<p>Quindi <code>Box</code> possiede ‚Äî prende possesso del valore, il costruttore <code>Box::new</code> prende il valore <code>v</code>, che noi gli passiamo come parametro, e ne trasferisce il possesso, quindi lo consuma, e trasferisce il possesso al <code>Box</code> stesso, che lo conserva all'interno dello <strong>heap</strong>.
Lo tiene l√¨ dentro fino a che l'oggetto <code>Box</code> non viene <em>droppato</em>, quando esce dallo stato di vita, e a quel punto la memoria viene rilasciata.</p>
<p>In caso di movimento, <code>Box</code> non implementa <code>Copy</code>, per√≤ implementa assolutamente l'assegnazione per movimento, dunque il puntatore a questo blocco sullo <strong>heap</strong> viene spostato a casa dell'altro, e il vecchio <code>Box</code> diventa inaccessibile.</p>
<p>Il tipo <code>T</code> pu√≤ avere una dimensione non nota durante la compilazione e quindi pu√≤ non implementare il tratto <code>Sized</code>. In questo caso, il <code>Box</code> diventa un oggetto che contiene due elementi: il puntatore all'elemento e la dimensione dell'elemento stesso ‚Äî similmente a un <code>&amp;str</code> o a uno slice.</p>
<p>Vediamolo all'azione.</p>
<h3 id="221-esempio-1"><a class="header" href="#221-esempio-1">2.2.1 Esempio</a></h3>
<p><img src="images/smart_pointer/image%2022.png" alt="image.png" /></p>
<p>Qui ho una funzione che √® responsabile di produrmi un dato, la cui durata io non so a priori, quindi voglio che mi allochi sullo <strong>heap</strong> un valore che deve restare vivo finch√© mi serve, e quindi lo incapsulo in un <code>Box</code> ‚Äî <code>let b1 = produce(false)</code>.</p>
<p><em>Cosa succede quando inizio a eseguire questa cosa qua?</em>
<code>b1</code> viene allocato sullo stack per ospitare quello che sar√† il valore di ritorno, dopodich√© invoco la funzione <code>produce</code>.</p>
<p><img src="images/smart_pointer/image%2023.png" alt="image.png" /></p>
<p>Siccome gli ho passato un parametro, <code>false</code>, sullo stack inietto questo parametro, inietto l'indirizzo a cui dovr√≤ ritornare, e poi mi trasferisco direttamente all'interno della funzione stessa.</p>
<p><img src="images/smart_pointer/image%2024.png" alt="image.png" /></p>
<p>All'interno della funzione stessa creo un <code>Box</code> ‚Äî <code>let mut b = Box::new(0)</code>.</p>
<p>Quindi <code>b</code> √® un puntatore che punta allo <strong>heap</strong>, nello <strong>heap</strong> viene allocato un blocco, quanto mi serve per un intero, in quell'intero ci scrivo <code>0</code>, e va bene.</p>
<p><img src="images/smart_pointer/image%2025.png" alt="image.png" /></p>
<p>Poi verifico se il parametro che ho ricevuto era <code>true</code>, ma io ho ricevuto <code>false</code> quindi non faccio niente.</p>
<p><img src="images/smart_pointer/image%2026.png" alt="image.png" /></p>
<p>E poi <code>return b</code>.</p>
<p><strong>Cosa succede?</strong>
Quel puntatore che io avevo nel campo <code>b</code> viene trasferito nella casellina che avevo preparato per il ritorno, lo stack si contrae.</p>
<p><img src="images/smart_pointer/image%2027.png" alt="image.png" /></p>
<p>Adesso il possessore del mio dato sullo <strong>heap</strong> √® il <code>main</code>, che ce l'ha nella sua variabile <code>b1</code>, e quindi torno al <code>main</code>.</p>
<p><img src="images/smart_pointer/image%2028.png" alt="image.png" /></p>
<p>Posso quindi stampare <code>b1</code> senza problemi ‚Äî √® un puntatore, proprio come sarebbe un <code>ref</code>. Semplicemente che mentre un <code>ref</code> potrebbe puntare anche sullo stack, <code>b1</code> <strong>sicuramente</strong> punta sullo <strong>heap</strong>.</p>
<p><img src="images/smart_pointer/image%2029.png" alt="image.png" /></p>
<p>Poi richiamo <code>produce</code>, <code>b2 = produce(true)</code>.</p>
<p><img src="images/smart_pointer/image%2030.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2031.png" alt="image.png" /></p>
<p>Dunque creo la variabile <code>b2</code>, inserisco <code>true</code> e l'indirizzo di ritorno sullo stack, chiamo la funzione <code>produce</code>, che si rialloca l'oggetto <code>b</code> che punter√† di nuovo a <code>0</code>, questa volta la condizione dell‚Äô <code>if</code> passa, e quindi dentro questa cosa qua ci scriver√† <code>5</code>.</p>
<p><img src="images/smart_pointer/image%2032.png" alt="image.png" /></p>
<p>Poi di nuovo <code>return b</code>, e quindi muovo il dato <code>b</code> dentro la casellina che √® stata preallocata per tenerlo.</p>
<p><img src="images/smart_pointer/image%2033.png" alt="image.png" /></p>
<p>Finisco <code>produce</code>, lo stack si contrae, nessuno deve fare niente di particolare.</p>
<p><img src="images/smart_pointer/image%2034.png" alt="image.png" /></p>
<p>A questo punto posso eseguire <code>drop(b1)</code>.</p>
<p><strong>Cosa capita facendo drop b1?</strong>
Niente di speciale: <code>b1</code> chiama il suo distruttore, e il distruttore di <code>b1</code> sa che <code>b1</code> possiede un dato dello <strong>heap</strong> e quindi fa la <code>free</code> o <code>delete</code> associata, insomma rilascia quel blocco l√¨. Facendo <code>drop</code> quel pezzo di memoria che stava sullo <strong>heap</strong> √® evaporato, ma anche <code>b1</code> √® evaporato insieme.</p>
<p><img src="images/smart_pointer/image%2035.png" alt="image.png" /></p>
<p><code>b2</code> √® ancora accessibile, lo posso tranquillamente stampare senza problemi.</p>
<p><img src="images/smart_pointer/image%2036.png" alt="image.png" /></p>
<p>Quando arriviamo alla chiusa graffa, questa comporta la contrazione dello stack. <code>b2</code> va via, passa al suo distruttore, rilascia, contraggo tutto, e la memoria √® pulita.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p><code>b1</code> libera lo <strong>heap</strong>. Ci rimane <code>b1</code> con il suo vecchio valore, ma √® inaccessibile. Se provi ad andarlo a leggere, il compilatore ti blocca ‚Äî √® rimasto il puntatore all'originale, ma non puoi scrivere del codice che ci va dentro a leggere, perch√© il compilatore ti blocca.</p>
<p>Te lo garantisce perch√© √® l'<strong>analisi statica del codice</strong> che dice: <em>‚Äúdopo la</em> <code>drop</code><em>, il tuo valore</em> <code>b1</code> <em>non possiede pi√π il dato, quindi non puoi accedervi‚Äù</em>.
Questo avviene in compilazione.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Nota 2</strong></p>
<p>Esattamente come <em>unique pointer</em>, <code>Box</code> non pu√≤ essere copiato, quindi non posso avere due diversi riferimenti allo stesso blocco sullo <strong>heap</strong>.</p>
<p><em>Perch√©?</em>
Perch√© altrimenti non si capirebbe chi lo possiede e non ci sarebbe pi√π la regola del rilascio singolo, ma cadrei nel rischio del doppio rilascio o del non rilascio che √® uno dei tanti <em>undefined behavior</em> di cui il C √® affetto, con la sua idea di puntatori.</p>
</blockquote>
<blockquote>
<p>üí° <strong>La funzione <code>drop()</code></strong></p>
<p><img src="images/smart_pointer/image%2037.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2038.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2039.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Smart pointers overview</strong></p>
<p>Sono oggetti che dentro di s√© contengono dei puntatori ma non sono dei puntatori, sono oggetti che li posseggono ma si presentano per Rust come fossero puntatori in quanto implementano a volte solo il tratto <code>Deref</code> a volte il tratto <code>DerefMut</code>.</p>
<p>La differenza tra i due tratti √® che in un caso applicando asterisco di fronte a questo oggetto ottengo un riferimento condiviso, applicandolo per quelli che implementano <code>DerefMut</code> ottengo un riferimento mutabile e di conseguenza ho la possibilit√† di modificare il contenuto presente al suo interno.</p>
</blockquote>
<h2 id="23-rc"><a class="header" href="#23-rc">2.3 <code>Rc</code></a></h2>
<p><img src="images/smart_pointer/image%2040.png" alt="image.png" /></p>
<p>Ci sono situazioni in cui noi abbiamo bisogno di avere due diversi puntatori che condividono un qualche dato.</p>
<p>Rust ci viene incontro mettendoci a disposizione due oggetti e due affiliati. I due oggetti si chiamano rispettivamente <code>Rc</code> (<em>reference counted</em>) e <code>Arc</code> (<em>atomic reference count</em>). Concettualmente fanno lo stesso mestiere. <code>Rc</code> √® usabile solo in contesti monothread. <code>Arc</code> √® usabile in tutti i contesti, quindi quelli monothread ma anche quelli multithread, e costa un po' di pi√π.</p>
<p><em>Perch√©?</em>
Perch√© garantisce che il suo funzionamento ‚Äî che fondamentalmente passa attraverso il criterio di <em>sapere quante copie ci sono di questo dato</em> ‚Äî si basa su un <strong>contatore interno</strong>. Questi contatori sono incrementati con un'operazione di <code>atomic increment</code> o decrementati con un'operazione di <code>atomic decrement</code> che costa di pi√π, proprio perch√© √® <em><strong>atomic</strong></em>, dell'operazione di decremento semplice. Per cui passiamo da 5-4 cicli macchina, dipende un po', a una <strong>ventina di cicli macchina</strong>.</p>
<p>Quindi, nei contesti dove siamo sicuri di lavorare <strong>monothread</strong>, possiamo usare tranquillamente <code>Rc</code>, perch√© √® pi√π efficiente (di poco, ma comunque pi√π efficiente). Nei contesti multithread dovremo necessariamente utilizzare gli <code>Arc</code>.
<em>Perch√©?</em> Perch√© con gli <code>Rc</code> il compilatore ci blocca dicendo: <em>"No, questo qui in un contesto multithread non lo puoi usare".</em></p>
<p>I due tipi, quindi, <code>Rc</code> e <code>Arc</code>, stanno in package diversi. <code>Rc</code> sta in <code>std::</code>, <code>rc::</code>, <code>Rc</code>, l'altro sta in <code>std::sync::Arc</code>. Quindi non c'√® manco il rischio di confonderli troppo.
Entrambi sono associati a un altro tipo che si chiama <code>Weak</code>, in un caso <code>std::rc::Weak</code>, nell'altro caso <code>std::sync::Weak</code>.</p>
<p>Fanno lo stesso mestiere che fanno i <em>shared pointer</em> del C++, ovvero, concettualmente, implementano il concetto di riferirmi a una struttura dati, nella quale io ho la possibilit√† di tenere traccia non solo del mio dato, ma anche di quanti sono a conoscere l'indirizzo di questo dato.</p>
<p>L'implementazione √® un po' diversa. In C++ un <em>shared pointer</em> √® un <strong>fat pointer</strong>, che √® costituito da due puntatori paralleli, uno al dato e uno al blocco di controllo. Perch√© non c'√® il vincolo che il blocco di controllo sia diacente al dato, pu√≤ stare dove vuole.
Qua, invece, la struttura √® tutta tenuta compatta. Dato e blocco di controllo sono appiccicati.</p>
<p>E quindi <code>Rc&lt;T&gt;</code>, dove <code>T</code> √® un tipo generico (quindi possiamo incapsulare dei numeri, delle stringhe, e qualsiasi altra cosa), contiene una struttura dati che ha due contatori, <code>strong</code> e <code>weak</code>, seguiti dal dato, dove il dato ha la lunghezza di cui ha bisogno.</p>
<p>Gli oggetti di tipo <code>Rc</code> sono convertibili in riferimenti semplici, a condizione che il tipo <code>T</code> sia <em>sized</em>. Quindi, se quel tipo l√¨ ha una lunghezza nota, non c'√® problema.
<em>Come faccio a procurarmi un riferimento semplice da un</em> <code>Rc</code><em>?</em>
Lo faccio con una notazione che sembra un po' strana: <code>&amp;**rc</code>* ‚Äî <em>perch√© <code>**r*c</code> <strong>mi fa puntare al dato</strong>, quindi mi fa vincere questa astrazione che lo smart pointer mette, dicendo "Fammi accedere al dato",</em> e quindi *<code>&amp;**rc</code> mi d√† il riferimento al dato dove sta.
Quindi cos√¨ posso prendere consapevolezza della posizione del mio dato.</p>
<p>Tendenzialmente, il meccanismo √® che quando creo un oggetto di tipo <code>Rc</code> il contatore <code>strong</code> vale <code>1</code>, perch√© l'ho appena creato e quindi esiste un puntatore a questa informazione, e invece il contatore <code>weak</code> vale <code>0</code>, perch√© al momento non ho ancora creato nessun <em>weak pointer</em>.</p>
<p>Gli oggetti di tipo <code>Rc</code> sono <strong>clonabili</strong>.
Se io ho bisogno di avere due puntatori che conoscono questo dato, se ho il puntatore <code>p1</code>, quando faccio <code>p1.clone()</code> ottengo <code>p2</code>.
<code>p2</code>, di fatto, punta allo stesso blocco, ma questa operazione <code>clone</code>, che non ha effetti di per s√© sul puntatore in quanto tale che viene duplicato, ha effetti sul dato puntato, perch√© nel momento in cui io clono il campo <code>strong</code> viene incrementato di uno.</p>
<p>Viceversa, gli oggetti di tipo <code>Rc</code> implementano il tratto <code>Drop</code>, e quando escono di scena, e quindi nel momento in cui raggiungono la loro fine sintattica, o qualcuno fa esplicitamente <code>drop</code> su di loro, il contatore <code>strong</code> descende di <code>1</code>.
Per come sono implementati, il rilascio effettivo si avr√† quando tutto √® andato.</p>
<p>Vediamo un esempio molto semplice.</p>
<h3 id="231-esempio"><a class="header" href="#231-esempio">2.3.1 Esempio</a></h3>
<p><img src="images/smart_pointer/image%2041.png" alt="image.png" /></p>
<p>Vogliamo implementare una struttura in qualche modo ad albero, cosa che con i <code>Box</code> non potremmo fare.
In questo caso abbiamo una lista di pezzi che ha vari punti di ingresso.</p>
<p>La struttura dati interna √® definita da un <code>enum List</code> con due possibilit√†: o contiene un <strong>numero</strong> con un puntatore <code>Rc</code> al successivo elemento della lista, oppure non c‚Äô√® <strong>niente</strong>. Questo ci permette di creare liste di lunghezza variabile ‚Äî dalla lista vuota, a liste di uno, due o pi√π elementi.</p>
<p>Alla base della struttura troviamo la lista pi√π corta possibile: una <strong>lista vuota</strong> contenuta nel suo reference count. Questo reference count ha un <code>strong counter = 1</code> e un <code>weak counter = 0</code>, ed √® noto solo a chi precede questa lista. Concatenando il valore <code>10</code> davanti ad essa, otteniamo il penultimo blocco: un altro <code>Rc</code> con <code>strong counter = 1</code> e <code>weak counter = 0</code> che incapsula il valore <code>10</code> e punta alla lista nulla.</p>
<p>In cima troviamo l'elemento <code>a</code>, definito nel main come <code>let a = Rc_new(...)</code>. Questo rappresenta l'elemento <code>5</code> concatenato con un <code>Rc</code> contenente l'elemento <code>10</code>. In sostanza, <code>a</code> √® una lista di due elementi: <code>5</code> seguito da <code>10</code>. Fin qui nulla di straordinario ‚Äî avremmo potuto ottenere lo stesso risultato usando un <code>Box</code>.</p>
<p>Se facessimo <code>drop(a)</code>, il conteggio (inizialmente <code>1</code>) scenderebbe a <code>0</code> (ignorando momentaneamente ci√≤ che si vede in slide, dove <code>a</code> √® conosciuto da altri due elementi) innescando una cascata di deallocazioni: la struttura <code>Cons</code> verrebbe eliminata, l'<code>Rc</code> contenuto provocherebbe la diminuzione del contatore dell'area puntata, portando il secondo elemento (contenente <code>10</code>) a <code>0</code>, causandone il rilascio. Questo porterebbe al rilascio dell'<code>Rc</code> in coda, completando cos√¨ la deallocazione dell'intera struttura.</p>
<p><em>In altre parole, quando eliminiamo la testa della catena (il punto di ingresso), l'intera struttura si disgrega a cascata.</em></p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Quando un oggetto esce di scope, richiama il tratto <code>Drop</code>.
In questo caso il <code>Drop</code> di <code>Rc</code> provvede a decrementare il contatore successivo, che se scende a zero provoca il <code>drop</code> dell'elemento successivo.</p>
</blockquote>
<p>In questo caso invece, anzich√© eliminare, allunghiamo la lista aggiungendo un nuovo elemento. Prepariamo <code>b</code>, anch'esso un reference count (<code>Rc::new</code>), che inizia con <code>3</code> e prosegue con un <code>clone()</code> di <code>a</code>.</p>
<p>Non possiamo usare <code>a</code> direttamente poich√© vogliamo mantenerlo disponibile, quindi lo cloniamo. L'effetto del clone √® che il conteggio del blocco puntato da <code>a</code> sale a <code>2</code>.</p>
<p>Dopodich√©, dico "<em>ma guarda, io ho un altro modo di far cominciare questa lista</em>". Invece di avere la lista, quella di <code>b</code>, che √® <code>3, 5, 10</code>, io ho anche un'altra possibilit√†. Davanti ad <code>a</code>, invece di metterci <code>3</code>, ci voglio mettere un <code>4</code>. E quindi mi preparo <code>c</code>.</p>
<p>Allora, in questo modo ho costruito una sorta di <strong>grafo</strong>, perch√© ho vari punti di ingresso, e seguendo questi punti di ingresso posso camminare l√¨ dentro.</p>
<p><em>Cosa succede nel momento in cui qualcuna di queste variabili va via?</em>
<em>Niente. O meglio, solo dei piccoli pezzi.</em></p>
<p>Nel momento in cui andasse via <code>b</code>, per esempio, si sbriciolerebbe il blocco a cui punta direttamente, perch√© il suo <code>ref count</code> scenderebbe da <code>1</code> a <code>0</code>.
La distruzione dell'<code>Rc</code> contenuto al suo interno porterebbe solo al decremento del <code>reference count</code> di <code>a</code>, a cui anche punta <code>a</code>, che passerebbe da <code>3</code> a <code>2</code>, e l√¨ si arresterebbe tutto. Nel momento in cui buttassi via <code>c</code>, anche l√¨ l'elemento che contiene il <code>4</code> si sbriciolerebbe, compreso il suo <code>Rc</code>, che mi farebbe semplicemente discendere il contatore, a cui anche <code>a</code> punta ancora, ad <code>1</code>. Quando anche <code>a</code> uscir√† di scope, si sbriciola tutto perch√® il reference count passa da <code>1</code> a <code>0</code>.</p>
<p>Se questi elementi vengono rimossi in un ordine diverso ‚Äî ad esempio, prima <code>a</code> (il contatore scende solo a <code>2</code>), poi <code>b</code> (sparisce l'elemento <code>3</code> ma il resto rimane), infine <code>c</code> (l'intera lista si disfa) ‚Äî il risultato finale non cambia. Qualunque sia l'ordine di rimozione, abbiamo due garanzie: quando l'ultimo elemento esce di scena, l'intera struttura viene rilasciata; e finch√© anche un solo elemento rimane, mantiene l'accesso garantito al proprio dato.</p>
<p>Questa cosa funziona perch√© <strong>non ci sono cicli</strong>. Nel costruire questo grafo qua, siamo stati attenti a evitare dei cicli che tornassero indietro. Perch√© se creassi mai un ciclo, lui non se ne accorge, ma vado a realizzare una struttura che non viene pi√π rilasciata. Quindi sta a me come programmatore capire che quando uso questo tipo di smart pointer, devo organizzarmi le cose in modo tale che i puntatori in un senso, <em>diciamo ‚Äúin avanti‚Äù,</em> sono fatti sotto forma di <code>Rc</code>, e i puntatori <em>‚Äúall'indietro‚Äù</em> sono fatti sotto forma di <code>Weak</code>.</p>
<p><img src="images/smart_pointer/image%2042.png" alt="image.png" /></p>
<p>Il tipo <code>Rc</code> definisce un paio di funzioni. Nel suo blocco <code>impl</code> troviamo delle cose come <code>strong_count</code> e anche <code>weak_count</code>, che ci danno la possibilit√† di sapere quanto valgono questi contatori. Non li possiamo modificare, ma li possiamo leggere.</p>
<p>√à interessante notare che queste funzioni sono state definite usando "<code>this</code>" invece del pi√π comune <code>self</code>.
<em>Perch√© questa scelta?</em> Si potrebbe usare anche <code>alfredo</code> ‚Äî l'importante √® non usare <code>self</code>,
perch√® se usassimo <code>self</code>, Rust interpreterebbe che, con <code>p</code> di tipo <code>Rc</code>, sarebbe valido scrivere <code>p.strong_count()</code><em>, trattandolo come un metodo normale.</em></p>
<p>Ma il <strong>problema</strong> nasce dal fatto che l'operatore punto causa anche la dereferenziazione dell'oggetto. Se l'oggetto contenuto nel nostro <code>Rc</code> avesse un proprio metodo chiamato <code>strong_count</code> (improbabile ma possibile, dato che deve funzionare con qualsiasi tipo), <em>cosa accadrebbe?</em> Si creerebbe un'ambiguit√†.</p>
<p>Quando faccio <code>p.strong_count</code>, non √® chiaro se mi riferisco al <code>strong_count</code> di <code>p</code> inteso come reference pointer (<code>Rc</code>) nudo e crudo, oppure se quel punto mi fa mettere un asterisco davanti, facendomi leggere <code>*p</code> (il dato a cui punto, cio√® il dato <code>T</code>) seguito da <code>strong_count</code>.</p>
<p>E quindi non andrebbe bene. Per togliere questo genere di problema, la definizione dei metodi <code>strong_count</code>, <code>weak_count</code>, eccetera, presenti all'interno, ha visto usare una variabile completamente diversa. E per affinit√† con tutti gli altri linguaggi l'ha chiamata semplicemente <code>this</code>. Questo vuol dire che noi non possiamo chiamare il metodo <code>strong_count</code> cos√¨ come √® con <code>p.strong_count</code>, perch√© il compilatore ci dice "<em>non lo trovo</em>". Dobbiamo chiamarlo nella sua notazione base, come in realt√† il compilatore trasforma i metodi, cio√® <code>Rc::strong_count(&amp;rc)</code>.</p>
<p>Questo √® l'unico criterio che va un po' saputo, √® un criterio puramente sintattico e serve a garantire che non facciamo casino. Lo troveremo anche in qualche altro luogo. Ci sono altre situazioni delle API di Rust dove, proprio per il fatto che in automatico lui quando trova la notazione punto mette tanti asterischi finch√© basta, in certe situazioni questo pu√≤ portare ad ambiguit√†. Allora, per togliere l'ambiguit√† √® stato fatto cos√¨.</p>
<p><strong>Importante:</strong> Come abbiamo gi√† anche detto, <code>Rc</code> non √® thread safe. Non gode del tratto <code>Send</code>, quindi non pu√≤ essere condiviso tra due thread differenti. Se noi provassimo a usarlo in un contesto multi-threaded e creassimo le condizioni per cui una variabile di tipo <code>Rc</code> sia visibile contemporaneamente a due thread distinti, il compilatore ci bloccherebbe, perch√© un'eventuale operazione di clonatura o di distruzione che porterebbe l'incremento o al decremento del contatore avverrebbe facendo un increment semplice che √® unsafe. E quindi poi non sono pi√π sicuro del risultato.</p>
<p><img src="images/smart_pointer/image%2043.png" alt="image.png" /></p>
<p>Nell‚Äôesempio di prima accennavamo al problema dei cicli, e della necessit√† di usare i <code>Weak</code> come puntatori <em>‚Äúall‚Äôindietro‚Äù</em>.</p>
<p>Esattamente come si √® risolto in C++, dicendo "<em>Guarda, i puntatori in avanti della struttura dati li modelliamo con degli</em> <code>Rc</code>, <em>i puntatori che tornano indietro li modelli con</em> <code>Weak</code>".</p>
<p><code>Weak</code> √® ambiguo come nome, esiste <code>std::rc::Weak</code>, √® il weak che fa coppia con <code>std:rc::Rc</code>, e poi c'√® <code>std::sync::Weak</code> che fa copia con <code>std::sync::Rc</code>, che quindi che fa coppia con l'altro <code>Rc</code>, per√≤ mediamente non c'√® casino.</p>
<p><em><em><em>Come facciamo un</em> <code>Weak</code></em>?</em>**
Mentre in C++ si crea un oggetto <code>weak pointer</code> a partire da uno <code>shared</code>, anche qui facciamo cos√¨, per√≤ non con il costruttore, ma mediante il metodo <code>downgrade</code>.</p>
<p>Se abbiamo gi√† uno <code>shared pointer</code> di qualche tipo che rappresenta il punto di ritorno, per creare un <code>weak pointer</code> che punti allo stesso luogo useremo <code>std::rc::downgrade(&amp;p)</code>, perch√© per lo stesso motivo di prima si chiama <code>this</code>.</p>
<p><em><strong>Quest'operazione qui che cosa fa?</strong></em>
Prende l'<code>rc</code> che avevamo precedentemente, che aveva il suo contatore <strong>strong</strong> e il suo contatore <strong>weak</strong>, lo duplica, ma invece di andare a incrementare il campo strong, incrementa il campo weak. In modo molto semplice. Questo va benissimo, di per s√© funziona sempre.
<strong>Piccolo problema:</strong> l'oggetto <code>Weak</code> non implementa <code>Deref</code>, quindi se mentre abbiamo il puntatore <code>p</code> di tipo <code>Rc</code>, possiamo fare <code>*p</code> per accedere al dato, se noi abbiamo l'oggetto <code>w</code> di tipo <code>Weak</code>, se facessimo <code>*w</code> non andremmo da nessuna parte, perch√© <code>Weak</code> non implementa <code>Deref</code>.</p>
<p><em><em><em>E cosa ce ne facciamo allora di un</em> <code>Weak</code></em>?</em>**
Quando ci serve, dobbiamo provare a riportarlo a essere un <code>Rc</code> completo.
<em>Come?</em> Invocando il metodo <code>upgrade</code>, che prova a farlo salire.</p>
<p><em>Cosa succede?</em> Banalmente il mio <code>Weak</code>, che punta allo stesso blocco di controllo visto prima, quando chiamo <code>upgrade</code>, verifica se il contatore degli strong √® maggiore di 0. Se √® maggiore di 0 vuol dire che il dato c'√® ancora, e di conseguenza incrementa il conteggio (fa l'effetto di una <code>clone</code> di fatto), e mi ritorna come risultato un nuovo shared pointer. Quindi il contatore dei weak resta quello che era, il contatore degli strong sale di un'unit√†, e mi viene ritornato l'<code>Rc</code> corrispondente.</p>
<p>Io lo uso, a questo punto questo <code>Rc</code> ha a tutti gli effetti quello che mi serve, e quando lo butter√≤ via scende di nuovo il conteggio degli strong e sono a posto.</p>
<p>Siccome √® possibile che <code>upgrade</code> funzioni, e siccome √® anche possibile che <code>upgrade</code> non funzioni, perch√© potrebbe darsi che in realt√† il contatore sia gi√† 0, e quindi il dato non ci sia pi√π, mentre <code>downgrade</code> ritorna sempre un <code>Weak</code>, <code>upgrade</code> restituisce un <code>Option&lt;Rc&lt;T&gt;&gt;</code>.
Cio√® a volte c'√®, quindi <code>Some(p)</code>, e allora a quel punto ce l'ho, oppure <code>None</code>, non c'√®.</p>
<h3 id="232-esempio-weak"><a class="header" href="#232-esempio-weak">2.3.2 Esempio <code>Weak</code></a></h3>
<p><img src="images/smart_pointer/image%2044.png" alt="image.png" /></p>
<p>Qui vediamo un esempio banale di questa cosa.</p>
<p>Creiamo un numero 5, che viene salvato nello heap, e di cui ci prendiamo il puntatore, lo chiamiamo <code>five</code>. Quindi 5 √® un normalissimo puntatore, che punta a un blocco sullo heap, che √® grande un po': un <code>usize</code> (quindi 4 o 8 byte) di <strong>strong counter</strong>, che vale 1, un <code>usize</code> di <strong>weak counter</strong>, che vale 0, e un <code>i32</code> (4 byte) che contiene il 5.
Quindi in tutto ci sono 20 byte l√¨ dentro (supponendo architettura 64 bit).
Dentro <code>five</code> c'√® questo puntatore a questo blocco di 20 byte.</p>
<p>Dopodich√© dico <code>weak_five</code>.
<em>Cos'√®</em> <code>weak_five</code>? <code>weak_five</code> √® un puntatore che ottengo facendo il <code>downgrade</code> di <code>five</code>.</p>
<p>Fare il <code>downgrade</code> di <code>five</code> vuol dire che duplico il puntatore, e quindi <code>weak_five</code> se lo vado a leggere √® identico a <code>five</code> ‚Äî l√¨ c'era scritto <code>0x7f5b9e714</code>, e anche di l√† c'√® la stessa sequenza, paro paro.</p>
<p>Facendo <code>downgrade</code>, quello che √® successo √® che quei due blocchi che stavano davanti al numero 5, che prima erano <strong>1</strong> e <strong>0</strong>, dopo l'operazione di <code>downgrade</code> diventano <strong>1</strong> e <strong>1</strong>. Adesso ho sia uno <strong>strong</strong> che un <strong>weak</strong>.</p>
<p>A questo punto, usando il <code>Weak</code>, vorrei andare a leggere il numero 5. Di per s√© non potrei direttamente leggere il numero 5: se io facessi <code>*weak_five</code> non vedrei un bel niente, il compilatore mi segna un errore ‚Äî non accedo al dato.
L'unico modo che ho per accedere al dato √® provare a fare l‚Äôupgrade di <code>weak_five</code>, con <code>weak_five.upgrade</code>.</p>
<p>Nel momento in cui lo faccio (supponendo che <code>five</code> non sia stato droppato nel frattempo, e che quindi il contatore valga almeno <strong>1</strong>) quello che succede √® che il punto <code>upgrade</code> ha successo.
In questo momento c'era scritto <strong><code>1, 1</code></strong>, e facendo l'<code>upgrade</code> diventa <strong><code>2, 1</code></strong>. Perch√© posseggo <code>five</code> originale, posseggo questo nuovo <code>Rc</code>, <code>strong_five</code>, e poi c'√® sempre <code>weak_five</code> che resta l√¨.</p>
<blockquote>
<p>üí° <strong>Rc ‚Äî downgrade &amp; upgrade</strong></p>
<p><img src="images/smart_pointer/image%2045.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2046.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2047.png" alt="image.png" /></p>
</blockquote>
<p>Poi c'√® un <code>assert</code>, <code>strong_five.is_some</code>, che serve per verificare che abbiamo ricevuto qualcosa di valido. Potrei usarlo per leggere il 5, ad esempio con <code>println!("*strong_5")</code>, ma per ora ci basta sapere che funziona.</p>
<p>A un certo punto lo <strong>droppo</strong>. Con il <code>drop</code> il contatore scende da 2 a 1. Nessun problema. Se faccio anche <code>drop</code> di <code>five</code>, il contatore degli <strong>strong</strong> scende da 1 a 0.</p>
<p><em>Cosa succede?</em> Che del nostro blocco di 20 byte sullo heap, gli ultimi 4 (l‚Äô<code>i32</code>) vengono rilasciati. <em>Perch√©?</em> Non ci sono pi√π riferimenti <strong>strong</strong>, quindi quel dato viene eliminato.
√à importante questo rilascio perch√©, anche se in questo esempio il guadagno √® minimo, queste strutture vengono usate tipicamente per puntare a oggetti molto pi√π grandi ‚Äî come un'immagine o una tabella di IA con milioni di numeri, che vanno condivisi tra diverse parti del programma e rilasciati quando quelle parti del programma terminano e non vi fanno pi√π riferimento.</p>
<p><strong>Rimane solo il blocco di controllo di 16 byte</strong>, allocato in modo consecutivo.
Il contatore ora √® <strong><code>0, 1</code></strong>.
<code>strong_five</code> √® stato eliminato (il compilatore garantisce che non ci accedo), <code>five</code> √® stato eliminato (e anche qui, il compilatore garantisce che non ci accedo), e rimane solo <code>weak_five</code> che punta alla sequenza <strong><code>0, 1</code></strong>. Se provassi a fare <code>weak_five.upgrade()</code>, il metodo controllerebbe il contatore strong, vedrebbe 0 e restituirebbe <code>None</code>. Non c'√® pi√π possibilit√† di accesso.</p>
<p>Questo meccanismo garantisce che i <strong>weak pointer</strong> possano chiudere dei cicli: possiamo creare catene in avanti e chiuderle all'indietro come vogliamo, sia in anelli completi che in catene di piccoli anelli. I puntatori <strong>weak</strong> non creano problemi per la gestione della memoria, perch√© il dato viene rilasciato quando spariscono tutti i riferimenti <strong>strong</strong>. C'√® quindi una direzione preferenziale: quando vengono eliminate tutte le "teste" che conoscono l'inizio della catena, questa si sbriciola pezzo per pezzo. I <strong>weak</strong> possono rimanere ma non causano problemi, non mantengono nulla in vita e vengono eliminati tranquillamente.</p>
<blockquote>
<p>üí° <strong>Ma, <code>Clone</code> non fa la copia in profondit√†?</strong></p>
<p>Nel caso di <code>Rc</code>, <code>Clone</code> non fa la copia in profondit√†.
Quello che fa √® duplicare il puntatore semplice e incrementare il conteggio dei riferimenti.</p>
<p><em>Quindi, noi abbiamo detto in modo generico che</em> <code>Clone</code> <em>fa la copia in profondit√†, ma non √® sempre cos√¨.</em></p>
<p>Mi d√† la <strong>garanzia</strong> di avere una copia della struttura: quando clono un <code>Rc</code> , ad esempio clonando <code>a</code> nell‚Äôesempio di prima, ottenendo <code>b</code>, ottengo lo stesso puntatore che ora si trova in <code>a</code>. I due sono completamente equivalenti ‚Äî entrambi vedono lo stesso blocco formato da struttura di controllo e dato posseduto.</p>
<p>√à come se la struttura fosse stata duplicata, anche se in realt√† non ce n'√® bisogno. L'obiettivo √® garantirmi che vedo un duplicato completo, e infatti lo vedo, ma mi gestisce questa cosa non duplicando veramente i dati, ma incrementando un contatore e lasciando le cose come stanno, che √® un buon guadagno in termini di memoria, prestazioni e sicurezza di condivisione!</p>
</blockquote>
<h2 id="33-cell"><a class="header" href="#33-cell">3.3 <code>Cell</code></a></h2>
<p><img src="images/smart_pointer/image%2048.png" alt="image.png" /></p>
<p><strong>√à semplice, √® un meccanismo tranquillo</strong>. √à esattamente la riproposizione di quello che la comunit√† del C++ ha impiegato un po' di anni a distillare. Rust ha <em>adottato le stesse scelte</em>, cambiando giusto due nomi e messo a posto alcuni dettagli che gli venivano pi√π comodi per la sua implementazione, ma concettualmente siamo perfettamente allineati.</p>
<p><strong>Solo che nel mondo C++ gli smart pointer finiscono l√¨.</strong>
Rust dice "<em>Caspita, quest'idea degli smart pointer √® potente. Ci sono anche altri casi in cui possiamo sfruttare questo concetto</em>". E introduce delle cose che non hanno nessun corrispettivo dall'altra parte. Vediamole un pezzo per volta.</p>
<p>Una delle prime faccende √® che <strong>Rust √® potente</strong>, il <code>borrow checker</code> ci protegge in tantissime situazioni. Ma il borrow checker, di fronte a una situazione che <em>forse potrebbe essere giusta, ma potrebbe anche essere sbagliata</em>, sceglie sempre di essere <strong>pessimista</strong> ‚Äî ce lo proibisce. Questo, in buona misura, va bene.</p>
<p>Ci sono alcuni casi per√≤ un po' stringenti, dove √® un impiccio. E vorremmo allentare le maglie. Premesso che un modo di allentare le maglie c'√® sempre: faccio un blocco <code>unsafe</code>, trasformo un riferimento non mutabile in un puntatore mutabile e faccio quello mi pare.
Solo che quando faccio cos√¨ e metto <code>unsafe</code> (e quindi passo a usare i puntatori cos√¨ come li userei in C) devo essere sicuro che faccio proprio solo delle cose giuste.</p>
<p>Per evitare di dover spesso fare azioni del genere, Rust dice "<em>Guarda, riconosco che c'√® un gruppo di situazioni che tendono a presentarsi con una certa frequenza in cui capita di fare certe cose‚Äù,</em> in particolare <strong>capita di dover modificare un dato di cui ho solo un riferimento normale.</strong></p>
<p><em>Come faccio?</em>
Beh, se io ho solo un riferimento normale, uno <strong>shared reference</strong> (<code>&amp;T</code>), non posso modificarlo, il <strong>borrow checker</strong> me lo impedisce.
E allora, Rust dice <em>"guarda, io ti creo un tipo che chiamo</em> <code>Cell</code><em>",</em> la <em><strong>cella</strong></em>.</p>
<p>√à un tipo generico: inquadri all'interno di questa cella un dato che ti pare.</p>
<p><em>Com'√® fatto sto tipo?</em>
√à il dato. Non ha niente di suo, √® solo il dato, come possiamo vedere nella rappresentazione in slide.
<code>Cell&lt;T&gt;</code> √® fatto con un blocco di memoria dentro cui c'√® <code>T</code>, nient'altro che <code>T</code>.</p>
<p>√à solo un modo per far digerire al compilatore che quel <code>T</code> l√¨, oltre ad avere le caratteristiche del tipo <code>T</code> che avrebbe per i fatti suoi, gli vogliamo dare una marcia in pi√π.</p>
<p><em>E qual √® la marcia in pi√π che gli vogliamo dare?</em>
Gli vogliamo dare la possibilit√† di <strong>cambiare il valore a partire dal suo riferimento condiviso</strong>.</p>
<p>Quindi, mentre normalmente quando io ho un <code>&amp;T</code> non ci posso fare nient'altro, quando ho un <code>&amp;Cell&lt;T&gt;</code> (e alla fine <code>&amp;Cell&lt;T&gt;</code> coincide con <code>&amp;T</code> perch√© appunto quello √®: non c'√® nient'altro), il compilatore mi lascia fare alcune limitate operazioni, e sa che alla fine, anche se lui implementa tramite blocchi <code>unsafe</code>, sono <em>safe</em> intrinsecamente, perch√© non √® possibile che ne venga fuori qualcosa di storto.</p>
<p>In particolare, quello che mi permette di fare √® di <em><strong>sostituire il suo contenuto con qualcos'altro</strong></em>. Quindi mi offre alcuni metodi, come <code>set</code>, che butta via il vecchio valore e lo sostituisce con uno nuovo, oppure come <code>replace</code>, che fa una cosa pi√π o meno simile, oppure posso sostituire il valore con il risultato di una funzione che sia compatibile con quel valore l√¨.</p>
<h3 id="331-esempio"><a class="header" href="#331-esempio">3.3.1 Esempio</a></h3>
<p><img src="images/smart_pointer/image%2049.png" alt="image.png" /></p>
<p>Nell'esempio qua sopra, abbiamo preparato una <code>struct</code> che ha due campi che di per s√© sono identici. Il primo √® un <code>u8</code>, l'altro √® un <code>Cell&lt;u8&gt;</code>, ognuno occupa sempre un byte, ma diversa √® l'interpretazione che il compilatore gli d√†.</p>
<p>Li popoliamo con <code>let my_struct = SomeStruct {...}</code> dove <code>a</code> vale <code>0</code> e <code>b</code> vale <code>Cell::new(1)</code>. <code>Cell::new(1)</code> non fa nient'altro che mettere un <code>1</code> l√¨ dentro, in quegli 8 bit. Perfetto. Fino qua niente di strano.</p>
<p><code>my_struct</code> non √® mutabile. Se io provo a fare <code>my_struct.a = 100</code>, il compilatore mi blocca. Anche se cercassi di fare <code>my_struct.b = *qualcosa_altro*</code> mi blocca, perch√© quello di per s√© √® un dato, e io non lo posso toccare.</p>
<p>Ma se dico <code>my_struct.b</code>, fino a qui sto facendo riferimento al suo campo immutabile, posso comunque usare i metodi che <code>Cell</code> mi aggiunge, come <code>my_struct.b.set</code> (nota: il campo <code>u8</code> non ha il metodo <code>set</code>, ma il campo <code>u8</code> dentro un <code>Cell</code> s√¨!).
<em>Cosa fa il metodo set di Cell?</em> Trasforma il self, che sarebbe un riferimento semplice, in un puntatore nativo, esegue l'operazione e termina.
Quindi <code>my_struct.b.set(100)</code> ha successo, proprio perch√© <code>Cell</code> permette questo tipo di operazioni.</p>
<p>E quindi, pur io avendo accesso a un dato che √® <strong>apparentemente immutabile</strong> (in questo caso ho una variabile che possiede, ma che possiede senza mutabilit√†), ho possibilit√† di <strong>cambiare l'interno</strong>. E lo stesso lo potrei fare se io a <code>my_struct</code> avessi una reference, o qualcosa del genere.
<em>Perch√©?</em> Perch√© ci√≤ che guadagna in termini di mutabilit√† √® il fatto che il compilatore dice "<em>quello l√¨ non √® un byte da solo, √® un byte <strong>visto nell'involucro di una cella</strong></em>" ‚Äî in termini di memoria √® un byte, ma in termini di capacit√† del compilatore, il compilatore assegna a quel byte l√¨, oltre ai metodi che tutti gli <code>u8</code> avrebbero per i fatti loro, mi aggiunge un gruppo di metodi che sono quelli di <code>Cell</code>. In particolare il metodo <code>set</code> mi d√† la possibilit√† di cambiarlo.</p>
<p>Nel caso specifico, siccome <code>u8</code> √® <code>Copy</code>, posso anche chiamare <code>get</code>.
<code>get</code> mi d√† una copia della cosa, √® chiamabile solo se il tipo <code>T</code> che mettiamo dentro <code>my_struct</code> √® un tipo <code>Copy</code>, altrimenti non andrebbe bene.</p>
<h3 id="332-metodi-offerti-da-cell"><a class="header" href="#332-metodi-offerti-da-cell">3.3.2 Metodi offerti da <code>Cell</code></a></h3>
<p><img src="images/smart_pointer/image%2050.png" alt="image.png" /></p>
<ul>
<li><code>get</code> <strong>mi d√† la possibilit√† di avere una copia di quello che c'√® dentro la cella.</strong></li>
<li><code>take</code> <strong>sostituisce il contenuto della cella (di cui io divento il padrone, quindi mi sbriciola, e mi tira fuori quel dato l√¨), e al posto di quel dato l√¨ mette il <em>default</em>.</strong>
Questo si pu√≤ fare solo nel momento in cui tipo <code>T</code>, gode del tratto <code>Default</code>.
Di nuovo, nel caso di <code>u8</code>, ad esempio, lo potrei fare perch√© i byte, tutti gli interi, tutti i numeri, hanno come default zero. Quindi al momento in cui io facessi <code>.take</code>, mi prendo il valore corrente e lascio al suo posto zero.</li>
<li><code>replace</code> <strong>sostituisce il contenuto della cella con quello passato come parametro, e restituisce il valore originale.</strong>
Alla fine <code>take</code> non fa nient'altro che fare una <code>replace</code> con il <code>default</code>.</li>
<li><strong><code>into_inner</code> sbriciola la cella e mi d√† l'accesso direttamente al suo contenuto.</strong>
Chiaramente non lo posso fare nell'esempio visto prima.
<em>Perch√©?</em> Perch√© la cella √® parte della <code>struct</code> pi√π ampia. Quindi potrei fare un <code>into_inner</code> solo nel momento in cui smontassi tutta la <code>struct</code>, non posso distruggerne dei pezzi singolarmente.</li>
</ul>
<h2 id="24-refcell"><a class="header" href="#24-refcell">2.4 RefCell</a></h2>
<p><img src="images/smart_pointer/image%2051.png" alt="image.png" /></p>
<p>Tuttavia, <code>Cell</code> mi d√† <em>alcuni</em> <strong>vantaggi</strong> (la possibilit√† di sostituire il dato contenuto con un altro), ma mi d√† anche delle <strong>penalizzazioni</strong> ‚Äî se no sarebbe tutto troppo facile!</p>
<p>Quello che <code>Cell</code> <strong>non</strong> mi permette di fare √® di avere un riferimento a cosa c'√® dentro la cella, di avere un riferimento a cosa ci sta dentro. Quindi io posso prendere possesso del suo contenuto. Posso cercare di copiare il suo contenuto. Per√≤, cos√¨ come da un lato mi regala dei metodi che non avevo, dall'altro mi toglie delle cose che avevo, e in particolare mi impedisce di prendere un riferimento.
Se ci provo il compilatore mi dice "<em>No, guarda, non si fa</em>". <em>Perch√©?</em> Perch√® <code>Cell</code> non implementa il tratto <code>Ref</code>.</p>
<p>Allora Rust dice "<em>Ci sono delle situazioni in cui invece ti verrebbe comodo avere questo</em>", e ci introduce un altro tipo di <em>aggeggio</em>, che si chiama <code>RefCell</code>.</p>
<p><em>Cos'√® un</em> <code>RefCell</code><em>?</em>
√à un contenitore simile a <code>Cell</code>, ma un po' pi√π sofisticato. Mentre <code>Cell</code> contiene solo il dato, questo contiene anche un <strong>flag</strong>.</p>
<p><em>E cosa mi dice quel flag?</em>
Quel flag mi dice "<em>Hai gi√† creato dei riferimenti a questo dato? E se li hai creati, li hai creati in lettura o li hai creati in scrittura?</em>"</p>
<p><strong>L'idea √® questa:</strong>
Normalmente il Borrow Checker, per le variabili normali, ci lascia prendere il riferimento, tutti quelli di cui abbiamo bisogno se sono riferimenti semplici, <em>un solo riferimento mutabile per volta</em>. E questa verifica √® fatta a <strong>compile time</strong>. In certe situazioni noi abbiamo bisogno di permettere a <strong>runtime</strong> di incapsulare il dato in una cella, ma anche averne il riferimento, che di volta in volta pu√≤ essere un riferimento mutabile o non mutabile. Mentre con i dati nativi, l'esistenza del riferimento mutabile √® garantita a compile time essere singola, e se non √® singola il compilatore non fa compilare, quindi il programma neanche esiste, nel caso di <code>RefCell</code> questa valutazione √® spostata a runtime.</p>
<p>Ovvero dice <em>‚ÄúIo ti lascio prendere il tuo dato e te lo metti l√¨ dentro, va bene. Se hai bisogno di crearti un riferimento a questo dato, io ti offro, nel caso di <code>RefCell</code>, un paio di metodi‚Äù</em>. Il metodo <code>borrow</code>, ad esempio, serve per richiedere un riferimento al dato.
A quel punto che cosa fa il metodo <code>borrow</code>? Verifica il flag, e dice, <em>‚Äúse ancora non √® dato a nessuno, lo do a te, e segno che c'√® un riferimento semplice. Se un altro mi chiede <code>borrow</code>, dico va bene, e segno che ci sono due riferimenti semplici.‚Äù</em></p>
<p>Quello che otteniamo tramite il metodo <code>borrow</code> non √® direttamente il riferimento al dato, ma piuttosto un oggetto che implementa il tratto <code>Ref</code> (quindi praticamente uno <strong>smart pointer</strong>), che quindi usiamo come fosse un <code>ref</code>, ma che ha il tratto <code>Drop</code> integrato. Quindi, quando quel riferimento l√¨ finisce di esistere, il flag dentro <code>RefCell</code> viene decrementato.
Quando il flag arriva a 0 sono tranquillo, nessun altro conosce il dato.</p>
<p>Se ci servisse un <code>ref mut</code> a questo dato, lo otteniamo con <code>borrow_mut</code>.
A questo punto io l√¨ dentro ci metto -1, o FFF, o comunque un codice qualunque che sia sufficientemente protetto rispetto al resto, e che so distinguere. Quello √® il riferimento mutabile. Nel momento in cui mi verr√† restituito, lo riporto a 0. Se mentre quella cosa l√¨ vale -1, arrivasse un altro che mi chiede un altro riferimento mutabile, lo proibisco. <strong>Come?</strong> Panicando.
<strong>Cio√® si fa garante a runtime che non possono esistere due riferimenti mutabili</strong> ‚Äî e l'unico modo che ha di essere garante di questo √® panicare.</p>
<p>Parallelamente se invece, mentre c'√® gi√† un riferimento mutabile, arrivasse uno che vuole un riferimento semplice, panica lo stesso, perch√© <strong>non pu√≤ succedere</strong>.
Oppure se mentre ci sono dei riferimenti semplici, arriva uno che lo vuole mutabile, panica.
Quindi in generale i metodi <code>borrow</code> e <code>borrow_mut</code>, se va bene ci danno una cosa che sembra un riferimento o un riferimento mutabile, che per√≤ √® uno smart pointer, e cio√® ha un <code>drop</code> associato che rimetta a posto le cose. Se le condizioni non sussistono, genera un panic.</p>
<p><strong>Importante:</strong> Sia <code>Cell</code> che <code>RefCell</code> hanno un <em>vincolo fondamentale</em> ‚Äî non possono operare in contesti multi-thread. In un contesto multi-thread, questi meccanismi perdono la loro efficacia poich√© non possono garantire l'assenza di conflitti tra un istante e l'altro.</p>
<p>Vediamo un esempio pratico.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Il dato <code>RC</code>, come smart pointer, incapsula il dato <code>T</code> come <em>immutabile</em>. A differenza di <code>Box</code> che possiede e pu√≤ modificare il suo valore, <code>RC</code>, essendo condiviso, non pu√≤ contenere un valore mutabile. Questo previene scenari problematici: immaginiamo di essere in due a conoscere lo stesso dato. Se ad esempio io opero basandomi sul valore "5" mentre tu lo modifichi in "10", la mia logica risulterebbe errata, portando a potenziali problemi.</p>
<p><strong>Per questo motivo sia <code>Rc</code> che <code>Arc</code> incapsulano dati immutabili</strong>. Sebbene questo sia restrittivo, possiamo comunque modificare i dati prendendoci la responsabilit√†. <em>Come?</em> Nei contesti single-thread, creiamo strutture <code>Rc</code> contenenti <code>RefCell</code> che a loro volta contengono il dato. Talvolta usiamo <code>Cell</code>, ma <code>RefCell</code> √® generalmente pi√π pratico. <strong>Questa √® una strategia efficace.</strong></p>
<p>In contesti multi-thread, invece, utilizziamo <strong><code>Arc</code></strong> (equivalenti a <code>Rc</code>) che, non potendo contenere <code>RefCell</code>, contengono <strong><code>Mutex</code></strong> con il dato all'interno. Il <code>Mutex</code>, un altro tipo di smart pointer che approfondiremo parlando di concorrenza, permette di <em>prendere possesso temporaneo del dato</em> (e quindi poterlo mutare) uno alla volta. Se altri thread richiedono l'accesso contemporaneamente, dovranno attendere. Una volta completate le operazioni necessarie, rilasciamo il <code>Mutex</code> permettendo ad altri di utilizzare il dato.</p>
<p>Quindi, usiamo in modo <strong>concatenato</strong> queste strutture, cio√® <em>ciascuna √® un'astrazione che mi d√† un pezzettino che √® a beneficio di qualcos'altro in un quadro pi√π complesso</em>. Questa idea degli smart pointer non √® proprio cos√¨ banale, perch√© i meccanismi elementari sono stupidi ‚Äî ad esempio il meccanismo dei contatori etc‚Ä¶ <strong>Quello che non √® banale sono le conseguenze, come li usiamo</strong>. Questi hanno un senso usati in modo concatenato, secondo dei pattern. E quei pattern l√¨ bisogna provare a giocarci. <em>Sono pensati per permetterci di uscire un po' dal seminato, ma non cos√¨ tanto da rischiare.</em></p>
</blockquote>
<h3 id="241-esempio"><a class="header" href="#241-esempio">2.4.1 Esempio</a></h3>
<p><img src="images/smart_pointer/image%2052.png" alt="image.png" /></p>
<p>Qui creiamo un oggetto <code>RefCell</code> che contiene <code>5</code> come valore. Provo a farmi dare un riferimento mutabile: <code>let m = c.borrow_mut()</code>. Se va bene, <code>m</code> √® di tipo <code>RefMut&lt;i32&gt;</code>. Questa prima operazione funziona.</p>
<p>Oltre al metodo <code>borrow</code> ho il metodo <code>try_borrow</code>. Mentre <code>borrow</code> lo fa e basta e se non pu√≤ panica, <code>try_borrow</code> mi restituisce un <code>Result</code>. Se va bene contiene il dato (<code>RefMut</code>), se va male contiene l'<code>Error</code>. Ho quindi due strategie tra cui scegliere.</p>
<p>Ne ho preso una volta e il contatore √® sceso a <code>-1</code>. Se a questo punto provassi a fare <code>try_borrow</code>, lui direbbe "<em>no, non puoi farlo perch√© dovrei portare il contatore a -2, e non va bene</em>". Mentre sul <code>+</code> pu√≤ salire a piacere (posso avere quanti reference condivisi voglio), di reference mutabili ne posso avere uno solo. Quindi se √® gi√† <code>-1</code>, un altro non lo fai. E quindi <code>assert!(c.try_borrow().is_err())</code>.</p>
<p><code>m</code>, che √® il <code>borrow_mut</code> ottenuto prima, lo posso usare normalmente: <code>*m = 6</code>. A questo punto dentro <code>c</code> c'√® scritto nel suo flag <code>-1</code> (ce l'ho in prestito) e come valore c'√® <code>6</code>. Alla chiusa graffa <code>m</code> esce dallo scope. <code>m</code> sembra un <code>ref mut</code>, ma √® uno smart pointer con un <code>drop</code> associato. Cosa fa quel <code>drop</code>? Rimette <code>0</code> nel flag. Il mio <code>RefCell</code> diventa quindi <code>0</code> come flag e <code>6</code> come valore.</p>
<p>Apro un'altra graffa, rifaccio un <code>m</code> e prendo un <strong>borrow semplice</strong>. Questa volta nella struttura del <code>RefCell</code>, se la andassi a guardare col debugger, vedrei che il flag vale <code>1</code> e il dato √® ancora <code>6</code>. Ho ottenuto dentro <code>m</code> una cosa che sembra un puntatore e quando la guardo come puntatore mi fa puntare al <code>6</code>. Ma mi fa puntare in <em>sola lettura</em>.</p>
<p>A questo punto se io provassi a fare <code>try_borrow</code>, che cosa succederebbe? Succederebbe che effettivamente lui me lo lascia fare. Il conteggio salirebbe a <code>2</code>. Questo conteggio che sale a <code>2</code> viene incapsulato all'interno del <code>Result</code>, ma poi come esco dal blocco <code>assert</code>, quel <code>Result</code> l√¨ che non uso in altro modo se non per verificare che sia <code>ok</code>, viene droppato e venendo droppato torna a <code>1</code>.</p>
<p>Dopodich√© faccio l'asserzione che <code>*m</code> valga <code>6</code>.
Dopodich√© incontro la chiusa graffa e la chiusa graffa mi fa scendere il contatore che era <code>1</code> a <code>0</code>. A questo punto <code>c</code>, che √® il <code>RefCell</code>, continua ad avere flag <code>0</code>, cio√® √® libero, in questo momento nessuno lo conosce, e il dato vale al momento <code>6</code>.</p>
<p>Quindi usando il <code>RefCell</code> ho la possibilit√† di creare questa <em>interior mutability</em>.</p>
<p>Sia <code>Cell</code> che <code>RefCell</code> mi danno l'interior mutability, ma lo danno in modo diverso.</p>
<ul>
<li><code>Cell</code> <em><strong>per sostituzione</strong></em> ‚Äî togli quello che c'√® e in cambio metti un'altra cosa, ma non puoi avere l'accesso come reference.</li>
<li><code>RefCell</code> <em><strong>mi d√† l'accesso come reference grazie al fatto che ci√≤ che mi restituisce √® uno</strong></em> <em><strong>smart pointer</strong></em>, cio√® una cosa che si comporta come un reference ma ha un tratto <code>Drop</code>, che serve a rimettere a posto le cose.</li>
</ul>
<h2 id="25-cow"><a class="header" href="#25-cow">2.5 <code>Cow</code></a></h2>
<p><img src="images/smart_pointer/image%2053.png" alt="image.png" /></p>
<p>C'√® un altro interessante oggetto chiamato <code>Cow</code> (<em>Clone on Write</em>).</p>
<p>Serve in quelle situazioni in cui noi abbiamo un dato che pu√≤ essere conosciuto da tanti e ogni tanto potrebbe capitare che qualcuno lo vuole cambiare, <strong>ma se lo cambia non deve cambiare per tutti, deve cambiare solo per s√©</strong>.</p>
<p>Per esempio, supponiamo di accedere ad un sito web ‚Äî ci viene assegnato un profilo standard che specifica il colore bianco, un font medio, una certa spaziatura e altre impostazioni.
Con 2000 utenti del sito web, non serve avere 2000 copie identiche di queste impostazioni. <strong>Finch√© nessuno le modifica</strong>, √® sufficiente far riferimento a un'unica struttura dati che contiene queste informazioni comuni. Tuttavia, poich√© ogni utente ha esigenze diverse, quando qualcuno modifica le impostazioni, √® opportuno duplicare l'oggetto solo per quell'utente specifico, mantenendo la modifica separata. ‚Üí <strong>Clone on write</strong>: finch√© leggo i dati, faccio riferimento alla parte condivisa. <em>Solo quando provo a modificarli, li separo creandone una copia.</em></p>
<p>Fondamentalmente, al suo interno, questo √® ottenuto implementando un <code>enum</code>, che ha due versioni. O √® <code>borrowed</code>, e in questo caso √® semplicemente un riferimento condiviso, e in capsula <code>&amp;b</code>, un riferimento al dato <code>b</code>, che ha un suo certo tempo di vita. Altrimenti, nel momento in cui io cercassi di fare un'operazione che modifica questo dato qua, lui dice "A<em>spetta un attimo, faccio un clone della struttura</em> <code>b</code><em>, di cui divento possessore, e a questo punto la struttura</em> <code>b</code> <em>√® mia, e quindi ci scrivo dentro quello che voglio. Ho perso il legame con quell'altro</em>".</p>
<p>Si crea a partire da <code>Cow::from</code>, e il compilatore sceglie in base a cosa gli do, se gli do un reference me lo mette dentro il <code>borrowed</code>, se gli do un valore pieno invece me lo mette nell'<code>owned</code>.</p>
<h1 id="3-smart-pointer-e-metodi"><a class="header" href="#3-smart-pointer-e-metodi">3. Smart pointer e metodi</a></h1>
<p><img src="images/smart_pointer/image%2054.png" alt="image.png" /></p>
<p><strong>Rust comprende bene il concetto di smart pointer</strong>, e me lo fa usare anche con l'accesso ai metodi.</p>
<p>In particolare, se io dispongo di una variabile, ad esempio di tipo <code>Box&lt;String&gt;</code>, questo √® un puntatore a una <code>String</code>, proprio come sarebbe un <code>&amp;String</code>. Se io avessi <code>&amp;String</code>, chiamiamolo chiamiamolo <code>s</code>, potrei fare <code>s.toUpperCase</code>.
Lo posso fare anche se quell'<code>s</code>, invece di essere un <code>ref</code> o un <code>ref mut</code>, fosse un <code>Box</code>. Quindi il compilatore in automatico, se io ho un <code>Box</code>, o un <code>Arc</code>, o un <code>Rc</code>, me lo fa tranquillamente usare, quindi l'accesso ai metodi avviene normalmente. <em>Perch√©?</em> Perch√© sia <code>Box</code>, che <code>Arc</code>, che <code>Rc</code> implementano il tratto <code>Ref</code>, che mi restituisce il riferimento al dato puntato. E quindi io lo uso normalmente l√¨ dentro.</p>
<p>Quello che <strong>non posso agevolmente fare</strong> invece √® imporre che un metodo possa applicarsi soltanto non a partire da un <code>&amp;self</code> o da un <code>&amp;mut self</code>, ma possa applicarsi soltanto a un <code>Box&lt;Self&gt;</code>.
Ovvero, per farlo sono obbligato a usare la <em>sintassi esplicita</em>. Avevamo gi√† visto in precedenza che nei metodi del blocco <code>impl</code> di una struttura, quando scriviamo ad esempio il metodo <code>m(&amp;self, ...)</code>, quel <code>&amp;self</code> il compilatore lo trasforma in <code>self: &amp;Self</code>.
E se scriviamo <code>&amp;mut self</code> piccolo, lo trasforma in <code>self: &amp;mut Self</code>.</p>
<p>Con gli <code>Arc</code>, con gli <code>Rc</code>, con i <code>Box</code>, viceversa, <strong>questo automatismo non esiste</strong>.
E quindi possiamo scrivere che abbiamo un certo metodo che impone necessariamente di partire da uno di questi puntatori, ma siamo obbligati a usare la sintassi esplicita. Ad esempio nella slide, stiamo introducendo all'interno di un'ipotetica struttura chiamata <code>Node</code> un metodo chiamato <code>append_to</code>, che pu√≤ solo applicarsi se io di questo <code>Node</code> ho un <code>Rc</code>.
Quindi lo devono definire cos√¨, <code>self: Rc&lt;Self&gt;</code>. Da questo momento in avanti, se io ho un <code>Rc&lt;Node&gt;</code>, posso fare <code>rc.append_to</code>, altrimenti non ci riesco.
<strong>Quindi mi serve a poter esprimere che alcuni metodi sono applicabili soltanto se io conosco l'identit√† della mia struttura dati attraverso uno <em>specifico smart pointer</em>.</strong></p>
<h1 id="4-tabella-riassuntiva"><a class="header" href="#4-tabella-riassuntiva">4. Tabella riassuntiva</a></h1>
<p><img src="images/smart_pointer/image%2055.png" alt="image.png" /></p>
<p>In questa <strong>tabella riassuntiva</strong> si cerca di mettere in evidenza la struttura dei tanti smart pointer che Rust ci mette a disposizione, mescolata anche alle strutture di altre informazioni.</p>
<p>Dall'alto trovate il <code>Box</code>. Il <code>Box</code> √® un <em>puntatore</em> che, a secondo dell'architettura (32 o 64 bit), vale 4 o 8 byte, e necessariamente punta un blocco che sta sullo heap. Quel blocco deve essere <code>Sized</code>.</p>
<p>Potresti avere un <code>Box</code> che punta uno <code>slice</code>. In questo caso, il box diventa un <strong>fat pointer</strong>, perch√© ha:</p>
<ul>
<li>la sua parte a 32/64 bit di puntatore</li>
<li>la sua parte di size, che indica quanti elementi di slice sono presenti</li>
</ul>
<p>Il <code>Vec</code> √® anch'esso uno smart pointer, ma con un blocco che pu√≤ espandersi o contrarsi, mentre il <code>Box</code> √® puntatore a un blocco di dimensione fissa.</p>
<p>Potrei avere un <code>Box&lt;dyn Trait&gt;</code>. In questo caso √® un <code>Box</code> che punta a un oggetto tratto, diventando anche qui un <strong>fat pointer</strong>:</p>
<ul>
<li>La prima parte punta all'oggetto</li>
<li>La seconda parte punta alla <code>vtable</code>, contenente i dati dell'oggetto tratto</li>
</ul>
<p>Un <code>Box</code> di un oggetto tratto pu√≤ essere convertito in un riferimento a un oggetto tratto, essendo equivalenti. La differenza sta nella mutabilit√†: il riferimento semplice non √® mutabile, mentre <code>ref mut</code> lo √®.</p>
<blockquote>
<p>üí° <strong>Da ChatGPT</strong></p>
<p><img src="images/smart_pointer/image%2056.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2057.png" alt="image.png" /></p>
<p><img src="images/smart_pointer/image%2058.png" alt="image.png" /></p>
</blockquote>
<p>Analogamente, il <code>Vec</code> pu√≤ essere convertito in un <code>Box</code> dello slice dei dati che possiede, solo non mutabile.</p>
<p>L'<code>Rc</code> √® un puntatore semplicissimo che punta sull‚Äôheap a un blocco che comincia con due numeri e prosegue col dato. √à allocato in modo tale che possa essere rilasciato il dato separatamente dal blocco.</p>
<p>L'<code>Arc</code> √® esattamente la stessa cosa. L'unica differenza √® l'istruzione macchina che viene usata per fare l'incremento o il decremento del contatore.
In questo caso √® un <em>atomic increment</em> che viene implementato in modi vari e secondo di quanti core ci sono, eccetera.</p>
<p>Il <code>Mutex</code> √® un altro smart pointer composto da vari elementi. Di base il <code>Mutex</code> incapsula il dato <code>T</code>. Contiene un flag chiamato <code>poison</code>, che serve a gestire il caso in cui un thread termini in modo anomalo mentre possiede il dato. Questo flag indica la possibilit√† che il contenuto sia corrotto, poich√© il thread √® terminato durante l'elaborazione senza completare le operazioni. Oltre al flag <code>poison</code>, il Mutex include un puntatore a una struttura fornita dal sistema operativo che garantisce l'accesso sequenziale ‚Äî una funzionalit√† che sarebbe impossibile implementare senza questa primitiva del sistema operativo.</p>
<p>E poi ci sono il <code>Cell</code> e il <code>RefCell</code>.</p>
<p>Il <code>Cell</code> coincide col dato e sta dove sta: posso avere un <code>Cell</code> sullo heap, posso avere un <code>Cell</code> sullo stack, non ci sono vincoli.</p>
<p>Il <code>RefCell</code> coincide col flag, diciamo il contatore, che vale:</p>
<ul>
<li>-1: lo sto dando in <code>mut</code></li>
<li>0: √® libero</li>
<li>numero positivo: lo sto dando in <em>shared</em></li>
</ul>
<p>seguito dal dato stesso. Poi gli altri sono tipi pi√π o meno semplici che dovreste gi√† conoscere.</p>
<h1 id="5-riferimenti"><a class="header" href="#5-riferimenti">5. Riferimenti</a></h1>
<p><img src="images/smart_pointer/image%2059.png" alt="image.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concorrenza---malnati-22-25"><a class="header" href="#concorrenza---malnati-22-25">Concorrenza - Malnati 22-25 <!-- omit in toc --></a></h1>
<h1 id="indice-15"><a class="header" href="#indice-15">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="16-concorrenza.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="16-concorrenza.html#11-thread-nativi">1.1 Thread nativi</a></li>
<li><a href="16-concorrenza.html#12-cosa-implica-la-concorrenza">1.2 Cosa implica la concorrenza</a></li>
<li><a href="16-concorrenza.html#13-pro-e-contro-della-programmazione-concorrente">1.3 Pro e Contro della Programmazione Concorrente</a></li>
<li><a href="16-concorrenza.html#14-modello-di-memoria">1.4 Modello di memoria</a></li>
<li><a href="16-concorrenza.html#15-problemi-aperti">1.5 Problemi aperti</a></li>
<li><a href="16-concorrenza.html#16-esecuzione-e-non-determinismo">1.6 Esecuzione e non determinismo</a>
<ul>
<li><a href="16-concorrenza.html#161-esempio">1.6.1 Esempio</a></li>
</ul>
</li>
<li><a href="16-concorrenza.html#17-sincronizzazione">1.7 Sincronizzazione</a>
<ul>
<li><a href="16-concorrenza.html#171-strutture-native-di-sincronizzazione">1.7.1 Strutture native di sincronizzazione</a></li>
</ul>
</li>
<li><a href="16-concorrenza.html#18-correttezza">1.8 Correttezza</a></li>
<li><a href="16-concorrenza.html#19-accesso-condiviso">1.9 Accesso condiviso</a></li>
</ul>
</li>
<li><a href="16-concorrenza.html#2-thread-in-rust">2. Thread in Rust</a>
<ul>
<li><a href="16-concorrenza.html#31-i-tratti-della-concorrenza">3.1 I tratti della concorrenza</a></li>
</ul>
</li>
<li><a href="16-concorrenza.html#3-mutex-in-rust">3. Mutex in Rust</a></li>
<li><a href="16-concorrenza.html#4-conditionvariable-in-rust">4. ConditionVariable in Rust</a></li>
<li><a href="16-concorrenza.html#5-canali-in-rust">5. Canali in Rust</a>
<ul>
<li><a href="16-concorrenza.html#51-esempio">5.1 Esempio</a></li>
<li><a href="16-concorrenza.html#52-canali-sincroni">5.2 Canali sincroni</a>
<ul>
<li><a href="16-concorrenza.html#521-esempio-con-buffer-di-dimensione-0"><strong>5.2.1 Esempio con buffer di dimensione 0</strong></a></li>
<li><a href="16-concorrenza.html#522-conclusioni-sui-canali-sincroni">5.2.2 Conclusioni sui canali sincroni</a></li>
</ul>
</li>
<li><a href="16-concorrenza.html#53-la-libreria-crossbeam">5.3 La libreria Crossbeam</a>
<ul>
<li><a href="16-concorrenza.html#531-fan-out--fan-in">5.3.1 Fan-Out / Fan-In</a></li>
<li><a href="16-concorrenza.html#532-pipeline">5.3.2 Pipeline</a></li>
<li><a href="16-concorrenza.html#533-producer--consumer">5.3.3 Producer / Consumer</a></li>
<li><a href="16-concorrenza.html#534-il-modello-degli-attori">5.3.4 Il modello degli attori</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="16-concorrenza.html#6-riferimenti">6. Riferimenti</a></li>
</ul>
<h1 id="1-introduzione-10"><a class="header" href="#1-introduzione-10">1. Introduzione</a></h1>
<p><img src="images/concorrenza/image.png" alt="image.png" /></p>
<p><strong>La programmazione concorrente</strong> di base si occupa di permetterci la gestione nel contesto dello stesso processo di pi√π attivit√† una fianco all'altra. Notate che di per s√© il concetto di concorrenza esiste nei sistemi operativi da tantissimo tempo: un sistema operativo si occupa di permettere a una singola CPU di poter eseguire molti processi separati, indipendentemente l'uno dall'altro.</p>
<p><em>E' diventata significativa negli anni 90</em> nel momento in cui i sistemi operativi hanno reso disponibile l'accesso al proprio <em><strong>scheduler</strong></em> permettendo la creazione, nel contesto dello stesso processo, di pi√π thread. Fino agli anni 90 la concorrenza veniva realizzata grazie al fatto che esistevano processi che giravano sulla macchina che potevano svolgersi s√¨ in parallelo, ma siccome erano isolati l'uno dall'altro non si impicciavano.</p>
<p>Dando invece la possibilit√† nel contesto di uno stesso processo (e quindi di uno stesso spazio di indirizzamento) di poter creare pi√π thread, ciascuno dei quali governa il proprio flusso di esecuzione, <strong>da un lato</strong> si √® dischiuso un uso pi√π efficace del potenziale parallelismo contenuto all'interno del nostro codice, <strong>dall'altro</strong> si sono aperti una serie di problemi che ora vogliamo sviscerare bene.</p>
<p>Quindi un programma concorrente √® quello che contiene al suo interno due o pi√π flussi di esecuzione. Notate che quando viene creato un processo il sistema operativo automaticamente crea il <em><strong>flusso di esecuzione primario</strong></em>, quello che noi normalmente facciamo partire dal main. In realt√† sappiamo che parte da prima, ma fa lo stesso. Di base quello √® l'unico flusso presente all'interno del processo a meno che noi in modo esplicito non chiediamo di attivarne degli altri.</p>
<p><em><strong>Come lo chiediamo?</strong></em>
Dipende‚Ä¶ Dipende dal sistema operativo, e dipende dal linguaggio. Fino ad alcuni anni fa non esisteva un modo normalizzato, nei linguaggi di basso livello, di creare thread alternativi. Occorreva ricorrere esplicitamente alle system call offerte dal sistema operativo. Nel caso di Unix o dei sistemi diciamo POSIX like, questo equivaleva a invocare la funzione <code>pthread_create</code>, nel caso di Windows questo equivaleva a chiamare l'API chiamata <code>CreateThread</code> e altri... Chiaramente questo poneva un problema perch√© realizzare dei programmi in multipiattaforma diventava pi√π complesso.</p>
<p>Quando chiediamo di attivare un thread all'interno di un processo esistente, quello che succede √® che il sistema operativo, nello spazio di indirizzamento del processo, riserva una nuova zona di memoria, grande di solito un megabyte, ma comunque dimensionabile, per poter contenere lo stack di questo nuovo thread. <strong>Perch√© ad ogni thread creato all'interno di un processo viene associato uno stack</strong>.</p>
<p><em>Quindi se √® vero che fino adesso noi abbiamo considerato i nostri processi come dotati di uno spazio di memoria all'interno delle quali c'√® uno stack e un heap</em>, nel momento in cui attiviamo pi√π thread, lo heap rimane sempre uno solo, condiviso da tutti. Di stack ce ne sono tanti quanti sono i thread che abbiamo attivato. Il thread che noi attiviamo non solo ha uno stack, ma ha associata anche una computazione, ovvero per poter creare un thread occorre specificare una funzione che ne rappresenta la computazione.</p>
<p>Di fatto il thread comincia a invocare questa funzione, procede, fa tutto quello che c'√® scritto all'interno, fino a quando questa funzione non ritorna. Nel momento in cui la funzione ritorna il thread viene chiuso e cessa di esistere. <strong>In base al sistema operativo la funzione invocata dal thread pu√≤ ritornare o meno un valore.</strong></p>
<p><strong>In generale i linguaggi moderni</strong> che espongono il concetto di thread lo fanno nascondendo completamente la funzione specifica del sistema operativo e ci danno astrazioni diverse. In alcuni casi ci danno delle astrazioni per cui il thread non ritorna niente, √® il caso di <strong>Java</strong>. In Java voi potete creare un thread, e l'oggetto thread √® determinato da un oggetto che implementa l'interfaccia <code>Runnable</code>, che √® un'interfaccia molto semplice, ha un unico metodo, <code>public void run</code>. Non ha argomenti, non ha tipo di ritorno, √® void. Di conseguenza quel thread l√¨ esegue, fa qualcosa, tutt'al pi√π vedr√≤ degli effetti collaterali, niente altro.</p>
<p>In altri casi, viceversa, altri linguaggi, <strong>C++</strong> piuttosto che <strong>Rust</strong>, ci offrono la possibilit√† di ritornare un valore. Quel valore l√¨ viene conservato fino a che qualcuno non lo va a leggere.</p>
<p><img src="images/concorrenza/image%201.png" alt="image.png" /></p>
<p>Notate che i dettagli di quello che succede sono completamente mediati dal sistema operativo. Quindi la libreria di supporto, in cooperazione con il sistema operativo, si occupa, all'atto della richiesta di creazione di un thread, di:</p>
<ul>
<li><strong>allocare uno stack</strong> grande quanto serve nel nostro spazio di indirizzamento</li>
<li><strong>preparare delle strutture lato kernel</strong> all'interno delle quali sia possibile conoscere lo stato della computazione del thread stesso</li>
</ul>
<p>Dopodich√© il thread verr√†, la rappresentazione che il sistema operativo d√† del thread al proprio interno verr√† resa disponibile allo <strong>scheduler</strong> che provveder√† ad allocare a questo thread la CPU, mettendolo insieme a tutte le altre attivit√† che il sistema operativo deve svolgere.</p>
<p>Notate che alcuni linguaggi ci danno l'<strong>accesso diretto ai thread</strong> cos√¨ come li fa il sistema operativo e in questo caso parliamo di supporto con <em>thread nativi</em>. In altri casi viceversa, la creazione di thread pu√≤ essere mediata da uno strato di runtime offerto dal linguaggio stesso. E' quello che sta succedendo in questo momento con <strong>Java</strong> a partire dalla versione 21, che mette a disposizione oltre che i thread nativi anche i cosiddetti <em><strong>green thread</strong></em>.
Questo √® reso possibile dal fatto che nel runtime di Java si √® scelto di implementare un proprio scheduler che agisce <em>on top</em> dello scheduler del sistema operativo. E nel fare questa scelta hanno pensato che questo potesse portare dei benefici sulla scalabilit√† in grande delle applicazioni.</p>
<p>In questo secondo caso, quando cio√® viene adottato uno <strong>scheduler intermedio</strong> che si pone on top dello scheduler del sistema operativo, genericamente chiamiamo il sistema di threading <em>green thread</em> o in alcuni casi <em>fibers</em> o <em>fibre</em>.</p>
<p>Di base, sia <strong>C++</strong> che <strong>Rust</strong> ci danno direttamente l'accesso ai thread nativi, ma ci danno anche la possibilit√† mediante librerie di terze parti di creare degli scheduler intermedi e quindi di implementare le astrazioni dei green thread.</p>
<p>Noi ci occuperemo in questo momento dei <strong>thread nativi</strong>, che sono quelli di base che la piattaforma sottostante ci garantisce. E ci concentreremo sulle tre piattaforme significative che sono quelle di <strong>Windows</strong> e il mondo <strong>Unix</strong> in generale, che in questo caso √® rappresentato dall'astrazione chiamata <strong>POSIX</strong>.</p>
<h2 id="11-thread-nativi"><a class="header" href="#11-thread-nativi">1.1 Thread nativi</a></h2>
<p><img src="images/concorrenza/image%202.png" alt="image.png" /></p>
<p><strong>Tipicamente</strong>, ciascun sistema operativo a modo proprio ci offre <em>tre funzioni fondamentali</em>, che sono:</p>
<ul>
<li><em>Crea un nuovo thread</em></li>
<li><em>Identifica ciascun thread in un modo univoco</em>
Il modo con cui lo identifico pu√≤ essere tramite una <strong>handle opaca</strong> e/o tramite un <strong>ID esplicito</strong> (thread numero 27, thread numero 54‚Ä¶). Le due cose sono in corrispondenza biunivoca: l'ID √® univoco a livello di sistema operativo, quindi se in un processo ho un thread che si chiama 27, quel thread si chiama 27 e non c'√® nessun altro thread che si chiama 27 in nessun altro processo che sta girando in questo momento. E normalmente √® associato anche a una handle in modo biunivoco.</li>
<li><em><strong>Join</strong></em></li>
</ul>
<p>L‚Äôoperazione join √® un'operazione che dice <em>‚Äúio ho creato questo thread che deve fare delle sue cose, adesso io mi fermo finch√© lui non ha finito‚Äù</em>. Eventualmente posso avere accesso, a secondo di come wrappo questa operazione, a uno stato finale di quel thread, il valore che mi ritorna, oppure non avercelo. Nel caso di <strong>Java</strong> non ce l'ho, join mi blocca e basta, viceversa in altri linguaggi ho la possibilit√† facendo l'operazione join di, quando il thread √® finito, recuperare quale valore mi ha restituito.</p>
<p>Queste sono le operazioni che in modo differente, ma concettualmente simile, fanno tutti i sistemi operativi. In modo differente vuol dire che sono tanti diversi i parametri che devo passare. Nel caso di <strong>Windows</strong> abbiamo due funzioni essenziali che mi creano, <code>CreateThread</code> semplice o <code>CreateThreadEx</code>, che differiscono nella quantit√† di parametri, richiedono come minimo l'indicazione della funzione da invocare, <code>CreateThread</code> anche la dimensione dello stack e qualcos'altro, la definizione del contesto di sicurezza e cos√¨ via.</p>
<p>Nel caso di <strong>POSIX</strong> tendenzialmente la <code>pthread_create</code> mi chiede altri parametri che contengono anche l√¨ in qualche modo l'indicazione della funzione da chiamare eccetera, per√≤ l'ordine e la sintassi √® differente.</p>
<p><strong>I linguaggi moderni</strong> nascondono tutto questo, liberandoci dal problema di sapere il dettaglio di cosa il sistema operativo fa. Quello che i sistemi operativi <em>non fanno, nel modo pi√π assoluto</em>, √® darci un modo di <strong>cancellare un thread</strong>.
Perch√© non c'√®? Perch√© in realt√† quando si √® provato a mettere qualcosa ci si √® resi conto che si facevano dei danni galattici.</p>
<p>La cancellazione √® possibile <em>solo in un processo cooperativo</em>, ovvero io chiedo in qualche modo (poi vedremo come) al thread di piantarla l√¨ e quando lui ha voglia la pianta l√¨.
L'alternativa √® <strong>uccidere tutto il processo</strong>. Quello lo posso fare. Uccidendo il processo distruggo tutti i thread che stanno dentro e di conseguenza libero lo spazio di indirizzamento e cos√¨ via.</p>
<p>Un tentativo di implementare la terminazione forzata dei thread √® stato fatto nella prima versione di <strong>Java</strong>, Java 1.0, che aveva introdotto i thread multipiattaforma. All'oggetto <code>Thread</code>, oltre al metodo <code>start</code> per l'avvio, era stato aggiunto il metodo <code>stop</code> per bloccare l'esecuzione. Tuttavia, il metodo <code>stop</code> si √® rivelato disastroso: potendo intervenire in modo asincrono e casuale, interrompeva il thread bruscamente in qualsiasi punto dell'esecuzione, lasciando strutture dati in uno stato inconsistente e impossibile da ricostruire. √à come se qualcuno venisse colpito all'improvviso: tutto ci√≤ che stava facendo rimane incompiuto, e gli altri thread non hanno modo di capire cosa sia stato completato e cosa no, creando una situazione ingestibile.</p>
<p>Di conseguenza ai thread si pu√≤ in qualche modo dire <strong>"<em><strong>per favore fermati</strong></em>"</strong> e quando lui si accorge che gli avete chiesto "fermati" e decide che ci sono le condizioni per fermarsi, allora si ferma. Per√≤ √® fondamentale: √® un <em><strong>atteggiamento cooperativo</strong></em>.</p>
<h2 id="12-cosa-implica-la-concorrenza"><a class="header" href="#12-cosa-implica-la-concorrenza">1.2 Cosa implica la concorrenza</a></h2>
<p><img src="images/concorrenza/image%203.png" alt="image.png" /></p>
<p>Di per s√© il concetto di concorrenza √® tutto qua.
Quindi, abbiamo creato la capacit√† di eseguire pi√π cose in parallelo nello stesso spazio di indirizzamento.</p>
<p>Uno potrebbe chiedersi <em>"e dove sta la difficolt√†?".</em>
Potrebbe anche chiedersi <em>"qual √® il beneficio di questa cosa?"</em></p>
<p>Allora i benefici sono tanti. Prima di tutto la possibilit√† di fare cose contemporaneamente. Contemporaneamente perch√© spesso i nostri programmi si trovano a dover fare ad esempio alcune operazioni che riguardano la <strong>I/O</strong>.</p>
<p>Ad esempio, io scrivo a un certo punto sul disco. Come avviene la scrittura sul disco? Beh, la scrittura sul disco avviene che io preparo le cose che voglio scrivere, poi le metto in un <strong>buffer</strong>, poi dico al sistema operativo <em>"trasferiscili nel disco"</em>. Il sistema operativo, con i meccanismi suoi ‚Äî usando il <strong>DMA</strong>, o non usandolo, non ha importanza ‚Äî trasferisce.
Il problema √® che io devo sapere quando quel buffer lo posso riusare. Quindi l'operazione <code>write</code>, che accetta il buffer da scrivere, mi blocca fino a che il sistema operativo non √® finito.</p>
<p><em>Quanto ci mette l'operazione</em> <code>write</code><em>?</em>
Dipende‚Ä¶ dipende da che disco avete (un disco rotativo, un disco allo stato solito etc‚Ä¶).
Ci pu√≤ mettere <strong>decine di migliaia di cicli macchina</strong>, a volte <strong>centinaia di migliaia di cicli macchina</strong>, che sono millisecondi. Millisecondi, nell'esperienza di un computer, sono <em>mesi nell'esperienza umana</em>. Di conseguenza, in quei millisecondi io sono fermo in attesa che il sistema operativo faccia. Potrei fare altre cose? Ovviamente s√¨.</p>
<p>E allora l'idea √® che, mentre un thread √® bloccato in un'operazione di I/O, ne posso avere un altro che fa delle cose utili. Quindi arrivo a sovrapporre temporalmente delle cose. Potrei ottenere in parte questo beneficio <strong>se creassi due processi</strong>.
Certo, tutto il mondo Unix vecchia maniera, 1970-1980, era pensato proprio sull'idea di creare molti processi. Alla base di Unix c'√® la System Call che si chiama <code>fork</code>, che vi permette di duplicare un processo col suo stato di esecuzione. E quindi io posso affidare a un altro processo il compito di fare un certo mestiere. Ma se poi quest'altro processo deve ritornarmi dei dati, √® complicato, perch√® √® completamente separato. √à vero che la partenza √® condivisa, ma l'arrivo invece √® separato. E quell'altro processo deve poi mandarmi indietro delle cose, e lo deve fare con dei sistemi di <strong>Inter-Process Communication</strong>, che costano tantissimo.</p>
<p>Viceversa, col mondo dei thread, siccome operiamo nello stesso spazio di indirizzamento, io posso dire a un thread <em>"scrivi qui il tuo risultato, quando tu avrai finito vengo a leggere e quello che hai trovato lo leggo: lo trovo l√¨, facile"</em>. Cio√® gli passo l'indirizzo di dove lui deve mettere i suoi risultati e poi lo andr√≤ a vedere. Quindi non ho nessun overhead di Inter-Process Communication.</p>
<p><img src="images/concorrenza/image%204.png" alt="image.png" /></p>
<p>Posso, se la mia CPU √® multi-core, veramente eseguire pi√π operazioni in <strong>completo parallelo</strong>. Mentre un core svolge un compito, un altro pu√≤ dedicarsi a un'attivit√† differente. Prendiamo come esempio la moltiplicazione di due grandi matrici tipiche dell'AI, ciascuna da un milione per un milione di elementi. Possiamo suddividere queste moltiplicazioni tra i core disponibili. Ogni core si occupa di calcolare alcune righe della matrice risultante: uno elabora una riga, un altro un'altra riga e cos√¨ via. Le operazioni sono indipendenti tra loro, quindi non ci sono interferenze. In questo modo per√≤ completiamo il calcolo molto pi√π rapidamente.</p>
<h2 id="13-pro-e-contro-della-programmazione-concorrente"><a class="header" href="#13-pro-e-contro-della-programmazione-concorrente">1.3 Pro e Contro della Programmazione Concorrente</a></h2>
<p><strong>Questi sono i pro</strong> della programmazione concorrente. E ci sono ovviamente anche i contro.</p>
<p><em>Quali sono i contro?</em>
I contro sono che i nostri <em>modelli mentali naufragano</em>.
Noi siamo nati e cresciuti abituati a pensare a un programma che si svolge <strong>linearmente</strong>, sequenzialmente nel tempo ‚Äî <em>faccio questo, poi faccio quello, poi faccio quell'altro.</em></p>
<p>Noi lo concepiamo cos√¨ il nostro programma, √® fondamentale concepirlo cos√¨. Abbiamo ben chiaro che la sequenza che scriviamo delle istruzioni <em>denota la precedenza nel tempo</em>. E questo ci permette di dire che alla riga X una certa cosa non √® ancora capitata perch√© viene scritta la riga X+Œî, con Œî positivo. E quindi siamo tranquilli che sicuramente l√¨ questa cosa √® vera.</p>
<p>Peccato che nel momento in cui l'esecuzione diventa <strong>concorrente</strong>, le relazioni temporali tra quello che avviene nel thread1 e quello che avviene nel thread2 non sono pi√π ovvie. Perch√© i due si svolgono ognuno dai fatti loro. E quindi io posso aver gi√† finito quando tu non hai neanche ancora cominciato. E non basta dire <em>"cominciamo insieme"</em>, perch√© poi ognuno di noi ha storie diverse.</p>
<p>Di conseguenza quello che capita √® che ci sono <strong>nuove fonti di errore</strong> e soprattutto <strong>nuove tipologie di errore</strong> a cui non avremmo normalmente mai pensato. E che se non vediamo, pensiamo che siano farlocche, che non esistano. Ma in realt√† ci sono e ora cercheremo di prendere consapevolezza di questa cosa.</p>
<p>Il problema di fondo √® legato al fatto che la memoria <em>non pu√≤ pi√π essere pensata come un deposito statico</em>. Noi siamo abituati a pensare che se io ho scritto 32 in una certa variabile, da quando l'ho scritto, tutti che vanno a leggere ci trovano 32. In realt√† √® pi√π complesso di cos√¨. Perch√© io non scrivo mica direttamente nella variabile. Dobbiamo prendere in considerazione un po' pi√π in profondit√† com'√® fatta l'architettura dell'elaborazione. In pi√π, se mentre io scrivo tu leggi, <em>cosa leggi?</em> Boh, possono capitare cose molto strane.</p>
<p><img src="images/concorrenza/image%205.png" alt="image.png" /></p>
<p>La prima cosa che diciamo √® che se in un processo sono presenti due o pi√π thread, ciascuno di questi thread per conto suo si svolge normalissimamente. Fa esattamente quello che farebbe un programma normale, cio√® fa le cose nell'ordine che sono scritte. Quindi di per s√© la scrittura del codice del singolo thread non √® problematica. Il problema √® <strong>l'interazione tra l'uno e l'altro</strong>.</p>
<p>Cosa posso dire di <em>‚Äúa che punto √® l'altro se io ho raggiunto questo punto?‚Äù</em> <em>Niente</em>.</p>
<p>Se voi mangiate insieme, il fatto che uno di voi abbia finito il suo piatto vuol dire che anche gli altri hanno finito? Manco per idea: potreste essere molto veloci e quindi finire prima di tutti, oppure potreste essere molto lenti e finire per ultimi, oppure potreste avere una velocit√† di mangiare intermedia e qualcuno dei vostri commensali ha gi√† finito e qualcuno √® ancora l√¨ che mangia.</p>
<p>Quindi c'√® <strong>solo un modo</strong> di capire dove sono gli altri: <em>parlarsi</em>.</p>
<p>Piccolo problema, il parlarsi non √® parte del nostro normale modello.
Quindi il nostro programma deve <em>arricchirsi di qualcosa che permette di chiedere agli altri</em>, ma per chiedere agli altri io li devo conoscere, devo sapere che esistono.</p>
<p>Allora, di fatto creare un programma <strong>multi-threaded</strong> richiede di (oltre a definire le attivit√† che ciascun thread deve fare per s√© per adempiere al proprio compito primario) <em>aggiungere a quel thread delle altre attivit√† che gli servono per coordinarsi</em>, perch√© queste ci permettono poi di andare avanti e fare insieme.</p>
<p>Quindi, sostanzialmente, il nostro programma diventa <strong>pi√π complesso</strong>, perch√© aggiungiamo alle attivit√† singole, normali, che gi√† prevederemmo, ne aggiungiamo delle altre che servono a capire dove siamo arrivati. In alcuni casi ci basta l'indicazione che <em>l'altro √® pronto, o che l'altro non √® pronto</em>, in altri casi ci serve il <strong>risultato intermedio</strong> calcolato dall'altro, perch√© noi su quel risultato intermedio ci costruiamo sopra. In altri casi ci servono altre informazioni, e abbiamo bisogno di una relazione molto pi√π complessa.</p>
<p>I <strong>meccanismi di comunicazione</strong> interagiscono per√≤ con l'architettura interna, e ci danno una serie di cose su cui non abbiamo mai ragionato.
<em>Perch√©?</em> Perch√© non ce n'era bisogno, perch√© in fondo i nostri programmi, fin tanto che erano <em>single thread</em>, non avevano bisogno di vedere quel livello di dettaglio. Per√≤ nel momento in cui i programmi diventano <strong>multi-thread</strong>, occorre capire.</p>
<p><img src="images/concorrenza/image%206.png" alt="image.png" /></p>
<p>Di base, il nostro processore prosegue normalmente con un ciclo che √® quello standard, <strong>fetch decode execute</strong>, cio√® prende un'istruzione, la guarda, capisce cosa quell'istruzione vuol dire e la fa. Poi ne prende un'altra e la fa, e va avanti cos√¨ una dopo l'altra tranquillamente.</p>
<p>Questo meccanismo prosegue fino a quando normalmente non scatta un qualche <em><strong>interrupt</strong></em> che segnala la fine del quanto di tempo. A quel punto interviene il <strong>sistema operativo</strong> che dice <em>‚ÄúFermi tutti‚Äù</em>, congela l'esecuzione di ciascun thread, quindi lo stato dei registri presenti nella CPU in una qualche zona di memoria del kernel, e va a scegliere un altro thread a farlo cominciare.</p>
<p>Queste interruzioni, che gi√† avvengono normalmente in tutti i nostri progetti, <em>non danno nessun fastidio</em>. <em>Perch√©?</em> Perch√© il nostro thread viene sospeso a un certo punto, il sistema operativo fa entrare un altro processo che fa le sue cose, scadr√† il suo quanto di tempo, ripristina il nostro processo, che riprende esattamente da dove si era fermato ‚Äî non √® capitato nulla.</p>
<p>Esattamente come quando voi la sera andate a dormire, lasciate la stanza in ordine o in disordine a secondo della vostra inclinazione, e quando vi svegliate la ritrovate come l'avete lasciata. Il vostro sonno non ha cambiato niente.
Ma se <strong>non siete soli in casa</strong>, √® assolutamente possibile che mentre voi dormite, qualcun altro sposti le cose. E quindi, quando vi svegliate, non trovate pi√π quello che pensavate di aver lasciato. Semplicemente perch√© un altro √® venuto, ha preso e ha fatto le cose sue.</p>
<p><strong>Finch√© siete soli</strong>, questo problema non ce l'avete.
<strong>Quando cessate di essere soli</strong>, il problema si pone. E di colpo cambia tutto, perch√© non siete pi√π sicuri di dove avete messo le cose. O meglio, <em>di dove le potete trovare</em>. Dove le avete messe lo siete sicuri: le avete messe voi. Il problema √® che se √® arrivato qualcuno ve le ha spostate voi non lo potete sapere: <em>stavate dormendo</em>.</p>
<p><img src="images/concorrenza/image%207.png" alt="image.png" /></p>
<p>Siccome l'esecuzione di ciascun thread procede <strong>indipendentemente</strong> da quelle degli altri, l'unico modo di capire che cosa sta succedendo passa attraverso il <em>parlarsi</em>.</p>
<p><em>E come facciamo a parlarci?</em>
L'unico modo che abbiamo di parlarci √® immaginare di avere un <strong>pezzo di memoria</strong> dove uno scrive e l'altro legge. E quindi dobbiamo darci un ordine. Quindi, questo lo possiamo fare perch√© operiamo nello stesso <em>spazio di indirizzamento</em>. Io ti ho scritto qui un messaggio. Quando tu ti svegli, vieni, leggi, troverai l'informazione e agisci di conseguenza. Bello! Beh, pi√π o meno‚Ä¶</p>
<p><img src="images/concorrenza/image%208.png" alt="image.png" /></p>
<p><em>Perch√© ‚Äúpi√π o meno‚Äù?</em>
Perch√© quando un thread legge da una locazione di memoria, <em>che cosa ci trova?</em> Ci pu√≤ trovare il valore che inizialmente era stato predefinito per quella locazione se quella era, ad esempio, una <strong>variabile globale inizializzata</strong>.</p>
<p>Ad esempio, se ho definito nel mio programma una variabile globale <code>i</code> che vale 0, di tipo intero, che inizialmente vale 0, quindi ho scritto <code>int i = 0</code>, quando vado a leggere in una qualche funzione quanto vale <code>i</code>, potrei trovarci quello 0 iniziale. Facile.
Oppure potrei trovarci quello che io stesso ho scritto <em>prima</em>. Magari ad un certo punto ho eseguito un'istruzione <code>i = 27</code>, poi vado a leggere <code>i</code> e ci trovo il mio 27. Normalissimo. Esattamente come quando voi, risveglio al mattino, aprite il cassetto e vi aspettate di trovarci quello che ci avete messo la sera.</p>
<p>Oppure potrei trovarci quello che qualcun altro ci ha messo dentro! Perch√© stavo dormendo, e mentre dormivo √® arrivato un altro che ci ha messo una cosa.</p>
<p><strong>Piccolo problema</strong>. Il fatto che l'hardware su cui eseguiamo le nostre cose ha una serie di <em>ottimizzazioni</em> (l'uso della <strong>gerarchia di cache</strong>, il meccanismo di ordinamento delle istruzioni da parte del processore e del compilatore), fa s√¨ che questo terzo caso, cio√® ci leggo quello che ha scritto un altro, sia <em>particolarmente problematico</em>.</p>
<h2 id="14-modello-di-memoria"><a class="header" href="#14-modello-di-memoria">1.4 Modello di memoria</a></h2>
<p><img src="images/concorrenza/image%209.png" alt="image.png" /></p>
<p>Vediamo i dettagli. Come √® fatta la memoria di un sistema moderno di elaborazione? Beh, le nostre CPU, che sono fatte di pi√π core, non vanno a leggere e scrivere direttamente sulla RAM, perch√© se facessero cos√¨ andrebbero a manovella, sarebbe lentissimo. Perch√© la RAM √® maledettamente lenta, rispetto alle CPU. Quindi i sistemi moderni hanno vari livelli di cache.</p>
<p>Quando la CPU legge, legge se pu√≤ direttamente dai propri <em><em>registri</em>,</em>** e questa √® l'operazione che costa di meno in assoluto: un ciclo macchina.
Se il dato non viene dal registro, lo cerca nella <strong>cache di livello 1</strong>. La cache di livello 1, normalmente √® suddivisa in modo diverso per facilitare le architetture pipeline, in <em>cache dati</em> e <em>cache istruzioni</em>. C'√® poi ancora una terza che √® la cache di <strong>TLB</strong>, <em>Transition Lookaside Buffer</em>, quella che mi serve per passare dalla memoria virtuale alla memoria reale.</p>
<p>Per√≤ per quello che dobbiamo dire adesso ci basta questo. Quando io vado a leggere nella memoria cache, guardo e vedo <em>"vorrei leggere questa informazione,</em> <em>√® scritta qui‚Äù</em>. La memoria cache √® <em>piccolina ma molto veloce</em>. Le informazioni sono rappresentate a tag, cio√® che usa come tag l'indirizzo vero in cui vorrei leggere, e valore. Se lo trovo l√¨, magnifico, ho direttamente il mio dato.</p>
<p>Pu√≤ darsi che nella cache quell'indirizzo l√¨ non ci sia. Allora lo vado a chiedere al sistema a monte. Si √® verificato un <strong>cache miss</strong>. Lo vado a chiedere a un sistema a monte che a sua volta potrebbe avercelo o meno. La cache di livello 1 √® piccola ma molto veloce, mi costa <em>due cicli macchine</em>. Se non lo trovo l√¨, lo vado a cercare nella <strong>cache di livello 2</strong>, che √® pi√π grande e quindi √® maggiore la probabilit√† di trarci delle cose, ma √® un po' pi√π lenta. Se non lo trovo neanche nella cache di livello 2, lo vado a cercare nella <strong>cache di livello 3</strong>, che √® ancora pi√π grande (dell'ordine dei megabyte, a volte delle decine, a volte delle centinaia di megabyte), ma √® ancora pi√π lenta. E se non lo trovo neanche nella cache di livello 3, lo devo andare a prendere nella <strong>RAM</strong>, che √® grande gigabyte, ma √® molto lenta.</p>
<p>Fin qua nella lettura. <em>Cosa succede quando scrivo?</em> Dipende, potrei avere un sistema di cache <em>write-through</em> oppure potrei avere un sistema di cache che invece √® <em>ritardato</em>. Nel sistema write-through, nel momento in cui io scrivo che nella locazione 3b5f ci metto 27, lo scrivo nella cache di livello 1, lo propago nella cache di livello 2, lo propago nella cache di livello 3, e lo propago nella RAM principale. Che per√≤ ci arriva un bel po' dopo, perch√© ciascuna va alla sua velocit√† e quindi le cose arrivano pian piano.</p>
<p>Potrei avere una cache invece che non √® write-through, e quindi io ci scrivo 27 e il dato sta nella cache di livello 1 e a quel punto solo quando liberer√≤ quella cella di cache, quando la invalider√≤, provveder√≤ a scrivere effettivamente sul livello superiore. Quindi con un ulteriore ritardo. √à molto pi√π efficiente, ma √® molto pi√π, ci mette molto di pi√π a propagarsi.</p>
<p>Se quindi nella locazione il core 0, nella locazione 3b5f ha messo 27, il core n cosa vede nella locazione 3b5e0? <em>Boh</em>, perch√© il 27 si √® fermato nella sua cache, poi piano piano, prima o poi arriver√† nella RAM. Ma l'altro ha la sua copia cache, che non √® immediatamente aggiornata. Quindi io ho gi√† scritto 27, ma di l√† ci leggo ancora quello che c'era scritto prima.</p>
<p>Quindi <strong>non √® pi√π vero che non appena scrivo l'altro vede</strong>. Io ho appena scritto nella mia copia locale, ma questa ci arriver√† tra un po' agli altri.</p>
<p><em>Come ne vengo fuori?</em> <em>Possiamo dire quando √® finalmente arrivata nella RAM?</em> Di base no.
<em>Posso dire quando finalmente mi √® risalita fino alla corrispondente cache dell'altro core?</em> Manco per idea.
<strong>Nessun linguaggio mi espone questo</strong>, perch√© la cache non traspare da nessuna delle istruzioni che noi abbiamo visto.</p>
<p>La cache √® un'ottimizzazione <em>bellissima, potentissima</em>, che fa s√¨ che i nostri PC vadano molto veloci e si riescano a fare videoconferenze, intelligenza artificiale e altre cose simpatiche, ma che mi crea questi problemi. Perch√© quando siamo insieme, mi crea un <strong>bottleneck</strong> che non traspare. Perch√© il linguaggio non lo mappa. O meglio, i linguaggi di alto livello non lo mappano.</p>
<p>Nell'Assembler in realt√† questo esiste perch√© i singoli processori multicore, o comunque quelli dotati di cache, hanno alcune <strong>istruzioni particolari</strong>, che sono fatte un po' diverse tra di loro, ma concettualmente servono a dire "<em>Questo dato dalla cache propagalo immediatamente fino alla RAM, costi quel che costi, e al contrario questo dato prendilo comunque dalla RAM, anche se ce l'avessi in cache, costi quel che costi</em>". Perch√© io voglio essere sicuro che quel dato l√¨ sia quello vero.</p>
<p>Il problema √® che queste istruzioni qua, che si chiamano <strong>Memory Barrier</strong>, <strong>Memory Fence</strong>, a seconda del processore specifico che stiamo utilizzando, o anche altro, <em>non traspaiono nei nostri linguaggi di alto livello</em>. Quando io dichiaro la mia variabile la chiamo di tipo <code>i32</code>, la chiamo di tipo <code>String</code>, ma la assegno e la leggo normalmente. Non vedo l'esistenza di queste cose.</p>
<p><img src="images/concorrenza/image%2010.png" alt="image.png" /></p>
<p>Le cose tra l'altro possono essere anche pi√π complesse, perch√© i processori pi√π performanti radunano le cache con <strong>vari livelli di gerarchia</strong>, per cui:</p>
<ul>
<li>la <strong>cache di livello 1</strong> √® dedicata al singolo core</li>
<li>la <strong>cache di livello 2</strong> normalmente √® appaiata a coppie di core</li>
<li>la <strong>cache di livello 3</strong>, viceversa, raduna tutti i core</li>
</ul>
<p>Ci sono sistemi che di cache, di livelli di cache ne hanno 4 o anche 5.</p>
<p><img src="images/concorrenza/image%2011.png" alt="image.png" /></p>
<p>La differenza sostanziale √® quella dei <strong>tempi di accesso</strong>. Qui √® riportata nella tabella di Bobrov, il tempo reale (in microsecondi o nanosecondi a seconda dei casi), e il tempo nella scala umana, dove il rapporto √® un ciclo macchina/un secondo.
Quello che per la CPU √® un ciclo macchina √® riportato in una scala umana (siccome facciamo fatica a immaginare quanto √® 3 nanosecondi rispetto a 2 millisecondi) in cui al ciclo macchina corrisponde un secondo, per cui:</p>
<ul>
<li>l'accesso alla <strong>cache di livello 1</strong>, che normalmente costa circa 2 cicli, √® come se durasse <em>2 secondi</em></li>
<li>la <strong>cache livello 2</strong> mi costa l'equivalente di <em>7 secondi</em></li>
<li>la <strong>cache di livello 3</strong> mi costa circa <em>un minuto</em></li>
<li>l'accesso alla <strong>RAM</strong> mi costa <em>4 minuti</em></li>
<li>l'accesso al <strong>disco</strong> mi costa, in base alla tecnologia di disco che sto usando, da un <em>quarto d'ora a giorni</em>, addirittura se uso dischi rotazionali, <em>mesi</em></li>
</ul>
<p>Ecctera‚Ä¶</p>
<h2 id="15-problemi-aperti"><a class="header" href="#15-problemi-aperti">1.5 Problemi aperti</a></h2>
<p><img src="images/concorrenza/image%2012.png" alt="image.png" /></p>
<p><strong>Allora, che problemi porta tutto questo?</strong> Porta problemi di <em>atomicit√†</em>.</p>
<p><em>Quali operazioni hanno effetti indivisibili?</em>
Cio√® che non possono essere viste separatamente ‚Äî in un colpo solo cambio due cose, e non prima una e poi l'altra.</p>
<p><em>Quali problemi hanno di visibilit√†?</em>
Non sempre il fatto che io abbia modificato una variabile la rende visibile all'altro. Perch√© se la mia modifica si √® fermata nella mia cache e non √® stata propagata alla RAM vera e non √® risalita fino alla cache dell'altro, l'altro non se ne accorger√† minimamente che io ho scritto.</p>
<p>Poi c'√® un <strong>terzo problema</strong>, ancora meno ovvio: <em>l'ordinamento</em>. Quando scrivo prima in una posizione e poi in un'altra, mi aspetto che un altro thread legga i dati nello stesso ordine in cui li ho scritti.
Quindi, se riesce a leggere il secondo dato, si potrebbe pensare <em>"sicuramente pu√≤ leggere anche il primo"</em>. In realt√† <strong>non √® cos√¨</strong>. I tempi di propagazione possono essere diversi: se scrivo prima <em>alfa</em> in un posto e poi <em>beta</em> in un altro, un altro thread potrebbe gi√† leggere beta ma non vedere ancora alfa. Per questo non posso usare la lettura di beta come garanzia che alfa sia disponibile, dato che alfa potrebbe avere un tempo di propagazione pi√π lungo.</p>
<p>Questo genere di cose noi normalmente non le abbiamo viste mai, non le abbiamo mai preso in considerazione, perch√© non ce n'√® mai stato bisogno, in quanto quando c'√® <strong>un solo thread</strong> che fa le cose, lui va sempre a pescare dalla sua cache, quindi il fatto che quella cache si propaghi anche oltre, per lui √® rilevante. Lui vede la sua, se non c'√® c'√® quella di livello superiore, se non c'√® c'√® quella di livello superiore, va tutto bene. L√¨ l‚Äôastrazione √® perfetta.</p>
<p>Quando siamo in due invece, il fatto che ciascuno di noi guardi nella propria cache, non dice niente di cosa sta capitando in quell'altra. E allora il nostro programma si deve arricchire di pezzi che prima non prendevamo in considerazione, che servono a dire <em>‚ÄúAllora, nella maggior parte delle situazioni, quando lavoro per me soltanto (e quindi quando faccio delle cose che gli altri non han bisogno di sapere), me le faccio normalmente col massimo delle prestazioni. In quei piccoli punti dove io parlo per gli altri, cio√® scrivo una cosa affinch√© un altro la legga, questa cosa la devo scrivere in un modo molto inefficiente, ma che per√≤ mi d√† garanzia che l'altro la possa leggere davvero‚Äù</em>.</p>
<p><em>E quindi che cosa devo fare?</em>
Devo svuotare la cache prima, scrivere, e forzare di nuovo lo svuotamento della cache, in modo tale che sono certo che il dato di l√† arrivi, e svuoto la cache mia e anche di tutti gli altri. Quindi potenzialmente penalizzandoli, ma mettendomi al riparo dal fatto che non rischiano di leggere un dato errato. Solo che nei linguaggi di alto livello l'istruzione <em>‚Äúsvuota la cache‚Äù</em>, o <em>‚Äúforza la scrittura della cache‚Äù</em>, non c'√®.
Quella istruzione l√¨ √® presente, annegata, dentro alcune funzioni di libreria, che non solo fanno questo mestiere di bassissimo livello, ma fanno delle cose un po' pi√π utili e creano delle astrazioni che adesso vogliamo imparare.</p>
<p>Le due astrazioni che vogliamo imparare si chiamano <em><strong>mutex</strong></em> e <em><strong>condition variable</strong></em>, e servono fondamentalmente a darci dei comportamenti affidabili coi quali possiamo ottenere garanzia che il nostro programma fa quello che pensiamo debba fare e non quello che vuole lui.</p>
<p><img src="images/concorrenza/image%2013.png" alt="image.png" /></p>
<p>Le istruzioni effettive dipendono dall'architettura del processore. I processori di tipo x86 hanno un certo meccanismo e ci mettono a disposizione alcune istruzioni che si chiamano <em><strong>memory fence</strong></em>.</p>
<p>I processori tipo ARM invece, che hanno una modalit√† molto pi√π sofisticata e potenzialmente con prestazioni molto pi√π alte, ed √® il motivo per cui Apple ad esempio ha scelto di abbandonare gli x86 ed √® passata ai suoi processori ARM, √® legata al fatto che l'astrazione che gli ARM offrono, che prende il nome di <em><strong>memory barrier</strong></em>, mi permette di distinguere in modo molto pi√π fine se sto facendo un'operazione di lettura e quindi io devo accedere a un dato che mi ha scritto un altro, quindi l'unica cosa che devo fare √® svuotare la mia cache per essere sicuro di attingere dalla fonte. Oppure sto facendo un'operazione di scrittura, per cui non ho bisogno di svuotare prima la mia cache, ma posso scrivere e poi forzare il flushing, ovvero il consolidamento dei dati presenti in cache nella memoria principale. Oppure devo fare un'operazione di tipo <em>exchange</em>, dove io leggo e contemporaneamente scrivo e in quel caso l√¨ ho bisogno sicuramente di svuotare prima e di forzare la scrittura dopo, in modo tale che l'altro certamente veda il dato e io veda certamente il dato originale. Quindi a secondo del tipo di operazione io posso in modo molto pi√π fine definire che cosa voglio andare a fare.</p>
<p><img src="images/concorrenza/image%2014.png" alt="image.png" /></p>
<p><strong>Quando non usiamo correttamente i costrutti necessari</strong> per questo genere di cose, andiamo incontro a problemi di vario tipo.</p>
<p>Se non includiamo per niente meccanismi di <strong>sincronizzazione</strong>, il nostro programma <em>va a caso</em>. <em>Perch√©?</em> Perch√© non √® detto che l'altro veda un dato sbagliato. <em>E' come attraversare la strada col semaforo rosso</em> ‚Äî non vi schiacciano, sicuramente. Per√≤ potrebbero farlo e avrebbero ragione.</p>
<p>Va a caso, perch√© siccome non fa niente per sincronizzarsi con gli altri, se gli va bene gli va bene, e se gli va male gli va male. Ma non ha modo neanche di capirlo se gli √® andata bene o se gli √® andata male. <strong>Perch√© non ha modo di comunicare con gli altri.</strong></p>
<p>Questa √® quindi una soluzione <strong>molto pericolosa</strong> che genera <em>malfunzionamenti casuali e completamente irriproducibili</em>. Di conseguenza, diventa impossibile debuggare il codice. Quando il cliente vi contatta dicendo <em>"questa cosa non funziona"</em>, non sarete in grado di identificare il problema. Magari nei vostri test tutto funziona perfettamente, ma per il cliente il programma si blocca. Questi errori tendono a manifestarsi nelle situazioni pi√π imprevedibili: il codice funziona sul vostro computer ma si blocca su un altro, semplicemente perch√© ha temporizzazioni leggermente diverse. <strong>E naturalmente, questi problemi emergono sempre nel momento peggiore possibile.</strong></p>
<p><img src="images/concorrenza/image%2015.png" alt="image.png" /></p>
<p><strong>Allora, internamente ogni thread √® mappato all'interno del kernel</strong> <strong>con un <em>oggetto</em> che ne ricorda il suo stato</strong>. Questo <strong>oggetto</strong> serve allo scheduler del kernel per poter <em>congelare l'esecuzione</em> di quel thread quando deve smettere e <em>ripristinarla</em> quando dovr√† ricominciare nel momento in cui tocca di nuovo a lui fare delle cose. Dentro l'oggetto kernel quello che viene salvato √® lo stato del core su cui quel thread √® in esecuzione ‚Äî tipicamente c'√® l'elenco dei registri di quel core: <em>io ti ho congelato al tempo t, dentro <code>AX</code> c'era scritto questo, dentro a <code>BX</code> c'era scritto quello, dentro a <code>CX</code> c'era scritto quell'altro. Quando toccher√† di nuovo a te essere eseguito prendo questo insieme di valori, li rimetto nei registri e ti dico continua. E tu continui e fai le tue cose.</em></p>
<p>Tipicamente dentro quei registri l√¨ c'erano in alcuni casi dei dati, in alcuni casi dei <strong>puntatori</strong>, cio√® degli <em>indirizzi di memoria</em>. Ad esempio il <strong>program counter</strong> diceva qual era la prossima istruzione da eseguire, ad esempio lo <strong>stack pointer</strong> diceva dove √® arrivato lo stack e cose del genere. Ma anche altri registri potrebbero avere dei loro indirizzi.
<em>Questi indirizzi dove puntano?</em> Puntano <strong>nello spazio di indirizzamento del processo</strong>, che √® <strong>condiviso da tutti i thread</strong> che operano l√¨ dentro.</p>
<p>Ora, mentre lo scheduler tira via un thread per un qualche motivo potrebbe continuare a lasciar girare degli altri thread dello stesso processo, che hanno la possibilit√† di andare avanti e fare cose. Per cui mentre il thread <strong>t1</strong> √® l√¨ che dorme, il thread <strong>t2</strong>, che √® suo fratello, fa cose e in quello spazio di indirizzamento cambia delle informazioni. Quando <strong>t1</strong> si risveglia deve capire cosa √® successo, non ne ha nessuna percezione.</p>
<p><img src="images/concorrenza/image%2016.png" alt="image.png" /></p>
<p>Quindi:</p>
<ul>
<li>Tutti i thread dello stesso processo condividono il <strong>codice eseguibile</strong>, questo non √® un problema perch√© quello √® solo in lettura e quindi non ci d√† fastidio.</li>
<li>Tutti i thread dello stesso processo condividono lo <strong>heap</strong> e questo √® potenzialmente un problema perch√© io cambio una cosa e la puoi cambiare anche tu. <em>E chi vince? E come vince?</em></li>
<li>Ciascun thread ha il proprio <strong>stack</strong>.</li>
<li>Tutti i thread condividono le <strong>variabili globali</strong>, ammesso che ce ne siano.</li>
</ul>
<p>Sicuramente heap e variabili globali sono due grosse fonte di collisione perch√© √® dove √® pi√π facile scontrarsi.</p>
<p>Gli <strong>stack</strong> sono solo <em>relativamente</em> riservati, perch√© quando rivelo l'indirizzo di una variabile del mio stack (scrivendolo in una variabile globale o nello heap), questa diventa accessibile anche agli altri thread che, seguendo i puntatori, possono modificarla.
<em>Non posso dire che le variabili locali sono automaticamente protette</em>. Lo sono nella misura in cui nessuno ne dischiude l'indirizzo, ma nel momento in cui qualcuno ne dischiude l'indirizzo non sono pi√π protette neanche un po', quindi <strong>tutta la memoria del processo √® potenzialmente a rischio</strong>.</p>
<h2 id="16-esecuzione-e-non-determinismo"><a class="header" href="#16-esecuzione-e-non-determinismo">1.6 Esecuzione e non determinismo</a></h2>
<p><img src="images/concorrenza/image%2017.png" alt="image.png" /></p>
<p>In alcuni casi io ho bisogno di avere certezza che <em>mentre io cambio un <strong>dato condiviso</strong>, nessun altro venga a impicciarsi di quel dato l√¨, n√© per leggerlo n√© per scriverlo</em>.
E questo tipo di situazione viene gestito utilizzando una primitiva che si chiama <strong>mutex</strong>, che vuol dire <em>mutual exclusive</em>. √à un oggetto che mi protegge un'area di memoria dicendo "<em>mentre io scrivo o mentre io leggo, nessun altro n√® legge n√© scrive, ci lavoro da solo</em>. <em>Quando ho finito lo libero e quindi potranno entrare gli altri che faranno le loro cose.‚Äù</em></p>
<p>Il sistema operativo mi protegge, <em>perch√©?</em> Perch√© io accedo alla zona protetta dal mutex eseguendo un'operazione di <em><strong>locking</strong></em>, in cui chiedo di prendere possesso, se il mutex √® libero effettivamente questo possesso mi viene concesso e accedo, se il mutex in questo momento √® in uso a qualcun altro mi blocco l√¨ sull'operazione lock e aspetto. Prima o poi chi ce l'ha in uso in questo momento finir√†, far√† l'operazione duale che si chiama <em><strong>unlock</strong></em> e di conseguenza potr√≤ entrare. E se siamo in due a aspettare faremo la coda, uno dei due entrer√† e l'altro continua ad aspettare fino a che non sar√† anche il suo turno. Questo √® un esempio di forma di <strong>sincronizzazione</strong>. Si usa quando dobbiamo procedere uno per volta.</p>
<p>In altre situazioni io ho bisogno di <em>aspettare che succeda un qualcosa fino a che tu non mi fai sapere che posso continuare</em>.
In questa situazione qua invece io ho bisogno di fare un'<em><strong>attesa passiva</strong></em>. Quando sar√† ora di continuare tu mi darai un segnale e a quel punto io so che posso andare avanti. Per questo tipo di cosa in cui non ho necessariamente una zona condivisa ma ho bisogno di aspettare che tu abbia finito qualcosa si usa un altro tipo di astrazione che si chiama <em><strong>condition variable</strong></em> (<code>Condvar</code> in Rust).</p>
<p>Quindi obiettivo nostro √® imparare a usare queste due forme di astrazione che sono le <strong>astrazioni fondamentali</strong> su cui si basano tutte le altre forme di coordinamento.</p>
<p><img src="images/concorrenza/image%2018.png" alt="image.png" /></p>
<p>Quindi possiamo inventarci degli altri modi di governarsi ma sono tutti riconducibili a un uso misto di queste due. Anzi, quello <strong>essenziale</strong> √® il <strong>mutex</strong>, mentre la <strong>condvar</strong> richiede un mutex ‚Äî mentre il mutex pu√≤ esistere da solo, la condvar non pu√≤ esistere in assenza di un mutex.
<strong>L'insieme di queste due cose qui abilita tutto il resto.</strong></p>
<p>Non √® un caso ad esempio che in <strong>Java</strong> gli <code>Object</code> abbiano al proprio interno due comportamenti intrinseci. Il primo √® il comportamento <code>synchronized</code>, ogni object in Java si pu√≤ comportare da mutex mettendo davanti ai suoi metodi la parola chiave <code>synchronized</code>. Ogni oggetto in Java si pu√≤ anche comportare da condvar grazie al fatto che la classe <code>Object</code> ha dentro di s√© i metodi <code>wait</code>, <code>notify</code> e <code>notifyAll</code>, che ci danno la possibilit√† di segnalare quando capita qualcosa di rilevante. Lo stesso vale in altri linguaggi.</p>
<p>Notate che nella storia si √® arrivati a identificare queste due come le <strong>operazioni essenziali</strong> passando per altri tentativi. Tony Hoare nel 1960 si era allineato sull'idea dei <em>semafori</em>. I <strong>counting semaphore</strong> sono delle primitive dove io mantengo un numerino che non pu√≤ mai diventare negativo e ti offro due operazioni. <code>increment</code> e <code>decrement</code> (lui la chiamate <code>p</code> e <code>v</code> ma √® un nome improponibile perch√© non si capisce mai chi fa che cosa). Increment mi fa salire il numero di un'unit√†, e decrement me lo abbassa con il vincolo che <strong>non pu√≤ mai diventare pi√π piccolo di zero</strong>. Quindi se io cerco di decrementare una cosa che √® gi√† zero aspetto fino a che qualcuno non fa un increment costitutivo e mi dia il permesso.</p>
<p>La variante dei semafori √® che non solo c'√® un minimo che √® zero ma c'√® anche un massimo che √® <em>n</em> e quindi io non posso mai andare oltre il massimo. Se cerco di andare oltre il massimo e fare un increment quando lui √® gi√† al massimo devo aspettare che qualcuno faccia contestualmente un decrement, cos√¨ da poterci stare. Nel tempo i linguaggi hanno scelto di non usare i semafori come astrazione perch√© √® molto pi√π prona a errori, √® difficile da concepire. Va bene in pochi casi quando io devo proteggere l'accesso forse a un circular buffer o a un numero limitato di risorse, ma √® <em>molto pi√π difficile da generalizzare</em>. Viceversa la coppia <strong>mutex/condvar</strong> garantisce la possibilit√† di esprimere tutte le altre forme.</p>
<h3 id="161-esempio"><a class="header" href="#161-esempio">1.6.1 Esempio</a></h3>
<p><img src="images/concorrenza/image%2019.png" alt="image.png" /></p>
<p><strong>Prendiamo velocemente un esempio</strong>, utilizzando Rust e questo programmino.</p>
<p>La prima cosa da capire √® che <em>creare i thread √® una banalit√†</em>. In Rust c'√® una struttura dati chiamata <code>thread</code> che ci offre il metodo <code>spawn</code> per creare un thread. Quindi questo facciamo <code>let t1 = thread::spawn</code>, dove <code>thread::spawn</code> accetta una chiusura.</p>
<p><code>thread::spawn</code> serve semplicemente a dire "<em>da adesso in avanti fai partire un'attivit√† che si svolger√† in parallelo a quella del thread principale</em>".
<em>Che cosa fa questa attivit√†?</em> Esegue il codice contenuto nella chiusura finch√© non termina.
In questo caso, la chiusura che passiamo a <code>t1</code> √® molto semplice: fa <code>for i = 0..10</code> stampando "aaa" seguito da i, quindi "aaa0", "aaa1", "aaa2" fino a 9.</p>
<p>Dopo aver creato <code>t1</code> facciamo anche <code>t2</code> che fa lo stesso lavoro, ma invece di stampare "aaa" stampa " bbb". Lo spazio iniziale √® semplicemente per rendere pi√π facile distinguere le stampe quando gli output dei thread si mescolano.</p>
<p>Nel <code>for</code> √® anche inclusa un'operazione necessaria in Rust, che non servirebbe in C++. Rust ha delle <strong>ottime ottimizzazioni</strong>: siccome questo ciclo dura poco (10 iterazioni) e la print √® particolarmente efficiente in Rust, vedremmo <code>t1</code> finire prima che <code>t2</code> inizi, perdendo la percezione della concorrenza. Per evitarlo, potremmo aumentare il ciclo da 10 a 10.000 iterazioni (e allora inizierei a vederli intersecarsi), oppure inserire una <em>piccolissima pausa</em> di un nanosecondo ‚Äî veramente minima ‚Äî che mi garantisce l'intrecciarsi dei thread, rendendo evidente il comportamento che ci interessa.</p>
<p>Il thread principale dopo aver creato il <strong>t1</strong> e il <strong>t2</strong> li aspetta ed esegue l'operazione <code>join</code>.
<code>t1.join</code> ritorna un <code>Result</code>. Quel <code>Result</code> ha successo ed √® il risultato della funzione (il risultato del thread), ma in questo caso il mio thread non ritorna niente quindi in questo caso torna uno <code>Unit</code>, oppure contiene un <code>Error</code> se in qualche modo questo thread si impiantasse al proprio interno. Quindi se il thread √® finito bene o male lo so facendo l'<code>unwrap</code> della <code>join</code>. Il thread principale aspetta che <strong>t1</strong> e <strong>t2</strong> entrambi siano finiti e poi finisce anche lui.</p>
<p><img src="images/concorrenza/image%2020.png" alt="image.png" /></p>
<p><em>Cosa succede se io eseguo questo codice?</em>
Vedo che partono, in questo caso sono quasi equamente distribuiti: per ogni <code>aaaa</code> c'√® anche un <code>bbbb</code>. <em>√à un caso, √® assolutamente un caso</em>.</p>
<p><img src="images/concorrenza/image%2021.png" alt="image.png" /></p>
<p>Se io lo rilanciamo qui adesso abbiamo che ci sono due <code>aaaa</code> di fila, <code>aaaa1</code> e <code>aaaa2</code>.</p>
<p>Se lo lanciassi una terza volta vedrei ancora una cosa diversa. <em>Perch√©?</em> Perch√© ciascun thread procede secondo le sue norme.
Io sono sicuro che <code>aaaa0</code> viene scritto prima di <code>aaaa1</code>, viene scritto prima di <code>aaaa2</code>, e prima di <code>aaaa3</code>. Di questo posso essere sicurissimo. Del fatto che <code>aaaa1</code> venga scritto prima di <code>bbbb1</code> non lo so minimamente. Non lo posso neanche sapere perch√© non c'√® nessun modo di comunicare tra i due. E quindi viene come viene.</p>
<blockquote>
<p>üí° <strong>Nota</strong></p>
<p>Con l‚Äôistruzione <code>thread::sleep(Duration::from_nanos(1))</code> chiedo al sistema operativo di togliermi dallo <em>scheduler</em> e di rimettermi tra un nanosecondo. Il sistema operativo <strong>non</strong> mi rimetter√† tra un nanosecondo perch√© non fa neanche in tempo: cio√® gi√† solo per togliermi dalla CPU se ne mangia 50 di nanosecondi.</p>
<p>Non appena ha finito di togliermi dalla CPU, si accorge che 1ns ormai √® scaduto e mi rimette dentro. Ma l'effetto netto √® che mi ha tolto la CPU. Se avessimo messo un tempo pi√π lungo, sarebbe stato troppo, e l'altro thread nel frattempo avrebbe avuto il tempo di finire tutto.</p>
</blockquote>
<p>Quindi di base <strong>lo svolgimento dei singoli thread √® indipendente uno dall'altro</strong>.</p>
<p>Adesso proviamo un‚Äôaltra cosa, la facciamo in C++.
La facciamo in C++ perch√© non posso farla in Rust, perch√© Rust per via delle sue regole del Borrow Checker mi impedirebbe di fare certe cose.
E meno male che mi impedisce, perch√© adesso vediamo una cosa che non ci aspetteremmo.</p>
<p><img src="images/concorrenza/image%2022.png" alt="image.png" /></p>
<p>Cos√¨ come in Rust, creare un thread √® banale anche in C++.
In Rust esiste <code>thread::spawn</code> e in C++ creiamo l'oggetto della classe <code>std::thread</code>.</p>
<p>Dichiariamo <code>int i = 0</code>, una variabile. Adesso creo due thread che hanno il compito di incrementarmi questa variabile.</p>
<p>E quindi scrivo <code>thread t1 std::thread</code> e qui dentro, proprio come avrei fatto in Rust, gli devo passare la <strong>chiusura</strong> che dice cosa deve fare. Questa chiusura opera su <code>i</code>, che viene catturata e fa questa computazione: <code>for(_n=0; _n &lt; 10.000.000; _n++)</code> ‚Äî per 10 milioni di volte incrementiamo <code>i</code> con <code>i++</code>.
Quindi quando questa attivit√† parte lui comincia a farmi salire <code>i</code>, che cresce continuamente. E questo √® il primo thread, <code>t1</code>.</p>
<p>Poi facciamo un altro thread, <code>std::thread t2</code> e lo facciamo uguale. Anche lui cattura <code>i</code>, in modo tale che mi possa modificarla.</p>
<p>Abbiamo quindi avviato due thread, tutti fanno salire <code>i</code>.
Poi aspettiamo che finiscano, esattamente come facevamo prima e quindi scriviamo <code>t1.join()</code>, <code>t2.join()</code>.
Vediamo che le primitive Rust e C++ si assomigliano, cambia un po' il nome delle classi, ma concettualmente fanno lo stesso mestiere.</p>
<p>A questo punto stampiamo <code>i</code>.</p>
<p><em>Quanto vale</em> <code>i</code><em>?</em></p>
<p><img src="images/concorrenza/image%2023.png" alt="image.png" /></p>
<p>Dovrebbe valere 20 milioni, se le cose funzionassero correttamente.
E invece vediamo che vale <code>10.647.429</code>.
Se rilanciamo, dar√† un altro valore, sempre inferiore a 20 milioni, comunque.</p>
<p><img src="images/concorrenza/image%2024.png" alt="image.png" /></p>
<p>Allora proviamo a cambiare il codice: prima di incrementare <code>n</code>, facciamo <code>int v1 = i</code>, e dopo aver incrementato facciamo <code>int v2 = i</code>, cio√® prendiamo quanto vale <code>i</code> prima e dopo aver incrementato.</p>
<p>Quindi, fotografiamo <code>i</code> prima dell'incremento, e fotografiamo <code>i</code> dopo l'incremento.
Poi, se <code>v2</code> √® diverso da <code>v1+1</code> (e noi ci aspetteremmo che <code>v2</code> e <code>v1+1</code> siano uguali, se le cose funzionassero correttamente), stampiamo il delta, cio√® <em>quanto differiscono</em>.</p>
<p><strong>Ora, il fatto che ci siano delle differenze pu√≤ anche starci</strong>, perch√© io guardo <code>i</code> adesso, poi la incremento, ma mentre io incremento, incrementa anche l'altro. Per cui √® abbastanza ovvio che ogni tanto il delta sia pi√π grande di uno.</p>
<p>Vediamo cosa viene fuori eseguendo il codice.</p>
<p><img src="images/concorrenza/image%2025.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2026.png" alt="image.png" /></p>
<p>In alcuni casi √® un delta piccolo, come <em>6</em>, in alcuni casi √® un delta grosso, come <em>18 mila</em>. Notiamo che ce n‚Äô√® anche uno negativo, <em>-1</em>.
<strong>Come √® possibile che torni indietro visto che tutti e due facciamo pi√π uno?</strong></p>
<p><strong>Cio√®, che vediamo dei delta positivi, ci sta,</strong> perch√© io magari l'ho fotografato, poi mi sono addormentato, l'altro nel frattempo √® andato avanti, e poi ho incrementato anch'io. E quindi vedo dei delta anche grandi, <em>10 mila, 15 mila</em>, ha senso. Siccome io mi addormento in tempi che non so quali sono, mentre io dormo lui va avanti, e quando mi risveglio vedo dei cambiamenti molto grossi. <strong>√à normale che sia cos√¨</strong>. A volte il cambiamento √® molto piccolo perch√© non mi sono addormentato, semplicemente abbiamo fatto insieme un incremento e quindi √® andata cos√¨.</p>
<p><em>Ma perch√© vedo -1? Non c'√® nulla che abbassa.</em></p>
<p><strong>Questo vi fa toccare con mano che non √® cos√¨ banale.</strong> Notate che se io spengo il secondo thread, cio√® ne lancio uno solo, il risultato √® esattamente 10 milioni e il delta √® sempre 1.
Quindi, questa cosa si verifica come conseguenza del fatto che ci sono due thread che lavorano sulla stessa variabile. Perch√© se io facessi due thread, e uno mi incrementa <code>i</code>, e l'altro mi incrementa <code>j</code>, nessun problema.</p>
<p><em>Il fatto che io abbia due thread che lavorano sulla stessa variabile mi spacca delle cose</em> e non viene la somma che mi aspetto.
Gi√† questo √® un problema, perch√© ciascuno cicla esattamente 10 milioni di volte. Se io li eseguo separatamente vedo che fa 10 milioni, quindi il codice del singolo thread √® giusto. Insieme invece si impicciano. E soprattutto succede una cosa che non ci spieghiamo: questo numero torna indietro. Quindi quando si programma con i thread le cose sono meno ovvie‚Ä¶</p>
<p>Allora, cosa succede? Il problema √® l‚Äôistruzione <code>++</code><strong>.</strong>
Nella nostra testa questa √® un'operazione atomica, perch√© lavorando in modo sequenziale noi la variabile <code>i</code> non abbiamo modo di vederla mentre cambia ‚Äî per noi l'operazione <code>++</code> prende 27 e restituisce 28. Finita l√¨.</p>
<p><em>Ma in realt√† quel</em> <code>++</code> <em>come √® fatto, se andiamo a guardare l'assembler del processore?</em>, quella cosa l√¨ √® fatta di tre istruzioni assembler:</p>
<ol>
<li>Muovo il dato dall'indirizzo dove sta al registro AX</li>
<li>Nel registro AX faccio increment</li>
<li>Muovo dal registro AX il valore incrementato di nuovo nella memoria ****</li>
</ol>
<p><strong>Sono tre istruzioni assembler.</strong> La campanella che mi dice <em>"Tocca a un altro"</em> quando pu√≤ scattare? <em>In qualunque momento. Anche in mezzo a queste tre istruzioni.</em></p>
<p>Ora potrebbe succedere questo: che io ho fotografato AX, quello che era, valeva 25. Perfetto. Poi me lo porto dentro l'accumulatore. Continua a valere 25. Lo incremento, diventa 26. Sto per scriverlo. <strong>Sto per scriverlo e qui vengo sospeso.</strong> Non l'ho ancora scritto, quindi ho 26 nell'accumulatore e ce l'ho l√¨, perch√© non tocca pi√π a me. Se fossi da solo non c'√® nessun problema, quando mi risveglio scrivo 26. Ma mentre io sono sospeso e ho questo 26 da scrivere, l'altro sta andando avanti. <em>E che cosa fa?</em> Parte da 25, e incrementa. Magari per pi√π tempo, magari fino a 30. Io a questo punto riparto e scrivo 26. <em><strong>Da 30 sono tornato indietro.</strong></em>
L'altro va a vedere, dice "quanto √®?" Da 29 ero passato a 30. Io nel frattempo mi sono svegliato, ho messo il 26, lui rilegge e vede che da 30 √® tornato a 26. <strong>Delta meno 4.</strong></p>
<p><strong>Questa cosa qua non √® ovvia</strong>. Uno non ci pensa di per s√©, ma succede questo. E l'effetto netto di questo tornare indietro √® legato al fatto che il risultato, nell‚Äôesempio di prima, non fa 20 milioni come mi aspetto, fa molto di meno. <em>Proprio perch√© ci sono tutti questi meno che capitano</em>. <strong>Quell'operazione <code>++,</code> che nella nostra mente era un'operazione atomica</strong> ‚Äî perch√© per quello che potevamo osservare il comportamento di un programma in un contesto single threaded √® atomica ‚Äî <em>non √® invece atomica</em>.</p>
<p><em>Ora, questa cosa come si risolve?</em> Ha due soluzioni.</p>
<p><img src="images/concorrenza/image%2027.png" alt="image.png" /></p>
<p><strong>La prima soluzione</strong> √® legata al fatto che sia in Rust che in C++ ci sono alcuni tipi, che sono i <em>tipi atomici</em>.
Ad esempio, quella <code>i</code> da <code>int</code> la faccio diventare un <code>std::atomic&lt;int&gt;</code>.
I tipi atomici sono dei tipi che il compilatore conosce e trasforma le operazioni di <code>++</code>, che da semplici meccanismi <em>‚Äúprendo il dato, lo incremento, lo riscrivo‚Äù</em>, vengono trasformate usando le memory barrier o le memory fence, a seconda del processore in cui sono, e incrementa in modo atomico.</p>
<p>Quindi a questo punto l‚Äôistruzione <code>i++</code> deve diventare un <code>i.fetch_add(1)</code>.</p>
<p><img src="images/concorrenza/image%2028.png" alt="image.png" /></p>
<p>Eseguendo, notiamo che ora il risultato √® corretto.
Ho ancora dei delta, ma sono tutti positivi e in ogni caso il mio risultato fa esattamente 20 milioni.
<strong>Quei delta sono delta sani,</strong> dovuti al fatto che io ho fotografato prima, ho incrementato, ho fotografato dopo e mentre io incrementavo anche l'altro ha incrementato, ma l'incremento √® avvenuto senza problemi.</p>
<p><strong>Che cosa fa</strong> <code>i.fetch_add(1)</code> <strong>?</strong>
Al tempo stesso mi recupera il valore e gli somma in modo atomico, in <strong>un'unica operazione non osservabile dagli altri</strong>.</p>
<p><em>Come succede questo?</em> Dipende dal processore.
Sugli x86 multi-core andando a settare un bit che c'√® dentro, e mentre quest'operazione si svolge inibisce gli altri core. √à un‚Äôoperazione che chiaramente mi fa andare globalmente pi√π piano, ma mi fa procedere correttamente. ARM ha altri meccanismi legati a come √® fatta l'architettura, ma a noi interessa sapere che il linguaggio ci offre un‚Äôastrazione pulita con la quale gestiamo questi meccanismi.</p>
<p><strong>Peccato che questo va bene</strong> per fare il <code>++</code> o il <code>--</code>, perch√© potrei fare <code>fetch_sub</code> e togliergli uno. Posso anche fare <code>fetch_add(2)</code> perch√© non mi fa solo il <code>++</code>, mi fa il pi√π uguale due, <em>ma √® limitato a queste cose</em>.</p>
<p>Se io avessi una lista, ad esempio, e volessi inserire degli elementi, inserire degli elementi √® un'operazione complicatissima che non √® fatta di un'unica operazione, devo farne varie perch√© devo staccare il primo, infilare il secondo, collegare i puntatori, etc‚Ä¶ sono tante operazioni da fare per tenere in piedi una lista. <strong>Non posso usare questo tipo di astrazione</strong> perch√© non c'√® un'istruzione singola che il processore mi offre per fare questo tipo di operazioni.</p>
<p>Se io invece di fare <code>++</code> facessi un‚Äôoperazione di inserimento in un vettore, questa operazione pu√≤ comportare tante cose: ad esempio magari esaurisco la capacity del vettore e quindi devo anche riallocarlo prima di inserire il nuovo elemento, e <em>mentre rialloco tutto deve essere fermo</em>.</p>
<p><strong>Questo approccio non andrebbe pi√π bene</strong> e allora sia Rust che C++ mi offrono un‚Äôastrazione che si chiama <code>mutex</code>.</p>
<p>Questo esempio abbiamo dovuto vederlo in C++ perch√© Rust, grazie alle regole del <em>borrow checker</em>, questo programma non me lo fa scrivere.</p>
<p><em><strong>Perch√© non me lo fa scrivere?</strong></em>
Perch√© io ho dovuto prendere come riferimento <code>i</code>, mutabile di fatto, ma il C++ non mi distingue i riferimenti mutabili da quelli immutabili. Mi da genericamente un riferimento. Ho dovuto prendere <code>i</code> come riferimento doppio e i due thread, tutti e due, potevano scriverci sopra insieme.</p>
<p><strong>Rust questo non me lo fa scrivere</strong> perch√© se io prendessi <code>ref mut</code> per uno, non lo posso prendere per l'altro. <em>E questo √® sano, √® sanissimo.</em> Perch√© vi sta segnalando che se voi state cercando di fare questa cosa qua, sbagliate. <strong>Sbagliate e non sapete neanche di sbagliare.</strong> Lui per√≤ lo sa fortunatamente, e ce lo impedisce!</p>
<p>Per questo si dice che Rust √® <strong>"fearless concurrency"</strong>, √® la ‚Äú<em>concorrenza senza paura‚Äù</em>.
<em>Perch√©?</em> Perch√© ha delle ringhiere belle e robuste che ti tengono in linea. <strong>Per√≤ bisogna capirlo perch√© non ci fa fare certe cose</strong>, altrimenti non ne vieniamo fuori.</p>
<p><img src="images/concorrenza/image%2029.png" alt="image.png" /></p>
<p><strong>Il programma che abbiamo visto ci mostra un esempio concreto di un fenomeno molto ampio che prende il nome di interferenza.</strong> Si crea tutte quelle volte in cui due o pi√π thread fanno accesso allo stesso dato, modificandolo.</p>
<p>Il problema di fondo, in questo caso, nasceva dal fatto che avevamo una <em>variabile condivisa</em>, nell'esempio in slide si chiama "a", noi la chiamavamo "i", ma fa lo stesso, a cui due thread insieme accedevano, in questo caso facendo un'operazione di tipo ‚Äú<strong>read, modify, write‚Äù</strong>, perch√© <code>a++</code> richiede leggere il vecchio valore, modificarlo, riscriverlo.</p>
<p>Nella nostra esperienza normale, da programmatori sequenziali, <code>++</code> √® un'operazione atomica, perch√© non possiamo osservarla durante lo svolgimento. Non abbiamo modo di percepire cosa capita l√¨ in mezzo. <strong>Ma se ci sono due thread</strong>, il secondo thread pu√≤ vedere la variabile ancora nello stato originale mentre la modifica √® in corso e di conseguenza ne possono nascere delle cose imprevedibili.</p>
<p><strong>L'effetto dell'interferenza</strong> √® che all'interno del programma sono presenti malfunzionamenti casuali. Noi lo percepivamo dal fatto che il risultato invece di fare 20 milioni faceva un numero inferiore, e soprattutto ogni volta un numero diverso. E non eravamo minimamente in grado di predire che numero sarebbe venuto. <em>E' un problema.</em></p>
<h2 id="17-sincronizzazione"><a class="header" href="#17-sincronizzazione">1.7 Sincronizzazione</a></h2>
<p><img src="images/concorrenza/image%2030.png" alt="image.png" /></p>
<p>Se due thread cercano di accedere in lettura a una stessa variabile, cio√® se tutte e due leggono soltanto e nessuno la scrive, non c'√® problema. Se la variabile √® <em>read only</em> si pu√≤ accedere anche in 50 ‚Äî una variabile immutabile non d√† problema. <strong>Il problema √® se qualcuno la cambia mentre qualcuno la scrive.</strong></p>
<p><em>Quando questo succede si verifica una cosa che si chiama <strong>corsa critica</strong> o <strong>race</strong> in inglese.</em> E' una situazione dove una serie di condizioni che non sono controllabili da noi come programmatori:</p>
<ul>
<li>la presenza della cache con n livelli</li>
<li>il fatto che il compilatore utilizzi o meno delle tecniche di ottimizzazione</li>
<li>il fatto che il processore possa eseguire il riordinamento delle istruzioni al suo interno per scegliere delle cose</li>
<li>la presenza della branch prediction che faccia qualche magia che √® fuori dal nostro controllo</li>
</ul>
<p>il risultato √® che <strong>a volte le cose vanno bene, a volte le cose vanno male</strong>. E quindi il dato che noi andiamo a leggere all'interno della variabile, in presenza di una scrittura che avviene in contemporanea, potrebbe essere:</p>
<ul>
<li>il valore che c'era originariamente prima che la scrittura avvenisse</li>
<li>il valore successivo alla scrittura <em>(e saremmo anche contenti)</em></li>
<li>una terza cosa che non c'entra un bel niente, ma che potrebbe venire fuori</li>
</ul>
<p><strong>Tutte le volte in cui ci troviamo in una situazione in cui abbiamo bisogno di leggere qualcosa che √® scritta da un altro, √® necessario che mettiamo in piedi una serie di vincoli:</strong></p>
<ol>
<li>Io devo leggere un dato che devo considerare buono, di conseguenza bisogna che prima svuoti la mia cache, perch√© se io avessi un dato obsoleto nella mia cache non andrebbe bene, leggerei il dato vecchio e non leggo la versione pi√π recente che c'√® da un'altra parte.</li>
<li><em>Deve avvenire solo quando sono certo che nessun altro lo stia scrivendo</em>, perch√© se lo leggo mentre viene scritto, potrei vedere dati corrotti. Questo √® particolarmente rischioso con dati multi-word, cio√® pi√π grandi della dimensione massima che il computer pu√≤ gestire in un'unica operazione atomica.
Ad esempio potremmo avere un vector che √® grande 8, 16, 24 byte e mentre leggo il mio vector magari sto prendendo i primi 8 byte che posso prendere con un'operazione singola, mentre gli altri vengono cambiati, e quindi leggo una cosa che non √® pi√π buona.</li>
<li>Se sto leggendo e sto aspettando che mi arrivi un qualche risultato, <em>devo evitare di fare del polling</em>, perch√© se mi metto a fare del polling √® un disastro. <em>Mando la CPU al 100%, scarico la batteria in un istante e non combino niente di buono.</em> Quindi io devo proteggermi da queste situazioni.</li>
</ol>
<p><strong>Alcune di queste condizioni</strong> nascono dal fatto che i processori, che sanno di essere soggetti a questi problemi, includono nel proprio set di istruzioni alcune istruzioni particolari che servono proprio a garantire certe cose ‚Äî motivo per cui l'x86 ha i <em>fence</em> e l'ARM ha i <em>barrier</em>.</p>
<p><strong>Altre condizioni</strong> invece non sono garantibili dal processore in quanto tale, ma richiedono il fatto che il sistema operativo, che sa tutto quello che sta capitando sulla macchina, si faccia lui garante. Ed √® il motivo per cui i meccanismi di protezione che noi andiamo a mettere, come ad esempio i meccanismi basati sui <em>mutex</em>, sono possibili solo perch√© <strong>i mutex sono implementati dentro il sistema operativo</strong>.
<strong>Se non fosse il sistema operativo a darceli</strong> non potremmo costruire questa astrazione a livello puramente applicativo. C'√® bisogno di avere qualcuno che vigili al di sopra del resto.</p>
<p>Di conseguenza come avviene veramente la sincronizzazione e che caratteristiche ha, dipende dalla coppia <em>processore/<em>s</em>istema operativo</em>. Il primo ha le sue istruzioni specifiche, il secondo ha le sue astrazioni per esporre tali istruzioni. Per esempio, <strong>Linux su x86 √® diverso da Windows su x86</strong>. Poi si sforzano di darmi comunque degli astrazioni analoghe, ma sono diverse.</p>
<p>Per questo motivo i <strong>linguaggi di pi√π alto livello</strong> fanno un grosso sforzo di normalizzare questa distinzione. Il primo grosso intervento fu fatto nel 2011 con l'introduzione del <em>C++ 2011</em>, che ha avuto un suo fratello che √® il <em>C 2011</em>. In entrambi √® stata l‚Äôintroduzione l‚Äôastrazione dei thread, solo che nel C++ √® stata introdotta l‚Äôastrazione dei thread e anche dei mutex e anche degli atomics e anche delle condition variable. Nel C invece √® finito tutto l√¨, cio√® √® stata introdotta solo l‚Äôastrazione dei thread, che mi permette di distinguere tra un thread e l'altro, ma poi non ha avuto conseguenze. Quindi quando scrivo in C devo comunque, in buona misura, andare a mettere le mani sulla specifica API del sistema operativo, sulle system call che il sistema operativo mi offre. <strong>In C++ √® un po' meglio, in Rust ancora meglio.</strong></p>
<h3 id="171-strutture-native-di-sincronizzazione"><a class="header" href="#171-strutture-native-di-sincronizzazione">1.7.1 Strutture native di sincronizzazione</a></h3>
<p><img src="images/concorrenza/image%2031.png" alt="image.png" /></p>
<p><em><strong>Quali sono le strutture che ho a disposizione?</strong></em>
Allora, ci sono alcune strutture che esistono e sono usabili solo nel contesto del singolo processo e quindi sono supportate di fatto dal sistema operativo, ma la loro applicabilit√† √® strettamente limitata a thread che operano nello stesso processo.</p>
<p>Nel caso di <strong>Windows</strong> le astrazioni che ho sono quelle di C<em>riticalSection</em>, di <em>SRWLock</em> e di C<em>onditionVariable</em>.
Nel caso di <strong>Linux</strong>, da questo punto di vista, sono quelle del <em>pthread_mutex</em> e <em>pthread_cond</em>, che grossomodo coincidono con CriticalSection e ConditionVariable. Queste sono le estrazioni offerte a livello utente nel contesto del singolo processo (pi√π thread che lavorano all‚Äôinterno dello stesso processo).</p>
<p><strong>Ci sono per√≤ alcune situazioni</strong> in cui io ho bisogno di governare e sincronizzare due thread che appartengono a processi completamente distinti, perch√© potrebbero pestarsi i piedi. Ad esempio, io potrei avere un thread che scrive in un file e lo fa nel contesto del proprio processo e un altro thread che vive in un processo totalmente diverso che legge da quel file. In quel caso l√¨, le estrazioni citate sopra non mi sarebbero di nessun aiuto, perch√© non avrebbero visibilit√† reciproca.</p>
<p><strong>Esistono per√≤ degli oggetti kernel,</strong> e sono molto diversi dalle varie parti proprio come concezione, che mi danno un po' di aiuto. Allora, <strong>Windows</strong> mi mette a disposizione:</p>
<ul>
<li>i <em>mutex</em>, che assomigliano un po' a quelli che vedremo</li>
<li>gli <em>oggetti event</em>, che sono lontanissimamente parenti delle condition variable</li>
<li>i <em>semaphore</em>, quelli che contano</li>
<li>strutture per comunicare e sincronizzare: <em>pipe</em> e <em>mail slot</em></li>
</ul>
<p>Al contrario, nel mondo <strong>Linux,</strong> in questo caso specifico, abbiamo:</p>
<ul>
<li>i <em>semaphore</em></li>
<li><em>pipe</em> come modo di inter-process communication</li>
<li>i <em>segnali</em>, che in Windows non hanno nessuna corrispondenza</li>
<li>i <em>futex</em>, future extension, per una sincronizzazione pi√π lasca</li>
</ul>
<p>Sono astrazioni molto diverse tra di loro, su cui in qualche modo dobbiamo fare leva nel caso in cui abbiamo necessit√† di sincronizzare tra processi differenti.</p>
<p><img src="images/concorrenza/image%2032.png" alt="image.png" /></p>
<p><strong>Quello che noi dobbiamo fare nello scrivere un programma concorrente</strong> √® sostanzialmente un'estensione di quello che Rust fa per noi con i puntatori. Il borrow checker con i puntatori dimostra logicamente che il programma non √® sbagliato. <em>Non riesce a dimostrare che √® giusto, ma dimostra che non √® sbagliato</em>, ovvero che non facciamo nessuna <strong>azione illecita</strong>.</p>
<p>Noi sappiamo che questo in alcuni casi √® restrittivo, cio√® ci sono azioni che sarebbero lecite e che per√≤ il borrow checker non riesce a dimostrare. <strong>Ma siamo tranquilli che se il borrow checker ci fa passare</strong>, dal punto di vista dei puntatori e del possesso della memoria, non c'√® nessun problema.</p>
<p>Noi dobbiamo estendere a mano, col nostro cervello, questa operazione sui programmi concorrenti, <strong>garantendo che il programma concorrente che noi scriviamo √® corretto</strong>. Ovvero che non capita mai che un thread modifica un dato mentre un altro lo sta leggendo. <em>O mentre lo sta scrivendo, ancora peggio.</em></p>
<p><strong>In particolare dobbiamo essere concentrati sugli stati transitori.</strong> Pensate a un <code>Vec</code>. Dobbiamo fare un'operazione apparentemente banale, <code>push</code> nel vector.
<em>Cosa fa push nel vector?</em> Beh, fa una serie di operazioni assembler. Va a vedere se c'√® della capacity residua. Se c'√® della capacity residua va a posizionarsi al fondo del size, nel buffer che √® gi√† allocato, ci copia il dato e incrementa il size. <em>Ci sono una serie di passi intermedi in cui l'oggetto vector √® temporaneamente in uno stato sbagliato</em> ‚Äî io ho gi√† riempito un pezzo del buffer ma non ho ancora incrementato il contatore. Potrei anche fare il contrario, potrei incrementare subito il contatore per occuparmi poi dello spazio ma in quel caso l√¨ vorrebbe dire che il valore che c'√® scritto l√¨ dentro √® sbagliato. Non √® ancora scritto. <strong>Quindi qualunque scelta io faccia delle tante possibili mi ritrovo in un momento in cui il dato √® solo parzialmente modificato.</strong></p>
<p>Nei programmi puramente sequenziali questo <strong>non √® un problema</strong> perch√© √® tutto annegato nell'operazione <code>push</code>, e quindi io vedo lo stato prima di <code>push</code> e poi lo stato dopo <code>push</code>. <em>Tutto pulito</em>. Ma se io ho un programma concorrente che conosce l'indirizzo di quel vector, siccome non sa che cosa ci sto facendo col vector, potrebbe andarci a guardare dentro mentre io lo sto cambiando. E se ci va a guardare dentro mentre io lo sto cambiando potrebbe sbagliarsi, cio√® <strong>potrebbe credere a quello che legge, che non rappresenta uno stato definitivo</strong>.</p>
<p><strong>Quindi io devo proteggermi da queste situazioni</strong>. In generale questo vale per tutti gli oggetti <em>condivisi</em> <em>e</em> <em>mutabili</em>. Se io avessi solo oggetti immutabili tutto sarebbe tranquillo. Quell'oggetto l√¨ ha un valore, fine, e non pu√≤ cambiare. √à il motivo per cui <em>Borrow Checker</em> ci lascia prendere in lettura quante copie vogliamo, non si preoccupa mica, ma <strong>impone che come <code>ref mut</code> ce ne pu√≤ essere uno solo per volta,</strong> perch√© se ce ne fosse pi√π di uno si potrebbe incorrere in errori. Potremmo prendere delle cose fasulle.</p>
<p>Quindi la difficolt√† √® arricchire il nostro algoritmo, che avremmo pensato in modalit√† puramente sequenziale, di alcuni <em>rinforzi</em> che nei punti in cui serve, e solo in quelli (ovvero <strong>nei punti dove c'√® potenziale interferenza</strong>), vanno a costruirci uno schermo che impedisce che succedano cose brutte.</p>
<p>Di conseguenza, spesso e volentieri, usiamo un approccio "<strong>object oriented</strong>", ovvero diciamo <em>‚ÄúIo ho un dato che √® condiviso, come lo proteggo questo dato condiviso?‚Äù</em>
Beh, intanto lo incapsulo in una <em>struct</em> innanzitutto.
Questa struct la rendo <strong>privata</strong> in modo tale che nessuno possa direttamente metterci le mani dentro, e offro dei <strong>metodi</strong> che mi danno la possibilit√† di cambiarla.
Questi metodi si occupano, proprio perch√© sono quelli che mi garantiscono il cambio dell'evoluzione del suo stato, di prendere le precauzioni necessarie a far s√¨ che non capitino cose che non voglio.</p>
<p>Ad esempio, abbiamo visto nel conteggio prima che io ho dovuto trasformare quello che era un semplice intero in un <em><strong>atomic int</strong></em> e ho dovuto cambiare il modo in cui incrementavo. Prima facevo <code>++</code>, dopo ho dovuto dire <code>fetch_add</code>, in modo da garantirmi che quell'operazione l√¨ avvenisse in modo pulito. In altri casi io annego i miei dati in una struct e in questa struct ci metto non solo i miei dati ma anche altre cose, ad esempio gli oggetti tipo <em>mutex</em>, che mi proteggono da determinate cose, e che vado ad usare nel modo giusto, quando mi occorrono.</p>
<p>Quindi usiamo l'approccio object oriented con i metodi che <strong>incapsulano</strong> per garantire che l'accesso avviene sia in lettura che in scrittura, coerentemente con le regole che ci diamo.</p>
<h2 id="18-correttezza"><a class="header" href="#18-correttezza">1.8 Correttezza</a></h2>
<p><img src="images/concorrenza/image%2033.png" alt="image.png" /></p>
<p>Notate che in quasi tutti i linguaggi di programmazione tocca al programmatore scegliere <em>come</em>, <em>dove</em> e <em>quando</em> usare la sincronizzazione. <strong>√à l√¨ la vostra abilit√†</strong>.</p>
<p>Se non la usate correttamente il risultato √® un disastro. Avrete dei programmi che a volte vanno, a volte non vanno, a volte si impiantano e cose del genere.</p>
<p>L'unico modo per affrontare questo problema √®, come dicevamo, seguire l'approccio del borrow checker: dimostrare formalmente la correttezza dell'algoritmo. Dovete sviluppare un ragionamento del tipo <em>"Pu√≤ succedere questo? S√¨. Allora non va bene".</em> Oppure, <em>"Pu√≤ succedere questo? No. Perch√© non pu√≤ succedere? Dimostriamo il teorema."</em> La dimostrazione si basa sugli invarianti forniti da strutture pi√π semplici come mutex e condition variables, che ci garantiscono che certi eventi non possono verificarsi. Partendo da queste garanzie di basso livello, costruiamo la dimostrazione che anche ad alto livello il nostro programma mantiene la sua correttezza.</p>
<p>Per√≤ questo richiede che ci mettiamo l√¨ e facciamo la dimostrazione, proprio come dimostreremo il teorema di Pitagora, con una sequenza di passaggi logici che devono essere corretti, senza farci degli sconti.
Se il programma non √® corretto √® inutile pensare di ottimizzarlo, di farci delle cose sopra o anche solo di farci dei test.</p>
<p><strong>L'eventuale test che mettete in un programma concorrente non dimostra niente.</strong> Perch√© abbiamo visto che lanciando pi√π volte lo stesso identico programma, se il programma √® scritto male, possono venire fuori risultati ogni volta diversi. E quindi il fatto che voi avete lanciato un test ed √® andato bene <em>non vuol dire nulla</em>. Potrebbe essere stato un puro caso. <strong>Bisogna che il programma sia giusto alla fonte.</strong></p>
<p>Da questo punto di vista <em>programmare in Rust √® salutare</em> perch√© grazie al borrow checker una grande parte di possibili errori non possono essere costruiti perch√© non potete neanche compilarlo il programma. <strong>Il fatto che il borrow checker vi garantisca l'accesso in scrittura uno solo per volta √® un grande toccasana.</strong> Ma non basta. Ci sono situazioni in cui dovete aggiungere del vostro.</p>
<p><strong>Allora i problemi fondamentali</strong> li abbiamo gi√† citati. Sono quelli di <em>atomicit√†</em>. Abbiamo visto che il <code>++</code>, che sembra atomico, <strong>non lo √®</strong>. Ma <em>non sono atomiche una montagna di operazioni</em>. <code>push</code> di un vettore non √® atomico. Meno ancora se mai quel vettore dovesse riallocare. E quindi di base se due thread fanno accesso alla stessa struttura dati o un vector, e io leggo e tu scrivi o cose del genere, <strong>non sono in grado di capire chi sta facendo che cosa</strong>. Perch√© ho due thread che ognuno per i fatti suoi conosce quella roba l√¨ e cerca di modificarla o di leggerla in qualche modo. Ma non rendendosi conto che anche l'altro fa cose, faremmo disastri.</p>
<h2 id="19-accesso-condiviso"><a class="header" href="#19-accesso-condiviso">1.9 Accesso condiviso</a></h2>
<p><img src="images/concorrenza/image%2034.png" alt="image.png" /></p>
<p><strong>Atomicit√† e Visibilit√†.</strong>
<em>Quando una variabile che io ho modificato pu√≤ essere osservata da un altro?</em>
In generale questo richiede che io svuoti le cache. Se io non svuoto le cache, la modifica c'√® certamente nella mia cache, ma <em>non √® detto che sia stata propagata al resto del sistema</em>. E quindi il resto del sistema potrebbe ignorarlo.</p>
<p><strong>Ordinamento.</strong>
<em>Sotto quali condizioni una sequenza di operazioni fatte da un thread √® visibile <strong>nello stesso ordine da un altro?</strong></em>
In particolare, se io prima faccio A e poi B, il fatto che un altro veda B implica anche che vedr√† sicuramente A? <em>La risposta √® in generale no</em>. A meno che io non prenda delle misure per garantirlo.
Il fatto che non lo veda nasce dal fatto che ci possono essere tempi di propagazione diversi attraverso la cache, ci possono essere riordinamenti fatti all'interno del processore che usando ottimizzazioni (come la <code>branch prediction</code>) potrebbe decidere di fare una cosa prima di un'altra, e ci sono ottimizzazioni che pu√≤ fare il compilatore. E noi dobbiamo capire bene come forziamo ciascuno di questi tre layers a non fare quello che non vogliamo.</p>
<p><img src="images/concorrenza/image%2035.png" alt="image.png" /></p>
<p><strong>Allora, abbiamo tre pezzi da imparare sostanzialmente.</strong></p>
<p>Gli <em><strong>oggetti Atomic</strong></em>.
Ne abbiamo accennato l'uso in C++. In Rust sono la stessa cosa sostanzialmente. Sono oggetti che incapsulano dei dati elementari. Quindi io posso fare l'atomic di un numero sostanzialmente, tuttalpi√π di un puntatore. Ma <em>attenzione</em>, quello che rendo atomico √® l'aggiornamento del puntatore, <strong>non del dato puntato</strong>. Il dato puntato resta per i fatti suoi quello che sia. Quindi io posso garantire che questo puntatore l'ho cambiato di certo. Niente di pi√π di quello. Poi il dato puntato √® un'altra faccenda.</p>
<p><strong>Gli atomic</strong> vanno bene con dei dati banali: booleani, interi (di vario tipo, byte, long, short), e puntatori ‚Äî che di fatto sono poi degli interi pure loro. <strong>L'oggetto atomic</strong> mi offre una serie di metodi di tipo <em><strong>‚Äúread, modify, write‚Äù</strong></em> non interrompibili.
Ovvero, con garanzia, data sostanzialmente dalla CPU, perch√© poi queste operazioni mappano su istruzioni o blocchi di istruzioni forniti dalla CPU, che non sono interrompibili. Nell'x86 c'√® il prefisso <code>Lock</code>, che viene messo davanti all'operazione atomic, che inibisce gli altri core dal funzionare. E di conseguenza mi garantisce che mentre io leggo, incremento e scrivo, gli altri sono proprio fermi. E quindi non c'√® rischio che facciano cose strane.</p>
<p>Poi abbiamo i <strong><code>Mutex</code></strong> che adesso vediamo e cerchiamo di capire nella sostanza cosa fanno. Servono a garantire accesso uno per volta a strutture dati arbitrariamente complesse. <strong>L'implementazione che Rust fa dei mutex √® particolarmente efficace</strong>. Perch√© ce li presenta sotto forma di <em>smart pointer</em>. Il <code>Mutex</code> totalmente racchiude il dato che protegge. E non c'√® modo di accedere al dato se non tramite i meccanismi che il <code>Mutex</code> stesso mi d√†.
A differenza di quello che succede in C++ o in C dove il mutex sta a fianco ai dati, non attorno ai dati. E di conseguenza io potrei comunque leggere e scrivere (sbagliando, ma lo posso fare) il dato senza passare dal mutex. <strong>Rust</strong> invece in questo mi aiuta tantissimo perch√© mi dice <em>"il dato √® parte del mutex, tu non ci entri dentro se non chiedi al mutex il permesso"</em>. E il mutex te lo d√† secondo le sue regole. E questo di nuovo ci rende la vita molto tranquilla perch√© siamo sicuri che l√¨ non possiamo sbagliare.</p>
<p><strong>Le Condition variables</strong> servono in quelle situazioni in cui abbiamo bisogno di attendere senza consumare cicli di CPU che capiti qualcosa. Le condition variables possono essere usate <em>solo insieme a un mutex</em>. Perch√© nella loro API hanno bisogno di un mutex. <strong>Non posso crearla se non insieme a un mutex</strong>. Quindi da questo punto di vista sintatticamente non c'√® rischio di sbagliare. Semanticamente tocca a me capire che cosa devo fare.</p>
<p><img src="images/concorrenza/image%2036.png" alt="image.png" /></p>
<p><em><strong>Come usiamo i thread?</strong></em>
Potremmo scrivere direttamente il codice nativo che chiama le system call di Windows, di Linux, di Mac OS o altre cose, ma in realt√† preferiamo usare i <em>linguaggi moderni di alto livello</em> che ci danno le astrazioni necessarie.</p>
<p>Nel caso di C++ si include la libreria <code>thread</code> e si creano gli oggetti di tipo <code>std::thread</code>. Nel caso di Rust si usa la libreria <code>std::thread</code> che ci offre la funzione <code>spawn</code> che ci mette in condizioni di creare un nuovo thread. Esattamente come abbiamo visto.</p>
<p>Quindi da un punto di vista prettamente sintattico <strong>creare un thread √® banalissimo</strong>. E <code>std::thread::spawn</code>, <code>spawn</code> accetta una closure che indica che cosa vogliamo che questo thread faccia.
Dal momento in cui invochiamo <code>spawn</code> pu√≤ cominciare l'esecuzione di quest'altra funzione.</p>
<p><em>Pu√≤ cominciare, ma comincia?</em>
Dipende, dipende dal sistema operativo se ha un core libero o se non ce l'ha. Sicuramente quella funzione l√¨ viene messa attraverso i costrutti necessari del kernel nell'elenco delle cose da fare da parte dello scheduler del sistema operativo. Poi che lo scheduler la faccia partire immediatamente o la faccia partire da qui a un po' √® fuori dal nostro controllo. Non lo vediamo, ma sappiamo che potr√† partire.</p>
<p><strong>Questo comincia e produce delle cose.</strong> Se la funzione ritorna un valore di tipo <code>T</code> generico potremo accedere a quel tipo <code>T</code> attraverso il metodo <code>join</code> che ci viene offerto dal valore restituito dalla funzione <code>spawn</code>. <strong>Spawn restituisce un join handle</strong>. Questo join handle ci serve quando avremo bisogno di sapere se il thread ha finito o meno. Il join handle ha un unico metodo utile che √® <code>join</code> che <em>blocca il chiamante</em> fino a che il thread a cui quella join handle corrisponde non √® terminato. E restituisce un <code>Result</code>. Questo <code>Result</code>, se √® <code>Ok&lt;T&gt;</code>, contiene quindi il valore che la funzione del thread ha effettivamente calcolato, e questo ci d√† la possibilit√† di considerare il nostro thread come un <strong>produttore di un dato</strong> ‚Äî <em>‚Äúio ti affido questo compito: creami questa informazione‚Äù</em>.
Quindi al thread 1 faccio fare questo pezzo di calcolo, al thread 2 ne faccio fare un altro, al thread 3 ne faccio fare un altro e poi aspetto che finiscano, me li prendo e li combino e li uso per qualche scopo.</p>
<p>Oppure quel <code>Result</code> che il metodo <code>join</code> di join handle mi restituisce contiene un <code>Error</code> che potrebbe essere nato dal fatto che quel thread ha <em>panicato</em>.
Se l'esecuzione di questo thread ha generato una condizione di panic, allora chi lo aspetta pu√≤ saperlo.
<strong>Questa √® una grossa differenza rispetto a come avviene in C++</strong>. In C++ se un thread lancia un'eccezione che non viene raccolta, il processo termina.
In Rust, invece, se un thread panica, quel thread l√¨ cessa di esistere, ma chi ne fa la join riceve una descrizione del panic che si √® verificato al suo interno e pu√≤ usare questa descrizione per farci qualcosa, per cercare di aggiustare delle cose.</p>
<p><em>Notate che il thread che crea e il thread creato <strong>non hanno nessuna relazione di parentela</strong></em>.
Sono indipendenti. Poi di fatto il thread che crea ha la join handle, e quindi spesso utilizza quella join handle per aspettare quell'altro. Ma <strong>non √® necessario</strong>: io potrei prendere la join handle e passarla a un thread ulteriore che si occupa di aspettare tutti. Cio√® potrei fare altre cose.</p>
<h1 id="2-thread-in-rust"><a class="header" href="#2-thread-in-rust">2. Thread in Rust</a></h1>
<p><img src="images/concorrenza/image%2037.png" alt="image.png" /></p>
<p>Quindi banalmente l'uso dei thread √® fatto cos√¨.</p>
<p><strong>Attenzione.</strong> La funzione chiamata nel thread pu√≤ essere basata solo su variabili locali, e in questo caso non c'√® problema. Ma siccome quella √® una <em>chiusura</em> potrebbe anche fare riferimento a variabili dello scopo in cui √® stata definita. Siccome per√≤ il thread esiste per un tempo indefinitamente lungo, io <strong>non posso prendere dei ref allo scope</strong>, perch√© non sono in grado di dire quando quel thread finir√†. Quindi se ho bisogno di passargli delle informazioni <em>non gliele posso passare con dei ref</em>. Ma gli devo dare possesso del dato.</p>
<p>Per questo motivo spesso e volentieri quando creiamo i thread con <code>spawn</code> li creiamo passando una chiusura che comincia con la parola chiave <code>move</code>. Vuol dire che se io l√¨ dentro prendo riferimento a qualcosa del mio scope, questo diventa <strong>propriet√† completa</strong>. E quindi il <em>Borrow Checker</em> riesce a gestirsi il calcolo del lifetime. Altrimenti non ci sarebbe modo perch√© mentre nell'esecuzione sincrona io chiamo la funzione, aspetto che ritorni, eccetera, e posso usare le relazioni note temporali per poter dire se un reference dura abbastanza o meno, i thread invece, che iniziano adesso ma che possono finire chiss√† quando, non mi danno possibilit√† di avere nessun riferimento. Per questo motivo li facciamo cos√¨. Per lo meno i thread che creiamo con la funzione <code>spawn</code>.</p>
<p><img src="images/concorrenza/image%2038.png" alt="image.png" /></p>
<p>C'√® un secondo modo di costruire i thread un pochino pi√π sofisticato che dice <em>‚Äúguarda volendo all'interno del namespace <code>std::thread</code> c'√® una struct che si chiama <code>Builder</code> che mi d√† la possibilit√† di configurare il thread prima di lanciarlo‚Äù</em>.</p>
<p>Il thread per default parte con uno stack che ha una dimensione predefinita e riceve un nome che √® assegnato dalla libreria che potrebbe non essere particolarmente utile, ma se io nel mio algoritmo sto creando un thread che mi serve da <em>garbage collector</em> potrei trovare pi√π utile chiamarlo adeguatamente <code>garbage collector</code>, cos√¨ quando mai far√≤ delle stampe di debug o qualcosa del genere lui potr√† usare il nome <code>garbage collector</code> come propria identit√† e se questo si pianta potr√≤ dire <em>"si √® verificato un panico nel garbage collector"</em>.</p>
<p>La struttura <code>Builder</code> mi d√† la possibilit√† di <strong>configurare il mio thread</strong> e quindi in questo caso creo l'oggetto <code>Builder</code>, gli assegno un nome, gli assegno la dimensione dello stack in base a quanto penso che possa aver bisogno (eventualmente dandogli di meno di quello che gli darebbe normalmente se io so che quel thread l√¨ non ha una grossa profondit√† di ricorsione) e poi quando sono contento con i suoi dati lo faccio di fatto partire, <code>builder.spawn</code>.</p>
<h2 id="31-i-tratti-della-concorrenza"><a class="header" href="#31-i-tratti-della-concorrenza">3.1 I tratti della concorrenza</a></h2>
<p><img src="images/concorrenza/image%2039.png" alt="image.png" /></p>
<p><em><strong>Che cosa permette di passare a un thread?</strong></em>
Allora un thread pu√≤ catturare e fare accesso a delle variabili a condizione che queste variabili <em>rispettino alcuni vincoli</em>.
In particolare all'interno di Rust sono definiti due tratti che sono due tratti cosiddetti <em><strong>marker</strong></em>, come <code>Copy</code>. Il tratto <code>Copy</code> non ha niente come metodo suo, √® usato soltanto come un flag per dire <em>"√® lecito fare una copia di questa cosa"</em> ovvero fare quello che faresti col movimento ma dando ancora accesso all'originale.</p>
<p>I tratti marker della concorrenza si chiamano <code>Send</code> e <code>Sync</code>.</p>
<p><strong><code>Send</code></strong> significa che √® lecito che un certo dato sia passato a un altro thread.
<em>Quindi se io creo l'oggetto thread con <code>move</code> che cosa posso muovere dentro questo thread? <em><em>Qualunque cosa che abbia il tratto</em> <code>Send</code>.</em></em></p>
<p><em>E chi ce l'ha il tratto</em> <code>Send</code><em>?</em>
Quasi tutti, tranne i reference e i pointer nativi.
<em>Perch√©?</em> Perch√© se io ti passassi un reference, tu lo potresti usare da qui in avanti, <em>ma quanto a lungo lo usi? Boh, finch√© il thread padre c‚Äô√®.</em> Non sono in grado di capire se quel reference dura a lungo abbastanza. Di conseguenza i reference non te li passo. <strong>Ti posso passare soltanto un dato di cui hai il pieno possesso.</strong></p>
<blockquote>
<p>üí° <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2040.png" alt="image.png" /></p>
</blockquote>
<p><strong>C'√® un secondo marker che ci interessa, che √® <code>Sync</code></strong>.</p>
<p><em>Chi √® che ha il tratto</em> <code>Sync</code><em>?</em>
<em>Quelli che possono essere condivisi in sicurezza tra thread differenti</em>.</p>
<p>Se qualcuno gode del tratto <code>Sync</code> fa eccezione alla regola vista prima. Ovvero il suo riferimento √® passabile. <strong>Normalmente i riferimenti non sono passabili</strong>. Ma se una cosa gode del tratto <code>Sync</code> diventa passabile come riferimento.</p>
<p><em>Chi √® che non implementa</em> <code>Sync</code><em>?</em>
<code>Cell</code> e <code>RfCell</code>, perch√© se te li passassi sarebbe un disastro.</p>
<blockquote>
<p>üí° <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2041.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2042.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/concorrenza/image%2043.png" alt="image.png" /></p>
<p>Quindi qui vediamo dei casi.</p>
<p>La maggior parte degli oggetti vivono nel cerchio pi√π interno: <strong>godono cio√® sia di <code>Send</code> che di <code>Sync</code></strong>. E quindi non c'√® un grosso problema.</p>
<p><code>&amp;str</code> pur essendo un reference, siccome √® un reference immutabile, non mi d√† fastidio, e quindi gode sia di <code>Send</code> che di <code>Sync</code>.</p>
<p>Ci sono alcune cose che sono <code>Send</code> ma non <code>Sync</code>.
Ci sono cose che non sono n√© <code>Send</code> n√© <code>Sync</code>.</p>
<p>Questo ci aiuta perch√© <strong>Rust ci impedisce di sbagliare</strong>. Anche solo grazie a questi meccanismi.</p>
<p><img src="images/concorrenza/image%2044.png" alt="image.png" /></p>
<p>Notate che possiamo di fatto creare un'istanza di thread. In questo caso vedete che facciamo <code>spawn</code> l√¨ sopra.</p>
<p><em>Cosa provo a passargli?</em> <em>Provo a passargli un oggetto di tipo <code>Rc</code>, <code>data2</code></em>, che √® un <code>Rc</code> clonato da <code>data1</code>.
Poi proviamo a stampare cosa c'√® dentro <code>data1</code>, e provo a passare <code>data2</code> al thread.
<strong>Peccato che <code>Rc</code> non gode del tratto <code>Send</code></strong>.</p>
<p><em><em><em>Perch√© non gode del tratto</em> <code>Send</code></em>?</em>**
Perch√© quando andassi a distruggerlo, lui andrebbe a decrementare il contatore, ma <em>non lo farebbe in modo atomico!</em>
E non facendolo in modo atomico, non mi darebbe garanzia che quel <code>--</code> funzioni davvero.
Cio√® potrebbe capitarmi, come capitava prima col <code>++</code>, che vengono dei numeri a caso.
Perch√© lui non potrebbe dire che quel <code>--</code> non avviene mentre in contemporanea non avviene un <code>++</code> o un altro <code>--</code>. E di conseguenza potrebbero uscirne dei numeri completamente strambi. <strong>Di conseguenza non √® lecito</strong>.</p>
<p>Se invece al posto di <code>Rc</code> scrivessi <code>Arc::new</code> otterrei un comportamento simile ma la differenza starebbe nell'operazione <code>++</code> che viene fatto sul reference count. In questo caso sarebbe fatto con un <strong>atomic</strong>. <code>Arc</code> infatti sta per <em>Atomic Reference Count</em>.
E di conseguenza sarei sicuro che quel <code>++</code> √® un po' pi√π lento, ma sono sicuro della correttezza.</p>
<p>In questo caso della slide il compilatore mi blocca e mi dice <em>"Non puoi farlo perch√© <code>data2</code>, che √® di tipo</em> <code>Rc&lt;i32&gt;</code><em>, non pu√≤ essere mandato in modo sicuro da un thread e un altro perch√© non ha il tratto</em> <code>Send</code><em>"</em>.</p>
<p><img src="images/concorrenza/image%2045.png" alt="image.png" /></p>
<p>Adesso dobbiamo imparare l'uso dei mutex.</p>
<p>La sincronizzazione in Rust pu√≤ avvenire con <strong>due ‚Äúmega‚Äù modelli</strong>:</p>
<ol>
<li><strong>Il modello a stato condiviso</strong>
Nel modello a stato condiviso abbiamo una struttura dati a cui accedono pi√π thread che √® protetta debitamente e che mi d√† garanzia che le modifiche che faccio sono coerenti.</li>
<li><strong>Il modello a scambio di messaggi</strong>
Il modello a scambio di messaggi prevede che di condiviso non c'√® niente ma abbiamo creato dei canali attraverso cui ci mandiamo a dire delle cose.</li>
</ol>
<p>Gli algoritmi che andiamo a disegnare nell'uno e nell'altro caso sono diversi.</p>
<p><em>Alcune cose sono molto pi√π facili da implementare a stato condiviso e sono complicate con i messaggi.
Altre sono molto facili da implementare con i messaggi e sono molto complicate da implementare con lo stato condiviso</em>.</p>
<p>Per contro il C++ di suo ha solo il modello a stato condiviso come standard. Poi, chiaramente, usando librerie esterne possiamo arricchirlo con i messaggi.</p>
<p><strong>Rust</strong> invece ha incluso fin dall'inizio le due possibilit√† proprio per rendere pi√π comodo alla vita il programmatore che peraltro deve per√≤ conoscere i due modelli e, messo di fronte a un problema, <em>capire se √® pi√π facile affrontarlo con lo stato condiviso o √® pi√π facile affrontarlo con i messaggi</em>.</p>
<p><img src="images/concorrenza/image%2046.png" alt="image.png" /></p>
<p>Per avere lo <strong>stato condiviso</strong> usiamo gli oggetti di tipo <code>Mutex</code>.</p>
<h1 id="3-mutex-in-rust"><a class="header" href="#3-mutex-in-rust">3. Mutex in Rust</a></h1>
<p><img src="images/concorrenza/image%2047.png" alt="image.png" /></p>
<p>Gli oggetti di tipo mutex (tralasciando la parte C++ che vedremo dopo) partono da questo assunto: <strong>l'oggetto <code>Mutex&lt;T&gt;</code> incapsula il dato <code>T</code> qualunque <code>T</code> sia</strong>.</p>
<p>Quel dato l√¨ √® annegato dentro, quindi quando creo un mutex, <code>let M = Mutex::new(vec![1,2,3,4])</code>, il mio mutex racchiude il vettore con dentro <code>1,2,3,4</code>. Ci posso mettere quel che voglio, non ha importanza, pu√≤ essere complicato a piacere.
<em>√à tutto dentro il mutex e di suo il dato √® inaccessibile</em>.</p>
<p><em>Come faccio a sapere cosa c'√® dentro il mutex?</em>
Il mutex mi offre un unico metodo utile che si chiama <code>lock</code>.
Quando ho bisogno di sapere cosa c'√® scritto dentro il mutex oppure ho bisogno di modificare quello che c'√® scritto dentro il mutex, prendo la mia variabile mutex <code>M</code> e faccio <code>M.lock</code>.</p>
<p><em><em><em>Cosa fa</em> <code>M.lock</code></em>?</em>**
<code>M.lock</code> interagendo col sistema operativo verifica: <em>c'√® gi√† qualcuno che sta facendo delle cose?</em> Se s√¨ mi blocca l√¨ ‚Äî <code>lock</code> non ritorna fino a che c'√® qualcosa in corso.</p>
<p><strong>Quando i lavori in corso finiscono</strong>, ecco che <code>M.lock</code> ritorna e <em>che cosa ritorna?</em>
Mi ritorna un oggetto che √® uno <em>smart pointer</em>, cio√® un oggetto tramite cui, se lo dereferenzio, posso accedere al dato.
Se il mio dato √® un dato elementare come un numero dovr√≤ fare <code>*</code> del mio puntatore per vederlo. Se quello √® invece un dato pi√π sofisticato come un <code>Vec</code> o cose del genere, potendo usare la notazione punto, dell'asterisco ne faccio a meno semplicemente perch√© la notazione punto mette davanti gli asterischi di cui ho bisogno, ma nella sostanza √® uno smart pointer.</p>
<p>Finch√© quello smart pointer √® in giro il mutex resta di mia propriet√†. <strong>Nessun altro ci pu√≤ far niente</strong>. Quello smart pointer se √® dichiarato di tipo <code>mut</code> io potr√≤ cambiare il dato. Se √® dichiarato di tipo non <code>mut</code> lo potr√≤ solo leggere, ma quella √® una normalissima questione di Rust dell'accesso alle varie parti.</p>
<p><em>Quando questo smart pointer che mi √® stato restituito da</em> <code>lock</code> <em>esce dai piedi</em> ‚Äî cio√® lo droppo oppure raggiunge la fine del suo scope ‚Äî quello che succede √® che se c'era qualcun altro che voleva fare accesso al mutex pu√≤ entrare, viene sbloccato. Punto, tutto qui!</p>
<p><strong>Il mutex quindi garantisce mutual exclusion. Si entra uno per volta.</strong></p>
<p>Notate che l'oggetto <code>Mutex</code> di base io lo posso conoscere come oggetto non mutabile. Mi d√† una forma di <strong>mutabilit√† interna</strong> simile a <code>RefCell</code> che per√≤ √® condivisibile tra thread sotto certe condizioni, e come? Racchiudendolo dentro un <code>Arc</code>.
Quindi il modo tipico di proteggermi quando ho bisogno di avere un dato che voglio che due thread possano <em>pasticciare</em> per i fatti loro √® <em>prendere il mio dato, metterlo in un</em> <code>Mutex</code><em>, metterlo dentro un</em> <code>Arc</code>.
Questo <code>Arc</code> lo posso dare, clonare tante volte quanto serve e darne una copia a ciascuno dei thread.</p>
<blockquote>
<p>üí° <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2048.png" alt="image.png" /></p>
</blockquote>
<p>Ciascuno di questi thread, quando ha bisogno di accedere prende il suo <code>Arc</code>, fa  <code>.lock</code> (tanto <code>Arc</code> √® uno <strong>smart pointer</strong> e automaticamente me lo dereferenzia al metodo interno, quindi vedo il <code>Mutex</code>), quindi facendo <code>.lock</code> se c'√® bisogno aspetto (ma non me ne accorgo), e quando <code>lock</code> ritorna ho un altro smart pointer che per comodit√† chiamiamo <code>L</code> per comodit√†.
Questo smart pointer mi d√† l'accesso al dato, e sono sicuro che <em>mentre esiste questo smart pointer sono l'unico che lo pu√≤ vedere</em>. Faccio tutto quello che devo, possibilmente in fretta, e poi butto via <code>L</code>, questo smart pointer. Buttandolo via d√≤ la possibilit√† ad altri che volessero entrare, di poter fare delle cose.</p>
<p><strong>Scriviamo velocemente l'esempio</strong> <strong>che abbiamo visto prima del pi√π pi√π con i thread.</strong></p>
<p><img src="images/concorrenza/image%2049.png" alt="image.png" /></p>
<p>Allora qui ho due thread li sfrutto per questo <code>let a = Arc::new(Mutex::new(0))</code>.
Quindi incapsulo all'interno del mutex un <code>i32</code>, semplicissimo.
Dopodich√® lo clono perch√® di base un <code>Arc</code> che non lo posso dare cos√¨ com'√®: lo devo clonare per poterlo cedere ai singoli thread.</p>
<p>A questo punto ho tre <code>Arc</code> che conoscono dove sta il <code>Mutex</code> che dentro di s√© racchiude il suo numero: <code>a</code>, <code>a1</code> e <code>a2</code>.</p>
<p>Creo il primo <code>thread</code> con <code>thread::spawn</code>, gli aggiungo <code>move</code>, e come lambda gli passo un for che per 10 milioni di iterazioni fa <code>let mutex l = a1.lock().unwrap();</code> (<code>unwrap</code> perch√® <code>lock</code> restituisce un <code>Result</code>, e potrebbe fallire nel caso in cui un thread che possedeva il <code>Mutex</code> fosse morto mentre lo possedeva. Questo, nel nostro esempio non pu√≤ succedere quindi possiamo fare tranquillamente <code>unwrap</code>).
<code>a1</code> punta il mio <code>Mutex</code>, che a sua volta contiene il mio numero. Qui dentro lo voglio incrementare e quindi con <code>a1.lock()</code> prova a vedere se posso prenderne possesso.
Quando riesce a prendere possesso, dentro <code>l</code> ho uno smart pointer chiamato <code>MutexGuard</code>, che mi consente di accedere al dato.
A questo punto scrivo <code>*l += 1</code>. Scrivendo questo dereferenzio <code>l</code> (che come detto √® un <code>MutexGuard</code>, quindi uno smart pointer), accedo al dato, e gli sommo 1.</p>
<p>Poi <code>l</code> arriva alla chiusa graffa, esce dallo scope, il <code>drop</code> di <code>MutexGuard</code> si occupa di rilasciare il lock, e finalmente <code>l</code> va via dai piedi.
Se c'√® qualcun altro che ha bisogno di accedere al dato, adesso pu√≤  entrare.</p>
<p>Faccio lo stesso lavoro con il thread <code>t2</code> qua sotto. Anche qui 10 milioni. Scrivo <code>let l = a2</code> stavolta e anche questo thread lo dovr√≤ fare con <code>move</code>. <code>a2.lock().unwrap()</code>.
A questo punto facciamo anche qui <code>*l += 1</code>.</p>
<p>Quando abbiamo fatto queste due operazioni possiamo fare il <code>join</code> e possiamo fare un <code>println!</code> di <code>a.lock().unwrap()</code>.</p>
<p>A questo punto se eseguiamo vediamo 20 milioni come risultato.</p>
<p>Quindi il programma √® corretto.
Chiaramente ci ha messo un po' a fare 20 milioni, <em>perch√©?</em> Perch√© da ogni passaggio ha preso il <code>Mutex</code>, fermando l‚Äôaltro thread, ha fatto l‚Äôincremento, ha mollato il <code>Mutex</code> e l'altro thread √® potuto entrare, e cos√¨ via la stessa cosa anche per lui.</p>
<p>In questo esempio abbiamo protetto un numero ma avremmo potuto proteggere un <code>Vec</code>, una struttura, una lista, quello che vogliamo!</p>
<h1 id="4-conditionvariable-in-rust"><a class="header" href="#4-conditionvariable-in-rust">4. ConditionVariable in Rust</a></h1>
<p><img src="images/concorrenza/image%2050.png" alt="image.png" /></p>
<p>Abbiamo dunque incominciato a vedere alcuni dettagli della programmazione concorrente e abbiamo visto come possiamo attivare pi√π thread per poter svolgere in parallelo delle operazioni. In realt√† noi utilizziamo i thread in contesti anche pi√π ampi, <em>non solo l√† dove ci serve il reale parallelismo</em> (ovvero dove vogliamo servirci del fatto che la nostra CPU abbia molti core e ciascuno di questi possa svolgere una computazione totalmente indipendente dalle altre), ma spesso usiamo i thread come <em>surrogato</em> per la realizzazione di programmi semplicemente concorrenti, ovvero programmi nei quali concretamente le nostre azioni non si svolgono necessariamente in parallelo, nel senso che mentre faccio una cosa non necessariamente ne devo fare un'altra, perch√© alcune delle cose che faccio mi portano a dei blocchi.</p>
<p><strong>Ad esempio</strong>, se sto leggendo dal disco io arrivo a invocare la funzione <code>read</code> che in qualche modo √® responsabile di recuperare dal disco i dati che mi servono, ma siccome il sistema operativo ha bisogno di interagire con la periferica, e immaginando il disco di quelli rotativi, per cui la CPU deve aspettare che banalmente faccia il giro e si porti sul settore che mi interessa per leggere sotto la testina, ci sono <em>lunghi intervalli di tempo</em> nei quali non stiamo facendo assolutamente nulla, perch√© il nostro processore √® l√¨ in attesa che succeda qualcosa nel mondo fisico, cio√® che il disco giri.</p>
<p><strong>In realt√†</strong>, siccome la chiamata a <code>read</code> √® bloccante (ovvero non ritorna fino a che la lettura non √® completa), se mentre leggo dal file 1 ho bisogno di leggere anche dal file 2, beh, l'unica alternativa che ho, se non voglio aspettare che finisca la prima lettura per poter iniziare la seconda, √® creare due thread. In quel caso l√¨ io sto creando due thread che entrambi leggono dal file system, ma in realt√† non si stanno realmente svolgendo in parallelo.</p>
<p>Se andassi a guardare col task manager come √® l'utilizzo dei core, probabilmente vedrei che il il core 1, quello che legge dal primo file, √® occupato per un <strong>piccolissimo istante</strong> dove prepara le operazioni di lettura (cio√® spiega al sistema operativo che vuole leggere una certa cosa) e poi resta <em>idle</em> per una quantit√† di tempo, in attesa che il disco faccia il giro, e in un momento diverso il core 2 risulta occupato per un'altra breve frazione di tempo e poi di nuovo <em>idle</em> anche lui.</p>
<p>Ho quindi utilizzato <strong>due thread disgiunti</strong> (essendo questo il modo pi√π semplice offerto dal sistema operativo per eseguire operazioni concorrenti), pur non avendo un reale bisogno di parallelismo. Infatti, l'attivit√† effettiva del processore logico (necessaria per richiedere al sistema operativo l'accesso al file) occupa solo una <em>frazione di tempo piccolissima</em>, dopo la quale lavorano le periferiche. Con un'API diversa, come un'API <strong>asincrona</strong>, potrei invece usare un solo thread per dire al sistema operativo: <em>"Leggi, poi liberami e fammi proseguire"</em>. In questo modo, il thread pu√≤ continuare l'esecuzione dopo aver dato il comando <em>"leggi dall'hard disk"</em>, permettendo cos√¨ di gestire pi√π letture in parallelo con un singolo thread.</p>
<p>Via via che il sistema operativo √® pronto e ha risultati, dovrebbe poi trovare per√≤ un modo di farmeli sapere, motivo per cui nella programmazione asincrona, un modo elementare di gestire la cosa sarebbe, quando dico al sistema operativo ‚ÄúQ<em>uando leggi questo file potrei passati una callback, dicendo che quando l‚Äôhai effettivamente letto, mi richiami‚Äù</em>. In realt√† le cose non sono cos√¨ banali, perch√© se usassi una callback ci sarebbe il problema di capire in che thread il sistema operativo mi chiamerebbe.</p>
<p>Quindi questo lascia poi spazio al fatto che si possa affrontare il problema della <strong>concorrenza</strong>, cio√® del portare avanti attivit√† di lungo periodo in parallelo, anche con un solo thread, a condizione di avere una <em>interfaccia non bloccante</em>. Ed √® il motivo per cui c'√® tutto un capitolo della programmazione che √® la <strong>programmazione asincrona</strong>, dove i diversi linguaggi di programmazione mettono a disposizione vari tipi di concetti per fare delle cose. Fino adesso per√≤ noi questo capitolo non lo abbiamo ancora aperto, sappiamo che potenzialmente c'√®.</p>
<p>Per molti anni, diciamo <em>dal 1990 grosso modo, fino al 2012 circa</em>, quindi per pi√π di vent'anni, l'unica alternativa che veniva offerta ai programmatori che avevano bisogno di svolgere attivit√† anche lente, anche sostanzialmente poco CPU intensive, ma che si sovrapponessero temporalmente, era <strong>creare pi√π thread</strong>.</p>
<p><strong>Se io creo pi√π thread, cosa succeder√†?</strong> Il thread 1 chiama la <code>write</code> o la <code>read</code> (che √® bloccante), sta fermo tutto il tempo necessario per leggere, il thread 2 che si svolge, che potenzialmente potrebbe andare in parallelo, chiama anche lui la stessa funzione, e poi sta fermo per un mucchio di tempo. Il sistema operativo si rende conto che in realt√† nessuno dei due di questi thread, a parte un piccolo <em>spike</em> di computazione, non c'√® niente da fare (perch√® aspettano che poi siano le periferiche a restituire la lettura richiesta, come dicevamo nell‚Äôesempio), quindi gli toglie la CPU, tanto bisogna aspettare. Quando questi thread possono riprendere, riprendono, e troveranno nel valore di ritorno il dato che hanno letto.</p>
<p><strong>Questo ha dei vantaggi</strong> perch√© il programmatore pensa in modo sequenziale. In fondo leggere da un file √® un'operazione che sappiamo da tantissimi anni come si fa. Il fatto che i thread si blocchino non ci d√† un particolare fastidio, anzi quasi ci va comodo, <em>perch√©?</em> Perch√© io so che quando torno dalla <code>read</code> ho il mio dato letto e quindi ci posso ragionare sopra. Se ero dentro un ciclo, quel thread l√¨ mi ha bloccato, ma quando riprendo, riprender√≤ e andr√≤ avanti da quella posizione, quindi non ho perso niente.</p>
<p><strong>Il motivo per cui ci sono voluti venti e pi√π anni</strong> per passare alla programmazione asincrona √® che gestire operazioni non bloccanti era tutt'altro che banale. Quando chiamo un'operazione async read, il sistema operativo ritorna subito senza aver ancora letto i dati. A questo punto, se continuo con altre operazioni, devo tenere traccia del punto in cui mi trovo - se ero alla quinta iterazione, devo sapere che anche se procedo con le successive iterazioni, i dati precedenti non sono ancora disponibili. Inoltre, quando arrivano le callback, <em>non √® detto che arrivino nell'ordine originale delle richieste</em>. Per esempio, se sto leggendo da un disco con diversi settori, potrei ricevere prima i dati di una richiesta successiva semplicemente perch√© quei settori si trovano fisicamente prima sotto la testina di lettura.</p>
<p><strong>Questa √® una delle principali sfide delle operazioni asincrone</strong>: quando chiediamo al sistema operativo di dividere la lettura in due fasi (<em>prima la richiesta, poi la risposta mentre facciamo altro</em>), diventa complesso gestire lo stato dell'applicazione. Dobbiamo tenere traccia di ogni risposta che riceviamo e capire a quale richiesta corrisponde, rendendo l'intero processo pi√π articolato.</p>
<p><strong>Va detto che al contrario</strong>, quando io programmo con i thread, fin tanto che le attivit√† che i singoli thread fanno sono totalmente disgiunte, √® facilissimo: il singolo thread chiama <code>read</code>, prende il risultato, lo usa, poi magari √® dentro un ciclo <code>for</code>, chiama di nuovo <code>read</code>, lo riusa, chiama di nuovo <code>read</code>, lo riusa, etc‚Ä¶ alla fine ha letto tutto quello che voleva leggere e fa altro. <em>Fin tanto che le attivit√† non si impicciano, lavorare con i thread √® facilissimo</em>, perch√© sono tanti segmenti di computazione <strong>disgiunti</strong>.</p>
<p><strong>Il problema √®</strong> che noi spesso e volentieri lavoriamo con i thread perch√© vogliamo distribuire tra pi√π attori pezzi di una computazione pi√π grande, ovvero <em>non abbiamo solo il bisogno di fare cose diverse, ma facciamo cose diverse che sono parte di un progetto pi√π ampio</em>, che alla fine dovr√† funzionare tutto insieme.</p>
<p><strong>Proprio come succede</strong> quando qualcuno prepara un pranzo dove deve permettersi di cucinare il primo, il secondo, il contorno, l'antipasto, il cocktail, il dolce e quant'altro, dove queste attivit√†, s√¨, potrebbero essere strettamente serializzate, ma sarebbe un <em>disastro</em>, perch√© se come secondo voleste l'arrosto e lo serializzaste alla cottura del primo, e beh, l'arrosto ha bisogno delle sue due ore per cuocere e cosa succede? Che tra il primo e il secondo devo fare una pausa di due ore perch√© non ce l'ho ancora pronto.</p>
<p><strong>Quindi</strong> diventa complicato governare una cosa del genere. <em>Necessariamente</em> io voglio in qualche modo <em>portarmi avanti</em> e quindi ho diversi cuochi: uno si occupa del primo, uno si occupa del secondo, uno si occupa del dolce e cos√¨ via.
Il problema √® che tutti si occupano di questa cosa qui nel contesto del pranzo. Per cui poi i piatti via via che vengono cucinati devono essere serviti, e serviti nell'ordine giusto. Quindi vengono a far parte di una <strong>struttura coerente</strong>.</p>
<p><strong>Cosa succede</strong> se uno dei cuochi arrivasse con il suo piatto prima di quando serve? Beh, deve aspettare. Ha bisogno di regolarsi insieme con gli altri e i vari camerieri che poi serviranno a tavola e porteranno i piatti a disposizione devono avere presente a che punto siamo. Quindi c'√® un <em>bisogno di passare informazioni</em> tra i diversi attori, in modo che possano coordinarsi per raggiungere il risultato. <strong>Coordinarsi richiede comunicare</strong>.</p>
<p><em><strong>Come avviene la comunicazione tra thread?</strong></em>
La comunicazione tra thread avviene in due modi possibili, concettualmente un po' diversi. Il primo modo √® abbastanza semplice da capire, ma si porta dietro un mucchio di implicazioni. Questo primo modo √® quello che abbiamo visto precedentemente, e sostanzialmente dice <em>"Visto che i thread lavorano tutti nello stesso spazio di indirizzamento, se prendiamo una variabile possiamo usare quella variabile l√¨ per scriverci dentro delle cose."
Teniamo una versione aggiornata di quello che √® la cucina del nostro pranzo.</em> Per cui questa variabile, che sar√† una struct, ci mettiamo dentro il primo, il secondo, e dico <em>‚Äúil primo sta cuocendo‚Äù, ‚Äúil secondo neanche l'ho acceso ancora‚Äù, ‚Äúil dolce √® gi√† pronto‚Äù</em>, eccetera. Ci scriver√≤ un po' di cose. Chiaramente i vari thread aggiornano questa struttura condivisa.</p>
<p>Questa qui √® una struttura <strong>complicata,</strong> e bisogna garantirsi soltanto che la aggiorniamo uno per volta, perch√© se cercassimo di aggiornarla insieme potremmo fare dei <em>disastri</em>. Abbiamo visto prima come anche un'operazione stupidissima, un incremento, se fatta insieme, porta a una perdita di informazione.</p>
<p><em><strong>Come ci proteggiamo?</strong></em>
Allora, i linguaggi ci mettono a disposizione <strong>due astrazioni</strong>. La prima si chiama <code>Mutex</code> e nel caso di Rust lo vediamo come un oggetto che <em><strong>incapsula</strong></em> un dato. Il  <code>Mutex</code> √® una monade: nasconde il dato a chi vuole usarlo. Il dato √® <em>annegato</em> dentro il <code>Mutex</code>. <code>Mutex</code> √® una classe generica, <code>Mutex&lt;T&gt;</code>, dove T √® il dato che √® condiviso.</p>
<p>Io a quel dato non ci arrivo se non in un modo: invocando sull'oggetto <code>Mutex</code> il metodo <code>lock</code>. E il metodo <code>lock</code> ha una caratteristica <strong>importantissima</strong>: se il <code>Mutex</code> √® libero io immediatamente torno e ti torno uno smart pointer col quale tu accedi al dato, e lo puoi leggere e scrivere. Se invece nel momento in cui tu invochi <code>lock</code>, questo dato lo sta gi√† usando qualcun altro, <em><strong>aspetti</strong></em> e lock non ritorna fino a che il dato non √® libero per te.</p>
<p>Quindi io sono tranquillo che quando <code>lock</code> ritorna ho a disposizione il mio dato e sono <strong>l'unico che lo pu√≤ leggere e/o scrivere</strong>. Lo cambio, ci metto quello che voglio, faccio le mie operazioni, possibilmente un po' in fretta perch√© gli altri aspettano, quando ho finito butto via lo smart pointer che mi √® stato restituito da <code>lock</code> e buttandolo via automaticamente se c'era qualcun altro in coda questo qualcun altro lo prende.</p>
<p>Questa prima astrazione mi d√† garanzia che l'accesso alla struttura condivisa, mentre ce l‚Äôho io non ce l'ha nessun altro.</p>
<p>In molte situazioni un <code>Mutex</code> √® sufficiente.</p>
<p><strong>Ci sono per√≤ delle attivit√†</strong> che richiedono di iniziare un'operazione solo quando qualcun altro ha completato qualcos'altro. In questi casi, una possibilit√† √® fare <em>polling</em>, cio√® continuare a chiedere l'accesso alla struttura dati per controllare: <em>"√® gi√† pronto il secondo?"</em> No. Rilascio la struttura, la richiedo subito dopo: <em>"√® gi√† pronto il secondo?"</em> No. Rilascio e richiedo ancora. E cos√¨ via.</p>
<p><strong>Si pu√≤ fare, ma √® assolutamente <em>inefficiente</em></strong>.
Questa cosa qua comporta un uso altissimo della CPU, perch√© voi continuamente chiedete, consumate cicli macchine, tra l'altro per accedere in <em>modalit√† kernel</em>, perch√© poi il mutex ve lo d√† il kernel del sistema operativo, quindi passate la barriera, innalzate il privilegio, tornate indietro, etc‚Ä¶ per fare <strong>niente</strong>. Assolutamente niente. L'uso altissimo della CPU ha come effetto l'uso altissimo della corrente e quindi la batteria, se siete a batteria, si scarica. Il vostro algoritmo sta procedendo di zero. E' l√¨ che aspetta. Continua a chiedere <em>"√® pronto?"</em> No. <em>"√à pronto?"</em> No. <em>"√à pronto?"</em> No.</p>
<p><strong>Per evitare questa situazione</strong> qui abbiamo introdotto una seconda astrazione. La <code>Condvar</code>.</p>
<p><strong>Cosa fa la <code>Condvar</code>?</strong>
Mi d√† un modo <em>efficiente</em> di aspettare. <code>Condvar</code> offre sostanzialmente il metodo <code>wait</code>, che mi fa aspettare, <em>fino a quando?</em> Fino a che qualcuno non chiama <code>notify</code>.</p>
<p><strong>La funzione <code>notify</code> c'√® in due versioni</strong>: <code>notify_one</code> e <code>notify_all</code>, per gestire possibili differenze che ci sono.</p>
<p>Sostanzialmente la coppia <code>Mutex</code>-<code>Condvar</code> permette di gestire tutte le situazioni in cui ho bisogno di <strong>coordinare l'attivit√† di pi√π thread</strong> sfruttando uno stato condiviso. C'√® una variabile, una <code>struct</code>, dentro cui c'√® scritto tutto quello che serve per capire non solo cosa sto facendo io, ma <em>cosa stanno facendo tutti gli altri</em>, me compreso.
In quella struct sono responsabile di aggiornarne un pezzo, in base al mio ruolo, ma posso leggere tutti gli altri, mentre ne ho l'accesso, per poter decidere come comportarmi. E se ho proprio bisogno mi appoggio alla <code>Condvar</code> quando mi occorre aspettare altri.</p>
<p><strong>La <code>CondVar</code> non pu√≤ essere usata senza il <code>Mutex</code></strong>, semplicemente perch√© il suo metodo <code>wait</code> richiede come parametro quello smart pointer che il <code>Mutex</code> mi ha restituito. Quindi non basta solo affiancare un <code>Mutex</code> alla <code>Condvar</code>, ma bisogna anche averlo acquisito (cio√® devo avere il <code>MutexGuard</code> restituito dal metodo <code>lock</code>, quando il <code>Mutex</code> viene rilasciato da qualcun altro), altrimenti non posso proprio chiamare <code>wait</code> sintatticamente. Quindi <code>Mutex</code> <em>e</em> <code>Condvar</code> <em>vivono a braccetto</em>. La <code>Condvar</code> non pu√≤ esistere senza un <code>Mutex</code>.</p>
<p><strong>La <code>Condvar</code> vive a fianco al <code>Mutex</code>, non dentro il <code>Mutex</code></strong>.
Se stesse dentro il <code>Mutex</code> non potrebbe funzionare, <em>perch√©?</em> Perch√© nel momento in cui io chiamo <code>wait</code>, lei lo deve rilasciare sto mutex affinch√© altri lo possano prendere per poi riacquisirlo. Ma se fosse dentro il mutex questo giro non lo pu√≤ fare, perch√© nel momento in cui lo rilascia non pu√≤ pi√π poi richiederlo perch√© sarebbe tagliata fuori.</p>
<p><strong>La <code>Condvar</code> vive accanto al <code>Mutex</code>, non dentro di esso.</strong>
Questo √® fondamentale, perch√© quando un thread chiama <code>.wait()</code> su una <code>Condvar</code>, deve temporaneamente rilasciare il lock del <code>Mutex</code> per consentire ad altri thread di modificarne lo stato.
Se la <code>Condvar</code> fosse contenuta all‚Äôinterno del <code>Mutex</code>, rilasciare il lock significherebbe perdere l‚Äôaccesso anche alla <code>Condvar</code> stessa.
Di conseguenza, la <code>Condvar</code> e il <code>Mutex</code> devono essere oggetti separati ma strettamente coordinati.</p>
<blockquote>
<p>üí° <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2051.png" alt="image.png" /></p>
<p>Esempio:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (lock, condvar) = &amp;*shared;           // Arc&lt;(Mutex&lt;VecDeque&lt;T&gt;&gt;, Condvar)&gt;
let mut queue = lock.lock().unwrap();     // Acquisisce il lock

while queue.is_empty() {                  // Check sulla CV
<span class="boring">}</span></code></pre></pre>
</blockquote>
<pre><code>	&gt;/* Rilascia il lock e dorme finch√© qualcuno notifica. */
	&gt;/* Quando vengo svegliato, ho nuovamente possesso del lock  */
&gt;queue = condvar.wait(queue).unwrap(); 
</code></pre>
<blockquote>
<p>}</p>
<p>// ora queue non √® vuota ‚Üí consuma elemento
let item = queue.pop_front().unwrap();</p>
<pre><code></code></pre>
</blockquote>
<p><strong>Quindi necessariamente</strong> quando abbiamo una struttura condivisa, la struttura condivisa la scriviamo dentro un <code>Mutex</code> e poi a fianco a questo <code>Mutex</code> gli mettiamo una <code>Condvar</code> (usando una tupla, o una <code>struct</code> di qualche tipo). Questo pezzo di dato rappresenta l'informazione di quella parte di sistema che abbiamo bisogno di coordinare.</p>
<p>Se pi√π di un thread devono poterci accedere, o questi thread fanno parte di uno <em>scope comune</em> e allora basta avere una <code>reference</code> e siamo a posto, oppure <strong>se questi thread hanno <em>cicli di vita indipendenti</em></strong> (non fanno parte di uno scope comune), allora <strong>incapsuliamo questa coppia</strong> fatta di <code>Mutex</code> (che racchiude tutti i dati) e <code>Condvar</code> <strong>dentro un <code>Arc</code></strong>, che pu√≤ essere condiviso tra tutti i thread.</p>
<p><strong>Quindi la struttura pi√π generale</strong>, con lo stato condiviso, presuppone definire una tupla fatta di <code>Mutex</code> e <code>Condvar</code>. Il <code>Mutex</code> ha tutti i suoi dati e questa tupla, se ho bisogno, la condivido mediante <code>Arc</code>. Nell'<code>Arc</code> posso fare quanti cloni voglio, ciascun thread posseder√† un clone di questo <code>Arc</code>, nel momento in cui tutti i thread saranno morti il contatore dell'<code>Arc</code> scende a zero e di conseguenza <code>Mutex</code> e <code>Condvar</code> saranno rilasciati, liberando tutta la memoria.</p>
<p><strong>Questo √® un approccio di basso livello</strong>. <em>Di basso livello perch√©?</em> Perch√© d√† <em>visibilit√† a tutti di tutto</em>.
Nel momento in cui un thread ha possesso del <code>Mutex</code>, ha accesso all'intero dato. Normalmente gli algoritmi sono costruiti, con buon senso, dicendo che il thread che ha questo compito <strong>legge quello che gli interessa</strong> ma <strong>scrive solo questo pezzettino</strong>. E eventualmente dopo che l'ha scritto, se √® necessario, <em>notifica la</em> <code>Condvar</code> affinch√© altri possano svegliarsi. Per√≤ questa √® una regola di buon senso ma <strong>non √® garantita dal linguaggio</strong> in nessun modo.</p>
<p>Quindi √® possibile che se io mi occupo di cucinare il primo, per sbaglio o per volont√†, vada a modificare a che punto √® il secondo, anche se non devo. Il <code>Mutex</code> non me lo pu√≤ impedire perch√© nel momento in cui mi d√† accesso, <em>mi d√† accesso completo</em>. Dovrebbe essere il mio buon senso di programmatore che mi impedisce di farlo, ma questo non √® sempre presente. Quindi il rischio √® che posso (nel momento in cui posseggo il <code>Mutex</code>) <strong>impicciare gli altri</strong> modificando delle cose che non mi riguardano. In pi√π, mentre un thread possiede questa struttura, gli altri non la posseggono di sicuro. E questa √® la <em>garanzia del</em> <code>Mutex</code>.</p>
<p>√à vero che c'√® una possibile <strong>variazione sul tema:</strong> Rust, oltre a offrirci la primitiva <code>Mutex</code>, che ci d√† questo comportamento, ci offre anche la primitiva che si chiama <code>RwLock</code>.</p>
<p><code>RwLock</code> √® simile a un <code>Mutex</code> ma ha <em>due metodi diversi per lockare</em>:</p>
<ul>
<li>Uno in cui chiedo l'<strong>accesso in lettura</strong></li>
<li>Uno in cui chiedo l'<strong>accesso in scrittura</strong></li>
</ul>
<p>Il metodo col quale leggo l'accesso in lettura mi restituisce uno smart pointer che mi fa <em>solo leggere</em>, quindi non posso modificare la struttura dati. In compenso per√≤ se lo chiediamo in pi√π di uno in contemporanea, lo possiamo ottenere. Quindi possono avvenire <strong>molte letture in parallelo</strong>.</p>
<p>Ma nel momento in cui qualcuno ha bisogno di scrivere, deve chiedere il <strong>lock in scrittura</strong>.
Il lock in scrittura √® dato a <em>uno solo</em> e con il vincolo che viene dato <strong>solo quando non c'√® nessuno che legge</strong>. E quindi alla fine non √® cambiato molto.</p>
<p>Per questo motivo Rust mette a disposizione anche un altro approccio.
Consideriamo che <strong>ogni comunicazione implica una sincronizzazione</strong>. Pensiamo a come comunicano due thread con lo stato condiviso: uno acquisisce il <code>Mutex</code>, scrive i dati che vuole trasmettere all'altro, eventualmente notifica la <code>Condvar</code>, e rilascia il <code>Mutex</code>. L'altro thread si sveglia, acquisisce il <code>Mutex</code> appena possibile, legge e comprende. Quindi per permettere la comunicazione abbiamo necessariamente dovuto usare strutture di sincronizzazione come <code>Mutex</code> e <code>Condvar</code>.</p>
<p>Il secondo approccio capovolge questa prospettiva: <strong>ogni comunicazione √® anche una sincronizzazione</strong>. In altre parole, <em>tu non puoi ascoltare finch√© io non parlo, e se mi ascolti, significa che ho gi√† parlato.</em> Per questo Rust ci offre il concetto di <em><strong>canale</strong></em>.
Un canale √® semplicemente una struttura dati condivisa tra mittenti e destinatari che permette lo scambio di messaggi.</p>
<p><em>Cos'√® un messaggio?</em>
Un canale √® una struttura generica, <code>channel&lt;T&gt;</code>, dove <code>T</code> √® un qualunque tipo di dato che gode del tratto <code>Send</code>, cio√® deve essere <strong>trasmissibile da un thread a un altro</strong> ‚Äî <em>io non ti posso passare nulla che non sia</em> <code>Send</code>, e ci sta, perch√© viene generato da qualcuno che lo deposita nel canale e poi qualcun altro dal canale lo recupera.</p>
<p>Il canale √® <strong>strettamente sequenziale</strong>. Se io nel canale inietto tre valori, ad esempio dei numeri, <code>1, 2, 3</code>, chi legge li legger√† <em>strettamente nell'ordine</em> con cui sono stati scritti: <code>1, 2, 3</code>.</p>
<p>Non √® detto che se io scrivo <code>1</code> ci sia subito qualcuno che lo legge, perch√© il canale <strong>disaccoppia il tempo</strong> del mittente dal destinatario ‚Äî <em>io l'ho scritto, e sta l√¨ fino a che qualcuno non lo legge</em>. Se c'√® qualcuno pronto lo legge subito, se c'√® qualcuno che dorme lo legger√† tra un po'. Quando lo legge viene tirato via dal canale, quindi il messaggio permane nel canale per il tempo necessario a permettere a chi lo legge di andarselo a prendere e vedere. Se nel frattempo chi scrive aggiunge altre cose, le aggiunge, staranno dietro in coda.</p>
<p><em>Quante ce ne possono stare in un canale?</em>
Un canale semplice ne pu√≤ tenere tante quanto la RAM del computer ne consente. Vengono detti <code>unbounded</code>, che non vuol dire infiniti, perch√© la mia memoria √® finita, quindi dopo un po' se non c'√® pi√π spazio non li potr√≤ scrivere, ma comunque tanti. I canali normalmente sono pensati perch√© <strong>un thread scriva</strong> e <strong>l'altro legga</strong>.</p>
<p><strong>Quando creo un oggetto di tipo canale</strong>, in realt√† non viene creato un oggetto singolo: ne vengono creati due. La funzione <code>channel</code> restituisce una tupla, con un <code>Sender</code> e un <code>Receiver</code>. Il <code>Sender</code> √® un oggetto che permette <strong>solo di mandare</strong>, il <code>Receiver</code> √® un oggetto che permette <strong>solo di ricevere</strong>. Quindi <code>Sender</code> mi offre solo <code>send</code> e <code>Receiver</code> mi offre solo <code>recv</code>, che √® il metodo per ricevere.</p>
<p>Quindi tendenzialmente quando uso i canali, <strong>creo prima di tutto il canale</strong>. Magari ne creo uno, magari ne creo due, magari ne creo venticinque, perch√© user√≤ il canale <em>non come uno spazio globale dove tutti vedono</em>, ma come un <strong>collegamento</strong>, un filo che unisce specificatamente il thread 1 col thread 2 affinch√© si possano dire delle cose. Mentre loro si parlano e si sincronizzano e usano il canale come strumento di sincronizzazione, altri thread possono fare su altri canali altre cose, senza impicciarsi. Quindi il canale da questo punto di vista permette di parlarsi sincronizzandosi <em>senza impicciare potenzialmente altri</em>.</p>
<p>Il metodo <code>send</code> ritorna sempre un <code>Error</code>. <em>Perch√© ritorna un error?</em> Perch√© √® possibile che il thread responsabile di leggere se ne sia gi√† andato. E quindi se io so che il destinatario non c'√® pi√π, √® inutile che scriva, perch√© non lo potr√† leggere pi√π nessuno. In realt√† questo √® reso possibile dal fatto che il metodo <code>channel</code> ci ritorna questa coppia di cose che a noi appaiono distinte ma dentro di s√© sono <strong>intrinsecamente legate</strong>. E quando il receiver viene buttato via, cio√® avviene il <code>drop</code> del receiver, il sender lo sa. E a questo punto, nel momento in cui il receiver non esiste pi√π, quindi non ci sar√† pi√π nessuno che potr√† leggere da quel canale, tentativi di scrittura sul sender <em>falliranno</em>.</p>
<p><strong>Anche <code>recv</code></strong> retorna un result ed √® duale ‚Äî <code>recv</code>, se la invoco e c'√® qualcosa gi√† nel canale me lo prende e me lo restituisce subito, mi prende il messaggio pi√π vecchio presente nel canale, quindi il <em>primo della lista</em> e me lo d√†. Se non c'√® niente nel canale mi fa aspettare e rimango l√¨ <strong>bloccato in <code>recv</code></strong> fino a che qualcuno non ci mette niente, oppure fino a che il sender non se ne va. Perch√© se venisse distrutto il sender il <code>recv</code> che √® l√¨ dice "<em>ah caspita, non potr√≤ mai pi√π leggere nulla perch√© l'unico modo per farmelo avere era quel sender, ma quel sender non c'√® pi√π, quindi anch'io non me ne vado</em>". Quindi l'uscita da <code>recv</code> √® un <code>Error</code> che mi dice "<strong>ok</strong>" nel momento in cui io ho ricevuto correttamente un dato e mi dice un error dicendo "<em>guarda, il canale √® stato chiuso, √® stato chiuso a monte, quindi √® inutile che tu stia qui a aspettare perch√© non prenderai mai pi√π niente</em>". Oppure mi blocca, fin tanto che il canale e le due estremit√† esistono un tentativo di lettura su un canale vuoto mi fa aspettare. Proprio come se leggessi da tastiera, chiamo <code>scanf</code> per leggere da tastiera, <code>scanf</code> e se io non batto nessun tasto sta fermo l√¨.</p>
<h1 id="5-canali-in-rust"><a class="header" href="#5-canali-in-rust">5. Canali in Rust</a></h1>
<p>C'√® un pezzettino in pi√π che rende i canali standard di Rust abbastanza versatili. L'oggetto <code>Sender</code> √® <strong>clonabile</strong>.</p>
<p><em>Cosa vuol dire che l'oggetto sender √® clonabile?</em>
Vuol dire che questo canale si comporta in realt√† con una politica che si chiama <strong>MPSC</strong>, <em>Multiple Producer Single Consumer</em>. Perch√© io creo il canale con la funzione <code>channel</code>, questo mi ritorna sempre e solo una tupla (un <code>Sender</code>, un <code>Receiver</code>), per√≤ il <code>Sender</code> pu√≤ essere clonato.</p>
<p><em>Cosa capita quando io clono il sender?</em>
Beh che avr√≤ pi√π pezzi che possono iniettare sul canale. Questi pezzi possono essere affidati a thread distinti. Tutti quanti possono scrivere, come un <em>imbuto che finisce in un'unica coda</em>.</p>
<p>Se due thread provano contemporaneamente a scriverci qualcosa, <strong>uno dei due vincer√†</strong>. Il sistema operativo sceglier√† uno dei due e dice "<em>tu entri per primo, tu entri per secondo</em>". Proprio come se mettiamo delle palline in un imbuto che ha la gola stretta da farne passare una sola per volta, queste palline stanno un po' l√¨, rimbalzano una contro l'altra, poi alla fine una delle due si infila e l'altra aspetta. Quale delle due non lo sappiamo. Ma non ha nessuna importanza. Sono arrivate insieme, quindi vanno via insieme. Se arrivassero invece a tempi distinti, ognuna si infila giustamente nel momento in cui serve.</p>
<p>Dal punto di vista del comportamento del mittente, cio√® la funzione <code>send</code> dei tanti sender che posso aver creato, mi restituir√† un errore nel momento in cui l'unico receiver (che <em>non √® clonabile</em>) muore. Perch√© giustamente pi√π nessuno potr√† scrivere niente quando non c'√® pi√π ricevitore. Al contrario, il ricevitore mi restituir√† un error quando il conteggio dei sender sar√† sceso a zero. Quindi, se io ho creato <strong>tre cloni del sender</strong> e ho un receiver che ascolta:</p>
<ul>
<li>il receiver aspetta, aspetta, aspetta</li>
<li>un clone muore, il receiver continua a aspettare</li>
<li>un altro clone muore, il receiver continua a aspettare</li>
<li>l'ultimo clone muore, a quel punto il receiver esce con errore dicendo "non ce n'√® pi√π"</li>
</ul>
<p>Se il singolo sender manda <code>1, 2, 3</code>, il receiver vedr√† <code>1, 2, 3</code>. Se mentre quel sender manda <code>1, 2, 3</code>, un altro manda in contemporanea <code>A, B, C</code>, il receiver trover√† un misto di <code>1, 2, 3</code> e <code>A, B, C</code>. <strong>Sicuramente</strong> il receiver non legger√† <code>2</code> prima di aver letto <code>1</code>, ma <code>A</code> potrebbe riceverlo prima di <code>1</code>, dopo <code>1</code> o dopo <code>2</code>. Perch√© insieme questi due stanno mandando delle cose. Le sequenze che si originano da un singolo sono <em>garantite</em>. Le sequenze che ricevo da diversi possono <em>mischiarsi in qualunque ordine</em>.</p>
<p>Il sender d√† sempre la priorit√† al dato gi√† disponibile. Quando quel dato √® esaurito deve aspettare. E aspetta fino a che gli risultano esserci sender in vita. Nel momento in cui si accorgesse che non c'√® pi√π nessun sender in vita, esce con errore.</p>
<p>L'uso dei canali di base √® banale. Nel senso che la meccanica √® questa qua. Ma notate che anche la meccanica dei <code>Mutex</code> √® banale. Anche la meccanica delle <code>Condvar</code> √® abbastanza banale. Esattamente come con la combinazione <code>Mutex</code>/<code>Condvar</code> √® difficile capire cosa succede quando li mettiamo insieme e capire bene come organizzare il nostro codice, perch√© succeda quello che vogliamo noi e non quello che vogliono loro, lo stesso succede con i canali. Anzi, per certi aspetti, con i canali potrebbe essere pi√π strano. <strong>Perch√©?</strong> Perch√© ci presuppone una modalit√† di programmare <em>basata a eventi</em>. Quindi bisogna giocarci un po‚Äô con i canali, per farseli andar bene e capire che cosa succede.</p>
<p><img src="images/concorrenza/image%2052.png" alt="image.png" /></p>
<p>Vediamo di fare degli esempi e di comprenderci meglio.</p>
<p>Il meccanismo che viene adottato √® quello della <em>cessione della propriet√†</em>. Nel momento in cui il metodo <code>send</code> di <em>sender</em> viene invocato, il metodo <code>send</code> <strong>prende possesso del dato</strong> <code>T</code>, che io voglio scrivere sul canale, <strong>e lo cede al canale stesso</strong>. Quindi chi ha inviato un dato <strong>non ce l'ha pi√π</strong>. Se il dato era copiabile, va bene, gli sar√† rimasto. Ma di base il meccanismo √® basato sul <strong>movimento</strong> ‚Äî la propriet√† passa dal sender al canale e resta del canale fino a che non avviene un <code>recv</code>, a quel punto <strong>la propriet√† √® diventata del ricevitore</strong>, il quale poi ne fa cosa vuole.</p>
<p><strong>Questo ci garantisce</strong>, sostanzialmente, che noi possiamo comunicare qualcosa. Siccome c'√® un passaggio di propriet√†, inizialmente il dato √® posseduto nel contesto di un thread, poi a un momento in cui √® solo dentro il canale e <em>non appartiene di per s√© a nessun thread</em>, perch√© il canale √® condiviso nel suo possesso, e poi diventa di propriet√† del thread che riceve.</p>
<p>Questo fondamentalmente implica che otteniamo contemporaneamente una <strong>comunicazione</strong> <em>(ti passo questo dato e quindi dentro questo dato ci posso scrivere quello che ti voglio far sapere)</em> ma anche una <strong>sincronizzazione</strong> <em>(io non posso leggere fino a che qualcuno non ha scritto)</em>.
<strong>E quindi mi restituisce quell'ordine relativo di avanzamento che due thread normalmente non hanno.</strong></p>
<p>In uno dei primissimi esempi che abbiamo mostrato, introducendo l'uso dei thread, abbiamo detto che se io ho due thread che contano da 1 a 10 e stampano, posso dire per certo che i numeri da 1 a 10 del thread 1 escono in ordine, posso dire per certo che i numeri da 1 a 10 del secondo thread escono in ordine, ma <em>non so dire niente di cosa capita tra l'uno e l'altro</em>, cio√® se i primi 10 escono prima dei secondi 10 o viceversa, se escono mescolati e cos√¨ via. <strong>Perch√©?</strong> Perch√© l'avanzamento dei thread √® indipendente, il sistema operativo li schedula tutte le volte che ha una CPU libera, cercando di farli andare avanti.</p>
<p>Attraverso l'uso dei canali io posso garantire che il thread che riceve faccia delle azioni <strong>necessariamente successive</strong> ad altre azioni che sono capitate nel thread che manda. Perch√© il canale mi d√† questa garanzia. Il tipo di errore che viene restituito se il canale √® chiuso dall'altra estremit√† √® leggermente diverso:</p>
<ul>
<li><code>SendError</code> se cerco di scrivere su un canale di cui non c'√® pi√π un ricevitore</li>
<li><code>RecvError</code> se cerco di leggere da un canale in cui non c'√® pi√π nessun sender</li>
</ul>
<p>Vediamo un esempio pratico.</p>
<h2 id="51-esempio"><a class="header" href="#51-esempio">5.1 Esempio</a></h2>
<p><img src="images/concorrenza/image%2053.png" alt="image.png" /></p>
<p>In questo esempio vogliamo creare un canale e usarlo per far parlare thread diversi.</p>
<p><strong>Come creo un canale?</strong>
Il canale si crea con <code>let (tx, rx) = channel();</code>.
La funzione <code>channel</code> che appartiene al namespace <code>std::sync::mpsc</code> (<em>multiple producer single consumer</em>) restituisce una tupla. La tupla ha nel campo 0 il sender, e nel campo 1 il receiver.
Possiamo chiamarli, ad esempio, <code>tx, rx</code> ‚Äî <code>tx</code> trasmette, <code>rx</code> riceve.</p>
<p><img src="images/concorrenza/image%2054.png" alt="image.png" /></p>
<p>In questo momento sono <code>Sender&lt;?&gt;</code>, perch√© al momento il sistema dei tipi non ha avuto abbastanza informazioni per immaginarsi cosa scambier√≤ l√¨ dentro. Volendo posso spiegarglielo in anticipo, posso dirgli <code>channel::&lt;i32&gt;</code> per esempio:</p>
<p><img src="images/concorrenza/image%2055.png" alt="image.png" /></p>
<p>Posso mandare qualsiasi cosa, <strong>a condizione che sia <code>Send</code></strong>, cio√® goda del tratto <code>Send</code>.
Se non gode del tratto <code>Send</code> non lo posso mandare.</p>
<p><em>Chi √® che non gode del tratto Send?</em>
Non gode del tratto <code>Send</code> gli <code>Rc</code> semplici, i <code>RefCell</code> e in generale tutti questi tipi un po' strani che <em>violano le regole base del movimento</em>.</p>
<p><strong>A questo punto ho creato il canale</strong>.
Creare un canale non serve a niente se non avete qualcuno che legge e qualcuno che scrive. Allora facciamoci al momento una cosa semplice: uno che legge e uno che scrive.</p>
<p><img src="images/concorrenza/image%2056.png" alt="image.png" /></p>
<p>Con <code>let t1 = thread::spawn</code> creiamo un thread, e qua dobbiamo passargli una lambda. Gli passo una lambda con la clausola <code>move</code>, <em>perch√©?</em> Perch√© in questo caso io voglio che questo thread si prenda la responsabilit√† di possedere quello che usa.</p>
<p>E in questo caso gli passiamo il canale <code>tx</code>, lo facciamo ciclare con un <code>for</code>, e ad ogni iterazione facciamo <code>tx.send</code>, per mandare qualcosa sul canale.
Qui possiamo scegliere se fare <code>tx.send(‚Ä¶)**.unwrap()**</code>, se siamo sicuri che il canale sar√† sempre aperto, oppure gestire eventuali errori restituiti facendo come mostrato sopra.
Facendo cos√¨ garantiamo che se per qualche motivo il ricevitore dovesse morire, ci fermiamo prima e <em>non proviamo neanche a mandare un altro dato, perch√© il ricevitore non ha potuto ricevere quello che abbiamo appena provato a mandare</em>.</p>
<blockquote>
<p>üí° <strong>Differenza <code>format!</code> e <code>println!</code></strong></p>
<p><img src="images/concorrenza/image%2057.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/concorrenza/image%2058.png" alt="image.png" /></p>
<p>Poi creiamo anche un thread che riceve: <code>let t2 = thread::spawn(move || ...)</code>, <em>e cosa fa questo qua?</em>
Finch√© riesco a ricevere cose (<code>while let Ok(v) = rx.recv()</code> ), ogni volta la cosa che ricevo la chiamo <code>v</code>, che √® una stringa, stampo.
Quando non riesco pi√π a riceverle in questo modo faccio <code>println!("receiver done")</code>.</p>
<p><em>Ho creato due thread, ma basta fare questo?</em> <strong>No.</strong>
Quando il thread principale finisce i thread secondari muoiono, perch√© la fine del thread principale mi fa tornare alla funzione <code>CRT startup</code>, che contiene una chiamata alla <em>system call</em> <code>exit</code>, e quindi il processo muore. Quindi, <strong>a differenza di quello che succede in Java</strong>, dove se voi create un thread, quel thread viene automaticamente aspettato, a meno che non avete impostato che √® un thread di background, qua dobbiamo noi aspettare il thread, altrimenti non ce la facciamo, e quindi qui dobbiamo fare <code>t1.join.unwrap</code>, e <code>t2.join.unwrap</code>. In questo modo li aspettiamo e siamo certi che sono finiti entrambi, e solo a quel punto il main se ne pu√≤ andare tranquillamente.</p>
<p>Eseguiamo e vediamo l‚Äôoutput.</p>
<p><img src="images/concorrenza/image%2059.png" alt="image.png" /></p>
<p>Qui vediamo che il <strong>mittente parte allegramente</strong>, e parte per primo giustamente, perch√© l'abbiamo creato per primo, quindi ci sta. E lui riesce a scrivere <em>‚ÄúSending 0, 1, 2‚Äù</em>, senza problema, anche se l'altro non lo sta ricevendo. <em>Perch√©?</em> Perch√© il canale √® <strong>unbounded</strong>, e quindi in pancia gli possono stare pi√π cose contemporaneamente. Se io gli ne mando 3, se li prende tutti e 3 ‚Äî se gliene mandassi 300, se li prenderebbe tutti e 300.</p>
<p>In realt√† ne prende per un bel po', fino a che non scatter√† il <em>quantum normale dei thread</em> ‚Äî per 10 millisecondi lui produce, finiti i 10 millisecondi probabilmente il sistema operativo fa fare anche cose agli altri tanti programmi che girano all'interno del pc, ma va bene.
A un certo punto lo far√† riprendere. Pu√≤ darsi che quando riprendesse, se gliene facessimo generare veramente tanti, pu√≤ darsi che quando riprendesse quell'altro thread, il receiver, sia gi√† partito.</p>
<p>Qui stiamo generando talmente poche cose che vediamo che il <strong>sender che finisce ancora prima che qualcos‚Äôaltro venga schedulato al suo posto, e quindi anche prima del receiver</strong>. Il receiver non √® ancora neanche partito, non ha importanza. Quando finalmente riesce a partire si tira fuori il message 0, poi il message 1, poi il message 2. Tranquillamente. Quindi i messaggi ci arrivano nell'ordine con cui li abbiamo mandati.</p>
<p><em><strong>Cosa succede se noi di sender ne facessimo pi√π di uno?</strong></em>
Dobbiamo modificare leggermente il codice del nostro programma, perch√© cos√¨ non va bene.</p>
<p><img src="images/concorrenza/image%2060.png" alt="image.png" /></p>
<p>Allora, qua prepariamo un <code>Vec</code> e preparo un <code>for t in 1..4</code> ‚Äî per 4 volte creo un nuovo thread, e ciascuna <code>JoinHandle</code> la salvo nel <code>Vec</code>, in modo tale che poi me la posso ricordare. Ciascun thread fa ci√≤ che facevamo prima: ciclare 3 volte e mandare qualcosa sul canale.</p>
<p>Modifichiamo poi le stampe cos√¨ da poter differenziarle, quando provengono da thread diversi.</p>
<p><strong>Attenzione:</strong> non posso in realt√† farlo esattamente cos√¨. Perch√©? Perch√© avendo scritto <code>move</code>, il primo thread si prende possesso di <code>tx</code>, e poi il secondo thread <code>tx</code> non ce l‚Äôavrebbe pi√π.</p>
<p><img src="images/concorrenza/image%2061.png" alt="image.png" /></p>
<p>Quindi prima di poter fare questo devo duplicarmi <code>tx</code>: <code>let tx = tx.clone()</code>.
Qui sfrutto il fatto che Rust mi permette di ribattezzare una variabile con un nome gi√† esistente e quindi qui dentro ‚Äî in questo blocco di graffe del primo <code>for</code> ‚Äî creo un <code>tx</code> <em>(che sta sempre nello stack)</em> che √® <strong>clone</strong> di quell'altro.</p>
<p><em>Al termine di questo</em> <code>for</code><em>, quanti</em> <code>Sender</code> <em>avr√≤?</em>
Io ho creato il primo alla riga numero 5: <code>let tx, rx = ...</code>.
Poi per ciascuno dei thread abbiamo fatto una copia e quindi abbiamo l'originale e poi <em>n copie</em> (in questo caso 3) e quindi ne ho <em>n pi√π 1</em> ‚Äî in questo caso abbiamo in totale 4 <code>Sender</code>.
Quindi intravediamo un problema: abbiamo detto che il receiver termina quando vede che non ci sono pi√π sender, ma in questo caso noi abbiamo 4 oggetti <code>Sender</code>, e 3 thread soltanto che effettivamente mandano qualcosa.
In altre parole, quando questi 3 thread finiranno, il receiver non terminer√† anch‚Äôesso, <strong>perch√® c‚Äô√® ancora il <code>tx</code> originale in giro.</strong></p>
<p><em>Quando quei thread l√¨ finiranno e saranno tutti morti, quante copie di <code>tx</code> mi resteranno?</em> <strong>Una, l'originale</strong>.</p>
<p><em>Il thread t2 potr√† finire?</em> No, perch√© c'√® ancora l'originale.</p>
<p><strong>Dunque, dopo aver fatto le copie, l'originale lo devo distruggere.</strong>
Perch√© per Rust altrimenti esiste. E siccome esiste, lui che ne sa che qualcuno non possa usarlo per mandare cose. Quindi quando i miei 3 thread avranno finito di mandare le loro cose, butteranno via la loro copia e il conteggio scender√† da 4 a 3, poi a 2 e poi a 1. <strong>Ma ce ne sar√† ancora uno.</strong></p>
<p>Quindi il thread receiver dopo aver stampato 9 cose <em>(3 per ciascun thread)</em>, star√† l√¨ tranquillo ad aspettare. <strong>Se io non butto via l'originale prima di mettermi ad aspettare il thread, di qua non ne veniamo fuori.</strong></p>
<p><img src="images/concorrenza/image%2062.png" alt="image.png" /></p>
<p>Quindi dopo aver creato i 3 thread e aver passato a ciascuno di loro la propria copia di <code>tx</code>, dobbiamo aggiungermi un <code>drop(tx)</code>.
Chiaramente lo devo fare fuori dal <code>for</code>, perch√© se lo stessi facendo dentro il <code>for</code>, non potrei duplicarlo. Una volta che sono fuori, posso permettermi di buttarlo via.</p>
<p>A questo punto, invece di create il thread receiver come prima con <code>let t2 = ...</code>, scrivo <code>handles.push</code> e lo metto qui ‚Äî mi salvo sempre nel <code>Vec</code> anche l‚Äôhandle del thread receiver.</p>
<p>A questo punto, per aspettarli tutti, facciamo semplicemente <code>for h in handles { h.join().unwrap() }</code>. Questa √® l'attesa finale ‚Äî aspetto che finiscano tutti quanti i sender e i receiver.</p>
<p>Nota: <em>non ho certezza dell'ordine</em> con cui le stampe arrivano ‚Äî se arrivano insieme, possono apparire in qualunque ordine. Se non arrivano insieme, sicuramente appaiono strettamente nell'ordine con cui sono arrivati. L'unico momento di incertezza nasce dall'eventuale contemporaneit√†, che √® possibile proprio per il fatto che ho molti core, su cui possono effettivamente girare contemporaneamente thread diversi. Se avessi un solo core a disposizione, questo non succederebbe.</p>
<p>Proviamo ad eseguire questa cosa.</p>
<p><img src="images/concorrenza/image%2063.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2064.png" alt="image.png" /></p>
<p>Tutto come ci aspettiamo che funzioni.</p>
<p><img src="images/concorrenza/image%2065.png" alt="image.png" /></p>
<p><strong>Attenzione:</strong> se io andassi a rimuovere quella <code>drop(tx)</code> che abbiamo introdotto prima, il programma compila ancora, <strong>ma si pianta.</strong></p>
<p>Il receiver si prende tutti i dati che sono stati mandati dai sender, che alla fine sono terminati, ma siccome c‚Äô√® ancora il <code>tx</code> originale in vita, il receiver rimane in attesa, e il risultato √® che il programma si pianta perch√® il main non finisce, perch√® sta aspettando che il receiver termini, ma questo non pu√≤ accadere.</p>
<p>Quel sender non lo sta usando nessuno, ma lui non lo pu√≤ sapere.</p>
<p>Quindi il programma resta qua per l'eternit√† e di qua non si muove. Sono tutti in attesa:</p>
<ul>
<li>Il thread ricevitore aspetta che qualcuno gli mandi delle cose</li>
<li>Il thread principale aspetta che il ricevitore finisca</li>
<li>Il sender che rimane ancora vivo nelle mani del thread principale (che neanche sa di avercelo ‚Äî non se ne fa nulla, non lo sta usando)</li>
</ul>
<p>E quindi il programma √® bloccato qua - √® un <strong>deadlock</strong>. √à una delle tante forme di deadlock che si possono verificare.</p>
<p><strong>Attenzione:</strong> Rust non vi protegge dai deadlock. Non pu√≤ proteggervi dai deadlock, perch√© per farlo dovrebbe capire <em>completamente</em> cosa fa semanticamente il vostro programma. Quindi da quella cosa l√¨ dovete proteggervi voi, ragionando. Non √® particolarmente difficile in questo caso: bisogna droppare <code>tx</code>.</p>
<p>Il vantaggio dei <em><strong>deadlock</strong></em> √® che sono <strong>ripetibili</strong> e quindi li potete debuggare, a differenza delle <em><strong>interferenze</strong></em> che sono irripetibili.</p>
<p>Notate che nella maggior parte dei casi i deadlock sono ripetibili (in questo esempio qui √® assolutamente ripetibile), ma possono esserci situazioni in cui <em>ogni tanto</em> va in deadlock.</p>
<p>In quei casi l√¨ bisogna difendersi un po' meglio. L'<em>"ogni tanto va in deadlock"</em> nasce quando cerco di prendere due lock in sequenza ‚Äî <em>chiedo il primo, chiedo il secondo.</em>
Se c'√® qualcun altro che chiede gli stessi due lock in ordine inverso, ecco a quel punto l√¨ ci bloccheremmo: <em>io aspetto che tu rilasci il secondo lock (mentre posseggo il primo), e tu aspetti che io rilasci il primo lock (mentre possiedi il primo), quindi non ne uscieremo mai.</em></p>
<p>In ogni caso, siccome il programma √® bloccato, posso connettergli un debugger e andare a vedere dove √® bloccato. Potendogli connettere un debugger e andare a vedere dove, mi faccio un'idea del perch√© si blocca.</p>
<p>Almeno lui √® fermo l√¨, e quindi riesco a vedere in che riga sta aspettando e di l√¨ mi faccio un po' di ragionamenti per vedere come toglierla. Invece le interferenze avvengono al tempo t, ma le loro conseguenze si vedono al tempo t pi√π delta.</p>
<h2 id="52-canali-sincroni"><a class="header" href="#52-canali-sincroni">5.2 Canali sincroni</a></h2>
<p><img src="images/concorrenza/image%2066.png" alt="image.png" /></p>
<p>I canali fatti cos√¨ sono <em>unbounded</em>. Cio√® se invece di mandare tre messaggi ne mandiamo tre milioni, √® possibile che il sender scriva tre milioni sul canale prima che il receiver inizi a leggere anche solo il primo. Non ci sono vincoli.</p>
<p>In certe situazioni non √® quello che vogliamo, perch√© potrebbe crearsi una situazione in cui occupiamo una montagna di memoria senza neanche sapere bene per quale motivo. Perch√© sostanzialmente noi ci aspetteremmo che il receiver parta pressoch√© subito.</p>
<p>Allora possiamo generare della cosiddetta <em><strong>back pressure</strong></em>, ovvero possiamo fare in modo che se il receiver per qualche motivo √® lento, allora chi manda abbia buffer per un po' (perch√© √® giusto per compensare gli sbalzi), ma poi dopo un po' si ferma, perch√© dice <em>"Ma se tu non le ricevi che senso ha che continuo a mandarteli?".</em></p>
<p>Questo lo facciamo semplicemente usando la funzione <code>sync_channel</code>, invece di usare la funzione <code>channel</code>. Per il resto √® tutto identico.</p>
<p><code>sync_channel</code> ha un unico parametro che √® un numero: ci dice quanti messaggi possono stare nel buffer al massimo. Se il sender manda pi√π cose dello spazio disponibile si blocca, e aspetta che il canale si svuoti.</p>
<p>Quindi il criterio del <code>sync_channel</code> √® semplicemente: <em>nel momento in cui non c'√® pi√π spazio, aspetti.</em></p>
<p>Facciamo una prova rapida, tornando all‚Äôesempio di prima.</p>
<p><img src="images/concorrenza/image%2067.png" alt="image.png" /></p>
<p>Cambiamo la riga in cui costruiamo il canale, e da <code>channel</code> lo facciamo diventare <code>sync_channel</code>. Gli dobbiamo dire quanti messaggi possono stare nel canale, al massimo. Diciamo uno: al massimo c'√® una stringa l√¨ dentro.</p>
<p>Questo ci far√† vedere che se adesso lanciamo, necessariamente uno scrive e l'altro legge. In realt√† ne vedremo due probabilmente di fila perch√© noi la <code>println!</code> la facciamo prima di provare a fare <code>tx.send</code>. Quindi pu√≤ anche darsi che vediamo tre tentativi di scrivere: ‚ÄúThread 1 sending 0‚Äù, ‚ÄúThread 1 sending 1‚Äù, ‚ÄúThread 1 sending 2‚Äù, ma in realt√† non sta mandando un bel niente perch√© poi chiama la <code>send</code>, e l√¨ aspetta perch√® il buffer √® pieno.
Il fatto che si vedano le stampe di seguito anche se concettualmente non √® possibile, √® dovuto al fatto che la <code>println!</code> √® asincrona rispetto alla console.
E inoltre la stampa <em>‚ÄúGot Message‚Äù</em> del receiver pu√≤ spuntare <em>dopo</em> una stampa <em>‚ÄúThread 1 Sending‚Äù</em> successiva.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let (tx, rx) = sync_channel::&lt;String&gt;(1);
	let mut handles = vec![];
	
	for t in 1..4 {
		let tx = tx.clone();
		
		handles.push(thread::spawn(move || {
			for i in 0..3 {
				println!("Thread {t} sending {}", i);
				if tx.send(format!("Message {}.{}", t, i)).is_err() {
					println!("Aborting...");
					return;
				}
			}
			println!("Thread {t} is done!");
		}));
	}
	
	drop(tx);
	handles.push(thread::spawn(move || { 
		while let Ok(v) = rx.recv() {
			println!("Got {}", v);
		}
		println!("Receiver done!");
	}));
	
	for h in handles {
		j.join().unwrap();
	}
}</code></pre></pre>
<p><img src="images/concorrenza/image%2068.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2069.png" alt="image.png" /></p>
<p>Ok, allora:</p>
<ul>
<li>Thread 1 manda 0</li>
<li>Thread 1 manda 1</li>
<li>Thread 2 manda 0</li>
<li>Thread 3 manda 0</li>
</ul>
<p>Questo ci fa capire che thread 1 ha mandato 0, che √® finito nel buffer, e quindi subito dopo ha provato a mandare 1 e si √® bloccato. Nel frattempo √® partito il thread 2 che ha cercato di inserirci 0 e si √® bloccato perch√© il buffer √® ancora occupato. Poi √® partito thread 3 che ha cercato di mettere 0 e anche lui si √® bloccato.</p>
<p>Nel frattempo si √® svegliato il receiver che finalmente si √® mangiato il primo messaggio. <strong>Non fa neanche a tempo a scriverlo che se l'√® mangiato</strong> (tramite la stampa <code>Got Message 1.0</code>) che l'effetto di esserselo mangiato √® che il thread 1, che era l√¨ in coda, √® riuscito a infilare 1 nel canale, per procedere poi subito a fare una nuova stampa.</p>
<p>E quindi vediamo qui "Thread 1 Sending 2", che √® la conseguenza del fatto che il receiver si √® mangiato il messaggio originale, e ce lo stampa alla riga subito dopo <code>Got Message 1.0</code>. E subito dopo ci dice anche <code>Got Message 1.1</code>. E quindi i primi due sono stati consumati.</p>
<p><em>Nel frattempo cosa √® capitato?</em>
Che c'erano in coda a spingere sia il <strong>thread 2</strong> che il <strong>thread 3</strong>, che erano gi√† pronti l√¨ con il loro dato, ma non potevano entrare. E gli va bene perch√© uno dei due, in questo caso <strong>thread 3</strong>, riesce a passare davanti e lo deposita.
Lo deposita e a questo punto prova a depositare il successivo.
Gli va ancora bene perch√© il receiver √® attivo e quindi come lo deposita il receiver lo mangia subito, e quindi thread 3 riesce anche a depositare il secondo. E quindi vediamo <code>Got Message 3.0</code> e <code>3.1</code>.</p>
<p>Nel frattempo il buffer si √® di nuovo svuotato, a questo punto <strong>thread 1</strong> ha finito di mandare le sue cose e si √® tolto dai piedi. <strong>Thread 3</strong> anche lui √® riuscito a mandare buona parte delle cose e riesce a entrare a <strong>thread 2</strong>. Che manda finalmente <code>2.0</code> e poi cercherebbe di mandare <code>2.1</code>, ma nel frattempo c'era il <strong>thread 3</strong> con l'ultimo messaggio che entra, si toglie dai piedi, e a questo punto vediamo <code>2.1</code> e <code>2.2</code>. A quel punto sono morti tutti, e il ricevitore se n'√® andato.</p>
<p><strong>Quindi creando un canale cos√¨, gli diamo un vincolo.</strong> Io potrei addirittura farlo diventare di <strong>0</strong>.</p>
<p><em>Cosa succede se lo faccio di dimensione <strong>0</strong>?</em>
Succede che <em>non c'√® buffer</em>. Se io cerco di scrivere, aspetto fino a che in contemporanea a me non entra anche l'altro che legge: dobbiamo necessariamente incontrarci. Per questo motivo un <code>sync_channel</code> di <strong>0</strong> viene chiamato un <em><strong>rendezvous</strong></em> ‚Äî <em>un incontro</em>.</p>
<p><em>Ci passiamo l'oggetto di mano: io te lo d√≤ non perch√© lo appoggio qui e tu lo prendi, ma te lo d√≤ in mano.</em> <em>Quindi dobbiamo essere tutti e due presenti. Finch√© tu non ci sei io non te lo posso depositare.</em></p>
<h3 id="521-esempio-con-buffer-di-dimensione-0"><a class="header" href="#521-esempio-con-buffer-di-dimensione-0"><strong>5.2.1 Esempio con buffer di dimensione 0</strong></a></h3>
<p><img src="images/concorrenza/image%2070.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2071.png" alt="image.png" /></p>
<p>Dopo la ricompilazione, vediamo che tutti e tre i thread provano a mandare e rimangono fermi. In realt√† il thread 1 √® il primo che √® entrato. Quando finalmente arriva il ricevitore, si prende un pezzo - prima da thread 1 e poi da thread 3. Vediamo quindi <code>Got Message 1.0</code>, <code>Got Message 3.0</code>. E thread 1 e thread 3 tornano subito per passare un altro dato (<code>Thread 1 Sending 1</code> e <code>Thread 3 Sending 1</code>).
Poi riesce ad entrare <code>2.0</code>, poi <code>3.1</code>, poi <code>1.1</code>, poi <code>2.1</code> e cos√¨ via fino alla conclusione.</p>
<p><em>Anche qui potremmo chiederci: ma <code>Got Message 3.0</code> non dovrebbe avvenire prima del <code>Thread 3 Sending 1</code>?</em>
<strong>Attenzione:</strong> <code>Sending</code> lo scriviamo prima della <code>send</code>, mentre <code>Got Message</code> lo facciamo dopo la <code>receive</code>. Quando avviene la receive, si libera lo spazio, <strong>ma pu√≤ verificarsi un thread switching.</strong>
√à quindi possibile vedere prima la stampa che mostra la conseguenza dello spazio liberato (<code>Thread 3 Sending 1</code>) prima che l'altro thread comunichi di aver preso il dato (<code>Got Message 3.0</code>).</p>
<p>Quindi la stampa di 3,1 invia 1, la stampa di 3,3 di 1, e poi 3,1 effettivamente scrive l'1 sul canale. Questo accade perch√©, guardando il codice, <code>println!</code> √® prima della <code>send</code> ‚Äî quindi pu√≤ essere eseguita subito, senza vincoli. Poi per√≤ il thread si ferma l√¨ (righe 11 e 15).</p>
<h3 id="522-conclusioni-sui-canali-sincroni"><a class="header" href="#522-conclusioni-sui-canali-sincroni">5.2.2 Conclusioni sui canali sincroni</a></h3>
<p><strong>Quindi, i sync channel fissano una dimensione del buffer.</strong>
Ci sono casi in cui si pu√≤ mettere 0, ma di solito si mette un numero ragionevole: 10, 20, 50. <em>Perch√©?</em> Perch√© il buffer serve ad armonizzare <em><strong>l'andamento relativo</strong></em>. Quei numeri l√¨ si trovano di solito per sperimentazione nel momento in cui abbiamo l'algoritmo giusto, e allora si prova a vedere, cambiandoli un po', se si possono migliorare in media le prestazioni. Ma il presupposto √® che l'algoritmo sia giusto a priori.</p>
<h2 id="53-la-libreria-crossbeam"><a class="header" href="#53-la-libreria-crossbeam">5.3 La libreria Crossbeam</a></h2>
<p><img src="images/concorrenza/image%2072.png" alt="image.png" /></p>
<p><strong>I canali nella libreria standard di Windows</strong> sono canali strettamente <em>multiple producer, single consumer</em> (<strong>MPSC</strong>).</p>
<p>Altre librerie ci forniscono comportamenti diversi. Qui in particolare diamo spazio a una libreria che si chiama <strong>Crossbeam</strong>, che ha dentro di s√© una serie di astrazioni, tutte molto interessanti nel contesto della programmazione concorrente.</p>
<p>L'aspetto su cui vogliamo mettere l'accento, al di l√† delle tante strutture che sono citate qua dentro, sono i <strong>canali offerti da Crossbeam</strong>. Per poter usare Crossbeam bisogna metterlo tra le dipendenze nel cargo.toml. Nel momento in cui lo aggiungo alle dipendenze, posso usarlo nel progetto. I suoi canali, a differenza di quelli standard che sono <em>multiple producer, <strong>single</strong> consumer</em>, sono di tanti tipi.</p>
<p><img src="images/concorrenza/image%2073.png" alt="image.png" /></p>
<p>In particolare ci sono canali anche <em>multiple producer, <strong>multiple</strong> consumer</em>, dove cio√® <strong>anche il ricevitore pu√≤ essere clonato</strong>.</p>
<p><em>Come funzionano i canali multiple consumer?</em> <strong><em>Il messaggio √® sempre consumato una volta sola</em>.</strong> Se ci sono due a leggerlo, quel messaggio l√¨, a caso, verr√† letto o dal lettore 1 o dal lettore 2.
Nel senso che se ci sono pi√π lettori che insieme cercano di mangiarsi quella cosa l√¨, a caso, oppure il primo che √® arrivato, si recuperer√† il messaggio letto e l'altro aspetta il successivo.</p>
<p>Quindi si usano i multiple receiver in quelle situazioni in cui mi sta bene di non sapere a priori chi √® che consuma un certo messaggio.</p>
<p><em>Perch√© questo √® interessante?</em>
Perch√© mi abilita una serie di <strong>pattern di programmazione concorrente</strong> in cui posso organizzare il mio lavoro. Ce ne sono tre che vediamo qua dentro:</p>
<ul>
<li><strong>Fan-Out / Fan-In</strong></li>
<li><strong>Pipeline</strong></li>
<li><strong>Producer / consumer</strong></li>
</ul>
<h3 id="531-fan-out--fan-in"><a class="header" href="#531-fan-out--fan-in">5.3.1 Fan-Out / Fan-In</a></h3>
<p><img src="images/concorrenza/image%2074.png" alt="image.png" /></p>
<p>Il <strong>Fan-Out / Fan-In</strong> si usa in quelle situazioni in cui io ho una sorgente di dati che produce delle informazioni di qualche tipo.</p>
<p>Qui vediamo un esempio di tali situazioni.
Nel disegno, il filo ad elica √® un thread, √® il filo del thread che si dipana. Quindi ho un thread che fa da producer e che genera su un canale una sequenza di valori: sono quei quadratini azzurri messi l√¨ nel canale.</p>
<p>Questi valori, prima di poter essere davvero usati, hanno bisogno di subire una qualche trasformazione. Ad esempio, quelli l√¨ potrebbero essere delle <strong>coordinate GPS</strong>. Io ho il <strong>producer</strong>, √® un ricevitore GPS, con la sua radio e tutte quelle cose l√¨, e ogni secondo ti tira fuori una posizione nuova. Io voglio archiviare queste posizioni su un <strong>database</strong>, corredandole per√≤ non solo della <em>latitudine e longitudine</em>, che √® quello che mi dice il ricevitore GPS, ma anche del <strong>nome della via</strong> e il <strong>numero civico</strong>. Qui √® <em>Via Roma 33</em>. Qui invece hai girato, e sei finito in <em>Via Garibaldi 1</em>.</p>
<p>Quindi mi interessa <strong>arricchire</strong> quelle informazioni. Arricchire quelle informazioni √® un'operazione <strong>potenzialmente lenta</strong>, perch√© devo cercare in un grosso database, per cercare di matchare quel punto l√¨ a quali altri punti si trova vicino, e devo selezionare il pi√π vicino di quelli che ho dotato di via e numero civico. E quindi ci pu√≤ mettere tempo.</p>
<p>Allora, siccome voglio evitare di fare la somma di tutti questi tempi, perch√© quello che succederebbe √® che la coda si riempirebbe, e o vado in <strong>overflow</strong>, se il canale √® <em>unbounded</em>, oppure se lo faccio <em>bounded</em>, perdo dei punti dal GPS, perch√© a un certo punto cerco di depositare una cosa, ma il mio elaboratore non √® abbastanza rapido ad arricchirmelo con l'informazione che mi serve, e quindi lo perdo.</p>
<p><em>Allora cosa faccio?</em>
Ipotizzando che il tempo necessario a decorare il mio dato con l'arricchimento sia, diciamo, di <strong>5 volte</strong> il tempo della produzione, mi preparo <strong>6 worker</strong>, o anche 7, o anche 10, <em>in modo da averne un po' di pi√π</em>. Cos√¨ da, in media, cercare di stare nel tempo voluto.</p>
<p>E cosa fa il <strong>producer</strong>? Il producer scrive strettamente in ordine i suoi numeri, che tanto hanno un timestamp. Poi ho un <strong>gruppo di worker</strong>, cio√® un gruppo di thread, ognuno indipendente dagli altri, che lottano per strappare dal canale d'ingresso un messaggio. Appena si appropriano di un messaggio, fanno la <em>ricerca nel database</em>, lo decorano con l'indirizzo, e lo sbattono in uscita.</p>
<p>Ovviamente non √® detto che escano nello stesso ordine con cui sono entrati, perch√© i messaggi io li ho scritti <code>1, 2, 3</code>, poi siccome il tempo di arricchimento pu√≤ essere variabile per un insieme di motivi, pu√≤ darsi che mi escano <code>3, 1, 2</code>. Non √® un grosso problema. Il <strong>consumer finale</strong> √® poi responsabile di riordinarli.</p>
<p>Quindi un pattern del genere mi permette di avere <strong>n worker</strong>, che di per s√© sono identici, fanno esattamente lo stesso mestiere, ma siccome lo fanno in parallelo (perch√© io posso sfruttare <em>n CPU</em> che ho a disposizione), riescono a compensare il fatto che l'operazione che fanno √® lenta rispetto al tasso con cui io spedisco delle cose. Quindi in media io ho in uscita un pacchetto ogni volta che ho un pacchetto in ingresso, con il possibile riordinamento.</p>
<blockquote>
<p>üí° <strong>Curiosit√† sulla gestione dei thread tramite priorit√†</strong></p>
<p>L‚Äôidea di gestire l‚Äôordine con cui i thread fanno le cose con un meccanismo di priorit√† si pu√≤ fare, ma in generale √® un'idea <strong>pessima</strong>.
Gli scheduler hanno il concetto di <em>priorit√†</em>. Ma la priorit√†, nel momento in cui la assegno, mi divide i thread runnable in classi. Ci sono i runnable a priorit√† massima, che passano sempre e comunque davanti ai runnable di priorit√† pi√π bassa della loro.</p>
<p>Questa cosa qua sembra banale e ovvia, ma nasconde un <strong>piccolo problema</strong>, che si chiama <em><strong>priority inversion</strong></em>.
Potrebbe capitare in un momento che di cosa d'alta priorit√† non ce n'√® nessuna. Perfetto. E allora guardo quelli di priorit√† pi√π bassa. A priorit√† media non c'√® di nuovo nessuno. Perfetto di nuovo. Passo a quelli di priorit√† ancora pi√π bassa. A priorit√† bassissima ce ne sta uno. Magnifico. Lo lancio, tanto se avessi bisogno di far qualcosa di pi√π urgente, lo sospenderei immediatamente, perch√© come mi arriva qualcuno pi√π urgente, lo mollo l√¨ e passo all'urgente.</p>
<p>Quello l√¨ a <em>bassa priorit√†</em> potrebbe prendere un <strong>lock</strong>. Prende il lock e comincia a fare. Mentre possiede il lock, mi arriva uno ad <em>alta priorit√†</em>. Quindi lui lo congelo l√¨, con il suo lock in mano, perch√© non so a che punto √® arrivato, e mi metto a prendere in considerazione quello ad alta priorit√†.</p>
<p>Quello ad <em>alta priorit√†</em> vuole quello stesso lock. E <strong>non posso darglielo</strong>. Non posso darglielo perch√© ce l'ha quello a bassa priorit√†. E quindi, quello ad alta priorit√† si ferma necessariamente, va in stato <em>non runnable</em>, perch√© per il momento non c'√® il lock, e torna <em>runnable</em> quello a bassa priorit√†. Mentre sta ancora andando avanti, supponiamo che abbia 3 o 4 cose da fare, mentre sta ancora andando avanti, si presenta uno a <em>media priorit√†</em>. A questo punto, quello a media priorit√†, di nuovo, ha la prevalenza su quello a bassa, che di nuovo viene congelato, quindi il lock resta inaccessibile, e quello a media comincia a fare i fatti suoi. Supponiamo ora che quello a media priorit√† vada avanti per un'ora. <strong>Questo √® un grosso problema</strong>.</p>
<p>In questo modo, la prima missione su Marte √® fallita. La prima missione su Marte ha mandato un <strong>rover</strong>, che aveva un <strong>sistema operativo real-time a priorit√†</strong>, e aveva dei task ad <em>alta priorit√†</em>, a <em>media priorit√†</em>, a <em>bassa priorit√†</em>. Il rover √® atterrato su Marte, ha cominciato a fare cose, e si √® piantato. Ma ci hanno messo <strong>3 giorni</strong> quelli della NASA a capire perch√© si era piantato: si era verificata la <em><strong>priority inversion</strong></em>.</p>
<p>Per questo motivo i moderni sistemi operativi, la priorit√† di un thread, la legano <strong>dinamicamente</strong>. Cio√® tu lo battezzi a bassa priorit√†. Nel momento in cui possiedi un <em>lock</em>, e su quel lock si mette in attesa qualcuno a priorit√† maggiore della tua, temporaneamente ti trasferisce questa cosa. E quindi questo permette al task, che normalmente sarebbe a bassa priorit√†, poich√© sta possedendo un lock su cui c'√® in attesa qualcuno pi√π urgente, di dire <em>"va bene, allora, proprio perch√© questa cosa serve a lui che √® pi√π urgente, tu finisci e togliti in fretta dai piedi"</em>. E quello che √® medio aspetta. Ma qusta cosa √® crea una serie di turbe. Motivo per cui l'uso delle priorit√† sulle schedulazioni, va fatto con <em>tantissima, tantissima consapevolezza</em>. Questa cosa √® costata <strong>qualche milione di dollari</strong> alla NASA.</p>
</blockquote>
<p>Dunque, il meccanismo del <strong>Fan-Out / Fan-In</strong> √®: <em>sfrutto il fatto che ho un'operazione lenta, che richiede tempo, che tenderebbe a ritardarmi troppo il canale di ingresso, quindi ne metto una serie in parallelo, in modo tale che il tasso medio di uscita sia compatibile col tasso medio di ingresso.</em>
Se l'operazione fatta dal <strong>worker</strong> dura, diciamo, <em>dieci volte</em> il tempo medio in cui mi entra un nuovo messaggio, io di worker ne devo mettere <strong>venti</strong>, per essere tranquillo.</p>
<p><img src="images/concorrenza/image%2075.png" alt="image.png" /></p>
<p>Qui vediamo come si implementa. In realt√† √® banale, semplicemente perch√© con i <strong>canali di Crossbeam</strong>, io non solo posso clonare il <code>tx</code>, posso clonare anche l'<code>rx</code>. E potendo clonare anche l'<code>rx</code>, riesco a farmi quanti ricevitori voglio.</p>
<h3 id="532-pipeline"><a class="header" href="#532-pipeline">5.3.2 Pipeline</a></h3>
<p><img src="images/concorrenza/image%2076.png" alt="image.png" /></p>
<p>Secondo pattern alquanto comune, √® il <strong>pattern della pipeline</strong>.</p>
<p>Nella pipeline io ho una serie di fasi. Prendo un oggetto che ha una certa forma, gli faccio delle operazioni, poi lo produco e lo metto in uscita. Su ciascuno di queste cose faccio delle ulteriori trasformazioni e lo passo avanti e cos√¨ via, fino a dargli l'aspetto finale che mi interessa. Questo mi serve perch√© le varie <em>fasi intermedie</em> possono avere delle logiche pi√π o meno complesse e quindi io posso tenere ben separati i compiti che sto svolgendo, usando il <strong>buffer dei singoli canali</strong> <strong>come ammortizzatore</strong>. Perch√© a volte magari <em>stage 1</em> √® veloce e <em>stage 2</em> √® lento, a volte √® il contrario e in media si compensano grazie al fatto che i canali sono abbastanza elastici.</p>
<p>Quando uso la pipeline, mediamente faccio attenzione a generare della <strong>back pressure</strong>. Perch√© se mai si piantasse uno qualunque degli stadi intermedi o lo stadio finale, il produttore non ne saprebbe niente e continuerebbe a produrre, produrre, produrre, e dopo un po' questa cosa scoppia. Per cui si usano dei <strong>canali sync limitati</strong>, anche grossi, ma comunque limitati.</p>
<p><img src="images/concorrenza/image%2077.png" alt="image.png" /></p>
<p>Qua c'√® un esempio. Vedete infatti che qui vengono usati i <em>canali bounded</em>. Nel main vediamo <code>let (tx_input, rx_input) = bounded::&lt;i32&gt;(10)</code> ‚Äî voglio un canale che trasporta degli interi, che al massimo ne tiene 10. E cos√¨ via.</p>
<h3 id="533-producer--consumer"><a class="header" href="#533-producer--consumer">5.3.3 Producer / Consumer</a></h3>
<p><img src="images/concorrenza/image%2078.png" alt="image.png" /></p>
<p>Infine, l'ultimo dei pattern che possiamo vedere √® quello <em><strong>producer and consumer</strong></em>.</p>
<p>Qua di nuovo sfruttiamo un <strong>canale</strong> come strumento per distribuire del lavoro tra un certo numero di cose. Questo √® il pattern che normalmente si usa, ad esempio, per l'implementazione dei <strong>thread pool</strong>.</p>
<p><em>Cos'√® un thread pool?</em>
Un thread pool √® un <em>insieme di thread</em> che sono destinati a fare il lavoro che altri non vogliono fare. Ovvero, di base, loro aspettano di ricevere una descrizione, diciamo l'indirizzo della funzione da chiamare, su un canale. Aspettano. Nel momento in cui qualcuno gli dice <em>"C'√® questa cosa da fare: chiama la funzione a questo indirizzo‚Äù</em>. Loro ricevono dal canale l'indirizzo, che alla fine √® un numero, e poi invocano quella funzione l√¨.
Invocandola, la funzione viene eseguita nel contesto del <em>thread ricevitore</em> che fa tutte le sue cose. Normalmente quella l√¨ √® una funzione che non ha argomenti e non ritorna un bel niente, quindi ha <strong>effetti collaterali</strong> di varia natura. Ci pu√≤ richiedere tanto o poco tempo, non ha importanza.
Non appena finiscono di eseguire quella funzione tornano sul canale a vedere se c'√® un'altra cosa da fare.</p>
<p>Quindi i thread pool sono i <em>servi dei nostri programmi</em>. Li dimensioniamo con un numero di thread sufficienti per il livello di parallelismo che riteniamo la nostra macchina abbia. Ad esempio il numero di <strong>core fisici</strong>. Se io sto girando su una macchina che ha 4 core, perfetto, creo un thread pool con 4 thread. Che di base sono fermi, perch√© tutti e 4 cercherebbero di prendere del codice da eseguire e non ricevono nulla. Quando per√≤ l'algoritmo principale ha qualcosa da fare, la affida al thread pool: fa una <em>dispatch</em>, cio√® manda sul canale l'indirizzo della funzione da chiamare. E a quel punto sa che prima o poi verr√† chiamata. Questa funzione normalmente sar√† progettata con degli effetti collaterali, in modo che l'algoritmo principale possa capire quando finalmente ha finito. E vanno avanti cos√¨.</p>
<p>Allora l'uso dei canali <strong>multiple producer, multiple consumer</strong> va benissimo, perch√© qualunque thread pu√≤ affidare cose da fare, pu√≤ diventare un <em>producer</em>, e tipicamente i thread che formano il thread pool fanno da <em>consumer</em>. Stanno in attesa di ricevere cose da fare.</p>
<p><img src="images/concorrenza/image%2079.png" alt="image.png" /></p>
<p>E qui vediamo l'esempio di questo pattern.</p>
<h3 id="534-il-modello-degli-attori"><a class="header" href="#534-il-modello-degli-attori">5.3.4 Il modello degli attori</a></h3>
<p><img src="images/concorrenza/image%2080.png" alt="image.png" /></p>
<p><strong>Il modello degli attori</strong> √® un altro pattern che esiste, anche se oggigiorno √® messo un po' in discussione per un insieme di fattori. Questo modello √® implementato dalla libreria <strong>Actix</strong>. Actix √® una libreria molto grande, che ha varie declinazioni. Pi√π rilevante √® la declinazione <strong>Actix web</strong>, che implementa fondamentalmente il comportamento di un web server. Nella declinazione semplice, Actix soltanto, mette a disposizione il modello degli attori, dove l'<em>attore</em> √® un oggetto che possiede anche un thread.</p>
<p>Questo modello risale alla <strong>visione originale della programmazione a oggetti</strong>, cos√¨ come era nata alla fine degli anni '60, inizio degli anni '70, pensando che l'oggetto fosse una cosa attiva che riceve messaggi. Per questo motivo a volte si dice <em>"mando un messaggio a quell'oggetto"</em>, perch√© nella visione originale gli oggetti avevano un loro thread che consumava messaggi e agiva di conseguenza. E le chiamate tra oggetti non erano in realt√† vere invocazioni, come le usiamo oggigiorno, ma erano depositare nella lista delle cose che l'altro doveva fare un messaggio, affinch√© l'altro poi facesse.</p>
<h1 id="6-riferimenti"><a class="header" href="#6-riferimenti">6. Riferimenti</a></h1>
<p><img src="images/concorrenza/image%2081.png" alt="image.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processi---malnati-26"><a class="header" href="#processi---malnati-26">Processi - Malnati 26 <!-- omit in toc --></a></h1>
<h1 id="indice-16"><a class="header" href="#indice-16">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="17-processi_parte_1.html#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="17-processi_parte_1.html#11-processi-in-windows">1.1 Processi in Windows</a></li>
<li><a href="17-processi_parte_1.html#12-processi-in-linux">1.2 Processi in Linux</a></li>
<li><a href="17-processi_parte_1.html#13-creazione-di-processi">1.3 Creazione di processi</a>
<ul>
<li><a href="17-processi_parte_1.html#131-esempio">1.3.1 Esempio</a></li>
</ul>
</li>
<li><a href="17-processi_parte_1.html#14-fork-e-thread">1.4 <code>fork()</code> e thread</a>
<ul>
<li><a href="17-processi_parte_1.html#141-esempio">1.4.1 Esempio</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="17-processi_parte_1.html#2-processi-in-rust">2. Processi in Rust</a></li>
</ul>
<p>La parte sui processi √® assolutamente pi√π semplice, perch√© in realt√† la maggior parte della complessit√† deriva proprio dalla concorrenza, che per√≤ √® stata gi√† abbastanza vista nel momento in cui abbiamo trattato i thread.</p>
<h1 id="1-introduzione-11"><a class="header" href="#1-introduzione-11">1. Introduzione</a></h1>
<p><img src="images/processi/image.png" alt="image.png" /></p>
<p><em>Cos'√® un processo?</em>
√à lo strumento col quale il sistema operativo garantisce che possano essere eseguite applicazioni distinte senza che si pestino i piedi reciprocamente e lo fa fondamentalmente <strong>isolando gli spazi di indirizzamento</strong>. Quindi un processo √® un programma in esecuzione che ha un suo spazio di indirizzamento all'interno del quale vengono ricavati gli stack, lo heap eccetera, e all'interno del quale sono presenti uno o pi√π thread.</p>
<p>Il processo ha una sua identit√† a livello di sistema operativo garantito da un codice univoco, il <strong>process ID (PID)</strong>, e ha associato uno <em><strong>stato</strong></em>, ovvero pu√≤ essere in esecuzione oppure terminato. Quando un processo diventa terminato, questo processo restituisce un codice che ha una certa struttura. Tipicamente il codice di uscita di un processo viene utilizzato per comprendere se quel processo √® morto bene o √® morto male, quindi rappresenta sostanzialmente un codice d'errore.</p>
<p>Il principio di assegnare a ciascun processo uno spazio di indirizzamento √® alla base dell'<strong>isolamento</strong>, che garantisce fondamentalmente che due processi non si impiccino troppo. Notate che l'isolamento offerto dai processi √® <strong>limitato</strong>, <em>perch√©?</em> Perch√© in realt√† √® vero che nello spazio di indirizzamento ognuno fa quello che vuole e gli altri non possono vedere, ma tutti i processi hanno <em>risorse comuni</em>:</p>
<ul>
<li><strong>Tutti vedono lo stesso file system</strong>
Quindi se ad esempio il processo 1 crea un file e il processo 2 lo distrugge, si impicciano.</li>
<li><strong>Tutti i processi vedono lo stesso stack di rete</strong>
Quindi se il processo 1 crea una socket in ascolto sulla porta 80, il processo 2 non pu√≤ creare un‚Äôaltra socket sulla porta 80, e quindi si impicciano.</li>
</ul>
<p>Tutti i processi vedono le stesse librerie condivise, ovvero il codice eseguibile che viene mappato all'interno di un processo in parte √® l'eseguibile specifico, e in parte √® contenuto in <strong>librerie condivise</strong> che si chiamano <strong>DLL</strong> dentro Windows, si chiamano <strong>SO</strong> (Shared Object) nel mondo Unix-like, ma sostanzialmente sono pezzi aggiuntivi che vengono messi insieme alla parte di codice nello spazio di indirizzamento.</p>
<p>Il problema √® che queste librerie hanno una <em>versione</em>. Se io ho in esecuzione un programma che vuole caricare la libreria <code>libm</code>, responsabile della matematica, e ha bisogno della <strong>versione 32</strong>, ma poi ho un altro processo che quando si √® installato mi ha caricato la <strong>versione 35</strong> che non √® pi√π compatibile con la 32, il file <code>libm[.](http://ibem.so/)so</code> viene trovato (nella relativa cartella di sistema, a seconda del sistema operativo), ma √® la versione sbagliata e quindi quando poi vado a cercare dentro di mappare le funzioni che devo chiamare magari non le trovo, o le trovo fatte in un modo diverso da come me le aspetto, quindi si impicciano.</p>
<p>Quindi la vita dei processi non √® cos√¨ ben isolata, motivo per cui oggi giorno vengono distribuiti come unit√† di esecuzione i <em><strong>container</strong></em> piuttosto che i processi. Il container sfrutta la capacit√† che i kernel hanno di separare i diversi ambiti (l'insieme degli utenti, l'insieme del file system, lo stack di rete, l'uso delle risorse e cos√¨ via) in <strong>namespace indipendenti</strong> e sfruttano del kernel del sistema operativo soltanto la sua capacit√† di scheduling, affidando poi a componenti totalmente disgiunti il resto delle astrazioni offerte dalla macchina. Questo permette di avere un insieme di processi apparentemente isolati, ognuno con il proprio <em>indirizzo IP</em> associato, indipendente l'uno dall'altro, ognuno con il suo insieme di <em>porte</em>, ognuno con le sue <em>DLL</em> e cos√¨ via, che possono convivere sulla stessa macchina abbattendo i costi di configurazione, facilitando la convivenza tra cose molto eterogenee tra di loro.</p>
<p><img src="images/processi/image%201.png" alt="image.png" /></p>
<p>Il criterio dell'<strong>isolamento</strong> dovuto al fatto che due processi hanno spazi di indirizzamento separati, in alcune situazioni √® un impiccio, <em>perch√©?</em> Perch√© impedirebbe a due programmi distinti, ad esempio <em>Word</em> ed <em>Excel</em>, di scambiarsi dei dati, se non passando attraverso un file, che per√≤ √® una cosa poco efficiente. Affinch√® voi possiate fare <strong>copia</strong> su Word e <strong>incolla</strong> su Excel, bisogna che ci sia un pezzo di memoria condiviso, perch√© quando faccio <em>‚Äúcopia‚Äù</em> devo scrivere da qualche parte questa cosa che sto copiando, e devo andare a finire su una qualche zona che Excel possa vedere, se no su Excel come ce lo faccio l'<em>‚Äúincolla‚Äù</em>?</p>
<p>Per questo motivo i sistemi operativi, se da un lato <strong>isolano i processi</strong> assegnando loro spazi di indirizzamento disgiunti, dall'altro offrono alcune <strong>primitive</strong> che permettono di muovere dei dati da uno spazio all'altro. Queste primitive hanno caratteristiche diverse e cadono dentro un nome pi√π ampio che va sotto la sigla di <strong>IPC</strong> (<em>Inter Process Communication</em>). Qua le differenze tra sistemi operativi diventano molto grandi. Anche nel concetto stesso di processo le differenze sono molto grandi. E il modello adottato dai sistemi Unix ha poca analogia col modello adottato dal sistema Windows.</p>
<p><img src="images/processi/image%202.png" alt="image.png" /></p>
<p>Ci√≤ che rende un po' parenti il concetto di processo e il concetto di thread √® che <strong>ogni processo ha associato almeno un thread</strong>. Nel momento in cui un processo non ha pi√π nessun thread associato, quel processo √® morto, e viene buttato via dal sistema operativo. All'atto della creazione di un processo, il sistema operativo si prende la responsabilit√† di allocare anche il <strong>thread principale</strong>. Questo thread principale potr√† poi creare thread ulteriori a proprio piacimento.</p>
<p>Nei primi momenti di vita dei sistemi <em>multi-user</em>, quindi quando Unix √® nato, negli anni '70, il processo era l'unit√† fondamentale anche di concorrenza. Se io dovevo creare un server di rete, dovevo necessariamente pensarlo multiprocesso. Oggigiorno noi troviamo ancora la programmazione multiprocesso in varie condizioni. In parte come scelta per facilitare la <strong>system integration</strong>, ovvero: <em>perch√© devo reinventarmi una cosa che gi√† esiste e tanto comoda?</em> In fondo posso delegare un altro programma, fare un pezzo per me e poi prendermi il suo risultato. √à quello che facciamo ad esempio quando compiliamo un programma: ci affidiamo al fatto che possiamo sfruttare il <em>compilatore</em> che traduce un file sorgente in un file oggetto e poi chiamare il <em>linker</em> che prende insieme vari file oggetto e ci produce un file eseguibile, senza bisogno di fondere queste cose in un unico oggetto. Quindi possiamo beneficiare col principio della <strong>separazione delle responsabilit√†</strong>, il compilatore √® molto bravo a fare un pezzo, il linker √® molto bravo a farne un altro e si appoggiano dei file intermedi per passarsi delle cose.</p>
<p>Altre volte sfruttiamo, come nel caso di <strong>Chrome</strong>, ad esempio, processi per motivi di <strong>security</strong>. Chrome, per ogni tab che voi create, crea un <em>processo separato</em>. Questo garantisce che eventuali vulnerabilit√† presenti all'interno delle librerie che usa (che potrebbero permettere potenzialmente a del codice malevolo di farsi i fatti del vostro pc), non possano fare danni. Semplicemente perch√© se anche a seguito di qualcosa io riesco a iniettare del javascript che lavora nel contesto di una delle tab, al meglio potr√≤ sapere che cosa c'√® in quella tab, ma non riesco a vedere le altre tab che cosa hanno, perch√© sono in <strong>processi separati</strong> e non ho l'accesso.</p>
<h2 id="11-processi-in-windows"><a class="header" href="#11-processi-in-windows">1.1 Processi in Windows</a></h2>
<p><img src="images/processi/image%203.png" alt="image.png" /></p>
<p>I processi si creano in modo molto distinto nei sistemi operativi, con filosofie distinte. In <strong>Windows</strong> si crea un processo con la system called <code>CreateProcess</code> o con la sua variante <code>CreateProcessEx</code>, che differiscono sostanzialmente nel numero di parametri che passiamo. Un processo creato in Windows richiede l'indicazione del eseguibile da caricare, quindi <code>CreateProcess</code> si prende la briga di fare diverse operazioni:</p>
<ul>
<li>Crea innanzitutto un nuovo <em>spazio di indirizzamento</em>, vuoto</li>
<li>All'interno di quello spazio di indirizzamento mappa il <em>file eseguibile</em> il cui nome gli abbiamo passato come parametro della <code>CreateProcess</code></li>
<li>Poi crea il <em>thread principale</em> all'interno di quel processo e lo avvia</li>
</ul>
<p>Quel thread principale punter√† alla funzione <code>crt_startup</code> o alla funzione <code>_winmain</code> che saranno responsabili a loro volta di chiamare il <code>main</code> della nostra applicazione vera e propria. Quindi inizializzeranno le strutture di supporto e poi faranno partire il resto. Questo fa si che il processo parte pulito, immagine esatta di quello che c'√® nell'exe che io ho caricato.</p>
<p>Questo processo trover√† dentro la propria memoria alcune <strong>handle gi√† presenti</strong>, in particolare potr√† contenere dei riferimenti ad alcuni <em>file</em> che sono stati precedentemente aperti e che gli sono resi disponibili oppure potr√† trovare riferimento rispetto a <strong>oggetti kernel</strong> come semafori, pipe, mutex, eventi. Potr√† anche trovare inizializzate delle <strong>variabili d'ambiente</strong>. Le variabili d'ambiente sono una mappa di <code>string</code> in <code>string</code> per cui ad esempio io ho la variabile d'ambiente <code>PATH</code> che ha come valore ad esempio: <code>C:/Windows;C:/Windows/System32;</code> etc‚Ä¶</p>
<p>Per√≤ quello che <em>non pu√≤ condividere</em> un processo figlio sono riferimenti a thread presenti nel processo padre, non potr√† contenere riferimenti a processi presenti nel processo padre, a librerie dinamiche o regioni di memoria presenti nel processo padre. Quindi c'√® un <strong>isolamento molto buono</strong>.</p>
<p><img src="images/processi/image%204.png" alt="image.png" /></p>
<p><img src="images/processi/image%205.png" alt="image.png" /></p>
<p>La funzione che crea un processo fa un po' di operazioni, e qua vediamo la <code>CreateProcess</code>, vedete che ha una valanga di parametri, ed √® la versione semplice perch√© se avessimo mostrato <code>CreateProcessEx</code>, di parametri questa ne ha ancora di pi√π.</p>
<h2 id="12-processi-in-linux"><a class="header" href="#12-processi-in-linux">1.2 Processi in Linux</a></h2>
<p><img src="images/processi/image%206.png" alt="image.png" /></p>
<p>Nel mondo <strong>Unix</strong> (mettendo insieme <strong>Linux</strong> ma anche <strong>BSD,</strong> <strong>macOS</strong> e cose del genere) i processi si creano con una system call che si chiama <code>fork</code>.</p>
<p>A differenza della <code>CreateProcess</code>, <code>fork</code> di parametri ne ha <strong>zero</strong>.</p>
<p><em>Cosa fa fork?</em> <strong><em>Duplica lo spazio di indirizzamento corrente</em>.</strong>
Quindi nel contesto di un processo che gi√† esiste e che ha il suo spazio di indirizzamento dentro cui c'√® uno <strong>stack</strong> (uno o pi√π stack), c'√® lo <strong>heap</strong>, ci sono le <strong>variabili statiche</strong>, ci sono le <strong>cose globali</strong>, ci sono le <strong>variabili di ambiente</strong>, etc‚Ä¶ questo processo viene duplicato: ne ho due copie totalmente indipendenti, ma identiche inizialmente.</p>
<p><code>fork</code> lascia il processo padre inalterato, nel processo figlio inietta un unico thread che si trova lo stack gi√† completamente popolato. <em>Perch√©?</em> Perch√© √® duplicazione dello stack che aveva chi nel processo padre ha invocato <code>fork</code>.</p>
<p><strong><code>fork</code></strong> esce e nel processo figlio riprende l'esecuzione dal valore ritornato dalla funzione stessa ‚Äî questo thread non parte da zero, ma nasce con una <em>storia pregressa</em>. Dopo essere uscito da fork, potrebbe eseguire un return e tornerebbe a un punto precedente del codice, potrebbe fare un altro return e tornerebbe ancora pi√π indietro. <em>Perch√©?</em> Perch√© viene duplicato tutto, compreso lo stack.</p>
<p>Questa duplicazione √® ottenuta in modo molto efficiente sfruttando una caratteristica dell'<strong>MMU</strong>: il nostro spazio di indirizzamento √® uno spazio di indirizzamento <em>virtuale</em>. Abbiamo degli indirizzi che corrispondono alle pagine virtuali, poi la MMU ha le sue tabelle con cui mappa queste pagine virtuali in pagine fisiche. In questa tabella c'√® un flag hardware che si chiama <code>cow</code>, <em>copy on write</em>.</p>
<p>Nel momento in cui viene eseguita la <code>fork</code>, all'interno della system call si vanno a settare nella pagina della MMU i bit <code>cow</code> di ciascuna pagina in uso. Da questo momento in avanti avr√≤ due esecuzioni che proseguono: fin tanto che queste due esecuzioni non modificano niente, leggeranno le stesse pagine. La prima delle due che va a cambiare un byte qualunque provocher√† una <em>trap</em> del sistema operativo che duplicher√† fisicamente la pagina. L'originale resta di propriet√† dell'altro, il flag <code>cow</code> viene resettato e viene allocata una nuova pagina fisica (inizialmente copia della precedente) su cui si va a fare la modifica. Da questo momento in avanti i due processi non si impicciano pi√π.</p>
<p>Questo rende <strong>efficace</strong> ed <strong>efficiente</strong> il sistema di creazione dei processi, ma anche <em>complicato</em> perch√© non si parte da pulito, parto da sporco: in base a dove √® avvenuta la <code>fork</code> nel processo ‚Äî se nel <code>main</code>, o nella funzione A chiamata da B, che era stata chiamata da C, che a sua volta era stata chiamata dal main ‚Äî ci si ritrover√† in quel punto. Quindi chi si sveglia dalla <code>fork</code> come <em>child</em> deve capire <em>dove si trova.</em></p>
<h2 id="13-creazione-di-processi"><a class="header" href="#13-creazione-di-processi">1.3 Creazione di processi</a></h2>
<p><img src="images/processi/image%207.png" alt="image.png" /></p>
<p>Per questo motivo nei sistemi <strong>Unix</strong>, subito dopo la <code>fork</code>, spesso, se si √® <em>child</em>, si invoca <code>exec</code>.</p>
<p><em>Cosa fa exec?</em> <strong>Spiana completamente lo spazio di indirizzamento e lo sostituisce con il contenuto di un file eseguibile.</strong>
Notate che <code>exec</code> pu√≤ essere chiamata da qualunque programma in qualunque momento. Io ho un programma che inizia a fare in un certo modo e poi invoco <code>exec ls</code>. <em>Cosa succede?</em> Che il mio programma ha fatto alcune cose e poi finisce come se avessi chiamato <code>ls</code>. Perch√© <code>exec</code> dice <em>‚ÄúOk, butta via tutto e riparti da zero‚Äù</em>.</p>
<p><code>exec</code> qui √® scritto con l'asterisco perch√© viene in tante diverse versioni (<code>execl</code>, <code>exece</code>, <code>execle</code> etc‚Ä¶), la differenza tra le versioni √® solo sui parametri che mettiamo. Quelli che hanno una <code>e</code> al fondo hanno un parametro aggiuntivo che contiene un puntatore alle <em>variabili d'ambiente</em>. Quelli che prima della <code>e</code> hanno una <code>l</code> ricevono una <em>lista di parametri</em>. Quelli che prima della <code>e</code> hanno una <code>v</code> ricevono un <em>vettore</em>, cio√® un array di parametri. Quindi la differenza √® su <em>come io passo i parametri alla mia funzione</em>. Ma sostanzialmente, a parte questo, sono tutti uguali.</p>
<h3 id="131-esempio"><a class="header" href="#131-esempio">1.3.1 Esempio</a></h3>
<p><img src="images/processi/image%208.png" alt="image.png" /></p>
<p>Vediamo un esempio banale. Io qui in un <code>main</code> semplice scritto in C, la prima cosa che faccio all'interno del main √® invocare <code>fork</code>.</p>
<p><code>fork</code> √® una funzione che quando esce mi ritorna un numero.</p>
<p><strong><code>fork</code> viene chiamata una volta ma esce due volte:</strong> una volta nello spazio di indirizzamento del processo <em>padre</em>, una volta nello spazio di indirizzamento del processo <em>figlio</em>.
<em>Come le distinguo?</em> Se il valore che restituisce <code>fork</code> vale <code>0</code> sono il figlio, se non vale <code>0</code> sono il padre.
Se non vale <code>0</code> quel numero che mi restituisce √® il <strong>PID</strong>, il <em>process ID</em> del figlio. Questo mi permette di sapere che ho fatto un figlio e il sistema operativo me l'ha chiamato <code>77</code>.</p>
<p>Il figlio stesso invece se vuole sapere come si chiama lui deve chiamare la system call <code>getpid</code> che gli restituisce il suo nome. Oppure pu√≤ chiamare la funzione system call <code>getppid</code> che gli ritorna il <em>parent pid</em>, cio√® il process ID del suo genitore. Questo perch√© in <strong>Unix</strong>, i processi mantengono una <strong>forte relazione padre-figlio</strong> proprio per via della <code>fork</code>. In <strong>Windows</strong> questa relazione √® debolissima per cui non c'√® un equivalente cos√¨, soprattutto non c'√® l'equivalente della <code>fork</code>.</p>
<p><strong><code>fork</code></strong> potrebbe anche restituire <code>-1</code> nel caso in cui il sistema operativo non avesse risorse necessarie a creare un ulteriore processo. Nell‚Äôesempio in slide viene fatto uno <code>switch</code> sul valore ritornato da <code>fork</code>:</p>
<ul>
<li>Se viene ritornato <code>-1</code>, si pianta l√¨ tutto dicendo che c'√® stato un problema</li>
<li>Se ritorna <code>0</code>, questa √® l'istanza nel processo <em>figlio</em> e quindi ho la possibilit√† di fare cose diverse.
In questo caso viene invocato un processo completamente diverso: il processo <code>ch.exe</code>. Quando viene invocato <code>execl</code>, lo spazio di indirizzamento viene completamente reinizializzato col contenuto dell'eseguibile, perdendo ogni altra cosa. Quindi alle righe dopo <code>execl</code> non ci arriviamo nemmeno.</li>
<li>Se invece non ha ritornato n√© <code>-1</code> n√© <code>0</code>, vuol dire che questa √® la copia del processo <em>padre</em>, nel qual caso stampa semplicemente come si chiama il processo figlio e ritorna.</li>
</ul>
<h2 id="14-fork-e-thread"><a class="header" href="#14-fork-e-thread">1.4 <code>fork()</code> e thread</a></h2>
<p><img src="images/processi/image%209.png" alt="image.png" /></p>
<p>Questo aspetto √® importante da capire: se il processo padre nel momento in cui chiama la <code>fork</code> avesse pi√π di un thread, uno di questi √® quello che chiama <code>fork</code>, ma gli altri che cosa stanno facendo? Boh, non lo sappiamo. In ogni caso nel processo padre rimangono <strong>tutti i thread</strong> che c'erano, mentre nel processo figlio <strong>resta un solo thread</strong>, che comincia dall'uscita della <code>fork</code> avendo la storia pregressa ricevuta dal padre.</p>
<p><strong>Questo pu√≤ portare dei disastri</strong>, perch√© se uno degli altri thread possedeva un mutex, nel padre tutto continua perfettamente, ma nel figlio il mutex rimane di possesso di qualcuno <em>che non c'√® pi√π</em>, di cui si √® persa completamente traccia. E il thread unico che ha, se mai cercasse di chiedere l'accesso a quel mutex, non lo potrebbe ottenere, perch√© il mutex risulta occupato, ma <em>nessuno lo potr√† mai rilasciare</em>.</p>
<p>Per questo motivo, quando sono stati introdotti i thread nella specifica <strong>POSIX</strong>, cercando di razionalizzare un po' le cose, √® stata aggiunta una funzione che si chiama <code>pthread_atfork</code>, che serve a dire <em>‚ÄúChe cosa bisogna fare con i thread nel momento in cui si fa la fork?‚Äù</em></p>
<p>Questa funzione riceve <strong>tre parametri</strong>, che sono tre puntatori a funzione:</p>
<ul>
<li>Il primo puntatore a funzione viene chiamato <em>prima</em> di fare la fork, serve a garantire che nel processo padre si faccia qualche forma di pulizia</li>
<li>Le restanti due vengono eseguite in modo esclusivo solo nel figlio o solo nel padre:
<ul>
<li>Una si chiama <code>parent</code>, ovviamente va rieseguita solo nel padre</li>
<li>L'altra si chiama <code>child</code>, solo nel figlio</li>
</ul>
</li>
</ul>
<p><em>A cosa servono?</em></p>
<ul>
<li>Quella di preparazione serve a fermare tutti i thread, a fargli rilasciare le cose, eccetera, insomma aspettare che ci siano le condizioni per poter creare il nuovo processo</li>
<li>Le altre due servono a rimettere a posto le cose come vanno rimesse a posto, una volta che si √® creato il nuovo processo</li>
</ul>
<h3 id="141-esempio"><a class="header" href="#141-esempio">1.4.1 Esempio</a></h3>
<p><img src="images/processi/image%2010.png" alt="image.png" /></p>
<p><img src="images/processi/image%2011.png" alt="image.png" /></p>
<p>Qui vediamo cosa succede: il processo genitore chiama <code>fork</code> nel suo main, avendo precedentemente invocato <code>pthread_atfork(f1, f2, f3)</code>, dove <code>f1</code>, <code>f2</code>, ed <code>f3</code> sono tre funzioni che dobbiamo definire noi.</p>
<p>Nel momento in cui chiamassimo <code>fork</code>, automaticamente, prima che avvenga qualunque cosa, verrebbe chiamato <code>f1</code>, che ha la possibilit√† di preparare le condizioni, dopodich√© avverrebbe l'effettiva duplicazione del processo, e poi il processo padre continuerebbe invocando <code>f2</code>, e poi dalla <code>fork</code> esce con l'indicazione del <em>child</em>, <code>pid</code>.</p>
<p><img src="images/processi/image%2012.png" alt="image.png" /></p>
<p>Nel <strong>figlio</strong>, invece, quello che succede √® che dalla <code>fork</code> esce un unico thread, che per prima cosa chiama <code>f3</code>. Quando <code>f3</code> ritorna, prosegue uscendo dalla <code>fork</code> col valore <code>0</code>, e poi di l√¨ continua come gli pare.</p>
<p><img src="images/processi/image%2013.png" alt="image.png" /></p>
<p><strong>Questo √® importante da capire</strong> perch√© in un contesto di programmazione multiprocesso, se voi volete continuare in un processo figlio sfruttando il meccanismo della <code>fork</code>, quindi senza buttare via lo spazio di indirizzamento attuale e reinizializzarlo facendo un <code>exec</code>, ma volete semplicemente continuare, dovete tener conto che in un contesto multi thread questo pu√≤ portare tutta una serie di problemi e dovete prendere necessarie contromisure.</p>
<p>I processi tendenzialmente, una volta creati, si svolgono fino a che il <em><strong>thread principale</strong></em> presente al loro interno non termina. Se il thread principale presente al loro interno genera uno o pi√π thread, l'esecuzione continua fino a che esiste <strong>almeno un thread</strong>, oppure semplicemente fino a che il thread principale non muore del tutto, oppure fino a che uno dei thread secondari non muore in modo anomalo, e cos√¨ via. Qui c'√® tutta una casistica complicatissima dove sistemi operativi vari fanno cose diverse.</p>
<p><img src="images/processi/image%2014.png" alt="image.png" /></p>
<p>Un singolo thread, qualunque esso sia, sia esso il principale o il secondario, pu√≤ in qualunque momento chiedere di piantarla l√¨. <em><strong>Come?</strong></em></p>
<ul>
<li>In <strong>Windows</strong> invocando <code>ExitProcess</code></li>
<li>In <strong>Linux</strong> invocando la system call che si chiama <code>_exit</code></li>
</ul>
<p>In entrambi i casi passa un numerino intero a 8 bit, che rappresenta il <em>codice di uscita</em>. Questo codice di uscita potr√† essere usato da altri processi per capire se √® morto bene o morto male.</p>
<p>La convenzione che si usa:</p>
<ul>
<li>Se il codice di uscita √® 0 tutto √® andato per il meglio, il processo ha fatto quello che ci si aspettava facesse</li>
<li>Se il codice di uscita √® diverso da 0, quel codice rappresenta condizioni anormali, e non c'√® nessuna convenzione: ognuno sceglie quel che gli pare. Ad esempio, termino con 32. <em>Che vuol dire 32?</em> Boh, bisogna leggere nella documentazione del programma, ammesso che ci sia.</li>
</ul>
<p>La chiusura del processo, l'invocazione di <code>_exit</code> o di <code>ExitProcess</code>, comporta l'<strong>immediata terminazione</strong> di tutti i thread che sono presenti. Questi immediatamente vengono marcati come <em>"not runnable"</em> e poi buttati via, bruscamente e senza svuotare i loro stack, di conseguenza senza fare nessuna azione associata a eventuali distruttori presenti all'interno. Se ci sono dei file aperti, questi vengono marcati come "chiusi". Se, nel caso di <strong>Windows</strong>, sono state mappate all'interno di questo processo delle DLL, queste DLL vengono <em>"unmapped"</em>, vengono rilasciate.</p>
<p><img src="images/processi/image%2015.png" alt="image.png" /></p>
<p>In <strong>Linux</strong> noi possiamo chiamare la system call <code>_exit</code>, che viene riverberata anche nella libreria standard del C e del C++. La differenza √® solo sintattica: in C si chiama solo <code>exit</code>, √® una funzione semplice, in C++ si chiama <code>std::exit</code>. In entrambi i casi c'√® la possibilit√† di registrare a priori una callback che sar√† invocata per permettere qualche operazione di clean up generale. Lo si fa invocando la funzione <code>atexit</code> e passando il puntatore di una funzione da chiamare.</p>
<p><img src="images/processi/image%2016.png" alt="image.png" /></p>
<p>Quando il thread principale finisce, e quindi la funzione <code>main</code> (o chi per lei) ritorna al suo chiamante, il codice di startup aggiunge automaticamente una <code>exit</code>, passando come valore di ritorno il codice ritornato da <code>main</code>. Per cui in C dove <code>main</code> ha come signature <code>int main(int argc, char** argv)</code>, quell'<code>int</code> ritornato viene usato come codice di ritorno del processo. Quindi se <code>main</code> fa <code>return 5</code>, il processo termina col codice 5. Se <code>main</code> fa <code>return 0</code>, il processo termina ritornando 0.</p>
<p><img src="images/processi/image%2017.png" alt="image.png" /></p>
<p><strong>Notate</strong> che il fatto che <code>main</code> ritorni, quindi, vuol dire che chiamando <code>exit</code> e tutti i thread terminano.</p>
<p>I <strong>thread secondari</strong> sono tutti costruiti con un costrutto <code>try catch</code> che, in caso di eccezione non gestita, chiama la <code>exit</code>. A seconda del sistema operativo viene usato un codice diverso (-1, 17, 52), ma viene sempre chiamata <code>exit</code>. In realt√†, viene invocata <code>terminate</code> che a sua volta esegue <code>exit</code> con un codice non zero. Se un thread secondario termina in modo anomalo, l'intero processo viene terminato restituendo un codice non zero. <em>Questo comportamento √® presente in C e C++, ma non in Java n√© in Rust.</em></p>
<p><strong>Vediamo cosa capita in Rust</strong>.</p>
<h1 id="2-processi-in-rust"><a class="header" href="#2-processi-in-rust">2. Processi in Rust</a></h1>
<p><img src="images/processi/image%2018.png" alt="image.png" /></p>
<p>Prima di tutto Rust ci mette a disposizione un modulo che si chiama <code>std::process</code> che contiene un insieme di strutture dati mediante le quali possiamo:</p>
<ul>
<li>creare un processo</li>
<li>attendere la terminazione di un processo</li>
<li>chiedere informazioni al sistema operativo su quali sono i processi che esistono</li>
</ul>
<p>Quindi ci mette a disposizione delle astrazioni che cercano di nascondere le differenze grandi che i diversi sistemi operativi hanno al loro interno.</p>
<p>In particolare, per poter creare un nuovo processo all'interno di Rust usiamo la struct che si chiama <code>Command</code>. Quindi <code>Command::new</code> ci permette fondamentalmente di creare un nuovo processo, passandogli dei parametri e quindi dicendo che questo processo deve:</p>
<ul>
<li>cominciare caricando un certo eseguibile</li>
<li>ricevere determinati parametri che user√† per comportarsi in modo opportuno</li>
</ul>
<p>Inoltre potremo:</p>
<ul>
<li>customizzare l'insieme delle variabili d'ambiente</li>
<li>aspettare che questo processo non solo parta ma anche che finisca</li>
<li>indicargli un contenuto dello standard input a priori oppure fare in modo che il suo standard input venga prelevato da qualche fonte particolare</li>
<li>prelevare il contenuto del suo <strong>standard output</strong> quando sar√† terminato e leggerlo sotto forma di stringa o sotto forma di array, e lo stesso potremmo fare con <strong>standard error</strong></li>
</ul>
<p><img src="images/processi/image%2019.png" alt="image.png" /></p>
<p>In particolare, noi creiamo un nuovo processo con <code>Command::new</code> che √® un <em>builder</em>: <code>Command::new</code> non ha ancora costruito il processo stesso.</p>
<p>In questo caso <code>Command::new("cmd.exe")</code>, questo vuol dire che provo a creare un prompt dei comandi (se sono in Windows), <em>e cosa passo a questo prompt di command?</em>
Ho la possibilit√† di farci delle cose: ad esempio <code>.args()</code> accetta un array di stringhe (di <code>str</code> in realt√†), dove posso indicare quali argomenti voglio dare, se io sto compilando questo programma sotto Windows lancer√≤ <code>cmd</code> e gli passer√≤ <code>/C</code> maiuscolo e poi <code>echo hello</code>. Sto preparando l'esecuzione del nuovo processo, ma al momento non √® ancora partito.</p>
<p>Per farlo partire davvero devo invocare <code>.output()</code>, o un altro metodo analogo.
Questo fa s√¨ che il processo parta e mi venga restituita una <code>struct</code> destinata a contenere i dettagli di questo processo, in particolare ci trover√≤ il suo <strong>standard input</strong>, il suo <strong>standard output</strong>, il suo <strong>standard error</strong> e cos√¨ via, e il suo codice d'errore.</p>
<p><code>output()</code> ritorna un <code>Result</code>, quindi di solito si fa l'<code>unwrap()</code> o l'<code>expect()</code>; se non √® possibile creare il processo, <code>output()</code> torna un errore, altrimenti il processo torna normalmente.</p>
<p>Qua c'√® un <strong><code>if</code></strong> che gestiva due casi: se siamo su <strong>Windows</strong> lancia <code>cmd</code>, altrimenti lancia <code>shell</code>. I comandi passati sono diversi: se devo lanciare <code>shell</code>, invece di usare <code>args()</code> che accetta un vettore di stringhe, uso pi√π volte <code>.arg()</code>.
Ogni chiamata a <code>.arg()</code> aggiunge un argomento per lanciare il programma ‚Äî in questo caso passo prima <code>-c</code>, poi <code>echo hello</code>. Poi invoco <code>output()</code> per avviare effettivamente il processo e attendere.</p>
<p>Dopo l'esecuzione, stampo il valore di uscita e posso verificare il codice di errore.</p>
<p><em>Nota</em>: questa riga √® commentata perch√© <code>ExitStatus</code> qui √® definito su <strong><code>unix_wait_status</code></strong>, ma su <strong>Windows</strong> va chiamata una funzione diversa.</p>
<p><img src="images/processi/image%2020.png" alt="image.png" /></p>
<p>Quando invoco il processo, oltre a configurare i parametri di ingresso con <code>arg()</code> o <code>args()</code>, posso utilizzare <code>env()</code> o <code>envs()</code> per passare <strong>variabili d'ambiente</strong>. Queste sono coppie chiave-valore (entrambe di tipo stringa) che forniscono parametri addizionali al programma.</p>
<p>Tipicamente nelle variabili d'ambiente si trova:</p>
<ul>
<li>Il <code>PATH</code> - percorsi degli eseguibili</li>
<li>I percorsi delle librerie</li>
<li>Credenziali (es. password per database)</li>
<li>Altri parametri configurabili</li>
</ul>
<p>Ogni programma pu√≤ utilizzare le variabili d'ambiente come preferisce, incluso il non usarle affatto.</p>
<p>All'interno dell'oggetto <code>output</code> io trovo tre oggetti che si chiamano <strong><code>stdin</code></strong>, <strong><code>stdout</code></strong> e <strong><code>stderr</code></strong>, che mi permettono di configurare quel processo che ho creato da dove legge per default (il suo standard input), dove scrive per default (il suo standard output) e dove scrive le indicazioni degli errori (il suo standard error), che corrispondono nel mondo di Unix in generale, a tre handle: tre file descriptor il cui valore √® predefinito <code>0</code>, <code>1</code> e <code>2</code>.</p>
<ul>
<li><code>0</code> √® standard input</li>
<li><code>1</code> √® standard output</li>
<li><code>2</code> √® standard error</li>
</ul>
<p>In Windows non √® cos√¨, ci sono tre handle predefinite che sono degli alias, degli handle di file veri e propri, che hanno un valore negativo.</p>
<p>Io posso inizializzare il contenuto di standard input, standard output e standard error con delle funzioni di inizializzazione. Posso dire <code>inherit</code> per dire <em>‚ÄúUsa lo stesso standard input o lo stesso standard output o lo stesso standard error del processo creante‚Äù</em>, cio√® di quello in cui sto facendo il mio figlio. Quindi condividiamo ‚Äî se ad esempio qualcuno scrive sulla tastiera "ciao" lo potranno vedere sia il processo padre che il figlio.</p>
<p>Standard output, anche qui se uso <code>inherit</code>, le righe stampate l'uno e dell'altro si mescoleranno, come fossero quelle di due thread.</p>
<p>Posso anche usare l'opzione <strong><code>piped</code></strong>: se la imposto su standard input, il processo legger√† da una <em>pipe</em> (una sorta di canale) di cui io ho a disposizione l'altro estremo, permettendomi di inviargli i dati da leggere. Se imposto <code>piped</code> su standard output o standard error, il processo scriver√† su un canale da cui potr√≤ prelevare l'output.</p>
<p>In alternativa, posso usare l'opzione <strong><code>null</code></strong>: in questo caso, se il processo tenta di leggere trover√† subito end of file, mentre se tenta di scrivere l'operazione fallir√†.</p>
<p><img src="images/processi/image%2021.png" alt="image.png" /></p>
<p>Posso configurare il processo in diversi modi prima di avviarlo. Ad esempio, usando <code>current_dir()</code> posso specificare una cartella di lavoro diversa da quella del processo padre. Per quanto riguarda l'avvio, ho tre opzioni principali:</p>
<ul>
<li><strong><code>output()</code></strong> ‚Üí avvia e attende l'output completo</li>
<li><strong><code>status()</code></strong> ‚Üí avvia e si blocca fino alla terminazione</li>
<li><strong><code>spawn()</code></strong> ‚Üí avvia senza attendere la terminazione</li>
</ul>
<p><img src="images/processi/image%2022.png" alt="image.png" /></p>
<p>Dopo lo <code>spawn()</code>, ottengo un oggetto <code>Child</code> che contiene i dettagli del processo creato. Questa struttura include anche il metodo <code>kill()</code> che permette di terminare forzatamente il processo figlio prima della sua naturale conclusione.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processi---malnati-27"><a class="header" href="#processi---malnati-27">Processi - Malnati 27 <!-- omit in toc --></a></h1>
<h1 id="indice-17"><a class="header" href="#indice-17">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="18-processi_parte_2.html#1-recap">1. Recap</a>
<ul>
<li><a href="18-processi_parte_2.html#11-la-struttura-command">1.1 La struttura <code>Command</code></a>
<ul>
<li><a href="18-processi_parte_2.html#111-i-flussi-standard-input-standard-output-e-standard-error">1.1.1 I flussi standard input, standard output e standard error</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="18-processi_parte_2.html#2-lanciare-un-processo">2 Lanciare un processo</a>
<ul>
<li><a href="18-processi_parte_2.html#21-il-metodo-status">2.1 Il metodo <code>status()</code></a></li>
<li><a href="18-processi_parte_2.html#22-il-metodo-spawn">2.2 Il metodo <code>spawn()</code></a>
<ul>
<li><a href="18-processi_parte_2.html#221-esempio">2.2.1 Esempio</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="18-processi_parte_2.html#3-terminare-un-processo">3. Terminare un processo</a>
<ul>
<li><a href="18-processi_parte_2.html#31-stato-terminale-di-un-processo-in-linux">3.1 Stato terminale di un processo in Linux</a></li>
<li><a href="18-processi_parte_2.html#32-orfani-e-zombie">3.2 Orfani e zombie</a></li>
</ul>
</li>
<li><a href="18-processi_parte_2.html#4-trasferire-dati-tra-processi-diversi">4. Trasferire dati tra processi diversi</a>
<ul>
<li><a href="18-processi_parte_2.html#41-code-di-messaggi">4.1 Code di messaggi</a></li>
<li><a href="18-processi_parte_2.html#42-pipe">4.2 Pipe</a></li>
</ul>
</li>
</ul>
<h1 id="1-recap"><a class="header" href="#1-recap">1. Recap</a></h1>
<p><img src="images/processi_2/image.png" alt="image.png" /></p>
<p><strong>Abbiamo visto come un processo sia l'unit√† che il sistema operativo utilizza per incapsulare l'esecuzione di un programma</strong>, affidandogli uno spazio di indirizzamento indipendente.</p>
<p>I processi vengono creati con delle <em>system call</em> che sono molto diverse nel mondo di <strong>Windows</strong> e nel mondo <strong>Unix-like</strong>. Rust ci fornisce una versione standardizzata per la creazione di processi, che non lascia vedere la primitiva <code>fork</code>, ma ci fornisce direttamente gi√† una versione in cui noi possiamo creare un processo e contemporaneamente reinizializzarne lo spazio di indirizzamento con un altro eseguibile.</p>
<h2 id="11-la-struttura-command"><a class="header" href="#11-la-struttura-command">1.1 La struttura <code>Command</code></a></h2>
<p><img src="images/processi_2/image%201.png" alt="image.png" /></p>
<p><img src="images/processi_2/image%202.png" alt="image.png" /></p>
<p>Quindi alla base della creazione del processo c'√® sostanzialmente la creazione di un <code>Command</code> che fondamentalmente modella la parte di inizializzazione del nuovo processo. Si crea un <code>Command</code> con il costrutto <code>new</code> che vuole il nome di un eseguibile.
In realt√† <code>Command</code> √® un <em>builder</em> del processo, ovvero il processo viene generato al termine, nel momento in cui noi abbiamo configurato l'oggetto <code>Command</code> e invochiamo uno dei metodi che ne determinano l'avvio (<code>Spawn</code> piuttosto che <code>wait</code>).</p>
<p>Di base, la funzione <code>new</code> richiede il nome dell'eseguibile, poi possiamo popolare la struttura di lancio del nostro processo con gli eventuali argomenti passati individualmente con <code>.arg()</code> o passati collettivamente con <code>.args()</code> (in questo caso dobbiamo dare un array di stringhe). Possiamo popolare le <strong>variabili d'ambiente</strong> che user√† questo processo mediante <code>.env()</code> (per una singola variabile d'ambiente con il suo valore), <code>.envs()</code> (per un gruppo di variabili d'ambiente con il relativo valore).</p>
<h3 id="111-i-flussi-standard-input-standard-output-e-standard-error"><a class="header" href="#111-i-flussi-standard-input-standard-output-e-standard-error">1.1.1 I flussi standard input, standard output e standard error</a></h3>
<p><img src="images/processi_2/image%203.png" alt="image.png" /></p>
<p>Possiamo soprattutto modificarne i <strong>tre flussi fondamentali</strong>. Ogni processo ha associato:</p>
<ul>
<li>Uno <strong>standard input</strong> ‚Äî un file descriptor gi√† aperto che rappresenta l'input naturale da cui il processo attinge</li>
<li>Uno <strong>standard output</strong> ‚Äî un file gi√† aperto verso cui dirige le operazioni di uscita</li>
<li>Uno <strong>standard error</strong> ‚Äî verso cui dirige gli errori</li>
</ul>
<p>Nel mondo Unix-like questi corrispondono ai file descriptor <code>0</code>, <code>1</code> e <code>2</code>. Nel mondo Windows corrispondono ad altre handle.</p>
<p>Il builder <code>Command</code> ci mette a disposizione tre metodi ‚Äî <code>stdin</code>, <code>stdout</code> e <code>stderr</code> ‚Äî che ci consentono di configurare come il processo gestir√† input e output. Questi metodi accettano uno di tre possibili valori:</p>
<ul>
<li><strong><code>inherit</code></strong> ‚Äî usa l'equivalente nel processo corrente (es: <code>command.new(...).stdin(inherit)</code> user√† lo stesso standard input del processo corrente)</li>
<li><strong><code>piped</code></strong> ‚Äî crea un canale di comunicazione:
<ul>
<li>Per stdin: il processo legger√† da una pipe che possiamo controllare</li>
<li>Per stdout/stderr: il processo scriver√† su una pipe da cui possiamo leggere</li>
</ul>
</li>
<li><strong><code>null</code></strong> ‚Äî viene settato un descrittore chiuso/invalido:
<ul>
<li>In lettura: si ottiene subito end-of-file</li>
<li>In scrittura: l'output viene scartato</li>
</ul>
</li>
</ul>
<h1 id="2-lanciare-un-processo"><a class="header" href="#2-lanciare-un-processo">2 Lanciare un processo</a></h1>
<p><img src="images/processi_2/image%204.png" alt="image.png" /></p>
<p><em>Come lanciamo il processo?</em>
Un oggetto <code>Command</code> ci permette di configurarlo, ma a quel punto abbiamo solo <em>configurato</em> il processo, che non esiste ancora in quanto tale. Affinch√© venga effettivamente invocata la funzione associata al sistema operativo (la <code>CreateProcess</code> in Windows o la <code>fork</code> seguita da <code>exec</code> in Linux) dobbiamo attivare o il metodo <code>status</code> o il metodo <code>spawn</code>.</p>
<h2 id="21-il-metodo-status"><a class="header" href="#21-il-metodo-status">2.1 Il metodo <code>status()</code></a></h2>
<p><strong><code>status()</code></strong> √® bloccante: applicato a un <code>Command</code> fa s√¨ che il processo venga effettivamente creato, venga eseguito e rimango bloccato fino a che quel processo non √® completamente terminato. Quando il processo termina ottengo come risultato da <code>status</code> il codice di terminazione racchiuso in un <code>Result</code>.</p>
<p><em>Perch√© racchiuso in un</em> <code>Result</code><em>?</em>
Perch√© √® possibile che quel processo non venga neanche costruito ‚Äî se gli ho dato come eseguibile il nome di una cosa che non c'√®, non √® possibile creare il processo e potrei ottenere un <code>Result</code> che mi dice <em>"Questa cosa non √® neanche partita".</em> Viceversa se √® possibile farlo partire ottengo il suo status, cio√® l'intero che normalmente definisce il risultato dell‚Äôesecuzione.</p>
<p>Lo status √® una cosa pi√π complessa. Nel caso di <strong>Windows</strong> √® genericamente solo un numero (il valore ritornato da <code>main</code> o passato alla system call <code>ExitProcess</code>). Nel caso dei sistemi <strong>Unix</strong> invece √® molto pi√π articolato: √® fatto di 16 bit, 8 dei quali rappresentano il codice di uscita effettivamente generato dal processo stesso, ma i restanti 8 hanno un'interpretazione pi√π complessa come bit field, perch√© indicano possibili forme di terminazione dovute a fattori esterni ‚Äî ad esempio il fatto che avete fatto <code>kill</code> di quel processo. Quindi, se il processo √® terminato tramite un segnale, ottenete sull'exit status un codice che vi riporta quale segnale ne ha causato l'interruzione.</p>
<p>Quando creiamo un <code>Command</code> e invochiamo <code>status()</code>, il processo rimane in attesa fino alla terminazione, quando otterremo il risultato.</p>
<h2 id="22-il-metodo-spawn"><a class="header" href="#22-il-metodo-spawn">2.2 Il metodo <code>spawn()</code></a></h2>
<p>In altre situazioni vogliamo attivare il processo figlio mentre il nostro programma continua l'esecuzione. In questo caso usiamo <code>spawn()</code>. Chiamando <code>spawn()</code> viene avviata l'esecuzione del processo figlio in parallelo. Per conoscerne l'esito, dobbiamo utilizzare il valore restituito da <code>spawn()</code>.</p>
<p><code>spawn()</code> restituisce un oggetto di tipo <code>Child</code>, o meglio un <code>Result&lt;Child&gt;</code>, perch√© come prima √® possibile che il comando specificato non esista e quindi non sia neanche possibile avviarlo. Se invece la creazione del processo ha successo, la struttura <code>Child</code> contenuta nel <code>Result</code> ci permette di interagire con il processo figlio.</p>
<p><img src="images/processi_2/image%205.png" alt="image.png" /></p>
<p>*Cosa contiene la struttura Child?
*****All'interno troviamo i tre campi <code>stdin</code>, <code>stdout</code> e <code>stderr</code>, che rappresentano i flussi standard del processo figlio. Questi campi vengono inizializzati in base a come li abbiamo configurati prima della chiamata a <code>.spawn()</code>.</p>
<p>Se per uno di questi flussi abbiamo specificato <code>inherit()</code>, allora il processo figlio condivider√† lo stesso flusso del processo padre: in quel caso, non possiamo (e non ha senso) accedere ai campi <code>stdin</code>, <code>stdout</code> o <code>stderr</code> perch√© non ci danno alcun controllo diretto.</p>
<p>Al contrario, se abbiamo usato <code>piped()</code>, allora il relativo campo (<code>stdin</code>, ad esempio) conterr√† l'altra estremit√† di una <strong>pipe</strong>, che possiamo usare per interagire con il processo figlio: ad esempio, scrivendo su <code>child.stdin</code>, possiamo fornire input al processo figlio; leggendo da <code>child.stdout</code> o <code>child.stderr</code>, possiamo ottenere il suo output o eventuali messaggi di errore.</p>
<p>All'interno della struttura <code>Child</code> troviamo anche l'identit√† del processo creato: il metodo <code>id()</code> ci fornisce il PID associato.</p>
<p>Abbiamo inoltre a disposizione due metodi di attesa:</p>
<ul>
<li><code>wait()</code> ‚Üí ci blocca fino alla terminazione del processo</li>
<li><code>wait_with_output()</code> ‚Üí ci blocca e restituisce anche l'eventuale standard output configurato</li>
</ul>
<p>Infine abbiamo anche a disposizione il metodo <code>kill</code> che ci d√† la possibilit√† di interrompere la sua esecuzione. In effetti nel caso dei sistemi <strong>Unix</strong> corrisponde a inviargli il <strong>segnale 15</strong>, quello che ne chiede la terminazione graziosa ‚Äî gli facciamo sapere che vogliamo che smetta e lui ha la possibilit√† di fare un catch di questo segnale e quindi decidere se vuole o meno. Nei sistemi Unix quando invece un programma si pianta, di solito l'altro modo √® fare <code>kill -9</code>. Il <strong>segnale 9</strong> comporta la deschedulazione da parte del sistema operativo di tutti i thread associati e la rimozione di tutte le strutture dati. √à un'uccisione senza possibilit√† di replica da parte del processo stesso ‚Äî viene eliminato dal sistema operativo.</p>
<p>C'√® qualcosa di simile in <strong>Windows</strong> attraverso il task manager, dove potete scegliere tra terminare un processo oppure fare <em>force termination</em>. Quest'ultima ha un comportamento analogo al <code>kill -9</code>.</p>
<p><img src="images/processi_2/image%206.png" alt="image.png" /></p>
<p>L'aspetto su cui ci concentriamo in questo momento, particolarmente rilevante, √® legato al fatto che possiamo attivare dei programmi gi√† esistenti sul nostro computer ‚Äî che magari abbiamo scritto noi stessi, oppure sono eseguibili che il sistema operativo ci mette a disposizione (compilatore, linker o qualunque altra cosa) ‚Äî e vogliamo controllarli in modo pi√π interattivo.</p>
<p>√à vero che una parte di controllo la esercitiamo passando dei parametri. Il compilatore normalmente riceve tutto quello di cui ha bisogno sui parametri (es: <code>gcc -c myfile.c -o myfile.bin</code>). Quindi la riga di comando spesso √® sufficiente. In alcuni casi per√≤ non lo √® ‚Äî anzi, vogliamo beneficiare dalla possibilit√† di mandargli degli input custom per ottenere dei benefici.</p>
<p>Vediamo un esempio.</p>
<h3 id="221-esempio-2"><a class="header" href="#221-esempio-2">2.2.1 Esempio</a></h3>
<p>Per capirlo, prendiamo confidenza con un comando presente sui sistemi Unix-like chiamato <code>rev</code>. √à un comando molto semplice: <code>rev</code> legge dal suo standard input e scrive sullo standard output. In particolare, legge una riga per volta e la riscrive girata al contrario.</p>
<p><img src="images/processi_2/image%207.png" alt="image.png" /></p>
<p>Se eseguo <code>rev</code>, il processo rimane in attesa aspettando input.
Se scrivo "<em>ciao</em>", risponde "<em>oaic</em>", e ritorna in attesa di un altro input.
Continua cos√¨ fino a quando non riceve un end of file ‚Äî a quel punto termina.</p>
<p>Questo √® un semplice esempio di programma interattivo. Potremmo usare <code>ls</code> o altri comandi, ma <code>ls</code> non prende niente da standard input, quindi √® meno utile per il nostro scopo.</p>
<p><img src="images/processi_2/image%208.png" alt="image.png" /></p>
<p>Nell'esempio che esaminiamo, iniziamo popolando la struttura <code>Child</code>. Con <code>Command::new("rev")</code> vogliamo eseguire il processo <code>rev</code>. Gli forniamo in ingresso una <strong>pipe</strong> per potergli inviare dati, e il suo output viene diretto su un'altra <strong>pipe</strong> da cui potremo leggere ci√≤ che scrive.</p>
<p>Non necessita di parametri aggiuntivi, quindi non usiamo <code>.arg()</code>.</p>
<p><code>spawn()</code> restituisce un <code>Result</code> che potremmo gestire con <code>unwrap()</code>, ma usiamo <code>expect()</code> per avere un messaggio pi√π chiaro in caso di errore. A questo punto il processo √® in attesa ‚Äî proprio come quando abbiamo eseguito <code>rev</code> dal terminale, e lui aspettava di ricevere input.</p>
<p>L'<strong>input</strong> del processo lo accedo grazie al <code>Child</code> che ho ottenuto. Di conseguenza vado sulla struttura <code>Child</code> che mi √® stata restituita da <code>Command::new</code>, accedo al campo <code>stdin</code>, e ne prendo possesso con <code>.take</code>.</p>
<p><code>.take</code> mi serve perch√© ho bisogno di accedere all'estremit√† di ingresso della pipe. Ovviamente questo pu√≤ dare un risultato di errore, <em>perch√©?</em> Perch√© se quello <code>standard input</code> non l'ho creato di tipo <code>piped</code>, non posso prendere nessuna estremit√† di accesso. E quindi facciamo anche <code>.expect</code> per gestire l‚Äôerrore.</p>
<p>A questo punto ho lo <code>standard input</code>, ovvero ho il punto in cui posso scrivere affinch√© lui legga. Quindi tutto quello che scriver√≤ sull'oggetto cos√¨ chiamato <code>stdin</code> sar√† ci√≤ che questo programma legge.</p>
<p><em>Quindi in questo caso cosa faccio?</em> <code>.write_all</code>, quindi prendi il buffer che ti sto passando e che buffer ti passo? Ti passo <code>"hello world"</code> come stringa trasformato in byte e quindi lui si vedr√† "<code>h</code>" √® 58, "<code>e</code>" √® 65 eccetera, e cos√¨ via fino al fondo.</p>
<p>Quindi vedr√† questa sequenza di byte, dopodich√© <code>.expect</code> e quindi lui ha cominciato a mangiare questa riga, verifico di esserci riuscito e quindi faccio l'<code>unwrap</code>.</p>
<p>Dopodich√© lui probabilmente avr√† gi√† preso questa stringa e l'avr√† gi√† anche girata al contrario. E poi aspetter√† la riga successiva perch√©, come abbiamo visto prima, <code>rev</code> va avanti e se gli diamo mille righe ciascuna di queste la prende e la gira al contrario.</p>
<p>Di conseguenza per fare in modo che lui smetta facciamo <code>drop(stdin)</code>, chiudendo la mia estremit√† della <strong>pipe</strong>. Lui che cercher√† di leggere, ricever√† un <em>end of file</em> e ricevendo questo <em>end of file</em> capir√† che ha finito. Questo mi permette, a questo punto, di poter fare <code>let output = child.wait_with_output</code>. Quindi, benissimo, adesso che gli ho mandato tutto quello di cui potevo aver bisogno, posso andare a vedere cosa mi ha dato in uscita.</p>
<p>E di conseguenza prendo dalla struttura <code>output</code>, <code>&amp;output.stdout</code>.</p>
<p><code>output</code> contiene sia il suo <code>standard output</code> che il suo <code>standard error</code>. E me li restituisce sotto forma di vettori di <code>u8</code>, quindi vettori di byte. In questo caso io prendo il vettore di byte chiamato <code>standard output</code> e lo converto in una stringa. Converto in una stringa, ma lui a priori dice "Quello l√¨ per me √® un array di byte, non sono certo che sia una stringa ben formata <code>UTF-8</code>. Vabb√®, provaci, alla peggio la aggiusti‚Äù. Per questo √® <code>from_utf8_lossy</code>, nel senso che lui fa in modo, se trova delle combinazioni inadeguate, le butta via e le sostituisce con dei caratteri che mi segnano il fatto che l√¨ ha trovato qualcosa di incomprensibile. Quindi non si rompe.</p>
<p>A questo punto ho una stringa, anzi ho un <code>Cow</code> (<em>copy on write</em>) di stringa, ma fa lo stesso, un'ottimizzazione che fa lui, e la stampo. E poi vado a verificare che mi sia venuto effettivamente "<em>hello world</em>" girato al contrario e c'√® l'<code>assert</code> finale.</p>
<p><img src="images/processi_2/image%209.png" alt="image.png" /></p>
<p><strong>Nota:</strong> qui abbiamo scritto direttamente <code>write_all</code>. Questa tecnica funziona nel momento in cui voi dovete mandare <strong>poca roba</strong>. Se io qui avessi dovuto mandargli un testo un pochino pi√π ampio che non soltanto "hello world", <em>cosa poteva succedere?</em> Poteva succedere che io gli mando un po' di byte, ma lui non li legge subito, perch√© in mezzo ci sar√† un <strong>buffer</strong>. Questo buffer si riempie fino a un certo punto, dopodich√© se lui non √® veloce a leggere, io cerco di scrivere ancora. Ma lui non riesce a prenderselo. E di conseguenza siamo bloccati.</p>
<p><img src="images/processi_2/image%2010.png" alt="image.png" /></p>
<p>Allora, per evitare questa situazione, l'alternativa a fare questo mestiere √® racchiudere quest'operazione in un <strong>thread</strong>. E lo facciamo con <code>move</code>, in modo tale che lui prende <code>stdin</code> qua dentro.</p>
<p><em>Cosa succede se io lo metto in un thread?</em>
A questo punto posso gestire un testo anche lunghissimo senza problemi, perch√© questo thread opera <strong>parallelamente</strong> alla parte della <code>wait_with_output</code>. Il processo legge dall'input, lo converte e lo scrive sul suo output continuamente. Tuttavia, se gli mando una grande quantit√† di dati, a un certo punto non riuscir√† pi√π a scrivere sull'output perch√© nessuno sta leggendo dall'altra parte.</p>
<p><strong>Allora</strong>, facendo in questa maniera io rendo <strong>concorrente</strong> il feeding dei dati con l'acquisizione dell'informazione. E questo me lo sblocca. Cos√¨ sono tranquillo che, indipendentemente da quanto sia la mole dei dati che sto inviando, questi verranno passati in <strong>parallelo</strong> all'operazione di attesa dopo, eccetera.</p>
<p>Di questo thread non faccio il <code>join</code> per un motivo semplice: di fatto io riuscir√≤ a raccogliere l'intero output solo nel momento in cui quel thread avr√† finito. Quindi √® <em>automatico</em> che quando arrivo alla riga dove c'√® scritto <code>assert</code>, quel thread √® finito. E di conseguenza non mi interessa fare la join in modo esplicito.</p>
<h1 id="3-terminare-un-processo"><a class="header" href="#3-terminare-un-processo">3. Terminare un processo</a></h1>
<p><img src="images/processi_2/image%2011.png" alt="image.png" /></p>
<p>Vediamo due cose sull'<strong>exit code</strong>. Io posso in qualunque momento interrompere un programma, perch√© i sistemi operativi.</p>
<p>Un processo pu√≤ terminare se stesso in qualunque momento, grazie al fatto che i sistemi operativi mi offrono una <strong>system call</strong> opportuna. In <strong>Windows</strong> c'√® <code>ExitProcess</code>, in <strong>Unix</strong> c'√® <code>exit</code>. Fanno pi√π o meno lo stesso lavoro. Entrambe accettano un intero. Il modo con cui trattano questo intero √® un po' diverso.</p>
<p><code>std::process::exit</code> accetta un numero intero e causa la terminazione del processo. La terminazione del processo comporta, come dicevamo, <strong>l'immediata uccisione di tutti i thread esistenti</strong>, che si bloccano l√¨ dove sono. Quindi se stavano scrivendo un file, quel file resta scritto per met√†. Non hanno modo di reagire, non c'√® nulla che si possa fare. Questa va chiamata, da parte del programmatore, in quelle situazioni in cui si abbia la ragionevole certezza che non si fanno dei danni.</p>
<p><code>exit</code> ci d√† la possibilit√† di comunicare un qualunque codice di risultato del processo.</p>
<p>In alternativa c'√® una funzione simile che si chiama <code>abort</code>. √à l'equivalente di <code>terminate</code> in C. Analogamente a <code>exit</code> comporta l'uscita immediata del processo. A differenza di <code>exit</code> non ci consente di indicare un codice custom di errore, ne mette uno lui di default, che √® interpretato in modo coerente dal sistema operativo, come <strong>interruzione anomala</strong>. Serve proprio per significare "Que<em>sto programma √® morto in modo anomalo</em>". Non c'√® rischio di poter farlo interpretare diversamente. Chiaramente avendo lo stesso comportamento di <code>exit</code> va chiamato quando pensiamo che sia il male minore. Le conseguenze, cio√® della terminazione brutale, non abbiano altri impatti.</p>
<p><strong>Poi abbiamo la macro <code>panic!</code></strong>, che causa invece la <strong>terminazione del thread corrente</strong> ‚Äî non bruscamente, ma forzando la <em>contrazione dello stack</em> fino a tornare all'inizio.
Il fatto che forzi la contrazione dello stack significa che tutte le variabili locali presenti sullo stack che implementavano il tratto <code>Drop</code> (e di conseguenza avevano un distruttore associato), questo tratto <code>Drop</code> venga eseguito. Quindi, se ho adottato correttamente il <strong>pattern RAI</strong>, la mia struttura si pulisce in modo concreto.</p>
<p>Notate che se <code>panic!</code> viene invocato su un thread secondario ‚Äî a differenza di quello che succede in <strong>C++</strong> dove una eccezione lanciata su un thread secondario comporta la contrazione dello stack, ma anche la terminazione del processo perch√© al cuore della funzione che crea i thread viene messo, prima di invocare il codice dell'utente, viene messo un <code>try{...}catch{ // ... std::terminate }</code>. Ovvero, se questo thread muore anomalamente, il processo termina, chiamando l'equivalente dell'<code>abort</code>. Quindi termina con un codice di errore che indica il fallimento.</p>
<p>In Rust <strong>non √® cos√¨</strong>. Se un thread secondario panica, lui si toglie dei piedi, svanisce, tutto il suo stack si contrae, le variabili vengono distrutte correttamente, ma il processo resta vivo.
La condizione di panico pu√≤ essere poi letta: se qualcuno fa il <code>join</code> della handle del thread che ha panicato, otterr√† una condizione di errore sul join, e la condizione di errore racconter√† fondamentalmente il messaggio associato al panic.</p>
<p>Questo se √® un thread secondario. <strong>Se invece il panic avviene sul thread principale, il processo termina</strong>. <em>Perch√©?</em> Perch√© il processo principale parte in un contesto che √® definito dalla <em>C runtime library</em>, che fondamentalmente racchiude l'esecuzione di <code>main</code> in un blocco del tipo <code>try{...}catch{exit}</code>. Quindi la presenza di questa <code>exit</code> fa s√¨ che se il thread principale panica, esce.</p>
<p><img src="images/processi_2/image%2012.png" alt="image.png" /></p>
<p>Se io ho creato un altro processo, posso essere interessato a sapere come finisce. Se il processo io l'ho creato dentro Rust, ho la struttura <code>Child</code> associata, e su questa struttura posso invocare i metodi come <code>wait</code>, piuttosto che <code>wait_with_output</code>, che mi danno la possibilit√† di avere accesso al suo codice di uscita. E di rimanere bloccato fino a che questo processo non √® terminato.</p>
<p>Se il processo non l'ho creato dentro <strong>Rust</strong>, ma √® un processo che esiste, ad esempio magari ho visto tramite <code>ps</code> che esiste il processo numero 74, e vorrei sapere quando il processo numero 74 finisce, come faccio? Di base, i singoli sistemi operativi mi danno uno strumento per farlo. Ci sono <em>system call</em> apposite. Sono un po' diverse al solito.</p>
<p>Sotto <strong>Windows</strong> esiste <code>WaitForSingleObject</code>. Esiste anche la sua funzione sorella che si chiama <code>WaitForMultipleObjects</code>.</p>
<p><code>WaitForSingleObject</code> accetta una <em>handle</em> di un <em>oggetto aspettabile</em>. √à una funzione complessa, si usa per un mucchio di cose: si usa per sapere se un processo termina, si usa per sapere se un <em>mutex</em> √® libero, si usa per sapere se √® possibile scrivere su un file. √à una funzione estremamente versatile. La differenza tra <code>single object</code> e <code>multiple object</code>, come potreste intuire, √® che in un caso gli passate solo una handle, nel caso di multiple gli passate pi√π handle. Ma nel caso di multiple gli passate anche un <em>flag</em> che specifica se voglio che tutti quelli che gli ho passato siano finiti oppure che uno qualunque di questi siano finiti. Quindi avete la possibilit√† di controllarlo.</p>
<p>Nel caso di <strong>Linux</strong> le cose sono diverse e qui avete a disposizione tre comandi distinti: <code>wait</code>, <code>waitpid</code>, <code>waitid</code>, che sono legati al mantenimento della struttura <em>parent-child</em> tra processi che nel mondo <strong>Unix</strong> √® particolarmente rilevante. <strong>Windows</strong> invece, non avendo questa relazione, permette che chiunque aspetti chiunque altro senza grossi problemi.</p>
<p><img src="images/processi_2/image%2013.png" alt="image.png" /></p>
<p><em>Che differenza c'√® tra queste funzioni?</em></p>
<p><strong><code>wait</code></strong> funziona cos√¨: controlla i propri processi figli. Se il processo non ha creato figli, o se tutti i figli sono gi√† stati gestiti, <code>wait</code> ritorna -1 per indicare che non c'√® nulla da attendere. Se invece esistono dei figli attivi, la chiamata si blocca finch√© <strong>uno qualunque di questi sottoprocessi non termina</strong>. A quel punto viene restituito il PID (Process ID) del figlio terminato. Per esempio: se hai due figli con PID 27 e 54, quando chiami <code>wait</code> il processo attende finch√© uno dei due non termina. Se termina il processo 27, <code>wait</code> restituisce 27.</p>
<p>Nel fare questa operazione qua non solo mi fa aspettare fino a che uno dei figli finisce, ma provvede anche ad attribuire al processo corrente tutte le <strong>metriche</strong> legate al processo figlio. Se quel processo figlio ha fatto delle operazioni di I/O, i miei <em>contatori di I/O</em> vengono incrementati della quantit√† di I/O fatta dal figlio. Se quello l√¨ ha usato <em>12 milioni di cicli di CPU</em>, i miei cicli di CPU vengono sommati a questa cosa qua.</p>
<p><img src="images/processi_2/image%2014.png" alt="image.png" /></p>
<p><strong><code>waitpid</code></strong>, viceversa, √® una funzione mirata a un singolo figlio. Mentre <code>wait</code> aspetta il prossimo, finch√© c'√®, <code>waitpid</code> dice "<em>io voglio aspettare esattamente questo qua</em>".</p>
<p>Quindi siccome <code>fork</code> ci ha restituito il PID del figlio creato, e quindi se abbiamo fatto dei figli sappiamo chi sono, noi possiamo <em>mirare l'attesa di un figlio specifico</em> con <code>waitpid</code>. E in questo rimaniamo bloccati fino a che quel figlio l√¨ non termina, quando poi quel figlio termina otteniamo il suo status e eventuali altre informazioni.</p>
<h2 id="31-stato-terminale-di-un-processo-in-linux"><a class="header" href="#31-stato-terminale-di-un-processo-in-linux">3.1 Stato terminale di un processo in Linux</a></h2>
<p><img src="images/processi_2/image%2015.png" alt="image.png" /></p>
<p><em>Che cosa c'√® nello <strong>status</strong>?</em>
Le funzioni di uscita accettano un intero 32 bit, e quell'intero 32 bit √® completamente accessibile nel mondo di <strong>Windows</strong>. Nel mondo di <strong>Linux</strong>, in realt√†, √® limitato a soli 8 bit. E il valore che ci viene restituito dall'<em>exit-status</em> √® fatto di 16, che vanno interpretati secondo questa tabellina:</p>
<ul>
<li>Se il figlio √® terminato <em>normalmente</em>, nel byte pi√π significativo ci trover√≤ il suo codice d'errore. E nel byte meno significativo ci leggo 0.</li>
<li>Se il figlio √® terminato a seguito di un <em>segnale</em>, ad esempio avete fatto kill del processo, nel byte pi√π significativo leggete 0, e nel byte meno significativo leggete il numero del segnale (es. 15 per una kill normale).</li>
</ul>
<p>Alcuni tipi di segnali possono causare il <strong>dump della memoria</strong>.</p>
<p><em>Cos'√® il dump della memoria?</em>
Sostanzialmente un istante prima di distruggere lo spazio di indirizzamento, il sistema operativo copia tutto il contenuto dello spazio di indirizzamento del processo che ha ricevuto il segnale, dentro un file, che si chiama <code>core</code>.</p>
<p><em>Perch√© serve?</em> Perch√© vi permette di avviarci sopra un debugger e andare a vedere cosa c'era l√¨ dentro. Tipicamente i segnali che possono causare il core dump sono i segnali come <code>segv</code>, <em>segment violation</em> ‚Äî voi magari avete cercato di leggere da un indirizzo che non esisteva, a quel punto il sistema operativo vi blocca, uccide il processo col segnale segment violation e fa il core dump. Per segnalarvi che il core dump √® avvenuto, setta il bit pi√π significativo del secondo byte.</p>
<p>A volte, voi avete un programma che produce un mucchio di output. Magari vi sar√† capitato di fare <strong>CTRL+S</strong>.</p>
<p><em>Cosa fa CTRL+S?</em> <strong>CTRL+S</strong> √® un segnale di <em>pause</em>. Blocca lo svolgimento del processo corrente, per darvi la possibilit√† di capire cosa sta facendo. Non lo ha ucciso, lo ha solo sospeso, lo ha marcato tutti i suoi thread come <em>non schedulabili</em>. E di conseguenza, sta fermo l√¨ dove √® arrivato.</p>
<p><em>Cosa si fa quando si batte <strong>CTRL+S</strong>?</em> Per far riprendere il vostro programma, dovete battere <strong>CTRL+Q</strong>. <strong>CTRL+Q</strong> lo sblocca, lo fa ripartire esattamente dove era. Cio√®, informa lo scheduler che tutti i suoi thread possono tornare a fare quello che dovranno fare. E di conseguenza, voi vedete che va avanti.</p>
<p>Queste due indicazioni possono essere ricevute. E in questo caso, potete sapere che lui era bloccato, e vedete sul byte pi√π significativo l'indicazione di quale segnale lo ha bloccato, e nel byte meno significativo vedete <code>7F</code>. Viceversa, se √® stato continuato da un segnale, leggete <code>FFFF</code>, tutti uno. Questo vi d√† idea di cosa sta capitando l√¨ dentro.</p>
<h2 id="32-orfani-e-zombie"><a class="header" href="#32-orfani-e-zombie">3.2 Orfani e zombie</a></h2>
<p><img src="images/processi_2/image%2016.png" alt="image.png" /></p>
<p><strong>Se un processo figlio muore prima che il padre abbia chiamato la <code>wait</code> o <code>waitpid</code>, il figlio diventa uno <em>zombie</em></strong>.</p>
<p>Se il processo padre finisce prima dei figli, i figli vengono automaticamente riassegnati a <em><strong>init</strong></em>: il processo numero 1.
Nella struttura di Unix, il processo numero 1 si chiama <code>init</code>, ed √® quello che d√† origine a tutto il sistema. Quindi diventano figli di 1. Infatti, <code>init</code> passa la sua vita, dopo aver inizializzato il sistema, ad aspettare, chiamando <code>wait</code>.</p>
<p>Viceversa, se un figlio termina prima che il padre ne abbia chiamato la <code>wait</code>, quel figlio diventa uno <em>zombie</em>. <em>Cosa vuol dire?</em> Vuol dire che non pu√≤ essere rilasciata tutta la sua informazione. Ad esempio, il <strong>codice che ha restituito</strong> devo tenerlo l√¨ da qualche parte, perch√© ad un certo punto il padre ne far√† una <code>wait</code>, e vorr√† sapere com'√® finito sto figlio.</p>
<p>Quindi, il sistema operativo rilascia lo spazio di indirizzamento, ma <strong>non rilascia alcune delle strutture dati interne</strong> che ha associato, fino a che qualcuno non ne fa la <code>wait</code> e si prende carico di questi risultati.</p>
<p>Se fate <code>ps</code>, a volte <code>ps -e</code> o qualcosa del genere, che vi elenca tutti i processi che sono in esecuzione sulla vostra macchina, troverete una colonnina dove c'√® lo stato del figlio. Alcune di queste righe potrebbero contenere una <strong>z</strong>: sono i processi in stato di zombie.</p>
<h1 id="4-trasferire-dati-tra-processi-diversi"><a class="header" href="#4-trasferire-dati-tra-processi-diversi">4. Trasferire dati tra processi diversi</a></h1>
<p><img src="images/processi_2/image%2017.png" alt="image.png" /></p>
<p>Quando due processi hanno bisogno di parlarsi, le cose sono pi√π complicate di quello che sarebbe quando due thread devono parlarsi. Se due thread devono parlarsi, sfruttano il fatto che abbiamo una <strong>memoria condivisa</strong>. Quindi, se io ti passo l'indirizzo di un dato, tu lo vedi. Nessun problema.</p>
<p>Quando invece due processi devono parlarsi, siccome lo <em>spazio di indirizzamento √® completamente separato</em>, il fatto che da me l'indirizzo si chiami <code>3b7f</code>, non vuol dire assolutamente nulla da parte tua. Quindi non possiamo comunicarci gli indirizzi.</p>
<p>Di conseguenza, se due processi devono scambiarsi informazioni √® necessario passare dal <em>formato interno</em> che ciascuno dei due utilizza (che √® fatto come vogliamo, in base all'utilit√† che ci serve), ad una <strong>rappresentazione esterna</strong>, utile per poter essere trasferita in qualche modo da un'altra parte e riletta.</p>
<p>√à il problema, ad esempio, che avete con le immagini: le immagini sono strutture binarie che hanno una serie di informazioni al loro interno. Poi le immagini, da un processo all'altro, ad esempio quando un browser carica un'immagine, non carica l'immagine la bitmap pura, carica un <code>png</code> o un <code>jpeg</code> o un <code>gif</code>.</p>
<p><em>Perch√©?</em> Perch√© queste, al di l√† del fatto che sono compressi e quindi pongono un'ottimizzazione dal punto di vista del resto, hanno una <strong>struttura riconoscibile</strong> facendo dei riferimenti che sono <em>privi di puntatori</em>. Internamente un JPEG √® una struttura alquanto articolata, che:</p>
<ul>
<li>suddivide l'immagine in macro blocchi 16x16</li>
<li>singoli macro blocchi sono divisi in 4 blocchi 8x8</li>
<li>ciascun blocco 8x8 √® rappresentato con la <em>trasformata discreta di coseni</em></li>
<li>c'√® un vettore di quantizzazione</li>
</ul>
<p>√à una struttura alquanto articolata che permette la compressione dell'immagine. Ma questa struttura √® impacchettata in un modo che <strong>non abbia nessun riferimento alla memoria</strong>, agli indirizzi di memoria, in modo tale che possa essere mossa da una parte all'altra.</p>
<p>Quando il vostro browser riceve un JPEG, lo spacchetta, lo trasforma in un'immagine rappresentata come meglio crede, e poi la mostra sul video in modo che sia visibile. Questo significa che passare da un processo all'altro richiede un <strong>processo di serializzazione</strong>, in cui:</p>
<ul>
<li>traduco il mio formato interno in uno adatto a essere spostato</li>
<li>tramite qualche meccanismo lo faccio arrivare a destinazione</li>
<li>chi lo riceve deve fare l'operazione duale, l‚Äô<em>unmarshalling</em> (la deserializzazione), che trasforma dal formato esterno di nuovo a quello interno, che pu√≤ essere molto diverso dall'originale, non ha nessuna importanza</li>
</ul>
<p>I processi di natura loro sono separati, ma i sistemi operativi ci mettono a disposizione alcuni meccanismi, che prendono il nome di <strong>IPC (Inter Process Communication)</strong>, che permettono di parlarsi. Ce ne sono vari, purtroppo Windows li ha molto diversi da Linux e Unix in generale. Noi ne vediamo velocemente due: le code di messaggi e le pipe.</p>
<h2 id="41-code-di-messaggi"><a class="header" href="#41-code-di-messaggi">4.1 Code di messaggi</a></h2>
<p>Permettono a pi√π processi mittenti di inviare messaggi di dimensione variabile verso un unico destinatario (il proprietario della coda). Un processo pu√≤ inviare un blocco da 5 byte, un altro da 45 byte, un altro ancora da un megabyte e mezzo - la dimensione non √® rilevante. Il sistema operativo gestisce l'impacchettamento dei messaggi, e il destinatario li riceve uno alla volta, rispettando rigorosamente l'ordine di arrivo.</p>
<p>Dopodich√© deve occuparsi di capire cosa c'√® scritto dentro, quindi chi codifica questa cosa avr√† scelto di imbustare questo messaggio in un modo coerente. All'interno di una coda di messaggi possiamo mandare delle unit√† che hanno una <em>dimensione variabile</em>, quindi non siamo obbligati a renderle tutte uguali, che vengono lette <em>atomicamente</em>. Quindi io mando un messaggio, quello l√¨ va in coda, quando sar√† il suo turno viene prelevato e viene letto tutto.</p>
<h2 id="42-pipe"><a class="header" href="#42-pipe">4.2 Pipe</a></h2>
<p><img src="images/processi_2/image%2018.png" alt="image.png" /></p>
<p>La pipe √® molto pi√π a basso livello, non ha il concetto di messaggio: √® semplicemente un <em>tubo dentro cui scorrono dei byte</em>.</p>
<p>La pipe ha un solo mittente e un solo destinatario, <em>uno che inietta di qua e uno che preleva dall'altra parte.</em> La segmentazione dei messaggi all'interno √® frutto di una convenzione. Nell'esempio che abbiamo visto prima col comando <code>rev</code> la segmentazione √® fatta sui new line, decidendo che quelli che ci mandiamo non sono dei byte e basta, ma sono delle stringhe, e per queste stringhe usiamo il new line per indicare la fine della stringa. √à una convenzione per√≤, bisogna che mittente e destinatario la seguano correttamente.</p>
<p>All'interno della pipe noi possiamo mandarci, seguendo <strong>convenzioni diverse</strong>, cose diverse. Potremmo decidere ad esempio che i <strong>primi 4 byte</strong> rappresentano sempre la lunghezza di un blocco che viene dopo. Chiaramente una cosa del genere richiede che io l'informazione di lunghezza la comunichi per prima, in modo tale che chi riceve:</p>
<ul>
<li>prima sa che deve leggere almeno 4 byte, che rappresentano la lunghezza</li>
<li>una volta che li ha ricevuti sa che deve ricevere tanti byte, quanti sono scritti l√¨ dentro, e sar√† il primo messaggio</li>
</ul>
<p>Poi di nuovo cercher√† di leggere altri 4 byte, quella sar√† la nuova lunghezza, e poi cerca di leggere un altro blocco, e cos√¨ via.</p>
<p><img src="images/processi_2/image%2019.png" alt="image.png" /></p>
<p>Ci sono primitive diverse in realt√† per fare questa cosa qua, e anche il comportamento √® un po' distinto. In Windows √® possibile fare delle <em>pipe bidirezionali</em>, di base in Linux le pipe sono <em>monodirezionali</em>.</p>
<p><img src="images/processi_2/image%2020.png" alt="image.png" /></p>
<p><em>Come le vediamo in Rust?</em>
Alcune <strong>librerie esterne</strong> ci vengono messe a disposizione per aiutarci un po'. Qui la grossa difficolt√† √® che il livello di astrazione offerto da Windows in generale, e offerto da Unix in generale, √® molto molto distante, e quindi √® estremamente difficile dare delle primitive, omogenee, che vadano bene da una parte all'altra.</p>
<p>Qui vediamo un <strong>esempio relativamente semplice</strong>, in cui creiamo due comandi sul sistema operativo: il primo genera dell'output, che viene mandato al secondo tramite una pipe, che viene raccolto dal nostro programma Rust tramite un'altra pipe.</p>
<p><em>Come lo facciamo?</em>
Viene fatto un <code>Command::new</code> con <code>echo</code>, e passandogli come argomento una stringa.
<code>echo</code> prende la stringa che gli passiamo sulla command line, e la stampa. La stampa sul proprio standard output. Il problema √® che lo standard output di <code>echo</code>, lo mettiamo in una pipe.</p>
<p>Facciamo partire questa cosa, poi andiamo a prenderci l'uscita di questa pipe, <code>echo_child.stdout</code>, e su questa uscita la usiamo per creare l'ingresso della pipe successiva, per cui creiamo un secondo comando, <code>sed</code> (<em>stream editor</em>), che dice <em>"Cerca in tutte le righe che saranno nel tuo standard input. Se trovi la sequenza <code>tpyo</code>, sostituiscila con <code>typo</code>"</em>.
Leggi dall'uscita di quello prima, e scrivi su un'altra pipe. Facciamo partire anche questo con <code>spawn</code>.</p>
<p>Poi, prendiamo un'ulteriore uscita di questa pipe, <code>let output = sed_child.wait_with_output</code>, e direttamente la stampiamo. In questo caso, andiamo a verificare che contenga la sequenza corretta.</p>
<p>Questo ci fa vedere come noi possiamo, da Rust, organizzare <strong>catene di comandi</strong>.</p>
<p><img src="images/processi_2/image%2021.png" alt="image.png" /></p>
<p>Le cose che mettiamo su una pipe, di natura loro, sono <code>byte</code>. Se noi possiamo prendere delle stringhe, le stringhe le facciamo come sequenze di byte, ci sta. A volte per√≤, noi vogliamo passare dei <em>dati pi√π strutturati</em>. Il modo pi√π facile √® usare <code>serde</code>. <code>serde</code> √® un <em>crate</em> che ci fa la serializzazione, e la deserializzazione.</p>
<p>In particolare, <code>serde</code> ci offre la macro <code>derive</code>, che ci permette di generare automaticamente il modo per serializzare una <code>struct</code>.</p>
<p><em>Serializzarla in che modo?</em>
Oltre a includere <code>serde</code>, possiamo includere delle sottolibrerie di <code>serde</code>, come <code>serde_json</code>, che √® specializzato nel generare del <code>json</code>, e nel trasformare del <code>json</code> in un'altra struttura.
Oppure <code>serde_xml</code>, che √® specializzato nel trasformare in <code>xml</code>.</p>
<p><code>serde</code> √® una <strong>famiglia enorme di programmi</strong>, che ha capacit√† di serializzare e deserializzare in tantissimi formati. Alcuni molto conosciuti, altri un po' pi√π strambi.</p>
<p><img src="images/processi_2/image%2022.png" alt="image.png" /></p>
<p>Il crate <strong><code>interprocess</code></strong> cerca di mettervi a disposizione delle <em>funzionalit√† omogenee</em> tra Windows e Linux.</p>
<p><strong>Attenzione:</strong> fa quello che pu√≤, proprio perch√© ci sono delle cose che sono cos√¨ diverse concettualmente, √® molto difficile da gestire. Per cui, in quelle situazioni, occorre frantumare il codice sorgente e dire "<em>quando compilo sotto Windows metto certe cose, e quando compilo sotto Unix ne metto delle altre</em>". Quindi, creare dei programmi con versioni diverse, o perlomeno con delle catene di costruzione diverse.</p>
<p>Nel caso specifico di Linux, c'√® un ulteriore crate che √® lo <strong><code>zbus</code></strong>, che vi d√† accesso al <strong>D-Bus</strong>.
<strong>D-Bus</strong> √® una struttura che esiste all'interno di Linux, che permette a componenti molto diversi di mandarsi <em>messaggi strutturati</em> con tutta una sua semantica associata.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-things-to-keep-in-mind"><a class="header" href="#-things-to-keep-in-mind">üìù¬†Things to keep in mind</a></h1>
<blockquote>
<p>üí° <strong>Costruttore variabili globali</strong></p>
<p>In C++, se ho costruito delle variabili globali di tipo classe, queste possono avere un costruttore.
Il costruttore delle variabili globali viene invocato prima che il main parta.
Il distruttore delle variabili globali viene invocato dopo che il main √® terminato.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Puntatori e possesso + Smart Pointers</strong></p>
<ul>
<li><code>&amp;</code> ‚Üí Puntatore in sola lettura, senza possesso.</li>
<li><code>&amp;mut</code> ‚Üí Puntatore con accesso in scrittura, senza possesso.</li>
<li><code>Box&lt;T&gt;</code> ‚Üí Puntatore che <strong>possiede</strong> il dato.
<ul>
<li>Non pu√≤ essere copiato</li>
<li>Pu√≤ essere <em>mosso</em></li>
</ul>
</li>
<li><code>Rc&lt;T&gt;</code> ‚Üí <strong>Accesso condiviso (immutabile)</strong> al dato (&amp;T)
<ul>
<li><strong>La propriet√† √® condivisa</strong></li>
<li>Il dato √® posseduto collettivamente da tutti gli <code>Rc</code> che lo puntano</li>
<li>Contatori <strong>strong</strong> e <strong>weak</strong> ‚Üí Utile per strutture cicliche</li>
<li>Il blocco <code>dato+contatori</code> sta sullo heap</li>
</ul>
</li>
<li><code>Arc&lt;T&gt;</code> ‚Üí Equivalente <strong>thread-safe</strong> di <code>Rc&lt;T&gt;</code>
<ul>
<li>Accesso <strong>immutabile (&amp;T)</strong> condiviso tra pi√π thread</li>
<li>Usa <strong>atomic increment e decrement</strong></li>
<li>Usato con <code>Mutex&lt;T&gt;</code> o <code>RwLock&lt;T&gt;</code> per la mutabilit√†</li>
</ul>
</li>
<li><code>Cell&lt;T&gt;</code> ‚Üí Contenitore con¬†interior mutability per tipi¬†Copy
<ul>
<li>Permette di <strong>modificare il dato anche da un riferimento immutabile</strong></li>
<li>Il contenuto pu√≤ essere <strong>letto solo per copia</strong> (Copy), <strong>non per reference</strong></li>
</ul>
</li>
<li><code>RefCell&lt;T&gt;</code> ‚Üí Contenitore con <em>interior mutability</em> per <strong>tipi non Copy</strong>
<ul>
<li>Permette accesso <strong>in lettura (<code>borrow()</code>)</strong> e <strong>scrittura (<code>borrow_mut()</code>)</strong> anche da <code>&amp;self</code></li>
<li>Verifica le regole di borrowing <strong>a runtime</strong> (panic se violate)</li>
<li>Utile per dati mutabili condivisi in ambienti <strong>single-threaded</strong></li>
</ul>
</li>
<li><code>Mutex&lt;T&gt;</code> ‚Üí <strong>Protegge un dato con un lock esclusivo per accesso concorrente</strong>
<ul>
<li>Solo un thread per volta pu√≤ accedere in scrittura (via <code>.lock()</code>)</li>
<li>Interior mutability</li>
<li>Tipicamente usato con <code>Arc&lt;T&gt;</code> per <strong>mutabilit√† condivisa tra thread</strong></li>
</ul>
</li>
<li><code>Cow&lt;'a, B&gt;</code> ‚Üí <em>‚ÄúClone-On-Write‚Äù</em> ‚Üí wrapper che pu√≤ essere <strong>borrowed o owned</strong>
<ul>
<li>Se non mutato si comporta come <code>&amp;‚Äôa B</code></li>
<li>Se mutato effettua un <strong>clone</strong> del dato</li>
<li>Esempio: <code>Cow&lt;str&gt;</code> pu√≤ contenere <code>&amp;‚Äôa str</code> oppure <code>String</code></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>üí° <strong>Riferimenti, espressioni e valori immediati</strong></p>
<p>Scrivere <code>let r1 = &amp;75</code> √® assolutamente lecito: Rust scrive 75 dentro lo stack, come se avessimo creato una variabile temporanea, prende l‚Äôindirizzo di quella variabile e lo salva dentro <code>r1</code> e ci lascia fare delle cose.</p>
<p>Posso scrivere anche <code>let r1 = &amp;(i*5/4)</code> ‚Äî calcola il risultato, lo mette in un temporaneo sempre sullo stack, prende il puntatore e mi manda avanti.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Modificare l‚Äôarea puntata dai puntatori</strong></p>
<p>In Rust, generalmente questo non √® possibile.
L‚Äôunico modo per modificare manualmente un puntatore, per cambiare manualmente l‚Äôindirizzo cui sta puntando (tipo con aritmetica dei puntatori), √® usare i raw pointers (i puntatori nativi del C) in blocchi unsafe.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Create an array of i32 values
    let arr = [1, 2, 3, 4, 5];

    // Create a raw pointer to the first element of the array
    let mut r_ptr: *const i32 = arr.as_ptr();

    // Print the initial value pointed to by r_ptr
    println!("Initial value: {} @ {:p}", unsafe { *r_ptr }, r_ptr); // Output: Initial value: 1

    // Perform pointer arithmetic to move the pointer to the next element
    unsafe {
        r_ptr = r_ptr.add(1);
    }

    // Print the new value pointed to by r_ptr
    println!("New value: {} @ {:p}", unsafe { *r_ptr }, r_ptr); // Output: New value: 2

    // Perform pointer arithmetic to move the pointer to the third element
    unsafe {
        r_ptr = r_ptr.add(1);
    }

    // Print the new value pointed to by r_ptr
    println!("New value: {} @ {:p}", unsafe { *r_ptr }, r_ptr); // Output: New value: 3
}

/*  
		OUTPUT:
		Initial value: 1 @ 0x7fffbb6b8fa4
		New value: 2 @ 0x7fffbb6b8fa8
		New value: 3 @ 0x7fffbb6b8fac
*/
</code></pre></pre>
</blockquote>
<blockquote>
<p>üí° <strong>Le struct stanno sullo stack, SEMPRE (a meno che non sono boxate)</strong></p>
<p><img src="images/keep_in_mind/image.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%201.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Struct sullo stack vs struct sullo heap (Box<Struct>)</strong></p>
<p><img src="images/keep_in_mind/image%202.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%203.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%204.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Copia vs Movimento</strong></p>
<p>La <strong>copia</strong> √® una <strong>duplicazione</strong>: il nuovo valore √® indipendente dall‚Äôoriginale.
Tipi come gli interi (i32, u8, ecc.) vengono copiati quando vengono assegnati o passati a una funzione: si crea una nuova copia del dato, e l‚Äôoriginale resta valido.</p>
<p>Invece, per tipi come Box<T>, l‚Äôassegnazione comporta un <em><strong>movimento</strong></em> (move): il valore viene <em>spostato</em>, e l‚Äôoriginale non pu√≤ pi√π essere usato.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine: */
/* i32 implements Copy */
fn main() {
    let x1 = 5;
    let x2 = x1; // Copy
    
    println!("x1: {}", x1);
    println!("x2: {}", x2);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">/* This doesn't compile */
/* Box doesn't implement Copy */
fn main() {
    let b1 = Box::new(5);
    let b2 = b1; // Movement
    
    println!("b1: {}", b1);     // this should thrown an error
    println!("b2: {}", b2);
}</code></pre></pre>
<p>L‚Äôesempio a destra non funziona perch√®, dato che i dati posseduti da <code>b1</code> vengono <em>spostati</em> in <code>b2</code> (che ne diventa il nuovo proprietario), quando proviamo a stampare <code>b1</code> dopo il movimento, il compilatore ci blocca.
Ci suggerisce anche un modo per risolvere, qualora proprio volessimo tenere sia <code>b1</code> che <code>b2</code>: clonare <code>b1</code>.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn main() {
    let b1 = Box::new(5);
    let b2 = b1.clone();
    
    println!("b1: {}", b1);
    println!("b2: {}", b2);
}</code></pre></pre>
</blockquote>
<blockquote>
<p>üí° <strong>Copy vs Clone ‚Äî Part 1</strong></p>
<p><img src="images/keep_in_mind/image%205.png" alt="image.png" /></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec1.clone();    // vec2 is a deep copy of vec1
    let vec3 = vec2;            // vec2 data is moved to vec3
    
    println!("{:?}", vec1);     // OK
    println!("{:?}", vec2);     // ERROR!!!
}</code></pre></pre>
<p>Nell‚Äôesempio sopra, vediamo che possiamo clonare o spostare un Vec, ma non possiamo semplicemente copiarlo.
Questo √® vero per Vec, ma anche per qualsiasi tipo complesso come ad esempio delle struct custom con campi complessi all‚Äôinterno, e in generale per tutti quei tipi che necessitano di una gestione della memoria dinamica, e che dunque devono implementare il tratto <code>Drop</code>.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Copy vs Clone ‚Äî Part 2</strong></p>
<p><img src="images/keep_in_mind/image%206.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%207.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Mutabilit√†</strong></p>
<p>La mutabilit√† √® una caratteristica del <em>possessore</em>, non del <em>dato</em>.
Dunque se ad esempio avessi una funzione che crea un Box, e inizialmente questo √® immutabile, e poi restituisco questo Box al chiamante, che lo memorizza in una variabile, questa sarebbe il nuovo possessore del Box, che pu√≤ quindi decidere di mutarlo.</p>
<pre><pre class="playground"><code class="language-rust">/* This is fine */
fn makeBox(a: i32) -&gt; Box&lt;(i32, i32)&gt; {
    let r = Box::new( (a, 1) );
    return r;
}

fn main() {
    let mut b = makeBox(5); // OK
    b.0 = b.0 + 1;
    
    println!("{:?}", b);
}</code></pre></pre>
</blockquote>
<blockquote>
<p>üí° <strong>Movimento, stack ed heap</strong></p>
<p>Il movimento provoca una copia bit a bit di ci√≤ che c‚Äô√® sullo stack.
Quello che sta sullo heap non √® coinvolto nell‚Äôoperazione di movimento.</p>
<p><img src="images/keep_in_mind/image%208.png" alt="image.png" /></p>
<p>Ad esempio, supponiamo si avere un <code>Vec</code> che punta sullo heap a quella sequenza di interi. Se scrivessi <code>let v2 = v;</code>, sullo stack si creerebbe <code>v2</code>, cio√® un nuovo <code>Vec</code>, al cui interno troveremmo: nel primo campo <strong>lo stesso puntatore</strong> alla sequenza di interi, nel secondo campo <strong>la stessa capacity 8</strong>, e nel terzo campo <strong>la stessa size 5</strong>.</p>
<p>A questo punto il Vec originale <code>v</code> <strong>√® ancora presente sullo stack</strong>, ma √® ora inaccessibile: ha perso diritti e doveri sullo spazio allocato sull‚Äôheap.</p>
<p>Una volta usciti dallo scope sintattico, sia <code>v</code> che <code>v2</code> verranno egettate dallo stack, ma con una importante differenza: <code>v2</code> si occuper√† di rilasciare lo spazio sull‚Äôheap, mentre <code>v</code> non deve fare niente (questo meccanismo ‚Äî il fatto che v2 deve rilasciare, mentre v no ‚Äî lo gestisce il compilatore).</p>
</blockquote>
<blockquote>
<p>üí° <strong>Valori temporanei e riferimenti</strong></p>
<p><img src="images/keep_in_mind/image%209.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2010.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Spostare un puntatore in Rust</strong></p>
<p><img src="images/keep_in_mind/image%2011.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2012.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2013.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2014.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2015.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2016.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2017.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>I riferimenti implementano Copy</strong></p>
<p><img src="images/keep_in_mind/image%2018.png" alt="image.png" /></p>
<p>Output:</p>
<p><img src="images/keep_in_mind/image%2019.png" alt="image.png" /></p>
<p>Vediamo che <code>pt1</code> e <code>pt2</code> sono due puntatori distinti: puntano allo stesso indirizzo di memoria (l‚Äôindirizzo dove √® contenuto <code>x</code>), ma hanno indirizzi diversi. Dunque nel momento in cui abbiamo fatto <code>let pt2 = pt1</code>, abbiamo creato un nuovo reference ex novo, senza movimento.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Rc ‚Äî downgrade &amp; upgrade</strong></p>
<p><img src="images/keep_in_mind/image%2020.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2021.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2022.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Cell<T></strong></p>
<p><img src="images/keep_in_mind/image%2023.png" alt="image.png" /></p>
<p><img src="images/keep_in_mind/image%2024.png" alt="image.png" /></p>
</blockquote>
<blockquote>
<p>üí° <strong>Polimorfismo: <em>tipi generici</em> vs <em>oggetti tratto</em></strong></p>
<p><img src="images/keep_in_mind/image%2025.png" alt="image.png" /></p>
<p><strong>Tipi generici e Monomorfizzazione</strong>
Quando scriviamo del codice con tipi generici, al momento della compilazione Rust applica un processo di <em><strong>monomorfizzazione</strong></em>: una volta che il compilatore comprende qual √® il tipo concreto su cui deve eseguire il codice scritto con le metavariabili, genera il codice ottimizzato per quel tipo concreto. Quindi, se ad esempio abbiamo scritto una funzione con parametri generici, e poi la richiamiamo una volta su degli interi, e una volta su delle stringhe, a compile time verranno generate due versioni della stessa funzione: una ottimizzata per gli interi, l‚Äôaltra ottimizzata per le stringhe.</p>
<p>In ogni caso, √® possibile applicare dei vincoli su quali possano essere questi tipi concreti che andranno a sostituirsi alle metavariabili, specificando su queste quali sono i tratti che il tipo concreto deve implementare (<em><strong>Trait Bound</strong></em>).</p>
<p>Ad esempio <code>struct MyStruct&lt;T: Copy&gt; {copy_data: T, ... }</code> indica che questa struct accetta tra i suoi campi una variabile generica <code>copy_data</code>, il cui tipo deve implementare il tratto <code>Copy</code>.</p>
<ul>
<li><strong>Vantaggi</strong>:
<ul>
<li>Performance a runtime</li>
<li>Ottimizzazione del codice generato per la funzione</li>
<li><em>Code inlining</em> per limitare l‚Äôimpatto delle chiamate a funzione</li>
<li>Consente di esprimere vincoli pi√π complessi sui tratti</li>
</ul>
</li>
<li><strong>Svantaggi</strong>: codice generato dal compilatore di dimensioni maggiori (di fatto generiamo una versione della stessa funzione per ogni tipo concreto su cui la invochiamo).</li>
</ul>
<p><strong>Oggetti tratto</strong>
Gli oggetti tratto, d‚Äôaltro canto, consentono di rimandare a runtime la determinazione della funzione da chiamare, invece di doverla determinare a compile time. Infatti, attraverso la vtable del tipo concreto passato a runtime viene chiamata l‚Äôimplementazione di quella funzione offerta dal tipo concreto, specificata nella sua vtable.
Alla funzione viene dunque passato un oggetto tratto: un fat pointer che √® composto dal puntatore al dato concreto, e un puntatore alla vtable del tipo concreto.</p>
<ul>
<li><strong>Vantaggi:</strong>
<ul>
<li><strong>Codice pi√π compatto</strong>: quando scriviamo una funzione che usa oggetti tratto, siamo sicuri che il codice della funzione generato dal compilatore √® unico, ed √® proprio quello l√¨ che abbiamo scritto, a prescindere dal tipo concreto che verr√† passato alla funzione</li>
<li><strong>Un oggetto tratto √® un fat pointer, che pu√≤ puntare a dati di tipo diverso</strong>, e dunque di dimensione diversa. Per√≤ alla funzione/struttura passiamo sempre e solo un fat pointer da 16 byte (per architettura 64bit).</li>
<li><strong>Utile quando dobbiamo memorizzare in una collezione</strong> <strong>tipi diversi</strong>, ma che implementano un tratto comune.
Questo viene facile perch√® appunto memorizziamo semplicemente dei riferimenti a degli oggetti che implementano quel tratto l√¨, mentre nella programmazione generica avremmo dovuto usare una metavariabile <code>T: Some_trait</code>, che avrebbe implicato che <em><strong>tutti</strong></em> gli oggetti della collezione devono essere dello stesso tipo <code>T</code></li>
</ul>
</li>
<li><strong>Svantaggi:</strong>
<ul>
<li>Non tutti i tratti permettono di definire oggetti tratto (occorre che nessun metodo del tratto non si usi <code>self</code> come parametro o tipo di ritorno, ma solo <code>&amp;self</code> e <code>&amp;mut self</code>)</li>
<li>Non √® possibile definire un oggetto tratto legato a pi√π tratti disgiunti (invece con i tipi generici possiamo vincolarli a pi√π tratti!)</li>
<li>Chiamata del metodo pi√π dispendiosa e lenta: passa attaverso la vtable</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>üí° <strong>Puntatori e gestione della memoria in Rust</strong></p>
<p>I puntatori consentono di fare tantissime cose, ad esempio quando dobbiamo passare una struttura dati ad una funzione, possiamo passare un puntatore alla struttura, piuttosto che copiare la struttura intera. In pratica, ci d√† un modo efficiente per avere dei riferimenti a dei dati.</p>
<p>Tuttavia, un uso sbagliato dei puntatori (in linguaggi che ne consentono la manipolazione senza espliciti meccanismi che ne rendano sicuro l‚Äôutilizzo) pu√≤ portare a dei comportamenti indesiderati: gli undefined behaviours.</p>
<p>Tra questi troviamo:</p>
<ul>
<li><strong>Wild pointer</strong>
Se non inizializziamo un puntatore con un indirizzo valido, ma piuttosto lo usiamo cos√¨ com‚Äô√®, potremmo leggere o scrivere in un indirizzo qualsiasi: dipende da cosa c‚Äôera scritto nello stack al momento in cui abbiamo dichiarato il puntatore, senza inizializzarlo.</li>
<li><strong>Dangling pointer</strong>
Puntatore che punta ad una zona di memoria che per√≤ era stata rilasciata: ad esempio l‚Äôindirizzo di una variabile uscita di scope. Il puntatore dunque non √® pi√π valido, perch√® la variabile √® stata rilasciata, l‚Äôinformazione quindi non √® pi√π valida e la zona puntata ora potrebbe contenere qualsiasi altra cosa.</li>
<li><strong>Memory leakage</strong>
Se acquisiamo della memoria dinamica, e otteniamo il puntatore al blocco di memoria dinamica, ma poi non lo rilasciamo pi√π, nel momento in cui il puntatore esce di scope non solo non avremo rilasciato la memoria, ma perderemo anche l‚Äôinformazione di <em>dove</em> era quel blocco di memoria acquisito.
In pratica, quel blocco non pu√≤ essere rilasciato: abbiamo creato un buco nella memoria.</li>
<li><strong>Double free</strong>
Se abbiamo ad esempio due puntatori che puntano allo stesso blocco di memoria, e proviamo a fare un doppio rilascio, provochiamo danni nelle strutture dati che mantengono l‚Äôorganizzazione della memoria.</li>
</ul>
<p>Inoltre, in linguaggi come C i puntatori non hanno informazioni che rendano esplicito se chi li usa √® anche responsabile del rilascio della memoria puntata: insomma, il possesso del dato puntato non √® chiaro.</p>
<p>Per risolvere questi problemi, Rust combina due cose: da un lato l‚Äôutilizzo di svariati tipi di puntatori, ciascuno con un determinato scopo e determinate caratteristiche (abbiamo puntatori che posseggono, puntatori che non posseggono, puntatori che possono solo leggere, oppure puntatori che possono leggere e scrivere ma nel frattempo non possono esserci altri riferimenti allo stesso dato, oppure ancora puntatori che consentono un possesso condiviso, tenendo all‚Äôinterno del puntatore stesso le informazioni di in quanti conoscono quel dato etc‚Ä¶), dall‚Äôaltro l‚Äôutilizzo di un modulo del compilatore chiamato <strong>Borrow Checker</strong>, che facendo un‚Äôanalisi formale e logica del codice garantisce che non esista alcuna possibilit√† che le regole sul possesso e sui prestiti siano violate.</p>
<p>Rust implementa il paradigma RAII: <em>Resource Acquisition Is Initialization</em>, che in pratica stabilisce che chi acquisisce un dato diventa responsabile della sua inizializzazione, e anche della sua distruzione (e quindi del rilascio di memoria dinamica, laddove previsto).
In pratica, il dato √® posseduto da una e una sola variabile, e quando ad esempio proviamo ad assegnare una variabile ad un‚Äôaltra solo due sono le possibilit√†:</p>
<ul>
<li>Il dato viene <strong><em>moss</em>o</strong> nella nuova variabile, e quella vecchia diventa inaccessibile</li>
<li>Il dato viene <em><strong>copiato</strong></em>, generando una copia totalmente separata dal dato originale</li>
</ul>
<p>Oppure, il dato pu√≤ essere <em><strong>clonato</strong></em> (se non pu√≤ essere copiato, ma solo mosso), ma questa operazione deve essere resa esplicita dal programmatore.</p>
<p>Quando la variabile che possiede il dato arriva alla fine del suo ciclo di vita, questa dovr√† occuparsi del rilascio del dato posseduto: in Rust questo viene fatto attraverso l‚Äôimplementazione del tratto <code>Drop</code>, infatti i tipi di dati che necessitano particolari operazioni di rilascio (rilascio di blocco di memoria, chiusura di un file, chiusura di un socket etc‚Ä¶) devono implementare questo tratto.</p>
</blockquote>
<blockquote>
<p>üí° <strong>Borrow Checker</strong></p>
<p>Il <strong>Borrow Checker</strong> √® uno dei meccanismi centrali del compilatore Rust, e ha il compito di <strong>verificare che il codice rispetti le regole di possesso (ownership) e prestito (borrowing)</strong> dei dati. Questo sistema consente di scrivere <strong>codice sicuro in modo automatico, senza bisogno di garbage collector o analisi a runtime</strong>.</p>
<p>Il Borrow Checker analizza il codice <strong>durante la compilazione</strong> per assicurarsi che:</p>
<ul>
<li><strong>Ogni valore abbia un solo proprietario (owner)</strong>, che √® responsabile della sua validit√† e distruzione.
Controlla chi √® che possiede un certo dato, se, quando e a chi questo venga ceduto, rendendo impossibile l‚Äôaccesso alla variabile che lo deteneva in origine etc‚Ä¶</li>
<li><strong>Esistano regole chiare per il ‚Äúprestito‚Äù del dato</strong>:
<ul>
<li>√à possibile avere <strong>pi√π prestiti immutabili</strong> (&amp;T) <strong>oppure uno solo mutabile</strong> (&amp;mut T), <strong>mai entrambi contemporaneamente</strong>.</li>
<li>Un riferimento (prestito) <strong>non pu√≤ sopravvivere pi√π a lungo del dato originale</strong>.#</li>
</ul>
</li>
</ul>
<p><em>Perch√® √® utile?</em>
Con il Borrow Checker, Rust <strong>garantisce a compile-time</strong> che non esister√† mai un riferimento non valido. Questo:</p>
<ul>
<li>Elimina la necessit√† di una raccolta automatica della memoria (GC),</li>
<li>Garantisce sicurezza nella concorrenza (thread-safe by default),</li>
<li>Migliora le performance, perch√© evita runtime overhead.</li>
</ul>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
