<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concorrenza</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="concorrenza---malnati-22-25"><a class="header" href="#concorrenza---malnati-22-25">Concorrenza - Malnati 22-25 <!-- omit in toc --></a></h1>
<h1 id="indice"><a class="header" href="#indice">Indice <!-- omit in toc --></a></h1>
<ul>
<li><a href="#1-introduzione">1. Introduzione</a>
<ul>
<li><a href="#11-thread-nativi">1.1 Thread nativi</a></li>
<li><a href="#12-cosa-implica-la-concorrenza">1.2 Cosa implica la concorrenza</a></li>
<li><a href="#13-pro-e-contro-della-programmazione-concorrente">1.3 Pro e Contro della Programmazione Concorrente</a></li>
<li><a href="#14-modello-di-memoria">1.4 Modello di memoria</a></li>
<li><a href="#15-problemi-aperti">1.5 Problemi aperti</a></li>
<li><a href="#16-esecuzione-e-non-determinismo">1.6 Esecuzione e non determinismo</a>
<ul>
<li><a href="#161-esempio">1.6.1 Esempio</a></li>
</ul>
</li>
<li><a href="#17-sincronizzazione">1.7 Sincronizzazione</a>
<ul>
<li><a href="#171-strutture-native-di-sincronizzazione">1.7.1 Strutture native di sincronizzazione</a></li>
</ul>
</li>
<li><a href="#18-correttezza">1.8 Correttezza</a></li>
<li><a href="#19-accesso-condiviso">1.9 Accesso condiviso</a></li>
</ul>
</li>
<li><a href="#2-thread-in-rust">2. Thread in Rust</a>
<ul>
<li><a href="#31-i-tratti-della-concorrenza">3.1 I tratti della concorrenza</a></li>
</ul>
</li>
<li><a href="#3-mutex-in-rust">3. Mutex in Rust</a></li>
<li><a href="#4-conditionvariable-in-rust">4. ConditionVariable in Rust</a></li>
<li><a href="#5-canali-in-rust">5. Canali in Rust</a>
<ul>
<li><a href="#51-esempio">5.1 Esempio</a></li>
<li><a href="#52-canali-sincroni">5.2 Canali sincroni</a>
<ul>
<li><a href="#521-esempio-con-buffer-di-dimensione-0"><strong>5.2.1 Esempio con buffer di dimensione 0</strong></a></li>
<li><a href="#522-conclusioni-sui-canali-sincroni">5.2.2 Conclusioni sui canali sincroni</a></li>
</ul>
</li>
<li><a href="#53-la-libreria-crossbeam">5.3 La libreria Crossbeam</a>
<ul>
<li><a href="#531-fan-out--fan-in">5.3.1 Fan-Out / Fan-In</a></li>
<li><a href="#532-pipeline">5.3.2 Pipeline</a></li>
<li><a href="#533-producer--consumer">5.3.3 Producer / Consumer</a></li>
<li><a href="#534-il-modello-degli-attori">5.3.4 Il modello degli attori</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-riferimenti">6. Riferimenti</a></li>
</ul>
<h1 id="1-introduzione"><a class="header" href="#1-introduzione">1. Introduzione</a></h1>
<p><img src="images/concorrenza/image.png" alt="image.png" /></p>
<p><strong>La programmazione concorrente</strong> di base si occupa di permetterci la gestione nel contesto dello stesso processo di più attività una fianco all'altra. Notate che di per sé il concetto di concorrenza esiste nei sistemi operativi da tantissimo tempo: un sistema operativo si occupa di permettere a una singola CPU di poter eseguire molti processi separati, indipendentemente l'uno dall'altro.</p>
<p><em>E' diventata significativa negli anni 90</em> nel momento in cui i sistemi operativi hanno reso disponibile l'accesso al proprio <em><strong>scheduler</strong></em> permettendo la creazione, nel contesto dello stesso processo, di più thread. Fino agli anni 90 la concorrenza veniva realizzata grazie al fatto che esistevano processi che giravano sulla macchina che potevano svolgersi sì in parallelo, ma siccome erano isolati l'uno dall'altro non si impicciavano.</p>
<p>Dando invece la possibilità nel contesto di uno stesso processo (e quindi di uno stesso spazio di indirizzamento) di poter creare più thread, ciascuno dei quali governa il proprio flusso di esecuzione, <strong>da un lato</strong> si è dischiuso un uso più efficace del potenziale parallelismo contenuto all'interno del nostro codice, <strong>dall'altro</strong> si sono aperti una serie di problemi che ora vogliamo sviscerare bene.</p>
<p>Quindi un programma concorrente è quello che contiene al suo interno due o più flussi di esecuzione. Notate che quando viene creato un processo il sistema operativo automaticamente crea il <em><strong>flusso di esecuzione primario</strong></em>, quello che noi normalmente facciamo partire dal main. In realtà sappiamo che parte da prima, ma fa lo stesso. Di base quello è l'unico flusso presente all'interno del processo a meno che noi in modo esplicito non chiediamo di attivarne degli altri.</p>
<p><em><strong>Come lo chiediamo?</strong></em>
Dipende… Dipende dal sistema operativo, e dipende dal linguaggio. Fino ad alcuni anni fa non esisteva un modo normalizzato, nei linguaggi di basso livello, di creare thread alternativi. Occorreva ricorrere esplicitamente alle system call offerte dal sistema operativo. Nel caso di Unix o dei sistemi diciamo POSIX like, questo equivaleva a invocare la funzione <code>pthread_create</code>, nel caso di Windows questo equivaleva a chiamare l'API chiamata <code>CreateThread</code> e altri... Chiaramente questo poneva un problema perché realizzare dei programmi in multipiattaforma diventava più complesso.</p>
<p>Quando chiediamo di attivare un thread all'interno di un processo esistente, quello che succede è che il sistema operativo, nello spazio di indirizzamento del processo, riserva una nuova zona di memoria, grande di solito un megabyte, ma comunque dimensionabile, per poter contenere lo stack di questo nuovo thread. <strong>Perché ad ogni thread creato all'interno di un processo viene associato uno stack</strong>.</p>
<p><em>Quindi se è vero che fino adesso noi abbiamo considerato i nostri processi come dotati di uno spazio di memoria all'interno delle quali c'è uno stack e un heap</em>, nel momento in cui attiviamo più thread, lo heap rimane sempre uno solo, condiviso da tutti. Di stack ce ne sono tanti quanti sono i thread che abbiamo attivato. Il thread che noi attiviamo non solo ha uno stack, ma ha associata anche una computazione, ovvero per poter creare un thread occorre specificare una funzione che ne rappresenta la computazione.</p>
<p>Di fatto il thread comincia a invocare questa funzione, procede, fa tutto quello che c'è scritto all'interno, fino a quando questa funzione non ritorna. Nel momento in cui la funzione ritorna il thread viene chiuso e cessa di esistere. <strong>In base al sistema operativo la funzione invocata dal thread può ritornare o meno un valore.</strong></p>
<p><strong>In generale i linguaggi moderni</strong> che espongono il concetto di thread lo fanno nascondendo completamente la funzione specifica del sistema operativo e ci danno astrazioni diverse. In alcuni casi ci danno delle astrazioni per cui il thread non ritorna niente, è il caso di <strong>Java</strong>. In Java voi potete creare un thread, e l'oggetto thread è determinato da un oggetto che implementa l'interfaccia <code>Runnable</code>, che è un'interfaccia molto semplice, ha un unico metodo, <code>public void run</code>. Non ha argomenti, non ha tipo di ritorno, è void. Di conseguenza quel thread lì esegue, fa qualcosa, tutt'al più vedrò degli effetti collaterali, niente altro.</p>
<p>In altri casi, viceversa, altri linguaggi, <strong>C++</strong> piuttosto che <strong>Rust</strong>, ci offrono la possibilità di ritornare un valore. Quel valore lì viene conservato fino a che qualcuno non lo va a leggere.</p>
<p><img src="images/concorrenza/image%201.png" alt="image.png" /></p>
<p>Notate che i dettagli di quello che succede sono completamente mediati dal sistema operativo. Quindi la libreria di supporto, in cooperazione con il sistema operativo, si occupa, all'atto della richiesta di creazione di un thread, di:</p>
<ul>
<li><strong>allocare uno stack</strong> grande quanto serve nel nostro spazio di indirizzamento</li>
<li><strong>preparare delle strutture lato kernel</strong> all'interno delle quali sia possibile conoscere lo stato della computazione del thread stesso</li>
</ul>
<p>Dopodiché il thread verrà, la rappresentazione che il sistema operativo dà del thread al proprio interno verrà resa disponibile allo <strong>scheduler</strong> che provvederà ad allocare a questo thread la CPU, mettendolo insieme a tutte le altre attività che il sistema operativo deve svolgere.</p>
<p>Notate che alcuni linguaggi ci danno l'<strong>accesso diretto ai thread</strong> così come li fa il sistema operativo e in questo caso parliamo di supporto con <em>thread nativi</em>. In altri casi viceversa, la creazione di thread può essere mediata da uno strato di runtime offerto dal linguaggio stesso. E' quello che sta succedendo in questo momento con <strong>Java</strong> a partire dalla versione 21, che mette a disposizione oltre che i thread nativi anche i cosiddetti <em><strong>green thread</strong></em>.
Questo è reso possibile dal fatto che nel runtime di Java si è scelto di implementare un proprio scheduler che agisce <em>on top</em> dello scheduler del sistema operativo. E nel fare questa scelta hanno pensato che questo potesse portare dei benefici sulla scalabilità in grande delle applicazioni.</p>
<p>In questo secondo caso, quando cioè viene adottato uno <strong>scheduler intermedio</strong> che si pone on top dello scheduler del sistema operativo, genericamente chiamiamo il sistema di threading <em>green thread</em> o in alcuni casi <em>fibers</em> o <em>fibre</em>.</p>
<p>Di base, sia <strong>C++</strong> che <strong>Rust</strong> ci danno direttamente l'accesso ai thread nativi, ma ci danno anche la possibilità mediante librerie di terze parti di creare degli scheduler intermedi e quindi di implementare le astrazioni dei green thread.</p>
<p>Noi ci occuperemo in questo momento dei <strong>thread nativi</strong>, che sono quelli di base che la piattaforma sottostante ci garantisce. E ci concentreremo sulle tre piattaforme significative che sono quelle di <strong>Windows</strong> e il mondo <strong>Unix</strong> in generale, che in questo caso è rappresentato dall'astrazione chiamata <strong>POSIX</strong>.</p>
<h2 id="11-thread-nativi"><a class="header" href="#11-thread-nativi">1.1 Thread nativi</a></h2>
<p><img src="images/concorrenza/image%202.png" alt="image.png" /></p>
<p><strong>Tipicamente</strong>, ciascun sistema operativo a modo proprio ci offre <em>tre funzioni fondamentali</em>, che sono:</p>
<ul>
<li><em>Crea un nuovo thread</em></li>
<li><em>Identifica ciascun thread in un modo univoco</em>
Il modo con cui lo identifico può essere tramite una <strong>handle opaca</strong> e/o tramite un <strong>ID esplicito</strong> (thread numero 27, thread numero 54…). Le due cose sono in corrispondenza biunivoca: l'ID è univoco a livello di sistema operativo, quindi se in un processo ho un thread che si chiama 27, quel thread si chiama 27 e non c'è nessun altro thread che si chiama 27 in nessun altro processo che sta girando in questo momento. E normalmente è associato anche a una handle in modo biunivoco.</li>
<li><em><strong>Join</strong></em></li>
</ul>
<p>L’operazione join è un'operazione che dice <em>“io ho creato questo thread che deve fare delle sue cose, adesso io mi fermo finché lui non ha finito”</em>. Eventualmente posso avere accesso, a secondo di come wrappo questa operazione, a uno stato finale di quel thread, il valore che mi ritorna, oppure non avercelo. Nel caso di <strong>Java</strong> non ce l'ho, join mi blocca e basta, viceversa in altri linguaggi ho la possibilità facendo l'operazione join di, quando il thread è finito, recuperare quale valore mi ha restituito.</p>
<p>Queste sono le operazioni che in modo differente, ma concettualmente simile, fanno tutti i sistemi operativi. In modo differente vuol dire che sono tanti diversi i parametri che devo passare. Nel caso di <strong>Windows</strong> abbiamo due funzioni essenziali che mi creano, <code>CreateThread</code> semplice o <code>CreateThreadEx</code>, che differiscono nella quantità di parametri, richiedono come minimo l'indicazione della funzione da invocare, <code>CreateThread</code> anche la dimensione dello stack e qualcos'altro, la definizione del contesto di sicurezza e così via.</p>
<p>Nel caso di <strong>POSIX</strong> tendenzialmente la <code>pthread_create</code> mi chiede altri parametri che contengono anche lì in qualche modo l'indicazione della funzione da chiamare eccetera, però l'ordine e la sintassi è differente.</p>
<p><strong>I linguaggi moderni</strong> nascondono tutto questo, liberandoci dal problema di sapere il dettaglio di cosa il sistema operativo fa. Quello che i sistemi operativi <em>non fanno, nel modo più assoluto</em>, è darci un modo di <strong>cancellare un thread</strong>.
Perché non c'è? Perché in realtà quando si è provato a mettere qualcosa ci si è resi conto che si facevano dei danni galattici.</p>
<p>La cancellazione è possibile <em>solo in un processo cooperativo</em>, ovvero io chiedo in qualche modo (poi vedremo come) al thread di piantarla lì e quando lui ha voglia la pianta lì.
L'alternativa è <strong>uccidere tutto il processo</strong>. Quello lo posso fare. Uccidendo il processo distruggo tutti i thread che stanno dentro e di conseguenza libero lo spazio di indirizzamento e così via.</p>
<p>Un tentativo di implementare la terminazione forzata dei thread è stato fatto nella prima versione di <strong>Java</strong>, Java 1.0, che aveva introdotto i thread multipiattaforma. All'oggetto <code>Thread</code>, oltre al metodo <code>start</code> per l'avvio, era stato aggiunto il metodo <code>stop</code> per bloccare l'esecuzione. Tuttavia, il metodo <code>stop</code> si è rivelato disastroso: potendo intervenire in modo asincrono e casuale, interrompeva il thread bruscamente in qualsiasi punto dell'esecuzione, lasciando strutture dati in uno stato inconsistente e impossibile da ricostruire. È come se qualcuno venisse colpito all'improvviso: tutto ciò che stava facendo rimane incompiuto, e gli altri thread non hanno modo di capire cosa sia stato completato e cosa no, creando una situazione ingestibile.</p>
<p>Di conseguenza ai thread si può in qualche modo dire <strong>"<em><strong>per favore fermati</strong></em>"</strong> e quando lui si accorge che gli avete chiesto "fermati" e decide che ci sono le condizioni per fermarsi, allora si ferma. Però è fondamentale: è un <em><strong>atteggiamento cooperativo</strong></em>.</p>
<h2 id="12-cosa-implica-la-concorrenza"><a class="header" href="#12-cosa-implica-la-concorrenza">1.2 Cosa implica la concorrenza</a></h2>
<p><img src="images/concorrenza/image%203.png" alt="image.png" /></p>
<p>Di per sé il concetto di concorrenza è tutto qua.
Quindi, abbiamo creato la capacità di eseguire più cose in parallelo nello stesso spazio di indirizzamento.</p>
<p>Uno potrebbe chiedersi <em>"e dove sta la difficoltà?".</em>
Potrebbe anche chiedersi <em>"qual è il beneficio di questa cosa?"</em></p>
<p>Allora i benefici sono tanti. Prima di tutto la possibilità di fare cose contemporaneamente. Contemporaneamente perché spesso i nostri programmi si trovano a dover fare ad esempio alcune operazioni che riguardano la <strong>I/O</strong>.</p>
<p>Ad esempio, io scrivo a un certo punto sul disco. Come avviene la scrittura sul disco? Beh, la scrittura sul disco avviene che io preparo le cose che voglio scrivere, poi le metto in un <strong>buffer</strong>, poi dico al sistema operativo <em>"trasferiscili nel disco"</em>. Il sistema operativo, con i meccanismi suoi — usando il <strong>DMA</strong>, o non usandolo, non ha importanza — trasferisce.
Il problema è che io devo sapere quando quel buffer lo posso riusare. Quindi l'operazione <code>write</code>, che accetta il buffer da scrivere, mi blocca fino a che il sistema operativo non è finito.</p>
<p><em>Quanto ci mette l'operazione</em> <code>write</code><em>?</em>
Dipende… dipende da che disco avete (un disco rotativo, un disco allo stato solito etc…).
Ci può mettere <strong>decine di migliaia di cicli macchina</strong>, a volte <strong>centinaia di migliaia di cicli macchina</strong>, che sono millisecondi. Millisecondi, nell'esperienza di un computer, sono <em>mesi nell'esperienza umana</em>. Di conseguenza, in quei millisecondi io sono fermo in attesa che il sistema operativo faccia. Potrei fare altre cose? Ovviamente sì.</p>
<p>E allora l'idea è che, mentre un thread è bloccato in un'operazione di I/O, ne posso avere un altro che fa delle cose utili. Quindi arrivo a sovrapporre temporalmente delle cose. Potrei ottenere in parte questo beneficio <strong>se creassi due processi</strong>.
Certo, tutto il mondo Unix vecchia maniera, 1970-1980, era pensato proprio sull'idea di creare molti processi. Alla base di Unix c'è la System Call che si chiama <code>fork</code>, che vi permette di duplicare un processo col suo stato di esecuzione. E quindi io posso affidare a un altro processo il compito di fare un certo mestiere. Ma se poi quest'altro processo deve ritornarmi dei dati, è complicato, perchè è completamente separato. È vero che la partenza è condivisa, ma l'arrivo invece è separato. E quell'altro processo deve poi mandarmi indietro delle cose, e lo deve fare con dei sistemi di <strong>Inter-Process Communication</strong>, che costano tantissimo.</p>
<p>Viceversa, col mondo dei thread, siccome operiamo nello stesso spazio di indirizzamento, io posso dire a un thread <em>"scrivi qui il tuo risultato, quando tu avrai finito vengo a leggere e quello che hai trovato lo leggo: lo trovo lì, facile"</em>. Cioè gli passo l'indirizzo di dove lui deve mettere i suoi risultati e poi lo andrò a vedere. Quindi non ho nessun overhead di Inter-Process Communication.</p>
<p><img src="images/concorrenza/image%204.png" alt="image.png" /></p>
<p>Posso, se la mia CPU è multi-core, veramente eseguire più operazioni in <strong>completo parallelo</strong>. Mentre un core svolge un compito, un altro può dedicarsi a un'attività differente. Prendiamo come esempio la moltiplicazione di due grandi matrici tipiche dell'AI, ciascuna da un milione per un milione di elementi. Possiamo suddividere queste moltiplicazioni tra i core disponibili. Ogni core si occupa di calcolare alcune righe della matrice risultante: uno elabora una riga, un altro un'altra riga e così via. Le operazioni sono indipendenti tra loro, quindi non ci sono interferenze. In questo modo però completiamo il calcolo molto più rapidamente.</p>
<h2 id="13-pro-e-contro-della-programmazione-concorrente"><a class="header" href="#13-pro-e-contro-della-programmazione-concorrente">1.3 Pro e Contro della Programmazione Concorrente</a></h2>
<p><strong>Questi sono i pro</strong> della programmazione concorrente. E ci sono ovviamente anche i contro.</p>
<p><em>Quali sono i contro?</em>
I contro sono che i nostri <em>modelli mentali naufragano</em>.
Noi siamo nati e cresciuti abituati a pensare a un programma che si svolge <strong>linearmente</strong>, sequenzialmente nel tempo — <em>faccio questo, poi faccio quello, poi faccio quell'altro.</em></p>
<p>Noi lo concepiamo così il nostro programma, è fondamentale concepirlo così. Abbiamo ben chiaro che la sequenza che scriviamo delle istruzioni <em>denota la precedenza nel tempo</em>. E questo ci permette di dire che alla riga X una certa cosa non è ancora capitata perché viene scritta la riga X+Δ, con Δ positivo. E quindi siamo tranquilli che sicuramente lì questa cosa è vera.</p>
<p>Peccato che nel momento in cui l'esecuzione diventa <strong>concorrente</strong>, le relazioni temporali tra quello che avviene nel thread1 e quello che avviene nel thread2 non sono più ovvie. Perché i due si svolgono ognuno dai fatti loro. E quindi io posso aver già finito quando tu non hai neanche ancora cominciato. E non basta dire <em>"cominciamo insieme"</em>, perché poi ognuno di noi ha storie diverse.</p>
<p>Di conseguenza quello che capita è che ci sono <strong>nuove fonti di errore</strong> e soprattutto <strong>nuove tipologie di errore</strong> a cui non avremmo normalmente mai pensato. E che se non vediamo, pensiamo che siano farlocche, che non esistano. Ma in realtà ci sono e ora cercheremo di prendere consapevolezza di questa cosa.</p>
<p>Il problema di fondo è legato al fatto che la memoria <em>non può più essere pensata come un deposito statico</em>. Noi siamo abituati a pensare che se io ho scritto 32 in una certa variabile, da quando l'ho scritto, tutti che vanno a leggere ci trovano 32. In realtà è più complesso di così. Perché io non scrivo mica direttamente nella variabile. Dobbiamo prendere in considerazione un po' più in profondità com'è fatta l'architettura dell'elaborazione. In più, se mentre io scrivo tu leggi, <em>cosa leggi?</em> Boh, possono capitare cose molto strane.</p>
<p><img src="images/concorrenza/image%205.png" alt="image.png" /></p>
<p>La prima cosa che diciamo è che se in un processo sono presenti due o più thread, ciascuno di questi thread per conto suo si svolge normalissimamente. Fa esattamente quello che farebbe un programma normale, cioè fa le cose nell'ordine che sono scritte. Quindi di per sé la scrittura del codice del singolo thread non è problematica. Il problema è <strong>l'interazione tra l'uno e l'altro</strong>.</p>
<p>Cosa posso dire di <em>“a che punto è l'altro se io ho raggiunto questo punto?”</em> <em>Niente</em>.</p>
<p>Se voi mangiate insieme, il fatto che uno di voi abbia finito il suo piatto vuol dire che anche gli altri hanno finito? Manco per idea: potreste essere molto veloci e quindi finire prima di tutti, oppure potreste essere molto lenti e finire per ultimi, oppure potreste avere una velocità di mangiare intermedia e qualcuno dei vostri commensali ha già finito e qualcuno è ancora lì che mangia.</p>
<p>Quindi c'è <strong>solo un modo</strong> di capire dove sono gli altri: <em>parlarsi</em>.</p>
<p>Piccolo problema, il parlarsi non è parte del nostro normale modello.
Quindi il nostro programma deve <em>arricchirsi di qualcosa che permette di chiedere agli altri</em>, ma per chiedere agli altri io li devo conoscere, devo sapere che esistono.</p>
<p>Allora, di fatto creare un programma <strong>multi-threaded</strong> richiede di (oltre a definire le attività che ciascun thread deve fare per sé per adempiere al proprio compito primario) <em>aggiungere a quel thread delle altre attività che gli servono per coordinarsi</em>, perché queste ci permettono poi di andare avanti e fare insieme.</p>
<p>Quindi, sostanzialmente, il nostro programma diventa <strong>più complesso</strong>, perché aggiungiamo alle attività singole, normali, che già prevederemmo, ne aggiungiamo delle altre che servono a capire dove siamo arrivati. In alcuni casi ci basta l'indicazione che <em>l'altro è pronto, o che l'altro non è pronto</em>, in altri casi ci serve il <strong>risultato intermedio</strong> calcolato dall'altro, perché noi su quel risultato intermedio ci costruiamo sopra. In altri casi ci servono altre informazioni, e abbiamo bisogno di una relazione molto più complessa.</p>
<p>I <strong>meccanismi di comunicazione</strong> interagiscono però con l'architettura interna, e ci danno una serie di cose su cui non abbiamo mai ragionato.
<em>Perché?</em> Perché non ce n'era bisogno, perché in fondo i nostri programmi, fin tanto che erano <em>single thread</em>, non avevano bisogno di vedere quel livello di dettaglio. Però nel momento in cui i programmi diventano <strong>multi-thread</strong>, occorre capire.</p>
<p><img src="images/concorrenza/image%206.png" alt="image.png" /></p>
<p>Di base, il nostro processore prosegue normalmente con un ciclo che è quello standard, <strong>fetch decode execute</strong>, cioè prende un'istruzione, la guarda, capisce cosa quell'istruzione vuol dire e la fa. Poi ne prende un'altra e la fa, e va avanti così una dopo l'altra tranquillamente.</p>
<p>Questo meccanismo prosegue fino a quando normalmente non scatta un qualche <em><strong>interrupt</strong></em> che segnala la fine del quanto di tempo. A quel punto interviene il <strong>sistema operativo</strong> che dice <em>“Fermi tutti”</em>, congela l'esecuzione di ciascun thread, quindi lo stato dei registri presenti nella CPU in una qualche zona di memoria del kernel, e va a scegliere un altro thread a farlo cominciare.</p>
<p>Queste interruzioni, che già avvengono normalmente in tutti i nostri progetti, <em>non danno nessun fastidio</em>. <em>Perché?</em> Perché il nostro thread viene sospeso a un certo punto, il sistema operativo fa entrare un altro processo che fa le sue cose, scadrà il suo quanto di tempo, ripristina il nostro processo, che riprende esattamente da dove si era fermato — non è capitato nulla.</p>
<p>Esattamente come quando voi la sera andate a dormire, lasciate la stanza in ordine o in disordine a secondo della vostra inclinazione, e quando vi svegliate la ritrovate come l'avete lasciata. Il vostro sonno non ha cambiato niente.
Ma se <strong>non siete soli in casa</strong>, è assolutamente possibile che mentre voi dormite, qualcun altro sposti le cose. E quindi, quando vi svegliate, non trovate più quello che pensavate di aver lasciato. Semplicemente perché un altro è venuto, ha preso e ha fatto le cose sue.</p>
<p><strong>Finché siete soli</strong>, questo problema non ce l'avete.
<strong>Quando cessate di essere soli</strong>, il problema si pone. E di colpo cambia tutto, perché non siete più sicuri di dove avete messo le cose. O meglio, <em>di dove le potete trovare</em>. Dove le avete messe lo siete sicuri: le avete messe voi. Il problema è che se è arrivato qualcuno ve le ha spostate voi non lo potete sapere: <em>stavate dormendo</em>.</p>
<p><img src="images/concorrenza/image%207.png" alt="image.png" /></p>
<p>Siccome l'esecuzione di ciascun thread procede <strong>indipendentemente</strong> da quelle degli altri, l'unico modo di capire che cosa sta succedendo passa attraverso il <em>parlarsi</em>.</p>
<p><em>E come facciamo a parlarci?</em>
L'unico modo che abbiamo di parlarci è immaginare di avere un <strong>pezzo di memoria</strong> dove uno scrive e l'altro legge. E quindi dobbiamo darci un ordine. Quindi, questo lo possiamo fare perché operiamo nello stesso <em>spazio di indirizzamento</em>. Io ti ho scritto qui un messaggio. Quando tu ti svegli, vieni, leggi, troverai l'informazione e agisci di conseguenza. Bello! Beh, più o meno…</p>
<p><img src="images/concorrenza/image%208.png" alt="image.png" /></p>
<p><em>Perché “più o meno”?</em>
Perché quando un thread legge da una locazione di memoria, <em>che cosa ci trova?</em> Ci può trovare il valore che inizialmente era stato predefinito per quella locazione se quella era, ad esempio, una <strong>variabile globale inizializzata</strong>.</p>
<p>Ad esempio, se ho definito nel mio programma una variabile globale <code>i</code> che vale 0, di tipo intero, che inizialmente vale 0, quindi ho scritto <code>int i = 0</code>, quando vado a leggere in una qualche funzione quanto vale <code>i</code>, potrei trovarci quello 0 iniziale. Facile.
Oppure potrei trovarci quello che io stesso ho scritto <em>prima</em>. Magari ad un certo punto ho eseguito un'istruzione <code>i = 27</code>, poi vado a leggere <code>i</code> e ci trovo il mio 27. Normalissimo. Esattamente come quando voi, risveglio al mattino, aprite il cassetto e vi aspettate di trovarci quello che ci avete messo la sera.</p>
<p>Oppure potrei trovarci quello che qualcun altro ci ha messo dentro! Perché stavo dormendo, e mentre dormivo è arrivato un altro che ci ha messo una cosa.</p>
<p><strong>Piccolo problema</strong>. Il fatto che l'hardware su cui eseguiamo le nostre cose ha una serie di <em>ottimizzazioni</em> (l'uso della <strong>gerarchia di cache</strong>, il meccanismo di ordinamento delle istruzioni da parte del processore e del compilatore), fa sì che questo terzo caso, cioè ci leggo quello che ha scritto un altro, sia <em>particolarmente problematico</em>.</p>
<h2 id="14-modello-di-memoria"><a class="header" href="#14-modello-di-memoria">1.4 Modello di memoria</a></h2>
<p><img src="images/concorrenza/image%209.png" alt="image.png" /></p>
<p>Vediamo i dettagli. Come è fatta la memoria di un sistema moderno di elaborazione? Beh, le nostre CPU, che sono fatte di più core, non vanno a leggere e scrivere direttamente sulla RAM, perché se facessero così andrebbero a manovella, sarebbe lentissimo. Perché la RAM è maledettamente lenta, rispetto alle CPU. Quindi i sistemi moderni hanno vari livelli di cache.</p>
<p>Quando la CPU legge, legge se può direttamente dai propri <em><em>registri</em>,</em>** e questa è l'operazione che costa di meno in assoluto: un ciclo macchina.
Se il dato non viene dal registro, lo cerca nella <strong>cache di livello 1</strong>. La cache di livello 1, normalmente è suddivisa in modo diverso per facilitare le architetture pipeline, in <em>cache dati</em> e <em>cache istruzioni</em>. C'è poi ancora una terza che è la cache di <strong>TLB</strong>, <em>Transition Lookaside Buffer</em>, quella che mi serve per passare dalla memoria virtuale alla memoria reale.</p>
<p>Però per quello che dobbiamo dire adesso ci basta questo. Quando io vado a leggere nella memoria cache, guardo e vedo <em>"vorrei leggere questa informazione,</em> <em>è scritta qui”</em>. La memoria cache è <em>piccolina ma molto veloce</em>. Le informazioni sono rappresentate a tag, cioè che usa come tag l'indirizzo vero in cui vorrei leggere, e valore. Se lo trovo lì, magnifico, ho direttamente il mio dato.</p>
<p>Può darsi che nella cache quell'indirizzo lì non ci sia. Allora lo vado a chiedere al sistema a monte. Si è verificato un <strong>cache miss</strong>. Lo vado a chiedere a un sistema a monte che a sua volta potrebbe avercelo o meno. La cache di livello 1 è piccola ma molto veloce, mi costa <em>due cicli macchine</em>. Se non lo trovo lì, lo vado a cercare nella <strong>cache di livello 2</strong>, che è più grande e quindi è maggiore la probabilità di trarci delle cose, ma è un po' più lenta. Se non lo trovo neanche nella cache di livello 2, lo vado a cercare nella <strong>cache di livello 3</strong>, che è ancora più grande (dell'ordine dei megabyte, a volte delle decine, a volte delle centinaia di megabyte), ma è ancora più lenta. E se non lo trovo neanche nella cache di livello 3, lo devo andare a prendere nella <strong>RAM</strong>, che è grande gigabyte, ma è molto lenta.</p>
<p>Fin qua nella lettura. <em>Cosa succede quando scrivo?</em> Dipende, potrei avere un sistema di cache <em>write-through</em> oppure potrei avere un sistema di cache che invece è <em>ritardato</em>. Nel sistema write-through, nel momento in cui io scrivo che nella locazione 3b5f ci metto 27, lo scrivo nella cache di livello 1, lo propago nella cache di livello 2, lo propago nella cache di livello 3, e lo propago nella RAM principale. Che però ci arriva un bel po' dopo, perché ciascuna va alla sua velocità e quindi le cose arrivano pian piano.</p>
<p>Potrei avere una cache invece che non è write-through, e quindi io ci scrivo 27 e il dato sta nella cache di livello 1 e a quel punto solo quando libererò quella cella di cache, quando la invaliderò, provvederò a scrivere effettivamente sul livello superiore. Quindi con un ulteriore ritardo. È molto più efficiente, ma è molto più, ci mette molto di più a propagarsi.</p>
<p>Se quindi nella locazione il core 0, nella locazione 3b5f ha messo 27, il core n cosa vede nella locazione 3b5e0? <em>Boh</em>, perché il 27 si è fermato nella sua cache, poi piano piano, prima o poi arriverà nella RAM. Ma l'altro ha la sua copia cache, che non è immediatamente aggiornata. Quindi io ho già scritto 27, ma di là ci leggo ancora quello che c'era scritto prima.</p>
<p>Quindi <strong>non è più vero che non appena scrivo l'altro vede</strong>. Io ho appena scritto nella mia copia locale, ma questa ci arriverà tra un po' agli altri.</p>
<p><em>Come ne vengo fuori?</em> <em>Possiamo dire quando è finalmente arrivata nella RAM?</em> Di base no.
<em>Posso dire quando finalmente mi è risalita fino alla corrispondente cache dell'altro core?</em> Manco per idea.
<strong>Nessun linguaggio mi espone questo</strong>, perché la cache non traspare da nessuna delle istruzioni che noi abbiamo visto.</p>
<p>La cache è un'ottimizzazione <em>bellissima, potentissima</em>, che fa sì che i nostri PC vadano molto veloci e si riescano a fare videoconferenze, intelligenza artificiale e altre cose simpatiche, ma che mi crea questi problemi. Perché quando siamo insieme, mi crea un <strong>bottleneck</strong> che non traspare. Perché il linguaggio non lo mappa. O meglio, i linguaggi di alto livello non lo mappano.</p>
<p>Nell'Assembler in realtà questo esiste perché i singoli processori multicore, o comunque quelli dotati di cache, hanno alcune <strong>istruzioni particolari</strong>, che sono fatte un po' diverse tra di loro, ma concettualmente servono a dire "<em>Questo dato dalla cache propagalo immediatamente fino alla RAM, costi quel che costi, e al contrario questo dato prendilo comunque dalla RAM, anche se ce l'avessi in cache, costi quel che costi</em>". Perché io voglio essere sicuro che quel dato lì sia quello vero.</p>
<p>Il problema è che queste istruzioni qua, che si chiamano <strong>Memory Barrier</strong>, <strong>Memory Fence</strong>, a seconda del processore specifico che stiamo utilizzando, o anche altro, <em>non traspaiono nei nostri linguaggi di alto livello</em>. Quando io dichiaro la mia variabile la chiamo di tipo <code>i32</code>, la chiamo di tipo <code>String</code>, ma la assegno e la leggo normalmente. Non vedo l'esistenza di queste cose.</p>
<p><img src="images/concorrenza/image%2010.png" alt="image.png" /></p>
<p>Le cose tra l'altro possono essere anche più complesse, perché i processori più performanti radunano le cache con <strong>vari livelli di gerarchia</strong>, per cui:</p>
<ul>
<li>la <strong>cache di livello 1</strong> è dedicata al singolo core</li>
<li>la <strong>cache di livello 2</strong> normalmente è appaiata a coppie di core</li>
<li>la <strong>cache di livello 3</strong>, viceversa, raduna tutti i core</li>
</ul>
<p>Ci sono sistemi che di cache, di livelli di cache ne hanno 4 o anche 5.</p>
<p><img src="images/concorrenza/image%2011.png" alt="image.png" /></p>
<p>La differenza sostanziale è quella dei <strong>tempi di accesso</strong>. Qui è riportata nella tabella di Bobrov, il tempo reale (in microsecondi o nanosecondi a seconda dei casi), e il tempo nella scala umana, dove il rapporto è un ciclo macchina/un secondo.
Quello che per la CPU è un ciclo macchina è riportato in una scala umana (siccome facciamo fatica a immaginare quanto è 3 nanosecondi rispetto a 2 millisecondi) in cui al ciclo macchina corrisponde un secondo, per cui:</p>
<ul>
<li>l'accesso alla <strong>cache di livello 1</strong>, che normalmente costa circa 2 cicli, è come se durasse <em>2 secondi</em></li>
<li>la <strong>cache livello 2</strong> mi costa l'equivalente di <em>7 secondi</em></li>
<li>la <strong>cache di livello 3</strong> mi costa circa <em>un minuto</em></li>
<li>l'accesso alla <strong>RAM</strong> mi costa <em>4 minuti</em></li>
<li>l'accesso al <strong>disco</strong> mi costa, in base alla tecnologia di disco che sto usando, da un <em>quarto d'ora a giorni</em>, addirittura se uso dischi rotazionali, <em>mesi</em></li>
</ul>
<p>Ecctera…</p>
<h2 id="15-problemi-aperti"><a class="header" href="#15-problemi-aperti">1.5 Problemi aperti</a></h2>
<p><img src="images/concorrenza/image%2012.png" alt="image.png" /></p>
<p><strong>Allora, che problemi porta tutto questo?</strong> Porta problemi di <em>atomicità</em>.</p>
<p><em>Quali operazioni hanno effetti indivisibili?</em>
Cioè che non possono essere viste separatamente — in un colpo solo cambio due cose, e non prima una e poi l'altra.</p>
<p><em>Quali problemi hanno di visibilità?</em>
Non sempre il fatto che io abbia modificato una variabile la rende visibile all'altro. Perché se la mia modifica si è fermata nella mia cache e non è stata propagata alla RAM vera e non è risalita fino alla cache dell'altro, l'altro non se ne accorgerà minimamente che io ho scritto.</p>
<p>Poi c'è un <strong>terzo problema</strong>, ancora meno ovvio: <em>l'ordinamento</em>. Quando scrivo prima in una posizione e poi in un'altra, mi aspetto che un altro thread legga i dati nello stesso ordine in cui li ho scritti.
Quindi, se riesce a leggere il secondo dato, si potrebbe pensare <em>"sicuramente può leggere anche il primo"</em>. In realtà <strong>non è così</strong>. I tempi di propagazione possono essere diversi: se scrivo prima <em>alfa</em> in un posto e poi <em>beta</em> in un altro, un altro thread potrebbe già leggere beta ma non vedere ancora alfa. Per questo non posso usare la lettura di beta come garanzia che alfa sia disponibile, dato che alfa potrebbe avere un tempo di propagazione più lungo.</p>
<p>Questo genere di cose noi normalmente non le abbiamo viste mai, non le abbiamo mai preso in considerazione, perché non ce n'è mai stato bisogno, in quanto quando c'è <strong>un solo thread</strong> che fa le cose, lui va sempre a pescare dalla sua cache, quindi il fatto che quella cache si propaghi anche oltre, per lui è rilevante. Lui vede la sua, se non c'è c'è quella di livello superiore, se non c'è c'è quella di livello superiore, va tutto bene. Lì l’astrazione è perfetta.</p>
<p>Quando siamo in due invece, il fatto che ciascuno di noi guardi nella propria cache, non dice niente di cosa sta capitando in quell'altra. E allora il nostro programma si deve arricchire di pezzi che prima non prendevamo in considerazione, che servono a dire <em>“Allora, nella maggior parte delle situazioni, quando lavoro per me soltanto (e quindi quando faccio delle cose che gli altri non han bisogno di sapere), me le faccio normalmente col massimo delle prestazioni. In quei piccoli punti dove io parlo per gli altri, cioè scrivo una cosa affinché un altro la legga, questa cosa la devo scrivere in un modo molto inefficiente, ma che però mi dà garanzia che l'altro la possa leggere davvero”</em>.</p>
<p><em>E quindi che cosa devo fare?</em>
Devo svuotare la cache prima, scrivere, e forzare di nuovo lo svuotamento della cache, in modo tale che sono certo che il dato di là arrivi, e svuoto la cache mia e anche di tutti gli altri. Quindi potenzialmente penalizzandoli, ma mettendomi al riparo dal fatto che non rischiano di leggere un dato errato. Solo che nei linguaggi di alto livello l'istruzione <em>“svuota la cache”</em>, o <em>“forza la scrittura della cache”</em>, non c'è.
Quella istruzione lì è presente, annegata, dentro alcune funzioni di libreria, che non solo fanno questo mestiere di bassissimo livello, ma fanno delle cose un po' più utili e creano delle astrazioni che adesso vogliamo imparare.</p>
<p>Le due astrazioni che vogliamo imparare si chiamano <em><strong>mutex</strong></em> e <em><strong>condition variable</strong></em>, e servono fondamentalmente a darci dei comportamenti affidabili coi quali possiamo ottenere garanzia che il nostro programma fa quello che pensiamo debba fare e non quello che vuole lui.</p>
<p><img src="images/concorrenza/image%2013.png" alt="image.png" /></p>
<p>Le istruzioni effettive dipendono dall'architettura del processore. I processori di tipo x86 hanno un certo meccanismo e ci mettono a disposizione alcune istruzioni che si chiamano <em><strong>memory fence</strong></em>.</p>
<p>I processori tipo ARM invece, che hanno una modalità molto più sofisticata e potenzialmente con prestazioni molto più alte, ed è il motivo per cui Apple ad esempio ha scelto di abbandonare gli x86 ed è passata ai suoi processori ARM, è legata al fatto che l'astrazione che gli ARM offrono, che prende il nome di <em><strong>memory barrier</strong></em>, mi permette di distinguere in modo molto più fine se sto facendo un'operazione di lettura e quindi io devo accedere a un dato che mi ha scritto un altro, quindi l'unica cosa che devo fare è svuotare la mia cache per essere sicuro di attingere dalla fonte. Oppure sto facendo un'operazione di scrittura, per cui non ho bisogno di svuotare prima la mia cache, ma posso scrivere e poi forzare il flushing, ovvero il consolidamento dei dati presenti in cache nella memoria principale. Oppure devo fare un'operazione di tipo <em>exchange</em>, dove io leggo e contemporaneamente scrivo e in quel caso lì ho bisogno sicuramente di svuotare prima e di forzare la scrittura dopo, in modo tale che l'altro certamente veda il dato e io veda certamente il dato originale. Quindi a secondo del tipo di operazione io posso in modo molto più fine definire che cosa voglio andare a fare.</p>
<p><img src="images/concorrenza/image%2014.png" alt="image.png" /></p>
<p><strong>Quando non usiamo correttamente i costrutti necessari</strong> per questo genere di cose, andiamo incontro a problemi di vario tipo.</p>
<p>Se non includiamo per niente meccanismi di <strong>sincronizzazione</strong>, il nostro programma <em>va a caso</em>. <em>Perché?</em> Perché non è detto che l'altro veda un dato sbagliato. <em>E' come attraversare la strada col semaforo rosso</em> — non vi schiacciano, sicuramente. Però potrebbero farlo e avrebbero ragione.</p>
<p>Va a caso, perché siccome non fa niente per sincronizzarsi con gli altri, se gli va bene gli va bene, e se gli va male gli va male. Ma non ha modo neanche di capirlo se gli è andata bene o se gli è andata male. <strong>Perché non ha modo di comunicare con gli altri.</strong></p>
<p>Questa è quindi una soluzione <strong>molto pericolosa</strong> che genera <em>malfunzionamenti casuali e completamente irriproducibili</em>. Di conseguenza, diventa impossibile debuggare il codice. Quando il cliente vi contatta dicendo <em>"questa cosa non funziona"</em>, non sarete in grado di identificare il problema. Magari nei vostri test tutto funziona perfettamente, ma per il cliente il programma si blocca. Questi errori tendono a manifestarsi nelle situazioni più imprevedibili: il codice funziona sul vostro computer ma si blocca su un altro, semplicemente perché ha temporizzazioni leggermente diverse. <strong>E naturalmente, questi problemi emergono sempre nel momento peggiore possibile.</strong></p>
<p><img src="images/concorrenza/image%2015.png" alt="image.png" /></p>
<p><strong>Allora, internamente ogni thread è mappato all'interno del kernel</strong> <strong>con un <em>oggetto</em> che ne ricorda il suo stato</strong>. Questo <strong>oggetto</strong> serve allo scheduler del kernel per poter <em>congelare l'esecuzione</em> di quel thread quando deve smettere e <em>ripristinarla</em> quando dovrà ricominciare nel momento in cui tocca di nuovo a lui fare delle cose. Dentro l'oggetto kernel quello che viene salvato è lo stato del core su cui quel thread è in esecuzione — tipicamente c'è l'elenco dei registri di quel core: <em>io ti ho congelato al tempo t, dentro <code>AX</code> c'era scritto questo, dentro a <code>BX</code> c'era scritto quello, dentro a <code>CX</code> c'era scritto quell'altro. Quando toccherà di nuovo a te essere eseguito prendo questo insieme di valori, li rimetto nei registri e ti dico continua. E tu continui e fai le tue cose.</em></p>
<p>Tipicamente dentro quei registri lì c'erano in alcuni casi dei dati, in alcuni casi dei <strong>puntatori</strong>, cioè degli <em>indirizzi di memoria</em>. Ad esempio il <strong>program counter</strong> diceva qual era la prossima istruzione da eseguire, ad esempio lo <strong>stack pointer</strong> diceva dove è arrivato lo stack e cose del genere. Ma anche altri registri potrebbero avere dei loro indirizzi.
<em>Questi indirizzi dove puntano?</em> Puntano <strong>nello spazio di indirizzamento del processo</strong>, che è <strong>condiviso da tutti i thread</strong> che operano lì dentro.</p>
<p>Ora, mentre lo scheduler tira via un thread per un qualche motivo potrebbe continuare a lasciar girare degli altri thread dello stesso processo, che hanno la possibilità di andare avanti e fare cose. Per cui mentre il thread <strong>t1</strong> è lì che dorme, il thread <strong>t2</strong>, che è suo fratello, fa cose e in quello spazio di indirizzamento cambia delle informazioni. Quando <strong>t1</strong> si risveglia deve capire cosa è successo, non ne ha nessuna percezione.</p>
<p><img src="images/concorrenza/image%2016.png" alt="image.png" /></p>
<p>Quindi:</p>
<ul>
<li>Tutti i thread dello stesso processo condividono il <strong>codice eseguibile</strong>, questo non è un problema perché quello è solo in lettura e quindi non ci dà fastidio.</li>
<li>Tutti i thread dello stesso processo condividono lo <strong>heap</strong> e questo è potenzialmente un problema perché io cambio una cosa e la puoi cambiare anche tu. <em>E chi vince? E come vince?</em></li>
<li>Ciascun thread ha il proprio <strong>stack</strong>.</li>
<li>Tutti i thread condividono le <strong>variabili globali</strong>, ammesso che ce ne siano.</li>
</ul>
<p>Sicuramente heap e variabili globali sono due grosse fonte di collisione perché è dove è più facile scontrarsi.</p>
<p>Gli <strong>stack</strong> sono solo <em>relativamente</em> riservati, perché quando rivelo l'indirizzo di una variabile del mio stack (scrivendolo in una variabile globale o nello heap), questa diventa accessibile anche agli altri thread che, seguendo i puntatori, possono modificarla.
<em>Non posso dire che le variabili locali sono automaticamente protette</em>. Lo sono nella misura in cui nessuno ne dischiude l'indirizzo, ma nel momento in cui qualcuno ne dischiude l'indirizzo non sono più protette neanche un po', quindi <strong>tutta la memoria del processo è potenzialmente a rischio</strong>.</p>
<h2 id="16-esecuzione-e-non-determinismo"><a class="header" href="#16-esecuzione-e-non-determinismo">1.6 Esecuzione e non determinismo</a></h2>
<p><img src="images/concorrenza/image%2017.png" alt="image.png" /></p>
<p>In alcuni casi io ho bisogno di avere certezza che <em>mentre io cambio un <strong>dato condiviso</strong>, nessun altro venga a impicciarsi di quel dato lì, né per leggerlo né per scriverlo</em>.
E questo tipo di situazione viene gestito utilizzando una primitiva che si chiama <strong>mutex</strong>, che vuol dire <em>mutual exclusive</em>. È un oggetto che mi protegge un'area di memoria dicendo "<em>mentre io scrivo o mentre io leggo, nessun altro nè legge né scrive, ci lavoro da solo</em>. <em>Quando ho finito lo libero e quindi potranno entrare gli altri che faranno le loro cose.”</em></p>
<p>Il sistema operativo mi protegge, <em>perché?</em> Perché io accedo alla zona protetta dal mutex eseguendo un'operazione di <em><strong>locking</strong></em>, in cui chiedo di prendere possesso, se il mutex è libero effettivamente questo possesso mi viene concesso e accedo, se il mutex in questo momento è in uso a qualcun altro mi blocco lì sull'operazione lock e aspetto. Prima o poi chi ce l'ha in uso in questo momento finirà, farà l'operazione duale che si chiama <em><strong>unlock</strong></em> e di conseguenza potrò entrare. E se siamo in due a aspettare faremo la coda, uno dei due entrerà e l'altro continua ad aspettare fino a che non sarà anche il suo turno. Questo è un esempio di forma di <strong>sincronizzazione</strong>. Si usa quando dobbiamo procedere uno per volta.</p>
<p>In altre situazioni io ho bisogno di <em>aspettare che succeda un qualcosa fino a che tu non mi fai sapere che posso continuare</em>.
In questa situazione qua invece io ho bisogno di fare un'<em><strong>attesa passiva</strong></em>. Quando sarà ora di continuare tu mi darai un segnale e a quel punto io so che posso andare avanti. Per questo tipo di cosa in cui non ho necessariamente una zona condivisa ma ho bisogno di aspettare che tu abbia finito qualcosa si usa un altro tipo di astrazione che si chiama <em><strong>condition variable</strong></em> (<code>Condvar</code> in Rust).</p>
<p>Quindi obiettivo nostro è imparare a usare queste due forme di astrazione che sono le <strong>astrazioni fondamentali</strong> su cui si basano tutte le altre forme di coordinamento.</p>
<p><img src="images/concorrenza/image%2018.png" alt="image.png" /></p>
<p>Quindi possiamo inventarci degli altri modi di governarsi ma sono tutti riconducibili a un uso misto di queste due. Anzi, quello <strong>essenziale</strong> è il <strong>mutex</strong>, mentre la <strong>condvar</strong> richiede un mutex — mentre il mutex può esistere da solo, la condvar non può esistere in assenza di un mutex.
<strong>L'insieme di queste due cose qui abilita tutto il resto.</strong></p>
<p>Non è un caso ad esempio che in <strong>Java</strong> gli <code>Object</code> abbiano al proprio interno due comportamenti intrinseci. Il primo è il comportamento <code>synchronized</code>, ogni object in Java si può comportare da mutex mettendo davanti ai suoi metodi la parola chiave <code>synchronized</code>. Ogni oggetto in Java si può anche comportare da condvar grazie al fatto che la classe <code>Object</code> ha dentro di sé i metodi <code>wait</code>, <code>notify</code> e <code>notifyAll</code>, che ci danno la possibilità di segnalare quando capita qualcosa di rilevante. Lo stesso vale in altri linguaggi.</p>
<p>Notate che nella storia si è arrivati a identificare queste due come le <strong>operazioni essenziali</strong> passando per altri tentativi. Tony Hoare nel 1960 si era allineato sull'idea dei <em>semafori</em>. I <strong>counting semaphore</strong> sono delle primitive dove io mantengo un numerino che non può mai diventare negativo e ti offro due operazioni. <code>increment</code> e <code>decrement</code> (lui la chiamate <code>p</code> e <code>v</code> ma è un nome improponibile perché non si capisce mai chi fa che cosa). Increment mi fa salire il numero di un'unità, e decrement me lo abbassa con il vincolo che <strong>non può mai diventare più piccolo di zero</strong>. Quindi se io cerco di decrementare una cosa che è già zero aspetto fino a che qualcuno non fa un increment costitutivo e mi dia il permesso.</p>
<p>La variante dei semafori è che non solo c'è un minimo che è zero ma c'è anche un massimo che è <em>n</em> e quindi io non posso mai andare oltre il massimo. Se cerco di andare oltre il massimo e fare un increment quando lui è già al massimo devo aspettare che qualcuno faccia contestualmente un decrement, così da poterci stare. Nel tempo i linguaggi hanno scelto di non usare i semafori come astrazione perché è molto più prona a errori, è difficile da concepire. Va bene in pochi casi quando io devo proteggere l'accesso forse a un circular buffer o a un numero limitato di risorse, ma è <em>molto più difficile da generalizzare</em>. Viceversa la coppia <strong>mutex/condvar</strong> garantisce la possibilità di esprimere tutte le altre forme.</p>
<h3 id="161-esempio"><a class="header" href="#161-esempio">1.6.1 Esempio</a></h3>
<p><img src="images/concorrenza/image%2019.png" alt="image.png" /></p>
<p><strong>Prendiamo velocemente un esempio</strong>, utilizzando Rust e questo programmino.</p>
<p>La prima cosa da capire è che <em>creare i thread è una banalità</em>. In Rust c'è una struttura dati chiamata <code>thread</code> che ci offre il metodo <code>spawn</code> per creare un thread. Quindi questo facciamo <code>let t1 = thread::spawn</code>, dove <code>thread::spawn</code> accetta una chiusura.</p>
<p><code>thread::spawn</code> serve semplicemente a dire "<em>da adesso in avanti fai partire un'attività che si svolgerà in parallelo a quella del thread principale</em>".
<em>Che cosa fa questa attività?</em> Esegue il codice contenuto nella chiusura finché non termina.
In questo caso, la chiusura che passiamo a <code>t1</code> è molto semplice: fa <code>for i = 0..10</code> stampando "aaa" seguito da i, quindi "aaa0", "aaa1", "aaa2" fino a 9.</p>
<p>Dopo aver creato <code>t1</code> facciamo anche <code>t2</code> che fa lo stesso lavoro, ma invece di stampare "aaa" stampa " bbb". Lo spazio iniziale è semplicemente per rendere più facile distinguere le stampe quando gli output dei thread si mescolano.</p>
<p>Nel <code>for</code> è anche inclusa un'operazione necessaria in Rust, che non servirebbe in C++. Rust ha delle <strong>ottime ottimizzazioni</strong>: siccome questo ciclo dura poco (10 iterazioni) e la print è particolarmente efficiente in Rust, vedremmo <code>t1</code> finire prima che <code>t2</code> inizi, perdendo la percezione della concorrenza. Per evitarlo, potremmo aumentare il ciclo da 10 a 10.000 iterazioni (e allora inizierei a vederli intersecarsi), oppure inserire una <em>piccolissima pausa</em> di un nanosecondo — veramente minima — che mi garantisce l'intrecciarsi dei thread, rendendo evidente il comportamento che ci interessa.</p>
<p>Il thread principale dopo aver creato il <strong>t1</strong> e il <strong>t2</strong> li aspetta ed esegue l'operazione <code>join</code>.
<code>t1.join</code> ritorna un <code>Result</code>. Quel <code>Result</code> ha successo ed è il risultato della funzione (il risultato del thread), ma in questo caso il mio thread non ritorna niente quindi in questo caso torna uno <code>Unit</code>, oppure contiene un <code>Error</code> se in qualche modo questo thread si impiantasse al proprio interno. Quindi se il thread è finito bene o male lo so facendo l'<code>unwrap</code> della <code>join</code>. Il thread principale aspetta che <strong>t1</strong> e <strong>t2</strong> entrambi siano finiti e poi finisce anche lui.</p>
<p><img src="images/concorrenza/image%2020.png" alt="image.png" /></p>
<p><em>Cosa succede se io eseguo questo codice?</em>
Vedo che partono, in questo caso sono quasi equamente distribuiti: per ogni <code>aaaa</code> c'è anche un <code>bbbb</code>. <em>È un caso, è assolutamente un caso</em>.</p>
<p><img src="images/concorrenza/image%2021.png" alt="image.png" /></p>
<p>Se io lo rilanciamo qui adesso abbiamo che ci sono due <code>aaaa</code> di fila, <code>aaaa1</code> e <code>aaaa2</code>.</p>
<p>Se lo lanciassi una terza volta vedrei ancora una cosa diversa. <em>Perché?</em> Perché ciascun thread procede secondo le sue norme.
Io sono sicuro che <code>aaaa0</code> viene scritto prima di <code>aaaa1</code>, viene scritto prima di <code>aaaa2</code>, e prima di <code>aaaa3</code>. Di questo posso essere sicurissimo. Del fatto che <code>aaaa1</code> venga scritto prima di <code>bbbb1</code> non lo so minimamente. Non lo posso neanche sapere perché non c'è nessun modo di comunicare tra i due. E quindi viene come viene.</p>
<blockquote>
<p>💡 <strong>Nota</strong></p>
<p>Con l’istruzione <code>thread::sleep(Duration::from_nanos(1))</code> chiedo al sistema operativo di togliermi dallo <em>scheduler</em> e di rimettermi tra un nanosecondo. Il sistema operativo <strong>non</strong> mi rimetterà tra un nanosecondo perché non fa neanche in tempo: cioè già solo per togliermi dalla CPU se ne mangia 50 di nanosecondi.</p>
<p>Non appena ha finito di togliermi dalla CPU, si accorge che 1ns ormai è scaduto e mi rimette dentro. Ma l'effetto netto è che mi ha tolto la CPU. Se avessimo messo un tempo più lungo, sarebbe stato troppo, e l'altro thread nel frattempo avrebbe avuto il tempo di finire tutto.</p>
</blockquote>
<p>Quindi di base <strong>lo svolgimento dei singoli thread è indipendente uno dall'altro</strong>.</p>
<p>Adesso proviamo un’altra cosa, la facciamo in C++.
La facciamo in C++ perché non posso farla in Rust, perché Rust per via delle sue regole del Borrow Checker mi impedirebbe di fare certe cose.
E meno male che mi impedisce, perché adesso vediamo una cosa che non ci aspetteremmo.</p>
<p><img src="images/concorrenza/image%2022.png" alt="image.png" /></p>
<p>Così come in Rust, creare un thread è banale anche in C++.
In Rust esiste <code>thread::spawn</code> e in C++ creiamo l'oggetto della classe <code>std::thread</code>.</p>
<p>Dichiariamo <code>int i = 0</code>, una variabile. Adesso creo due thread che hanno il compito di incrementarmi questa variabile.</p>
<p>E quindi scrivo <code>thread t1 std::thread</code> e qui dentro, proprio come avrei fatto in Rust, gli devo passare la <strong>chiusura</strong> che dice cosa deve fare. Questa chiusura opera su <code>i</code>, che viene catturata e fa questa computazione: <code>for(_n=0; _n &lt; 10.000.000; _n++)</code> — per 10 milioni di volte incrementiamo <code>i</code> con <code>i++</code>.
Quindi quando questa attività parte lui comincia a farmi salire <code>i</code>, che cresce continuamente. E questo è il primo thread, <code>t1</code>.</p>
<p>Poi facciamo un altro thread, <code>std::thread t2</code> e lo facciamo uguale. Anche lui cattura <code>i</code>, in modo tale che mi possa modificarla.</p>
<p>Abbiamo quindi avviato due thread, tutti fanno salire <code>i</code>.
Poi aspettiamo che finiscano, esattamente come facevamo prima e quindi scriviamo <code>t1.join()</code>, <code>t2.join()</code>.
Vediamo che le primitive Rust e C++ si assomigliano, cambia un po' il nome delle classi, ma concettualmente fanno lo stesso mestiere.</p>
<p>A questo punto stampiamo <code>i</code>.</p>
<p><em>Quanto vale</em> <code>i</code><em>?</em></p>
<p><img src="images/concorrenza/image%2023.png" alt="image.png" /></p>
<p>Dovrebbe valere 20 milioni, se le cose funzionassero correttamente.
E invece vediamo che vale <code>10.647.429</code>.
Se rilanciamo, darà un altro valore, sempre inferiore a 20 milioni, comunque.</p>
<p><img src="images/concorrenza/image%2024.png" alt="image.png" /></p>
<p>Allora proviamo a cambiare il codice: prima di incrementare <code>n</code>, facciamo <code>int v1 = i</code>, e dopo aver incrementato facciamo <code>int v2 = i</code>, cioè prendiamo quanto vale <code>i</code> prima e dopo aver incrementato.</p>
<p>Quindi, fotografiamo <code>i</code> prima dell'incremento, e fotografiamo <code>i</code> dopo l'incremento.
Poi, se <code>v2</code> è diverso da <code>v1+1</code> (e noi ci aspetteremmo che <code>v2</code> e <code>v1+1</code> siano uguali, se le cose funzionassero correttamente), stampiamo il delta, cioè <em>quanto differiscono</em>.</p>
<p><strong>Ora, il fatto che ci siano delle differenze può anche starci</strong>, perché io guardo <code>i</code> adesso, poi la incremento, ma mentre io incremento, incrementa anche l'altro. Per cui è abbastanza ovvio che ogni tanto il delta sia più grande di uno.</p>
<p>Vediamo cosa viene fuori eseguendo il codice.</p>
<p><img src="images/concorrenza/image%2025.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2026.png" alt="image.png" /></p>
<p>In alcuni casi è un delta piccolo, come <em>6</em>, in alcuni casi è un delta grosso, come <em>18 mila</em>. Notiamo che ce n’è anche uno negativo, <em>-1</em>.
<strong>Come è possibile che torni indietro visto che tutti e due facciamo più uno?</strong></p>
<p><strong>Cioè, che vediamo dei delta positivi, ci sta,</strong> perché io magari l'ho fotografato, poi mi sono addormentato, l'altro nel frattempo è andato avanti, e poi ho incrementato anch'io. E quindi vedo dei delta anche grandi, <em>10 mila, 15 mila</em>, ha senso. Siccome io mi addormento in tempi che non so quali sono, mentre io dormo lui va avanti, e quando mi risveglio vedo dei cambiamenti molto grossi. <strong>È normale che sia così</strong>. A volte il cambiamento è molto piccolo perché non mi sono addormentato, semplicemente abbiamo fatto insieme un incremento e quindi è andata così.</p>
<p><em>Ma perché vedo -1? Non c'è nulla che abbassa.</em></p>
<p><strong>Questo vi fa toccare con mano che non è così banale.</strong> Notate che se io spengo il secondo thread, cioè ne lancio uno solo, il risultato è esattamente 10 milioni e il delta è sempre 1.
Quindi, questa cosa si verifica come conseguenza del fatto che ci sono due thread che lavorano sulla stessa variabile. Perché se io facessi due thread, e uno mi incrementa <code>i</code>, e l'altro mi incrementa <code>j</code>, nessun problema.</p>
<p><em>Il fatto che io abbia due thread che lavorano sulla stessa variabile mi spacca delle cose</em> e non viene la somma che mi aspetto.
Già questo è un problema, perché ciascuno cicla esattamente 10 milioni di volte. Se io li eseguo separatamente vedo che fa 10 milioni, quindi il codice del singolo thread è giusto. Insieme invece si impicciano. E soprattutto succede una cosa che non ci spieghiamo: questo numero torna indietro. Quindi quando si programma con i thread le cose sono meno ovvie…</p>
<p>Allora, cosa succede? Il problema è l’istruzione <code>++</code><strong>.</strong>
Nella nostra testa questa è un'operazione atomica, perché lavorando in modo sequenziale noi la variabile <code>i</code> non abbiamo modo di vederla mentre cambia — per noi l'operazione <code>++</code> prende 27 e restituisce 28. Finita lì.</p>
<p><em>Ma in realtà quel</em> <code>++</code> <em>come è fatto, se andiamo a guardare l'assembler del processore?</em>, quella cosa lì è fatta di tre istruzioni assembler:</p>
<ol>
<li>Muovo il dato dall'indirizzo dove sta al registro AX</li>
<li>Nel registro AX faccio increment</li>
<li>Muovo dal registro AX il valore incrementato di nuovo nella memoria ****</li>
</ol>
<p><strong>Sono tre istruzioni assembler.</strong> La campanella che mi dice <em>"Tocca a un altro"</em> quando può scattare? <em>In qualunque momento. Anche in mezzo a queste tre istruzioni.</em></p>
<p>Ora potrebbe succedere questo: che io ho fotografato AX, quello che era, valeva 25. Perfetto. Poi me lo porto dentro l'accumulatore. Continua a valere 25. Lo incremento, diventa 26. Sto per scriverlo. <strong>Sto per scriverlo e qui vengo sospeso.</strong> Non l'ho ancora scritto, quindi ho 26 nell'accumulatore e ce l'ho lì, perché non tocca più a me. Se fossi da solo non c'è nessun problema, quando mi risveglio scrivo 26. Ma mentre io sono sospeso e ho questo 26 da scrivere, l'altro sta andando avanti. <em>E che cosa fa?</em> Parte da 25, e incrementa. Magari per più tempo, magari fino a 30. Io a questo punto riparto e scrivo 26. <em><strong>Da 30 sono tornato indietro.</strong></em>
L'altro va a vedere, dice "quanto è?" Da 29 ero passato a 30. Io nel frattempo mi sono svegliato, ho messo il 26, lui rilegge e vede che da 30 è tornato a 26. <strong>Delta meno 4.</strong></p>
<p><strong>Questa cosa qua non è ovvia</strong>. Uno non ci pensa di per sé, ma succede questo. E l'effetto netto di questo tornare indietro è legato al fatto che il risultato, nell’esempio di prima, non fa 20 milioni come mi aspetto, fa molto di meno. <em>Proprio perché ci sono tutti questi meno che capitano</em>. <strong>Quell'operazione <code>++,</code> che nella nostra mente era un'operazione atomica</strong> — perché per quello che potevamo osservare il comportamento di un programma in un contesto single threaded è atomica — <em>non è invece atomica</em>.</p>
<p><em>Ora, questa cosa come si risolve?</em> Ha due soluzioni.</p>
<p><img src="images/concorrenza/image%2027.png" alt="image.png" /></p>
<p><strong>La prima soluzione</strong> è legata al fatto che sia in Rust che in C++ ci sono alcuni tipi, che sono i <em>tipi atomici</em>.
Ad esempio, quella <code>i</code> da <code>int</code> la faccio diventare un <code>std::atomic&lt;int&gt;</code>.
I tipi atomici sono dei tipi che il compilatore conosce e trasforma le operazioni di <code>++</code>, che da semplici meccanismi <em>“prendo il dato, lo incremento, lo riscrivo”</em>, vengono trasformate usando le memory barrier o le memory fence, a seconda del processore in cui sono, e incrementa in modo atomico.</p>
<p>Quindi a questo punto l’istruzione <code>i++</code> deve diventare un <code>i.fetch_add(1)</code>.</p>
<p><img src="images/concorrenza/image%2028.png" alt="image.png" /></p>
<p>Eseguendo, notiamo che ora il risultato è corretto.
Ho ancora dei delta, ma sono tutti positivi e in ogni caso il mio risultato fa esattamente 20 milioni.
<strong>Quei delta sono delta sani,</strong> dovuti al fatto che io ho fotografato prima, ho incrementato, ho fotografato dopo e mentre io incrementavo anche l'altro ha incrementato, ma l'incremento è avvenuto senza problemi.</p>
<p><strong>Che cosa fa</strong> <code>i.fetch_add(1)</code> <strong>?</strong>
Al tempo stesso mi recupera il valore e gli somma in modo atomico, in <strong>un'unica operazione non osservabile dagli altri</strong>.</p>
<p><em>Come succede questo?</em> Dipende dal processore.
Sugli x86 multi-core andando a settare un bit che c'è dentro, e mentre quest'operazione si svolge inibisce gli altri core. È un’operazione che chiaramente mi fa andare globalmente più piano, ma mi fa procedere correttamente. ARM ha altri meccanismi legati a come è fatta l'architettura, ma a noi interessa sapere che il linguaggio ci offre un’astrazione pulita con la quale gestiamo questi meccanismi.</p>
<p><strong>Peccato che questo va bene</strong> per fare il <code>++</code> o il <code>--</code>, perché potrei fare <code>fetch_sub</code> e togliergli uno. Posso anche fare <code>fetch_add(2)</code> perché non mi fa solo il <code>++</code>, mi fa il più uguale due, <em>ma è limitato a queste cose</em>.</p>
<p>Se io avessi una lista, ad esempio, e volessi inserire degli elementi, inserire degli elementi è un'operazione complicatissima che non è fatta di un'unica operazione, devo farne varie perché devo staccare il primo, infilare il secondo, collegare i puntatori, etc… sono tante operazioni da fare per tenere in piedi una lista. <strong>Non posso usare questo tipo di astrazione</strong> perché non c'è un'istruzione singola che il processore mi offre per fare questo tipo di operazioni.</p>
<p>Se io invece di fare <code>++</code> facessi un’operazione di inserimento in un vettore, questa operazione può comportare tante cose: ad esempio magari esaurisco la capacity del vettore e quindi devo anche riallocarlo prima di inserire il nuovo elemento, e <em>mentre rialloco tutto deve essere fermo</em>.</p>
<p><strong>Questo approccio non andrebbe più bene</strong> e allora sia Rust che C++ mi offrono un’astrazione che si chiama <code>mutex</code>.</p>
<p>Questo esempio abbiamo dovuto vederlo in C++ perché Rust, grazie alle regole del <em>borrow checker</em>, questo programma non me lo fa scrivere.</p>
<p><em><strong>Perché non me lo fa scrivere?</strong></em>
Perché io ho dovuto prendere come riferimento <code>i</code>, mutabile di fatto, ma il C++ non mi distingue i riferimenti mutabili da quelli immutabili. Mi da genericamente un riferimento. Ho dovuto prendere <code>i</code> come riferimento doppio e i due thread, tutti e due, potevano scriverci sopra insieme.</p>
<p><strong>Rust questo non me lo fa scrivere</strong> perché se io prendessi <code>ref mut</code> per uno, non lo posso prendere per l'altro. <em>E questo è sano, è sanissimo.</em> Perché vi sta segnalando che se voi state cercando di fare questa cosa qua, sbagliate. <strong>Sbagliate e non sapete neanche di sbagliare.</strong> Lui però lo sa fortunatamente, e ce lo impedisce!</p>
<p>Per questo si dice che Rust è <strong>"fearless concurrency"</strong>, è la “<em>concorrenza senza paura”</em>.
<em>Perché?</em> Perché ha delle ringhiere belle e robuste che ti tengono in linea. <strong>Però bisogna capirlo perché non ci fa fare certe cose</strong>, altrimenti non ne vieniamo fuori.</p>
<p><img src="images/concorrenza/image%2029.png" alt="image.png" /></p>
<p><strong>Il programma che abbiamo visto ci mostra un esempio concreto di un fenomeno molto ampio che prende il nome di interferenza.</strong> Si crea tutte quelle volte in cui due o più thread fanno accesso allo stesso dato, modificandolo.</p>
<p>Il problema di fondo, in questo caso, nasceva dal fatto che avevamo una <em>variabile condivisa</em>, nell'esempio in slide si chiama "a", noi la chiamavamo "i", ma fa lo stesso, a cui due thread insieme accedevano, in questo caso facendo un'operazione di tipo “<strong>read, modify, write”</strong>, perché <code>a++</code> richiede leggere il vecchio valore, modificarlo, riscriverlo.</p>
<p>Nella nostra esperienza normale, da programmatori sequenziali, <code>++</code> è un'operazione atomica, perché non possiamo osservarla durante lo svolgimento. Non abbiamo modo di percepire cosa capita lì in mezzo. <strong>Ma se ci sono due thread</strong>, il secondo thread può vedere la variabile ancora nello stato originale mentre la modifica è in corso e di conseguenza ne possono nascere delle cose imprevedibili.</p>
<p><strong>L'effetto dell'interferenza</strong> è che all'interno del programma sono presenti malfunzionamenti casuali. Noi lo percepivamo dal fatto che il risultato invece di fare 20 milioni faceva un numero inferiore, e soprattutto ogni volta un numero diverso. E non eravamo minimamente in grado di predire che numero sarebbe venuto. <em>E' un problema.</em></p>
<h2 id="17-sincronizzazione"><a class="header" href="#17-sincronizzazione">1.7 Sincronizzazione</a></h2>
<p><img src="images/concorrenza/image%2030.png" alt="image.png" /></p>
<p>Se due thread cercano di accedere in lettura a una stessa variabile, cioè se tutte e due leggono soltanto e nessuno la scrive, non c'è problema. Se la variabile è <em>read only</em> si può accedere anche in 50 — una variabile immutabile non dà problema. <strong>Il problema è se qualcuno la cambia mentre qualcuno la scrive.</strong></p>
<p><em>Quando questo succede si verifica una cosa che si chiama <strong>corsa critica</strong> o <strong>race</strong> in inglese.</em> E' una situazione dove una serie di condizioni che non sono controllabili da noi come programmatori:</p>
<ul>
<li>la presenza della cache con n livelli</li>
<li>il fatto che il compilatore utilizzi o meno delle tecniche di ottimizzazione</li>
<li>il fatto che il processore possa eseguire il riordinamento delle istruzioni al suo interno per scegliere delle cose</li>
<li>la presenza della branch prediction che faccia qualche magia che è fuori dal nostro controllo</li>
</ul>
<p>il risultato è che <strong>a volte le cose vanno bene, a volte le cose vanno male</strong>. E quindi il dato che noi andiamo a leggere all'interno della variabile, in presenza di una scrittura che avviene in contemporanea, potrebbe essere:</p>
<ul>
<li>il valore che c'era originariamente prima che la scrittura avvenisse</li>
<li>il valore successivo alla scrittura <em>(e saremmo anche contenti)</em></li>
<li>una terza cosa che non c'entra un bel niente, ma che potrebbe venire fuori</li>
</ul>
<p><strong>Tutte le volte in cui ci troviamo in una situazione in cui abbiamo bisogno di leggere qualcosa che è scritta da un altro, è necessario che mettiamo in piedi una serie di vincoli:</strong></p>
<ol>
<li>Io devo leggere un dato che devo considerare buono, di conseguenza bisogna che prima svuoti la mia cache, perché se io avessi un dato obsoleto nella mia cache non andrebbe bene, leggerei il dato vecchio e non leggo la versione più recente che c'è da un'altra parte.</li>
<li><em>Deve avvenire solo quando sono certo che nessun altro lo stia scrivendo</em>, perché se lo leggo mentre viene scritto, potrei vedere dati corrotti. Questo è particolarmente rischioso con dati multi-word, cioè più grandi della dimensione massima che il computer può gestire in un'unica operazione atomica.
Ad esempio potremmo avere un vector che è grande 8, 16, 24 byte e mentre leggo il mio vector magari sto prendendo i primi 8 byte che posso prendere con un'operazione singola, mentre gli altri vengono cambiati, e quindi leggo una cosa che non è più buona.</li>
<li>Se sto leggendo e sto aspettando che mi arrivi un qualche risultato, <em>devo evitare di fare del polling</em>, perché se mi metto a fare del polling è un disastro. <em>Mando la CPU al 100%, scarico la batteria in un istante e non combino niente di buono.</em> Quindi io devo proteggermi da queste situazioni.</li>
</ol>
<p><strong>Alcune di queste condizioni</strong> nascono dal fatto che i processori, che sanno di essere soggetti a questi problemi, includono nel proprio set di istruzioni alcune istruzioni particolari che servono proprio a garantire certe cose — motivo per cui l'x86 ha i <em>fence</em> e l'ARM ha i <em>barrier</em>.</p>
<p><strong>Altre condizioni</strong> invece non sono garantibili dal processore in quanto tale, ma richiedono il fatto che il sistema operativo, che sa tutto quello che sta capitando sulla macchina, si faccia lui garante. Ed è il motivo per cui i meccanismi di protezione che noi andiamo a mettere, come ad esempio i meccanismi basati sui <em>mutex</em>, sono possibili solo perché <strong>i mutex sono implementati dentro il sistema operativo</strong>.
<strong>Se non fosse il sistema operativo a darceli</strong> non potremmo costruire questa astrazione a livello puramente applicativo. C'è bisogno di avere qualcuno che vigili al di sopra del resto.</p>
<p>Di conseguenza come avviene veramente la sincronizzazione e che caratteristiche ha, dipende dalla coppia <em>processore/<em>s</em>istema operativo</em>. Il primo ha le sue istruzioni specifiche, il secondo ha le sue astrazioni per esporre tali istruzioni. Per esempio, <strong>Linux su x86 è diverso da Windows su x86</strong>. Poi si sforzano di darmi comunque degli astrazioni analoghe, ma sono diverse.</p>
<p>Per questo motivo i <strong>linguaggi di più alto livello</strong> fanno un grosso sforzo di normalizzare questa distinzione. Il primo grosso intervento fu fatto nel 2011 con l'introduzione del <em>C++ 2011</em>, che ha avuto un suo fratello che è il <em>C 2011</em>. In entrambi è stata l’introduzione l’astrazione dei thread, solo che nel C++ è stata introdotta l’astrazione dei thread e anche dei mutex e anche degli atomics e anche delle condition variable. Nel C invece è finito tutto lì, cioè è stata introdotta solo l’astrazione dei thread, che mi permette di distinguere tra un thread e l'altro, ma poi non ha avuto conseguenze. Quindi quando scrivo in C devo comunque, in buona misura, andare a mettere le mani sulla specifica API del sistema operativo, sulle system call che il sistema operativo mi offre. <strong>In C++ è un po' meglio, in Rust ancora meglio.</strong></p>
<h3 id="171-strutture-native-di-sincronizzazione"><a class="header" href="#171-strutture-native-di-sincronizzazione">1.7.1 Strutture native di sincronizzazione</a></h3>
<p><img src="images/concorrenza/image%2031.png" alt="image.png" /></p>
<p><em><strong>Quali sono le strutture che ho a disposizione?</strong></em>
Allora, ci sono alcune strutture che esistono e sono usabili solo nel contesto del singolo processo e quindi sono supportate di fatto dal sistema operativo, ma la loro applicabilità è strettamente limitata a thread che operano nello stesso processo.</p>
<p>Nel caso di <strong>Windows</strong> le astrazioni che ho sono quelle di C<em>riticalSection</em>, di <em>SRWLock</em> e di C<em>onditionVariable</em>.
Nel caso di <strong>Linux</strong>, da questo punto di vista, sono quelle del <em>pthread_mutex</em> e <em>pthread_cond</em>, che grossomodo coincidono con CriticalSection e ConditionVariable. Queste sono le estrazioni offerte a livello utente nel contesto del singolo processo (più thread che lavorano all’interno dello stesso processo).</p>
<p><strong>Ci sono però alcune situazioni</strong> in cui io ho bisogno di governare e sincronizzare due thread che appartengono a processi completamente distinti, perché potrebbero pestarsi i piedi. Ad esempio, io potrei avere un thread che scrive in un file e lo fa nel contesto del proprio processo e un altro thread che vive in un processo totalmente diverso che legge da quel file. In quel caso lì, le estrazioni citate sopra non mi sarebbero di nessun aiuto, perché non avrebbero visibilità reciproca.</p>
<p><strong>Esistono però degli oggetti kernel,</strong> e sono molto diversi dalle varie parti proprio come concezione, che mi danno un po' di aiuto. Allora, <strong>Windows</strong> mi mette a disposizione:</p>
<ul>
<li>i <em>mutex</em>, che assomigliano un po' a quelli che vedremo</li>
<li>gli <em>oggetti event</em>, che sono lontanissimamente parenti delle condition variable</li>
<li>i <em>semaphore</em>, quelli che contano</li>
<li>strutture per comunicare e sincronizzare: <em>pipe</em> e <em>mail slot</em></li>
</ul>
<p>Al contrario, nel mondo <strong>Linux,</strong> in questo caso specifico, abbiamo:</p>
<ul>
<li>i <em>semaphore</em></li>
<li><em>pipe</em> come modo di inter-process communication</li>
<li>i <em>segnali</em>, che in Windows non hanno nessuna corrispondenza</li>
<li>i <em>futex</em>, future extension, per una sincronizzazione più lasca</li>
</ul>
<p>Sono astrazioni molto diverse tra di loro, su cui in qualche modo dobbiamo fare leva nel caso in cui abbiamo necessità di sincronizzare tra processi differenti.</p>
<p><img src="images/concorrenza/image%2032.png" alt="image.png" /></p>
<p><strong>Quello che noi dobbiamo fare nello scrivere un programma concorrente</strong> è sostanzialmente un'estensione di quello che Rust fa per noi con i puntatori. Il borrow checker con i puntatori dimostra logicamente che il programma non è sbagliato. <em>Non riesce a dimostrare che è giusto, ma dimostra che non è sbagliato</em>, ovvero che non facciamo nessuna <strong>azione illecita</strong>.</p>
<p>Noi sappiamo che questo in alcuni casi è restrittivo, cioè ci sono azioni che sarebbero lecite e che però il borrow checker non riesce a dimostrare. <strong>Ma siamo tranquilli che se il borrow checker ci fa passare</strong>, dal punto di vista dei puntatori e del possesso della memoria, non c'è nessun problema.</p>
<p>Noi dobbiamo estendere a mano, col nostro cervello, questa operazione sui programmi concorrenti, <strong>garantendo che il programma concorrente che noi scriviamo è corretto</strong>. Ovvero che non capita mai che un thread modifica un dato mentre un altro lo sta leggendo. <em>O mentre lo sta scrivendo, ancora peggio.</em></p>
<p><strong>In particolare dobbiamo essere concentrati sugli stati transitori.</strong> Pensate a un <code>Vec</code>. Dobbiamo fare un'operazione apparentemente banale, <code>push</code> nel vector.
<em>Cosa fa push nel vector?</em> Beh, fa una serie di operazioni assembler. Va a vedere se c'è della capacity residua. Se c'è della capacity residua va a posizionarsi al fondo del size, nel buffer che è già allocato, ci copia il dato e incrementa il size. <em>Ci sono una serie di passi intermedi in cui l'oggetto vector è temporaneamente in uno stato sbagliato</em> — io ho già riempito un pezzo del buffer ma non ho ancora incrementato il contatore. Potrei anche fare il contrario, potrei incrementare subito il contatore per occuparmi poi dello spazio ma in quel caso lì vorrebbe dire che il valore che c'è scritto lì dentro è sbagliato. Non è ancora scritto. <strong>Quindi qualunque scelta io faccia delle tante possibili mi ritrovo in un momento in cui il dato è solo parzialmente modificato.</strong></p>
<p>Nei programmi puramente sequenziali questo <strong>non è un problema</strong> perché è tutto annegato nell'operazione <code>push</code>, e quindi io vedo lo stato prima di <code>push</code> e poi lo stato dopo <code>push</code>. <em>Tutto pulito</em>. Ma se io ho un programma concorrente che conosce l'indirizzo di quel vector, siccome non sa che cosa ci sto facendo col vector, potrebbe andarci a guardare dentro mentre io lo sto cambiando. E se ci va a guardare dentro mentre io lo sto cambiando potrebbe sbagliarsi, cioè <strong>potrebbe credere a quello che legge, che non rappresenta uno stato definitivo</strong>.</p>
<p><strong>Quindi io devo proteggermi da queste situazioni</strong>. In generale questo vale per tutti gli oggetti <em>condivisi</em> <em>e</em> <em>mutabili</em>. Se io avessi solo oggetti immutabili tutto sarebbe tranquillo. Quell'oggetto lì ha un valore, fine, e non può cambiare. È il motivo per cui <em>Borrow Checker</em> ci lascia prendere in lettura quante copie vogliamo, non si preoccupa mica, ma <strong>impone che come <code>ref mut</code> ce ne può essere uno solo per volta,</strong> perché se ce ne fosse più di uno si potrebbe incorrere in errori. Potremmo prendere delle cose fasulle.</p>
<p>Quindi la difficoltà è arricchire il nostro algoritmo, che avremmo pensato in modalità puramente sequenziale, di alcuni <em>rinforzi</em> che nei punti in cui serve, e solo in quelli (ovvero <strong>nei punti dove c'è potenziale interferenza</strong>), vanno a costruirci uno schermo che impedisce che succedano cose brutte.</p>
<p>Di conseguenza, spesso e volentieri, usiamo un approccio "<strong>object oriented</strong>", ovvero diciamo <em>“Io ho un dato che è condiviso, come lo proteggo questo dato condiviso?”</em>
Beh, intanto lo incapsulo in una <em>struct</em> innanzitutto.
Questa struct la rendo <strong>privata</strong> in modo tale che nessuno possa direttamente metterci le mani dentro, e offro dei <strong>metodi</strong> che mi danno la possibilità di cambiarla.
Questi metodi si occupano, proprio perché sono quelli che mi garantiscono il cambio dell'evoluzione del suo stato, di prendere le precauzioni necessarie a far sì che non capitino cose che non voglio.</p>
<p>Ad esempio, abbiamo visto nel conteggio prima che io ho dovuto trasformare quello che era un semplice intero in un <em><strong>atomic int</strong></em> e ho dovuto cambiare il modo in cui incrementavo. Prima facevo <code>++</code>, dopo ho dovuto dire <code>fetch_add</code>, in modo da garantirmi che quell'operazione lì avvenisse in modo pulito. In altri casi io annego i miei dati in una struct e in questa struct ci metto non solo i miei dati ma anche altre cose, ad esempio gli oggetti tipo <em>mutex</em>, che mi proteggono da determinate cose, e che vado ad usare nel modo giusto, quando mi occorrono.</p>
<p>Quindi usiamo l'approccio object oriented con i metodi che <strong>incapsulano</strong> per garantire che l'accesso avviene sia in lettura che in scrittura, coerentemente con le regole che ci diamo.</p>
<h2 id="18-correttezza"><a class="header" href="#18-correttezza">1.8 Correttezza</a></h2>
<p><img src="images/concorrenza/image%2033.png" alt="image.png" /></p>
<p>Notate che in quasi tutti i linguaggi di programmazione tocca al programmatore scegliere <em>come</em>, <em>dove</em> e <em>quando</em> usare la sincronizzazione. <strong>È lì la vostra abilità</strong>.</p>
<p>Se non la usate correttamente il risultato è un disastro. Avrete dei programmi che a volte vanno, a volte non vanno, a volte si impiantano e cose del genere.</p>
<p>L'unico modo per affrontare questo problema è, come dicevamo, seguire l'approccio del borrow checker: dimostrare formalmente la correttezza dell'algoritmo. Dovete sviluppare un ragionamento del tipo <em>"Può succedere questo? Sì. Allora non va bene".</em> Oppure, <em>"Può succedere questo? No. Perché non può succedere? Dimostriamo il teorema."</em> La dimostrazione si basa sugli invarianti forniti da strutture più semplici come mutex e condition variables, che ci garantiscono che certi eventi non possono verificarsi. Partendo da queste garanzie di basso livello, costruiamo la dimostrazione che anche ad alto livello il nostro programma mantiene la sua correttezza.</p>
<p>Però questo richiede che ci mettiamo lì e facciamo la dimostrazione, proprio come dimostreremo il teorema di Pitagora, con una sequenza di passaggi logici che devono essere corretti, senza farci degli sconti.
Se il programma non è corretto è inutile pensare di ottimizzarlo, di farci delle cose sopra o anche solo di farci dei test.</p>
<p><strong>L'eventuale test che mettete in un programma concorrente non dimostra niente.</strong> Perché abbiamo visto che lanciando più volte lo stesso identico programma, se il programma è scritto male, possono venire fuori risultati ogni volta diversi. E quindi il fatto che voi avete lanciato un test ed è andato bene <em>non vuol dire nulla</em>. Potrebbe essere stato un puro caso. <strong>Bisogna che il programma sia giusto alla fonte.</strong></p>
<p>Da questo punto di vista <em>programmare in Rust è salutare</em> perché grazie al borrow checker una grande parte di possibili errori non possono essere costruiti perché non potete neanche compilarlo il programma. <strong>Il fatto che il borrow checker vi garantisca l'accesso in scrittura uno solo per volta è un grande toccasana.</strong> Ma non basta. Ci sono situazioni in cui dovete aggiungere del vostro.</p>
<p><strong>Allora i problemi fondamentali</strong> li abbiamo già citati. Sono quelli di <em>atomicità</em>. Abbiamo visto che il <code>++</code>, che sembra atomico, <strong>non lo è</strong>. Ma <em>non sono atomiche una montagna di operazioni</em>. <code>push</code> di un vettore non è atomico. Meno ancora se mai quel vettore dovesse riallocare. E quindi di base se due thread fanno accesso alla stessa struttura dati o un vector, e io leggo e tu scrivi o cose del genere, <strong>non sono in grado di capire chi sta facendo che cosa</strong>. Perché ho due thread che ognuno per i fatti suoi conosce quella roba lì e cerca di modificarla o di leggerla in qualche modo. Ma non rendendosi conto che anche l'altro fa cose, faremmo disastri.</p>
<h2 id="19-accesso-condiviso"><a class="header" href="#19-accesso-condiviso">1.9 Accesso condiviso</a></h2>
<p><img src="images/concorrenza/image%2034.png" alt="image.png" /></p>
<p><strong>Atomicità e Visibilità.</strong>
<em>Quando una variabile che io ho modificato può essere osservata da un altro?</em>
In generale questo richiede che io svuoti le cache. Se io non svuoto le cache, la modifica c'è certamente nella mia cache, ma <em>non è detto che sia stata propagata al resto del sistema</em>. E quindi il resto del sistema potrebbe ignorarlo.</p>
<p><strong>Ordinamento.</strong>
<em>Sotto quali condizioni una sequenza di operazioni fatte da un thread è visibile <strong>nello stesso ordine da un altro?</strong></em>
In particolare, se io prima faccio A e poi B, il fatto che un altro veda B implica anche che vedrà sicuramente A? <em>La risposta è in generale no</em>. A meno che io non prenda delle misure per garantirlo.
Il fatto che non lo veda nasce dal fatto che ci possono essere tempi di propagazione diversi attraverso la cache, ci possono essere riordinamenti fatti all'interno del processore che usando ottimizzazioni (come la <code>branch prediction</code>) potrebbe decidere di fare una cosa prima di un'altra, e ci sono ottimizzazioni che può fare il compilatore. E noi dobbiamo capire bene come forziamo ciascuno di questi tre layers a non fare quello che non vogliamo.</p>
<p><img src="images/concorrenza/image%2035.png" alt="image.png" /></p>
<p><strong>Allora, abbiamo tre pezzi da imparare sostanzialmente.</strong></p>
<p>Gli <em><strong>oggetti Atomic</strong></em>.
Ne abbiamo accennato l'uso in C++. In Rust sono la stessa cosa sostanzialmente. Sono oggetti che incapsulano dei dati elementari. Quindi io posso fare l'atomic di un numero sostanzialmente, tuttalpiù di un puntatore. Ma <em>attenzione</em>, quello che rendo atomico è l'aggiornamento del puntatore, <strong>non del dato puntato</strong>. Il dato puntato resta per i fatti suoi quello che sia. Quindi io posso garantire che questo puntatore l'ho cambiato di certo. Niente di più di quello. Poi il dato puntato è un'altra faccenda.</p>
<p><strong>Gli atomic</strong> vanno bene con dei dati banali: booleani, interi (di vario tipo, byte, long, short), e puntatori — che di fatto sono poi degli interi pure loro. <strong>L'oggetto atomic</strong> mi offre una serie di metodi di tipo <em><strong>“read, modify, write”</strong></em> non interrompibili.
Ovvero, con garanzia, data sostanzialmente dalla CPU, perché poi queste operazioni mappano su istruzioni o blocchi di istruzioni forniti dalla CPU, che non sono interrompibili. Nell'x86 c'è il prefisso <code>Lock</code>, che viene messo davanti all'operazione atomic, che inibisce gli altri core dal funzionare. E di conseguenza mi garantisce che mentre io leggo, incremento e scrivo, gli altri sono proprio fermi. E quindi non c'è rischio che facciano cose strane.</p>
<p>Poi abbiamo i <strong><code>Mutex</code></strong> che adesso vediamo e cerchiamo di capire nella sostanza cosa fanno. Servono a garantire accesso uno per volta a strutture dati arbitrariamente complesse. <strong>L'implementazione che Rust fa dei mutex è particolarmente efficace</strong>. Perché ce li presenta sotto forma di <em>smart pointer</em>. Il <code>Mutex</code> totalmente racchiude il dato che protegge. E non c'è modo di accedere al dato se non tramite i meccanismi che il <code>Mutex</code> stesso mi dà.
A differenza di quello che succede in C++ o in C dove il mutex sta a fianco ai dati, non attorno ai dati. E di conseguenza io potrei comunque leggere e scrivere (sbagliando, ma lo posso fare) il dato senza passare dal mutex. <strong>Rust</strong> invece in questo mi aiuta tantissimo perché mi dice <em>"il dato è parte del mutex, tu non ci entri dentro se non chiedi al mutex il permesso"</em>. E il mutex te lo dà secondo le sue regole. E questo di nuovo ci rende la vita molto tranquilla perché siamo sicuri che lì non possiamo sbagliare.</p>
<p><strong>Le Condition variables</strong> servono in quelle situazioni in cui abbiamo bisogno di attendere senza consumare cicli di CPU che capiti qualcosa. Le condition variables possono essere usate <em>solo insieme a un mutex</em>. Perché nella loro API hanno bisogno di un mutex. <strong>Non posso crearla se non insieme a un mutex</strong>. Quindi da questo punto di vista sintatticamente non c'è rischio di sbagliare. Semanticamente tocca a me capire che cosa devo fare.</p>
<p><img src="images/concorrenza/image%2036.png" alt="image.png" /></p>
<p><em><strong>Come usiamo i thread?</strong></em>
Potremmo scrivere direttamente il codice nativo che chiama le system call di Windows, di Linux, di Mac OS o altre cose, ma in realtà preferiamo usare i <em>linguaggi moderni di alto livello</em> che ci danno le astrazioni necessarie.</p>
<p>Nel caso di C++ si include la libreria <code>thread</code> e si creano gli oggetti di tipo <code>std::thread</code>. Nel caso di Rust si usa la libreria <code>std::thread</code> che ci offre la funzione <code>spawn</code> che ci mette in condizioni di creare un nuovo thread. Esattamente come abbiamo visto.</p>
<p>Quindi da un punto di vista prettamente sintattico <strong>creare un thread è banalissimo</strong>. E <code>std::thread::spawn</code>, <code>spawn</code> accetta una closure che indica che cosa vogliamo che questo thread faccia.
Dal momento in cui invochiamo <code>spawn</code> può cominciare l'esecuzione di quest'altra funzione.</p>
<p><em>Può cominciare, ma comincia?</em>
Dipende, dipende dal sistema operativo se ha un core libero o se non ce l'ha. Sicuramente quella funzione lì viene messa attraverso i costrutti necessari del kernel nell'elenco delle cose da fare da parte dello scheduler del sistema operativo. Poi che lo scheduler la faccia partire immediatamente o la faccia partire da qui a un po' è fuori dal nostro controllo. Non lo vediamo, ma sappiamo che potrà partire.</p>
<p><strong>Questo comincia e produce delle cose.</strong> Se la funzione ritorna un valore di tipo <code>T</code> generico potremo accedere a quel tipo <code>T</code> attraverso il metodo <code>join</code> che ci viene offerto dal valore restituito dalla funzione <code>spawn</code>. <strong>Spawn restituisce un join handle</strong>. Questo join handle ci serve quando avremo bisogno di sapere se il thread ha finito o meno. Il join handle ha un unico metodo utile che è <code>join</code> che <em>blocca il chiamante</em> fino a che il thread a cui quella join handle corrisponde non è terminato. E restituisce un <code>Result</code>. Questo <code>Result</code>, se è <code>Ok&lt;T&gt;</code>, contiene quindi il valore che la funzione del thread ha effettivamente calcolato, e questo ci dà la possibilità di considerare il nostro thread come un <strong>produttore di un dato</strong> — <em>“io ti affido questo compito: creami questa informazione”</em>.
Quindi al thread 1 faccio fare questo pezzo di calcolo, al thread 2 ne faccio fare un altro, al thread 3 ne faccio fare un altro e poi aspetto che finiscano, me li prendo e li combino e li uso per qualche scopo.</p>
<p>Oppure quel <code>Result</code> che il metodo <code>join</code> di join handle mi restituisce contiene un <code>Error</code> che potrebbe essere nato dal fatto che quel thread ha <em>panicato</em>.
Se l'esecuzione di questo thread ha generato una condizione di panic, allora chi lo aspetta può saperlo.
<strong>Questa è una grossa differenza rispetto a come avviene in C++</strong>. In C++ se un thread lancia un'eccezione che non viene raccolta, il processo termina.
In Rust, invece, se un thread panica, quel thread lì cessa di esistere, ma chi ne fa la join riceve una descrizione del panic che si è verificato al suo interno e può usare questa descrizione per farci qualcosa, per cercare di aggiustare delle cose.</p>
<p><em>Notate che il thread che crea e il thread creato <strong>non hanno nessuna relazione di parentela</strong></em>.
Sono indipendenti. Poi di fatto il thread che crea ha la join handle, e quindi spesso utilizza quella join handle per aspettare quell'altro. Ma <strong>non è necessario</strong>: io potrei prendere la join handle e passarla a un thread ulteriore che si occupa di aspettare tutti. Cioè potrei fare altre cose.</p>
<h1 id="2-thread-in-rust"><a class="header" href="#2-thread-in-rust">2. Thread in Rust</a></h1>
<p><img src="images/concorrenza/image%2037.png" alt="image.png" /></p>
<p>Quindi banalmente l'uso dei thread è fatto così.</p>
<p><strong>Attenzione.</strong> La funzione chiamata nel thread può essere basata solo su variabili locali, e in questo caso non c'è problema. Ma siccome quella è una <em>chiusura</em> potrebbe anche fare riferimento a variabili dello scopo in cui è stata definita. Siccome però il thread esiste per un tempo indefinitamente lungo, io <strong>non posso prendere dei ref allo scope</strong>, perché non sono in grado di dire quando quel thread finirà. Quindi se ho bisogno di passargli delle informazioni <em>non gliele posso passare con dei ref</em>. Ma gli devo dare possesso del dato.</p>
<p>Per questo motivo spesso e volentieri quando creiamo i thread con <code>spawn</code> li creiamo passando una chiusura che comincia con la parola chiave <code>move</code>. Vuol dire che se io lì dentro prendo riferimento a qualcosa del mio scope, questo diventa <strong>proprietà completa</strong>. E quindi il <em>Borrow Checker</em> riesce a gestirsi il calcolo del lifetime. Altrimenti non ci sarebbe modo perché mentre nell'esecuzione sincrona io chiamo la funzione, aspetto che ritorni, eccetera, e posso usare le relazioni note temporali per poter dire se un reference dura abbastanza o meno, i thread invece, che iniziano adesso ma che possono finire chissà quando, non mi danno possibilità di avere nessun riferimento. Per questo motivo li facciamo così. Per lo meno i thread che creiamo con la funzione <code>spawn</code>.</p>
<p><img src="images/concorrenza/image%2038.png" alt="image.png" /></p>
<p>C'è un secondo modo di costruire i thread un pochino più sofisticato che dice <em>“guarda volendo all'interno del namespace <code>std::thread</code> c'è una struct che si chiama <code>Builder</code> che mi dà la possibilità di configurare il thread prima di lanciarlo”</em>.</p>
<p>Il thread per default parte con uno stack che ha una dimensione predefinita e riceve un nome che è assegnato dalla libreria che potrebbe non essere particolarmente utile, ma se io nel mio algoritmo sto creando un thread che mi serve da <em>garbage collector</em> potrei trovare più utile chiamarlo adeguatamente <code>garbage collector</code>, così quando mai farò delle stampe di debug o qualcosa del genere lui potrà usare il nome <code>garbage collector</code> come propria identità e se questo si pianta potrò dire <em>"si è verificato un panico nel garbage collector"</em>.</p>
<p>La struttura <code>Builder</code> mi dà la possibilità di <strong>configurare il mio thread</strong> e quindi in questo caso creo l'oggetto <code>Builder</code>, gli assegno un nome, gli assegno la dimensione dello stack in base a quanto penso che possa aver bisogno (eventualmente dandogli di meno di quello che gli darebbe normalmente se io so che quel thread lì non ha una grossa profondità di ricorsione) e poi quando sono contento con i suoi dati lo faccio di fatto partire, <code>builder.spawn</code>.</p>
<h2 id="31-i-tratti-della-concorrenza"><a class="header" href="#31-i-tratti-della-concorrenza">3.1 I tratti della concorrenza</a></h2>
<p><img src="images/concorrenza/image%2039.png" alt="image.png" /></p>
<p><em><strong>Che cosa permette di passare a un thread?</strong></em>
Allora un thread può catturare e fare accesso a delle variabili a condizione che queste variabili <em>rispettino alcuni vincoli</em>.
In particolare all'interno di Rust sono definiti due tratti che sono due tratti cosiddetti <em><strong>marker</strong></em>, come <code>Copy</code>. Il tratto <code>Copy</code> non ha niente come metodo suo, è usato soltanto come un flag per dire <em>"è lecito fare una copia di questa cosa"</em> ovvero fare quello che faresti col movimento ma dando ancora accesso all'originale.</p>
<p>I tratti marker della concorrenza si chiamano <code>Send</code> e <code>Sync</code>.</p>
<p><strong><code>Send</code></strong> significa che è lecito che un certo dato sia passato a un altro thread.
<em>Quindi se io creo l'oggetto thread con <code>move</code> che cosa posso muovere dentro questo thread? <em><em>Qualunque cosa che abbia il tratto</em> <code>Send</code>.</em></em></p>
<p><em>E chi ce l'ha il tratto</em> <code>Send</code><em>?</em>
Quasi tutti, tranne i reference e i pointer nativi.
<em>Perché?</em> Perché se io ti passassi un reference, tu lo potresti usare da qui in avanti, <em>ma quanto a lungo lo usi? Boh, finché il thread padre c’è.</em> Non sono in grado di capire se quel reference dura a lungo abbastanza. Di conseguenza i reference non te li passo. <strong>Ti posso passare soltanto un dato di cui hai il pieno possesso.</strong></p>
<blockquote>
<p>💡 <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2040.png" alt="image.png" /></p>
</blockquote>
<p><strong>C'è un secondo marker che ci interessa, che è <code>Sync</code></strong>.</p>
<p><em>Chi è che ha il tratto</em> <code>Sync</code><em>?</em>
<em>Quelli che possono essere condivisi in sicurezza tra thread differenti</em>.</p>
<p>Se qualcuno gode del tratto <code>Sync</code> fa eccezione alla regola vista prima. Ovvero il suo riferimento è passabile. <strong>Normalmente i riferimenti non sono passabili</strong>. Ma se una cosa gode del tratto <code>Sync</code> diventa passabile come riferimento.</p>
<p><em>Chi è che non implementa</em> <code>Sync</code><em>?</em>
<code>Cell</code> e <code>RfCell</code>, perché se te li passassi sarebbe un disastro.</p>
<blockquote>
<p>💡 <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2041.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2042.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/concorrenza/image%2043.png" alt="image.png" /></p>
<p>Quindi qui vediamo dei casi.</p>
<p>La maggior parte degli oggetti vivono nel cerchio più interno: <strong>godono cioè sia di <code>Send</code> che di <code>Sync</code></strong>. E quindi non c'è un grosso problema.</p>
<p><code>&amp;str</code> pur essendo un reference, siccome è un reference immutabile, non mi dà fastidio, e quindi gode sia di <code>Send</code> che di <code>Sync</code>.</p>
<p>Ci sono alcune cose che sono <code>Send</code> ma non <code>Sync</code>.
Ci sono cose che non sono né <code>Send</code> né <code>Sync</code>.</p>
<p>Questo ci aiuta perché <strong>Rust ci impedisce di sbagliare</strong>. Anche solo grazie a questi meccanismi.</p>
<p><img src="images/concorrenza/image%2044.png" alt="image.png" /></p>
<p>Notate che possiamo di fatto creare un'istanza di thread. In questo caso vedete che facciamo <code>spawn</code> lì sopra.</p>
<p><em>Cosa provo a passargli?</em> <em>Provo a passargli un oggetto di tipo <code>Rc</code>, <code>data2</code></em>, che è un <code>Rc</code> clonato da <code>data1</code>.
Poi proviamo a stampare cosa c'è dentro <code>data1</code>, e provo a passare <code>data2</code> al thread.
<strong>Peccato che <code>Rc</code> non gode del tratto <code>Send</code></strong>.</p>
<p><em><em><em>Perché non gode del tratto</em> <code>Send</code></em>?</em>**
Perché quando andassi a distruggerlo, lui andrebbe a decrementare il contatore, ma <em>non lo farebbe in modo atomico!</em>
E non facendolo in modo atomico, non mi darebbe garanzia che quel <code>--</code> funzioni davvero.
Cioè potrebbe capitarmi, come capitava prima col <code>++</code>, che vengono dei numeri a caso.
Perché lui non potrebbe dire che quel <code>--</code> non avviene mentre in contemporanea non avviene un <code>++</code> o un altro <code>--</code>. E di conseguenza potrebbero uscirne dei numeri completamente strambi. <strong>Di conseguenza non è lecito</strong>.</p>
<p>Se invece al posto di <code>Rc</code> scrivessi <code>Arc::new</code> otterrei un comportamento simile ma la differenza starebbe nell'operazione <code>++</code> che viene fatto sul reference count. In questo caso sarebbe fatto con un <strong>atomic</strong>. <code>Arc</code> infatti sta per <em>Atomic Reference Count</em>.
E di conseguenza sarei sicuro che quel <code>++</code> è un po' più lento, ma sono sicuro della correttezza.</p>
<p>In questo caso della slide il compilatore mi blocca e mi dice <em>"Non puoi farlo perché <code>data2</code>, che è di tipo</em> <code>Rc&lt;i32&gt;</code><em>, non può essere mandato in modo sicuro da un thread e un altro perché non ha il tratto</em> <code>Send</code><em>"</em>.</p>
<p><img src="images/concorrenza/image%2045.png" alt="image.png" /></p>
<p>Adesso dobbiamo imparare l'uso dei mutex.</p>
<p>La sincronizzazione in Rust può avvenire con <strong>due “mega” modelli</strong>:</p>
<ol>
<li><strong>Il modello a stato condiviso</strong>
Nel modello a stato condiviso abbiamo una struttura dati a cui accedono più thread che è protetta debitamente e che mi dà garanzia che le modifiche che faccio sono coerenti.</li>
<li><strong>Il modello a scambio di messaggi</strong>
Il modello a scambio di messaggi prevede che di condiviso non c'è niente ma abbiamo creato dei canali attraverso cui ci mandiamo a dire delle cose.</li>
</ol>
<p>Gli algoritmi che andiamo a disegnare nell'uno e nell'altro caso sono diversi.</p>
<p><em>Alcune cose sono molto più facili da implementare a stato condiviso e sono complicate con i messaggi.
Altre sono molto facili da implementare con i messaggi e sono molto complicate da implementare con lo stato condiviso</em>.</p>
<p>Per contro il C++ di suo ha solo il modello a stato condiviso come standard. Poi, chiaramente, usando librerie esterne possiamo arricchirlo con i messaggi.</p>
<p><strong>Rust</strong> invece ha incluso fin dall'inizio le due possibilità proprio per rendere più comodo alla vita il programmatore che peraltro deve però conoscere i due modelli e, messo di fronte a un problema, <em>capire se è più facile affrontarlo con lo stato condiviso o è più facile affrontarlo con i messaggi</em>.</p>
<p><img src="images/concorrenza/image%2046.png" alt="image.png" /></p>
<p>Per avere lo <strong>stato condiviso</strong> usiamo gli oggetti di tipo <code>Mutex</code>.</p>
<h1 id="3-mutex-in-rust"><a class="header" href="#3-mutex-in-rust">3. Mutex in Rust</a></h1>
<p><img src="images/concorrenza/image%2047.png" alt="image.png" /></p>
<p>Gli oggetti di tipo mutex (tralasciando la parte C++ che vedremo dopo) partono da questo assunto: <strong>l'oggetto <code>Mutex&lt;T&gt;</code> incapsula il dato <code>T</code> qualunque <code>T</code> sia</strong>.</p>
<p>Quel dato lì è annegato dentro, quindi quando creo un mutex, <code>let M = Mutex::new(vec![1,2,3,4])</code>, il mio mutex racchiude il vettore con dentro <code>1,2,3,4</code>. Ci posso mettere quel che voglio, non ha importanza, può essere complicato a piacere.
<em>È tutto dentro il mutex e di suo il dato è inaccessibile</em>.</p>
<p><em>Come faccio a sapere cosa c'è dentro il mutex?</em>
Il mutex mi offre un unico metodo utile che si chiama <code>lock</code>.
Quando ho bisogno di sapere cosa c'è scritto dentro il mutex oppure ho bisogno di modificare quello che c'è scritto dentro il mutex, prendo la mia variabile mutex <code>M</code> e faccio <code>M.lock</code>.</p>
<p><em><em><em>Cosa fa</em> <code>M.lock</code></em>?</em>**
<code>M.lock</code> interagendo col sistema operativo verifica: <em>c'è già qualcuno che sta facendo delle cose?</em> Se sì mi blocca lì — <code>lock</code> non ritorna fino a che c'è qualcosa in corso.</p>
<p><strong>Quando i lavori in corso finiscono</strong>, ecco che <code>M.lock</code> ritorna e <em>che cosa ritorna?</em>
Mi ritorna un oggetto che è uno <em>smart pointer</em>, cioè un oggetto tramite cui, se lo dereferenzio, posso accedere al dato.
Se il mio dato è un dato elementare come un numero dovrò fare <code>*</code> del mio puntatore per vederlo. Se quello è invece un dato più sofisticato come un <code>Vec</code> o cose del genere, potendo usare la notazione punto, dell'asterisco ne faccio a meno semplicemente perché la notazione punto mette davanti gli asterischi di cui ho bisogno, ma nella sostanza è uno smart pointer.</p>
<p>Finché quello smart pointer è in giro il mutex resta di mia proprietà. <strong>Nessun altro ci può far niente</strong>. Quello smart pointer se è dichiarato di tipo <code>mut</code> io potrò cambiare il dato. Se è dichiarato di tipo non <code>mut</code> lo potrò solo leggere, ma quella è una normalissima questione di Rust dell'accesso alle varie parti.</p>
<p><em>Quando questo smart pointer che mi è stato restituito da</em> <code>lock</code> <em>esce dai piedi</em> — cioè lo droppo oppure raggiunge la fine del suo scope — quello che succede è che se c'era qualcun altro che voleva fare accesso al mutex può entrare, viene sbloccato. Punto, tutto qui!</p>
<p><strong>Il mutex quindi garantisce mutual exclusion. Si entra uno per volta.</strong></p>
<p>Notate che l'oggetto <code>Mutex</code> di base io lo posso conoscere come oggetto non mutabile. Mi dà una forma di <strong>mutabilità interna</strong> simile a <code>RefCell</code> che però è condivisibile tra thread sotto certe condizioni, e come? Racchiudendolo dentro un <code>Arc</code>.
Quindi il modo tipico di proteggermi quando ho bisogno di avere un dato che voglio che due thread possano <em>pasticciare</em> per i fatti loro è <em>prendere il mio dato, metterlo in un</em> <code>Mutex</code><em>, metterlo dentro un</em> <code>Arc</code>.
Questo <code>Arc</code> lo posso dare, clonare tante volte quanto serve e darne una copia a ciascuno dei thread.</p>
<blockquote>
<p>💡 <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2048.png" alt="image.png" /></p>
</blockquote>
<p>Ciascuno di questi thread, quando ha bisogno di accedere prende il suo <code>Arc</code>, fa  <code>.lock</code> (tanto <code>Arc</code> è uno <strong>smart pointer</strong> e automaticamente me lo dereferenzia al metodo interno, quindi vedo il <code>Mutex</code>), quindi facendo <code>.lock</code> se c'è bisogno aspetto (ma non me ne accorgo), e quando <code>lock</code> ritorna ho un altro smart pointer che per comodità chiamiamo <code>L</code> per comodità.
Questo smart pointer mi dà l'accesso al dato, e sono sicuro che <em>mentre esiste questo smart pointer sono l'unico che lo può vedere</em>. Faccio tutto quello che devo, possibilmente in fretta, e poi butto via <code>L</code>, questo smart pointer. Buttandolo via dò la possibilità ad altri che volessero entrare, di poter fare delle cose.</p>
<p><strong>Scriviamo velocemente l'esempio</strong> <strong>che abbiamo visto prima del più più con i thread.</strong></p>
<p><img src="images/concorrenza/image%2049.png" alt="image.png" /></p>
<p>Allora qui ho due thread li sfrutto per questo <code>let a = Arc::new(Mutex::new(0))</code>.
Quindi incapsulo all'interno del mutex un <code>i32</code>, semplicissimo.
Dopodichè lo clono perchè di base un <code>Arc</code> che non lo posso dare così com'è: lo devo clonare per poterlo cedere ai singoli thread.</p>
<p>A questo punto ho tre <code>Arc</code> che conoscono dove sta il <code>Mutex</code> che dentro di sé racchiude il suo numero: <code>a</code>, <code>a1</code> e <code>a2</code>.</p>
<p>Creo il primo <code>thread</code> con <code>thread::spawn</code>, gli aggiungo <code>move</code>, e come lambda gli passo un for che per 10 milioni di iterazioni fa <code>let mutex l = a1.lock().unwrap();</code> (<code>unwrap</code> perchè <code>lock</code> restituisce un <code>Result</code>, e potrebbe fallire nel caso in cui un thread che possedeva il <code>Mutex</code> fosse morto mentre lo possedeva. Questo, nel nostro esempio non può succedere quindi possiamo fare tranquillamente <code>unwrap</code>).
<code>a1</code> punta il mio <code>Mutex</code>, che a sua volta contiene il mio numero. Qui dentro lo voglio incrementare e quindi con <code>a1.lock()</code> prova a vedere se posso prenderne possesso.
Quando riesce a prendere possesso, dentro <code>l</code> ho uno smart pointer chiamato <code>MutexGuard</code>, che mi consente di accedere al dato.
A questo punto scrivo <code>*l += 1</code>. Scrivendo questo dereferenzio <code>l</code> (che come detto è un <code>MutexGuard</code>, quindi uno smart pointer), accedo al dato, e gli sommo 1.</p>
<p>Poi <code>l</code> arriva alla chiusa graffa, esce dallo scope, il <code>drop</code> di <code>MutexGuard</code> si occupa di rilasciare il lock, e finalmente <code>l</code> va via dai piedi.
Se c'è qualcun altro che ha bisogno di accedere al dato, adesso può  entrare.</p>
<p>Faccio lo stesso lavoro con il thread <code>t2</code> qua sotto. Anche qui 10 milioni. Scrivo <code>let l = a2</code> stavolta e anche questo thread lo dovrò fare con <code>move</code>. <code>a2.lock().unwrap()</code>.
A questo punto facciamo anche qui <code>*l += 1</code>.</p>
<p>Quando abbiamo fatto queste due operazioni possiamo fare il <code>join</code> e possiamo fare un <code>println!</code> di <code>a.lock().unwrap()</code>.</p>
<p>A questo punto se eseguiamo vediamo 20 milioni come risultato.</p>
<p>Quindi il programma è corretto.
Chiaramente ci ha messo un po' a fare 20 milioni, <em>perché?</em> Perché da ogni passaggio ha preso il <code>Mutex</code>, fermando l’altro thread, ha fatto l’incremento, ha mollato il <code>Mutex</code> e l'altro thread è potuto entrare, e così via la stessa cosa anche per lui.</p>
<p>In questo esempio abbiamo protetto un numero ma avremmo potuto proteggere un <code>Vec</code>, una struttura, una lista, quello che vogliamo!</p>
<h1 id="4-conditionvariable-in-rust"><a class="header" href="#4-conditionvariable-in-rust">4. ConditionVariable in Rust</a></h1>
<p><img src="images/concorrenza/image%2050.png" alt="image.png" /></p>
<p>Abbiamo dunque incominciato a vedere alcuni dettagli della programmazione concorrente e abbiamo visto come possiamo attivare più thread per poter svolgere in parallelo delle operazioni. In realtà noi utilizziamo i thread in contesti anche più ampi, <em>non solo là dove ci serve il reale parallelismo</em> (ovvero dove vogliamo servirci del fatto che la nostra CPU abbia molti core e ciascuno di questi possa svolgere una computazione totalmente indipendente dalle altre), ma spesso usiamo i thread come <em>surrogato</em> per la realizzazione di programmi semplicemente concorrenti, ovvero programmi nei quali concretamente le nostre azioni non si svolgono necessariamente in parallelo, nel senso che mentre faccio una cosa non necessariamente ne devo fare un'altra, perché alcune delle cose che faccio mi portano a dei blocchi.</p>
<p><strong>Ad esempio</strong>, se sto leggendo dal disco io arrivo a invocare la funzione <code>read</code> che in qualche modo è responsabile di recuperare dal disco i dati che mi servono, ma siccome il sistema operativo ha bisogno di interagire con la periferica, e immaginando il disco di quelli rotativi, per cui la CPU deve aspettare che banalmente faccia il giro e si porti sul settore che mi interessa per leggere sotto la testina, ci sono <em>lunghi intervalli di tempo</em> nei quali non stiamo facendo assolutamente nulla, perché il nostro processore è lì in attesa che succeda qualcosa nel mondo fisico, cioè che il disco giri.</p>
<p><strong>In realtà</strong>, siccome la chiamata a <code>read</code> è bloccante (ovvero non ritorna fino a che la lettura non è completa), se mentre leggo dal file 1 ho bisogno di leggere anche dal file 2, beh, l'unica alternativa che ho, se non voglio aspettare che finisca la prima lettura per poter iniziare la seconda, è creare due thread. In quel caso lì io sto creando due thread che entrambi leggono dal file system, ma in realtà non si stanno realmente svolgendo in parallelo.</p>
<p>Se andassi a guardare col task manager come è l'utilizzo dei core, probabilmente vedrei che il il core 1, quello che legge dal primo file, è occupato per un <strong>piccolissimo istante</strong> dove prepara le operazioni di lettura (cioè spiega al sistema operativo che vuole leggere una certa cosa) e poi resta <em>idle</em> per una quantità di tempo, in attesa che il disco faccia il giro, e in un momento diverso il core 2 risulta occupato per un'altra breve frazione di tempo e poi di nuovo <em>idle</em> anche lui.</p>
<p>Ho quindi utilizzato <strong>due thread disgiunti</strong> (essendo questo il modo più semplice offerto dal sistema operativo per eseguire operazioni concorrenti), pur non avendo un reale bisogno di parallelismo. Infatti, l'attività effettiva del processore logico (necessaria per richiedere al sistema operativo l'accesso al file) occupa solo una <em>frazione di tempo piccolissima</em>, dopo la quale lavorano le periferiche. Con un'API diversa, come un'API <strong>asincrona</strong>, potrei invece usare un solo thread per dire al sistema operativo: <em>"Leggi, poi liberami e fammi proseguire"</em>. In questo modo, il thread può continuare l'esecuzione dopo aver dato il comando <em>"leggi dall'hard disk"</em>, permettendo così di gestire più letture in parallelo con un singolo thread.</p>
<p>Via via che il sistema operativo è pronto e ha risultati, dovrebbe poi trovare però un modo di farmeli sapere, motivo per cui nella programmazione asincrona, un modo elementare di gestire la cosa sarebbe, quando dico al sistema operativo “Q<em>uando leggi questo file potrei passati una callback, dicendo che quando l’hai effettivamente letto, mi richiami”</em>. In realtà le cose non sono così banali, perché se usassi una callback ci sarebbe il problema di capire in che thread il sistema operativo mi chiamerebbe.</p>
<p>Quindi questo lascia poi spazio al fatto che si possa affrontare il problema della <strong>concorrenza</strong>, cioè del portare avanti attività di lungo periodo in parallelo, anche con un solo thread, a condizione di avere una <em>interfaccia non bloccante</em>. Ed è il motivo per cui c'è tutto un capitolo della programmazione che è la <strong>programmazione asincrona</strong>, dove i diversi linguaggi di programmazione mettono a disposizione vari tipi di concetti per fare delle cose. Fino adesso però noi questo capitolo non lo abbiamo ancora aperto, sappiamo che potenzialmente c'è.</p>
<p>Per molti anni, diciamo <em>dal 1990 grosso modo, fino al 2012 circa</em>, quindi per più di vent'anni, l'unica alternativa che veniva offerta ai programmatori che avevano bisogno di svolgere attività anche lente, anche sostanzialmente poco CPU intensive, ma che si sovrapponessero temporalmente, era <strong>creare più thread</strong>.</p>
<p><strong>Se io creo più thread, cosa succederà?</strong> Il thread 1 chiama la <code>write</code> o la <code>read</code> (che è bloccante), sta fermo tutto il tempo necessario per leggere, il thread 2 che si svolge, che potenzialmente potrebbe andare in parallelo, chiama anche lui la stessa funzione, e poi sta fermo per un mucchio di tempo. Il sistema operativo si rende conto che in realtà nessuno dei due di questi thread, a parte un piccolo <em>spike</em> di computazione, non c'è niente da fare (perchè aspettano che poi siano le periferiche a restituire la lettura richiesta, come dicevamo nell’esempio), quindi gli toglie la CPU, tanto bisogna aspettare. Quando questi thread possono riprendere, riprendono, e troveranno nel valore di ritorno il dato che hanno letto.</p>
<p><strong>Questo ha dei vantaggi</strong> perché il programmatore pensa in modo sequenziale. In fondo leggere da un file è un'operazione che sappiamo da tantissimi anni come si fa. Il fatto che i thread si blocchino non ci dà un particolare fastidio, anzi quasi ci va comodo, <em>perché?</em> Perché io so che quando torno dalla <code>read</code> ho il mio dato letto e quindi ci posso ragionare sopra. Se ero dentro un ciclo, quel thread lì mi ha bloccato, ma quando riprendo, riprenderò e andrò avanti da quella posizione, quindi non ho perso niente.</p>
<p><strong>Il motivo per cui ci sono voluti venti e più anni</strong> per passare alla programmazione asincrona è che gestire operazioni non bloccanti era tutt'altro che banale. Quando chiamo un'operazione async read, il sistema operativo ritorna subito senza aver ancora letto i dati. A questo punto, se continuo con altre operazioni, devo tenere traccia del punto in cui mi trovo - se ero alla quinta iterazione, devo sapere che anche se procedo con le successive iterazioni, i dati precedenti non sono ancora disponibili. Inoltre, quando arrivano le callback, <em>non è detto che arrivino nell'ordine originale delle richieste</em>. Per esempio, se sto leggendo da un disco con diversi settori, potrei ricevere prima i dati di una richiesta successiva semplicemente perché quei settori si trovano fisicamente prima sotto la testina di lettura.</p>
<p><strong>Questa è una delle principali sfide delle operazioni asincrone</strong>: quando chiediamo al sistema operativo di dividere la lettura in due fasi (<em>prima la richiesta, poi la risposta mentre facciamo altro</em>), diventa complesso gestire lo stato dell'applicazione. Dobbiamo tenere traccia di ogni risposta che riceviamo e capire a quale richiesta corrisponde, rendendo l'intero processo più articolato.</p>
<p><strong>Va detto che al contrario</strong>, quando io programmo con i thread, fin tanto che le attività che i singoli thread fanno sono totalmente disgiunte, è facilissimo: il singolo thread chiama <code>read</code>, prende il risultato, lo usa, poi magari è dentro un ciclo <code>for</code>, chiama di nuovo <code>read</code>, lo riusa, chiama di nuovo <code>read</code>, lo riusa, etc… alla fine ha letto tutto quello che voleva leggere e fa altro. <em>Fin tanto che le attività non si impicciano, lavorare con i thread è facilissimo</em>, perché sono tanti segmenti di computazione <strong>disgiunti</strong>.</p>
<p><strong>Il problema è</strong> che noi spesso e volentieri lavoriamo con i thread perché vogliamo distribuire tra più attori pezzi di una computazione più grande, ovvero <em>non abbiamo solo il bisogno di fare cose diverse, ma facciamo cose diverse che sono parte di un progetto più ampio</em>, che alla fine dovrà funzionare tutto insieme.</p>
<p><strong>Proprio come succede</strong> quando qualcuno prepara un pranzo dove deve permettersi di cucinare il primo, il secondo, il contorno, l'antipasto, il cocktail, il dolce e quant'altro, dove queste attività, sì, potrebbero essere strettamente serializzate, ma sarebbe un <em>disastro</em>, perché se come secondo voleste l'arrosto e lo serializzaste alla cottura del primo, e beh, l'arrosto ha bisogno delle sue due ore per cuocere e cosa succede? Che tra il primo e il secondo devo fare una pausa di due ore perché non ce l'ho ancora pronto.</p>
<p><strong>Quindi</strong> diventa complicato governare una cosa del genere. <em>Necessariamente</em> io voglio in qualche modo <em>portarmi avanti</em> e quindi ho diversi cuochi: uno si occupa del primo, uno si occupa del secondo, uno si occupa del dolce e così via.
Il problema è che tutti si occupano di questa cosa qui nel contesto del pranzo. Per cui poi i piatti via via che vengono cucinati devono essere serviti, e serviti nell'ordine giusto. Quindi vengono a far parte di una <strong>struttura coerente</strong>.</p>
<p><strong>Cosa succede</strong> se uno dei cuochi arrivasse con il suo piatto prima di quando serve? Beh, deve aspettare. Ha bisogno di regolarsi insieme con gli altri e i vari camerieri che poi serviranno a tavola e porteranno i piatti a disposizione devono avere presente a che punto siamo. Quindi c'è un <em>bisogno di passare informazioni</em> tra i diversi attori, in modo che possano coordinarsi per raggiungere il risultato. <strong>Coordinarsi richiede comunicare</strong>.</p>
<p><em><strong>Come avviene la comunicazione tra thread?</strong></em>
La comunicazione tra thread avviene in due modi possibili, concettualmente un po' diversi. Il primo modo è abbastanza semplice da capire, ma si porta dietro un mucchio di implicazioni. Questo primo modo è quello che abbiamo visto precedentemente, e sostanzialmente dice <em>"Visto che i thread lavorano tutti nello stesso spazio di indirizzamento, se prendiamo una variabile possiamo usare quella variabile lì per scriverci dentro delle cose."
Teniamo una versione aggiornata di quello che è la cucina del nostro pranzo.</em> Per cui questa variabile, che sarà una struct, ci mettiamo dentro il primo, il secondo, e dico <em>“il primo sta cuocendo”, “il secondo neanche l'ho acceso ancora”, “il dolce è già pronto”</em>, eccetera. Ci scriverò un po' di cose. Chiaramente i vari thread aggiornano questa struttura condivisa.</p>
<p>Questa qui è una struttura <strong>complicata,</strong> e bisogna garantirsi soltanto che la aggiorniamo uno per volta, perché se cercassimo di aggiornarla insieme potremmo fare dei <em>disastri</em>. Abbiamo visto prima come anche un'operazione stupidissima, un incremento, se fatta insieme, porta a una perdita di informazione.</p>
<p><em><strong>Come ci proteggiamo?</strong></em>
Allora, i linguaggi ci mettono a disposizione <strong>due astrazioni</strong>. La prima si chiama <code>Mutex</code> e nel caso di Rust lo vediamo come un oggetto che <em><strong>incapsula</strong></em> un dato. Il  <code>Mutex</code> è una monade: nasconde il dato a chi vuole usarlo. Il dato è <em>annegato</em> dentro il <code>Mutex</code>. <code>Mutex</code> è una classe generica, <code>Mutex&lt;T&gt;</code>, dove T è il dato che è condiviso.</p>
<p>Io a quel dato non ci arrivo se non in un modo: invocando sull'oggetto <code>Mutex</code> il metodo <code>lock</code>. E il metodo <code>lock</code> ha una caratteristica <strong>importantissima</strong>: se il <code>Mutex</code> è libero io immediatamente torno e ti torno uno smart pointer col quale tu accedi al dato, e lo puoi leggere e scrivere. Se invece nel momento in cui tu invochi <code>lock</code>, questo dato lo sta già usando qualcun altro, <em><strong>aspetti</strong></em> e lock non ritorna fino a che il dato non è libero per te.</p>
<p>Quindi io sono tranquillo che quando <code>lock</code> ritorna ho a disposizione il mio dato e sono <strong>l'unico che lo può leggere e/o scrivere</strong>. Lo cambio, ci metto quello che voglio, faccio le mie operazioni, possibilmente un po' in fretta perché gli altri aspettano, quando ho finito butto via lo smart pointer che mi è stato restituito da <code>lock</code> e buttandolo via automaticamente se c'era qualcun altro in coda questo qualcun altro lo prende.</p>
<p>Questa prima astrazione mi dà garanzia che l'accesso alla struttura condivisa, mentre ce l’ho io non ce l'ha nessun altro.</p>
<p>In molte situazioni un <code>Mutex</code> è sufficiente.</p>
<p><strong>Ci sono però delle attività</strong> che richiedono di iniziare un'operazione solo quando qualcun altro ha completato qualcos'altro. In questi casi, una possibilità è fare <em>polling</em>, cioè continuare a chiedere l'accesso alla struttura dati per controllare: <em>"è già pronto il secondo?"</em> No. Rilascio la struttura, la richiedo subito dopo: <em>"è già pronto il secondo?"</em> No. Rilascio e richiedo ancora. E così via.</p>
<p><strong>Si può fare, ma è assolutamente <em>inefficiente</em></strong>.
Questa cosa qua comporta un uso altissimo della CPU, perché voi continuamente chiedete, consumate cicli macchine, tra l'altro per accedere in <em>modalità kernel</em>, perché poi il mutex ve lo dà il kernel del sistema operativo, quindi passate la barriera, innalzate il privilegio, tornate indietro, etc… per fare <strong>niente</strong>. Assolutamente niente. L'uso altissimo della CPU ha come effetto l'uso altissimo della corrente e quindi la batteria, se siete a batteria, si scarica. Il vostro algoritmo sta procedendo di zero. E' lì che aspetta. Continua a chiedere <em>"è pronto?"</em> No. <em>"È pronto?"</em> No. <em>"È pronto?"</em> No.</p>
<p><strong>Per evitare questa situazione</strong> qui abbiamo introdotto una seconda astrazione. La <code>Condvar</code>.</p>
<p><strong>Cosa fa la <code>Condvar</code>?</strong>
Mi dà un modo <em>efficiente</em> di aspettare. <code>Condvar</code> offre sostanzialmente il metodo <code>wait</code>, che mi fa aspettare, <em>fino a quando?</em> Fino a che qualcuno non chiama <code>notify</code>.</p>
<p><strong>La funzione <code>notify</code> c'è in due versioni</strong>: <code>notify_one</code> e <code>notify_all</code>, per gestire possibili differenze che ci sono.</p>
<p>Sostanzialmente la coppia <code>Mutex</code>-<code>Condvar</code> permette di gestire tutte le situazioni in cui ho bisogno di <strong>coordinare l'attività di più thread</strong> sfruttando uno stato condiviso. C'è una variabile, una <code>struct</code>, dentro cui c'è scritto tutto quello che serve per capire non solo cosa sto facendo io, ma <em>cosa stanno facendo tutti gli altri</em>, me compreso.
In quella struct sono responsabile di aggiornarne un pezzo, in base al mio ruolo, ma posso leggere tutti gli altri, mentre ne ho l'accesso, per poter decidere come comportarmi. E se ho proprio bisogno mi appoggio alla <code>Condvar</code> quando mi occorre aspettare altri.</p>
<p><strong>La <code>CondVar</code> non può essere usata senza il <code>Mutex</code></strong>, semplicemente perché il suo metodo <code>wait</code> richiede come parametro quello smart pointer che il <code>Mutex</code> mi ha restituito. Quindi non basta solo affiancare un <code>Mutex</code> alla <code>Condvar</code>, ma bisogna anche averlo acquisito (cioè devo avere il <code>MutexGuard</code> restituito dal metodo <code>lock</code>, quando il <code>Mutex</code> viene rilasciato da qualcun altro), altrimenti non posso proprio chiamare <code>wait</code> sintatticamente. Quindi <code>Mutex</code> <em>e</em> <code>Condvar</code> <em>vivono a braccetto</em>. La <code>Condvar</code> non può esistere senza un <code>Mutex</code>.</p>
<p><strong>La <code>Condvar</code> vive a fianco al <code>Mutex</code>, non dentro il <code>Mutex</code></strong>.
Se stesse dentro il <code>Mutex</code> non potrebbe funzionare, <em>perché?</em> Perché nel momento in cui io chiamo <code>wait</code>, lei lo deve rilasciare sto mutex affinché altri lo possano prendere per poi riacquisirlo. Ma se fosse dentro il mutex questo giro non lo può fare, perché nel momento in cui lo rilascia non può più poi richiederlo perché sarebbe tagliata fuori.</p>
<p><strong>La <code>Condvar</code> vive accanto al <code>Mutex</code>, non dentro di esso.</strong>
Questo è fondamentale, perché quando un thread chiama <code>.wait()</code> su una <code>Condvar</code>, deve temporaneamente rilasciare il lock del <code>Mutex</code> per consentire ad altri thread di modificarne lo stato.
Se la <code>Condvar</code> fosse contenuta all’interno del <code>Mutex</code>, rilasciare il lock significherebbe perdere l’accesso anche alla <code>Condvar</code> stessa.
Di conseguenza, la <code>Condvar</code> e il <code>Mutex</code> devono essere oggetti separati ma strettamente coordinati.</p>
<blockquote>
<p>💡 <strong>Da ChatGPT</strong></p>
<p><img src="images/concorrenza/image%2051.png" alt="image.png" /></p>
<p>Esempio:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (lock, condvar) = &amp;*shared;           // Arc&lt;(Mutex&lt;VecDeque&lt;T&gt;&gt;, Condvar)&gt;
let mut queue = lock.lock().unwrap();     // Acquisisce il lock

while queue.is_empty() {                  // Check sulla CV
<span class="boring">}</span></code></pre></pre>
</blockquote>
<pre><code>	&gt;/* Rilascia il lock e dorme finché qualcuno notifica. */
	&gt;/* Quando vengo svegliato, ho nuovamente possesso del lock  */
&gt;queue = condvar.wait(queue).unwrap(); 
</code></pre>
<blockquote>
<p>}</p>
<p>// ora queue non è vuota → consuma elemento
let item = queue.pop_front().unwrap();</p>
<pre><code></code></pre>
</blockquote>
<p><strong>Quindi necessariamente</strong> quando abbiamo una struttura condivisa, la struttura condivisa la scriviamo dentro un <code>Mutex</code> e poi a fianco a questo <code>Mutex</code> gli mettiamo una <code>Condvar</code> (usando una tupla, o una <code>struct</code> di qualche tipo). Questo pezzo di dato rappresenta l'informazione di quella parte di sistema che abbiamo bisogno di coordinare.</p>
<p>Se più di un thread devono poterci accedere, o questi thread fanno parte di uno <em>scope comune</em> e allora basta avere una <code>reference</code> e siamo a posto, oppure <strong>se questi thread hanno <em>cicli di vita indipendenti</em></strong> (non fanno parte di uno scope comune), allora <strong>incapsuliamo questa coppia</strong> fatta di <code>Mutex</code> (che racchiude tutti i dati) e <code>Condvar</code> <strong>dentro un <code>Arc</code></strong>, che può essere condiviso tra tutti i thread.</p>
<p><strong>Quindi la struttura più generale</strong>, con lo stato condiviso, presuppone definire una tupla fatta di <code>Mutex</code> e <code>Condvar</code>. Il <code>Mutex</code> ha tutti i suoi dati e questa tupla, se ho bisogno, la condivido mediante <code>Arc</code>. Nell'<code>Arc</code> posso fare quanti cloni voglio, ciascun thread possederà un clone di questo <code>Arc</code>, nel momento in cui tutti i thread saranno morti il contatore dell'<code>Arc</code> scende a zero e di conseguenza <code>Mutex</code> e <code>Condvar</code> saranno rilasciati, liberando tutta la memoria.</p>
<p><strong>Questo è un approccio di basso livello</strong>. <em>Di basso livello perché?</em> Perché dà <em>visibilità a tutti di tutto</em>.
Nel momento in cui un thread ha possesso del <code>Mutex</code>, ha accesso all'intero dato. Normalmente gli algoritmi sono costruiti, con buon senso, dicendo che il thread che ha questo compito <strong>legge quello che gli interessa</strong> ma <strong>scrive solo questo pezzettino</strong>. E eventualmente dopo che l'ha scritto, se è necessario, <em>notifica la</em> <code>Condvar</code> affinché altri possano svegliarsi. Però questa è una regola di buon senso ma <strong>non è garantita dal linguaggio</strong> in nessun modo.</p>
<p>Quindi è possibile che se io mi occupo di cucinare il primo, per sbaglio o per volontà, vada a modificare a che punto è il secondo, anche se non devo. Il <code>Mutex</code> non me lo può impedire perché nel momento in cui mi dà accesso, <em>mi dà accesso completo</em>. Dovrebbe essere il mio buon senso di programmatore che mi impedisce di farlo, ma questo non è sempre presente. Quindi il rischio è che posso (nel momento in cui posseggo il <code>Mutex</code>) <strong>impicciare gli altri</strong> modificando delle cose che non mi riguardano. In più, mentre un thread possiede questa struttura, gli altri non la posseggono di sicuro. E questa è la <em>garanzia del</em> <code>Mutex</code>.</p>
<p>È vero che c'è una possibile <strong>variazione sul tema:</strong> Rust, oltre a offrirci la primitiva <code>Mutex</code>, che ci dà questo comportamento, ci offre anche la primitiva che si chiama <code>RwLock</code>.</p>
<p><code>RwLock</code> è simile a un <code>Mutex</code> ma ha <em>due metodi diversi per lockare</em>:</p>
<ul>
<li>Uno in cui chiedo l'<strong>accesso in lettura</strong></li>
<li>Uno in cui chiedo l'<strong>accesso in scrittura</strong></li>
</ul>
<p>Il metodo col quale leggo l'accesso in lettura mi restituisce uno smart pointer che mi fa <em>solo leggere</em>, quindi non posso modificare la struttura dati. In compenso però se lo chiediamo in più di uno in contemporanea, lo possiamo ottenere. Quindi possono avvenire <strong>molte letture in parallelo</strong>.</p>
<p>Ma nel momento in cui qualcuno ha bisogno di scrivere, deve chiedere il <strong>lock in scrittura</strong>.
Il lock in scrittura è dato a <em>uno solo</em> e con il vincolo che viene dato <strong>solo quando non c'è nessuno che legge</strong>. E quindi alla fine non è cambiato molto.</p>
<p>Per questo motivo Rust mette a disposizione anche un altro approccio.
Consideriamo che <strong>ogni comunicazione implica una sincronizzazione</strong>. Pensiamo a come comunicano due thread con lo stato condiviso: uno acquisisce il <code>Mutex</code>, scrive i dati che vuole trasmettere all'altro, eventualmente notifica la <code>Condvar</code>, e rilascia il <code>Mutex</code>. L'altro thread si sveglia, acquisisce il <code>Mutex</code> appena possibile, legge e comprende. Quindi per permettere la comunicazione abbiamo necessariamente dovuto usare strutture di sincronizzazione come <code>Mutex</code> e <code>Condvar</code>.</p>
<p>Il secondo approccio capovolge questa prospettiva: <strong>ogni comunicazione è anche una sincronizzazione</strong>. In altre parole, <em>tu non puoi ascoltare finché io non parlo, e se mi ascolti, significa che ho già parlato.</em> Per questo Rust ci offre il concetto di <em><strong>canale</strong></em>.
Un canale è semplicemente una struttura dati condivisa tra mittenti e destinatari che permette lo scambio di messaggi.</p>
<p><em>Cos'è un messaggio?</em>
Un canale è una struttura generica, <code>channel&lt;T&gt;</code>, dove <code>T</code> è un qualunque tipo di dato che gode del tratto <code>Send</code>, cioè deve essere <strong>trasmissibile da un thread a un altro</strong> — <em>io non ti posso passare nulla che non sia</em> <code>Send</code>, e ci sta, perché viene generato da qualcuno che lo deposita nel canale e poi qualcun altro dal canale lo recupera.</p>
<p>Il canale è <strong>strettamente sequenziale</strong>. Se io nel canale inietto tre valori, ad esempio dei numeri, <code>1, 2, 3</code>, chi legge li leggerà <em>strettamente nell'ordine</em> con cui sono stati scritti: <code>1, 2, 3</code>.</p>
<p>Non è detto che se io scrivo <code>1</code> ci sia subito qualcuno che lo legge, perché il canale <strong>disaccoppia il tempo</strong> del mittente dal destinatario — <em>io l'ho scritto, e sta lì fino a che qualcuno non lo legge</em>. Se c'è qualcuno pronto lo legge subito, se c'è qualcuno che dorme lo leggerà tra un po'. Quando lo legge viene tirato via dal canale, quindi il messaggio permane nel canale per il tempo necessario a permettere a chi lo legge di andarselo a prendere e vedere. Se nel frattempo chi scrive aggiunge altre cose, le aggiunge, staranno dietro in coda.</p>
<p><em>Quante ce ne possono stare in un canale?</em>
Un canale semplice ne può tenere tante quanto la RAM del computer ne consente. Vengono detti <code>unbounded</code>, che non vuol dire infiniti, perché la mia memoria è finita, quindi dopo un po' se non c'è più spazio non li potrò scrivere, ma comunque tanti. I canali normalmente sono pensati perché <strong>un thread scriva</strong> e <strong>l'altro legga</strong>.</p>
<p><strong>Quando creo un oggetto di tipo canale</strong>, in realtà non viene creato un oggetto singolo: ne vengono creati due. La funzione <code>channel</code> restituisce una tupla, con un <code>Sender</code> e un <code>Receiver</code>. Il <code>Sender</code> è un oggetto che permette <strong>solo di mandare</strong>, il <code>Receiver</code> è un oggetto che permette <strong>solo di ricevere</strong>. Quindi <code>Sender</code> mi offre solo <code>send</code> e <code>Receiver</code> mi offre solo <code>recv</code>, che è il metodo per ricevere.</p>
<p>Quindi tendenzialmente quando uso i canali, <strong>creo prima di tutto il canale</strong>. Magari ne creo uno, magari ne creo due, magari ne creo venticinque, perché userò il canale <em>non come uno spazio globale dove tutti vedono</em>, ma come un <strong>collegamento</strong>, un filo che unisce specificatamente il thread 1 col thread 2 affinché si possano dire delle cose. Mentre loro si parlano e si sincronizzano e usano il canale come strumento di sincronizzazione, altri thread possono fare su altri canali altre cose, senza impicciarsi. Quindi il canale da questo punto di vista permette di parlarsi sincronizzandosi <em>senza impicciare potenzialmente altri</em>.</p>
<p>Il metodo <code>send</code> ritorna sempre un <code>Error</code>. <em>Perché ritorna un error?</em> Perché è possibile che il thread responsabile di leggere se ne sia già andato. E quindi se io so che il destinatario non c'è più, è inutile che scriva, perché non lo potrà leggere più nessuno. In realtà questo è reso possibile dal fatto che il metodo <code>channel</code> ci ritorna questa coppia di cose che a noi appaiono distinte ma dentro di sé sono <strong>intrinsecamente legate</strong>. E quando il receiver viene buttato via, cioè avviene il <code>drop</code> del receiver, il sender lo sa. E a questo punto, nel momento in cui il receiver non esiste più, quindi non ci sarà più nessuno che potrà leggere da quel canale, tentativi di scrittura sul sender <em>falliranno</em>.</p>
<p><strong>Anche <code>recv</code></strong> retorna un result ed è duale — <code>recv</code>, se la invoco e c'è qualcosa già nel canale me lo prende e me lo restituisce subito, mi prende il messaggio più vecchio presente nel canale, quindi il <em>primo della lista</em> e me lo dà. Se non c'è niente nel canale mi fa aspettare e rimango lì <strong>bloccato in <code>recv</code></strong> fino a che qualcuno non ci mette niente, oppure fino a che il sender non se ne va. Perché se venisse distrutto il sender il <code>recv</code> che è lì dice "<em>ah caspita, non potrò mai più leggere nulla perché l'unico modo per farmelo avere era quel sender, ma quel sender non c'è più, quindi anch'io non me ne vado</em>". Quindi l'uscita da <code>recv</code> è un <code>Error</code> che mi dice "<strong>ok</strong>" nel momento in cui io ho ricevuto correttamente un dato e mi dice un error dicendo "<em>guarda, il canale è stato chiuso, è stato chiuso a monte, quindi è inutile che tu stia qui a aspettare perché non prenderai mai più niente</em>". Oppure mi blocca, fin tanto che il canale e le due estremità esistono un tentativo di lettura su un canale vuoto mi fa aspettare. Proprio come se leggessi da tastiera, chiamo <code>scanf</code> per leggere da tastiera, <code>scanf</code> e se io non batto nessun tasto sta fermo lì.</p>
<h1 id="5-canali-in-rust"><a class="header" href="#5-canali-in-rust">5. Canali in Rust</a></h1>
<p>C'è un pezzettino in più che rende i canali standard di Rust abbastanza versatili. L'oggetto <code>Sender</code> è <strong>clonabile</strong>.</p>
<p><em>Cosa vuol dire che l'oggetto sender è clonabile?</em>
Vuol dire che questo canale si comporta in realtà con una politica che si chiama <strong>MPSC</strong>, <em>Multiple Producer Single Consumer</em>. Perché io creo il canale con la funzione <code>channel</code>, questo mi ritorna sempre e solo una tupla (un <code>Sender</code>, un <code>Receiver</code>), però il <code>Sender</code> può essere clonato.</p>
<p><em>Cosa capita quando io clono il sender?</em>
Beh che avrò più pezzi che possono iniettare sul canale. Questi pezzi possono essere affidati a thread distinti. Tutti quanti possono scrivere, come un <em>imbuto che finisce in un'unica coda</em>.</p>
<p>Se due thread provano contemporaneamente a scriverci qualcosa, <strong>uno dei due vincerà</strong>. Il sistema operativo sceglierà uno dei due e dice "<em>tu entri per primo, tu entri per secondo</em>". Proprio come se mettiamo delle palline in un imbuto che ha la gola stretta da farne passare una sola per volta, queste palline stanno un po' lì, rimbalzano una contro l'altra, poi alla fine una delle due si infila e l'altra aspetta. Quale delle due non lo sappiamo. Ma non ha nessuna importanza. Sono arrivate insieme, quindi vanno via insieme. Se arrivassero invece a tempi distinti, ognuna si infila giustamente nel momento in cui serve.</p>
<p>Dal punto di vista del comportamento del mittente, cioè la funzione <code>send</code> dei tanti sender che posso aver creato, mi restituirà un errore nel momento in cui l'unico receiver (che <em>non è clonabile</em>) muore. Perché giustamente più nessuno potrà scrivere niente quando non c'è più ricevitore. Al contrario, il ricevitore mi restituirà un error quando il conteggio dei sender sarà sceso a zero. Quindi, se io ho creato <strong>tre cloni del sender</strong> e ho un receiver che ascolta:</p>
<ul>
<li>il receiver aspetta, aspetta, aspetta</li>
<li>un clone muore, il receiver continua a aspettare</li>
<li>un altro clone muore, il receiver continua a aspettare</li>
<li>l'ultimo clone muore, a quel punto il receiver esce con errore dicendo "non ce n'è più"</li>
</ul>
<p>Se il singolo sender manda <code>1, 2, 3</code>, il receiver vedrà <code>1, 2, 3</code>. Se mentre quel sender manda <code>1, 2, 3</code>, un altro manda in contemporanea <code>A, B, C</code>, il receiver troverà un misto di <code>1, 2, 3</code> e <code>A, B, C</code>. <strong>Sicuramente</strong> il receiver non leggerà <code>2</code> prima di aver letto <code>1</code>, ma <code>A</code> potrebbe riceverlo prima di <code>1</code>, dopo <code>1</code> o dopo <code>2</code>. Perché insieme questi due stanno mandando delle cose. Le sequenze che si originano da un singolo sono <em>garantite</em>. Le sequenze che ricevo da diversi possono <em>mischiarsi in qualunque ordine</em>.</p>
<p>Il sender dà sempre la priorità al dato già disponibile. Quando quel dato è esaurito deve aspettare. E aspetta fino a che gli risultano esserci sender in vita. Nel momento in cui si accorgesse che non c'è più nessun sender in vita, esce con errore.</p>
<p>L'uso dei canali di base è banale. Nel senso che la meccanica è questa qua. Ma notate che anche la meccanica dei <code>Mutex</code> è banale. Anche la meccanica delle <code>Condvar</code> è abbastanza banale. Esattamente come con la combinazione <code>Mutex</code>/<code>Condvar</code> è difficile capire cosa succede quando li mettiamo insieme e capire bene come organizzare il nostro codice, perché succeda quello che vogliamo noi e non quello che vogliono loro, lo stesso succede con i canali. Anzi, per certi aspetti, con i canali potrebbe essere più strano. <strong>Perché?</strong> Perché ci presuppone una modalità di programmare <em>basata a eventi</em>. Quindi bisogna giocarci un po’ con i canali, per farseli andar bene e capire che cosa succede.</p>
<p><img src="images/concorrenza/image%2052.png" alt="image.png" /></p>
<p>Vediamo di fare degli esempi e di comprenderci meglio.</p>
<p>Il meccanismo che viene adottato è quello della <em>cessione della proprietà</em>. Nel momento in cui il metodo <code>send</code> di <em>sender</em> viene invocato, il metodo <code>send</code> <strong>prende possesso del dato</strong> <code>T</code>, che io voglio scrivere sul canale, <strong>e lo cede al canale stesso</strong>. Quindi chi ha inviato un dato <strong>non ce l'ha più</strong>. Se il dato era copiabile, va bene, gli sarà rimasto. Ma di base il meccanismo è basato sul <strong>movimento</strong> — la proprietà passa dal sender al canale e resta del canale fino a che non avviene un <code>recv</code>, a quel punto <strong>la proprietà è diventata del ricevitore</strong>, il quale poi ne fa cosa vuole.</p>
<p><strong>Questo ci garantisce</strong>, sostanzialmente, che noi possiamo comunicare qualcosa. Siccome c'è un passaggio di proprietà, inizialmente il dato è posseduto nel contesto di un thread, poi a un momento in cui è solo dentro il canale e <em>non appartiene di per sé a nessun thread</em>, perché il canale è condiviso nel suo possesso, e poi diventa di proprietà del thread che riceve.</p>
<p>Questo fondamentalmente implica che otteniamo contemporaneamente una <strong>comunicazione</strong> <em>(ti passo questo dato e quindi dentro questo dato ci posso scrivere quello che ti voglio far sapere)</em> ma anche una <strong>sincronizzazione</strong> <em>(io non posso leggere fino a che qualcuno non ha scritto)</em>.
<strong>E quindi mi restituisce quell'ordine relativo di avanzamento che due thread normalmente non hanno.</strong></p>
<p>In uno dei primissimi esempi che abbiamo mostrato, introducendo l'uso dei thread, abbiamo detto che se io ho due thread che contano da 1 a 10 e stampano, posso dire per certo che i numeri da 1 a 10 del thread 1 escono in ordine, posso dire per certo che i numeri da 1 a 10 del secondo thread escono in ordine, ma <em>non so dire niente di cosa capita tra l'uno e l'altro</em>, cioè se i primi 10 escono prima dei secondi 10 o viceversa, se escono mescolati e così via. <strong>Perché?</strong> Perché l'avanzamento dei thread è indipendente, il sistema operativo li schedula tutte le volte che ha una CPU libera, cercando di farli andare avanti.</p>
<p>Attraverso l'uso dei canali io posso garantire che il thread che riceve faccia delle azioni <strong>necessariamente successive</strong> ad altre azioni che sono capitate nel thread che manda. Perché il canale mi dà questa garanzia. Il tipo di errore che viene restituito se il canale è chiuso dall'altra estremità è leggermente diverso:</p>
<ul>
<li><code>SendError</code> se cerco di scrivere su un canale di cui non c'è più un ricevitore</li>
<li><code>RecvError</code> se cerco di leggere da un canale in cui non c'è più nessun sender</li>
</ul>
<p>Vediamo un esempio pratico.</p>
<h2 id="51-esempio"><a class="header" href="#51-esempio">5.1 Esempio</a></h2>
<p><img src="images/concorrenza/image%2053.png" alt="image.png" /></p>
<p>In questo esempio vogliamo creare un canale e usarlo per far parlare thread diversi.</p>
<p><strong>Come creo un canale?</strong>
Il canale si crea con <code>let (tx, rx) = channel();</code>.
La funzione <code>channel</code> che appartiene al namespace <code>std::sync::mpsc</code> (<em>multiple producer single consumer</em>) restituisce una tupla. La tupla ha nel campo 0 il sender, e nel campo 1 il receiver.
Possiamo chiamarli, ad esempio, <code>tx, rx</code> — <code>tx</code> trasmette, <code>rx</code> riceve.</p>
<p><img src="images/concorrenza/image%2054.png" alt="image.png" /></p>
<p>In questo momento sono <code>Sender&lt;?&gt;</code>, perché al momento il sistema dei tipi non ha avuto abbastanza informazioni per immaginarsi cosa scambierò lì dentro. Volendo posso spiegarglielo in anticipo, posso dirgli <code>channel::&lt;i32&gt;</code> per esempio:</p>
<p><img src="images/concorrenza/image%2055.png" alt="image.png" /></p>
<p>Posso mandare qualsiasi cosa, <strong>a condizione che sia <code>Send</code></strong>, cioè goda del tratto <code>Send</code>.
Se non gode del tratto <code>Send</code> non lo posso mandare.</p>
<p><em>Chi è che non gode del tratto Send?</em>
Non gode del tratto <code>Send</code> gli <code>Rc</code> semplici, i <code>RefCell</code> e in generale tutti questi tipi un po' strani che <em>violano le regole base del movimento</em>.</p>
<p><strong>A questo punto ho creato il canale</strong>.
Creare un canale non serve a niente se non avete qualcuno che legge e qualcuno che scrive. Allora facciamoci al momento una cosa semplice: uno che legge e uno che scrive.</p>
<p><img src="images/concorrenza/image%2056.png" alt="image.png" /></p>
<p>Con <code>let t1 = thread::spawn</code> creiamo un thread, e qua dobbiamo passargli una lambda. Gli passo una lambda con la clausola <code>move</code>, <em>perché?</em> Perché in questo caso io voglio che questo thread si prenda la responsabilità di possedere quello che usa.</p>
<p>E in questo caso gli passiamo il canale <code>tx</code>, lo facciamo ciclare con un <code>for</code>, e ad ogni iterazione facciamo <code>tx.send</code>, per mandare qualcosa sul canale.
Qui possiamo scegliere se fare <code>tx.send(…)**.unwrap()**</code>, se siamo sicuri che il canale sarà sempre aperto, oppure gestire eventuali errori restituiti facendo come mostrato sopra.
Facendo così garantiamo che se per qualche motivo il ricevitore dovesse morire, ci fermiamo prima e <em>non proviamo neanche a mandare un altro dato, perché il ricevitore non ha potuto ricevere quello che abbiamo appena provato a mandare</em>.</p>
<blockquote>
<p>💡 <strong>Differenza <code>format!</code> e <code>println!</code></strong></p>
<p><img src="images/concorrenza/image%2057.png" alt="image.png" /></p>
</blockquote>
<p><img src="images/concorrenza/image%2058.png" alt="image.png" /></p>
<p>Poi creiamo anche un thread che riceve: <code>let t2 = thread::spawn(move || ...)</code>, <em>e cosa fa questo qua?</em>
Finché riesco a ricevere cose (<code>while let Ok(v) = rx.recv()</code> ), ogni volta la cosa che ricevo la chiamo <code>v</code>, che è una stringa, stampo.
Quando non riesco più a riceverle in questo modo faccio <code>println!("receiver done")</code>.</p>
<p><em>Ho creato due thread, ma basta fare questo?</em> <strong>No.</strong>
Quando il thread principale finisce i thread secondari muoiono, perché la fine del thread principale mi fa tornare alla funzione <code>CRT startup</code>, che contiene una chiamata alla <em>system call</em> <code>exit</code>, e quindi il processo muore. Quindi, <strong>a differenza di quello che succede in Java</strong>, dove se voi create un thread, quel thread viene automaticamente aspettato, a meno che non avete impostato che è un thread di background, qua dobbiamo noi aspettare il thread, altrimenti non ce la facciamo, e quindi qui dobbiamo fare <code>t1.join.unwrap</code>, e <code>t2.join.unwrap</code>. In questo modo li aspettiamo e siamo certi che sono finiti entrambi, e solo a quel punto il main se ne può andare tranquillamente.</p>
<p>Eseguiamo e vediamo l’output.</p>
<p><img src="images/concorrenza/image%2059.png" alt="image.png" /></p>
<p>Qui vediamo che il <strong>mittente parte allegramente</strong>, e parte per primo giustamente, perché l'abbiamo creato per primo, quindi ci sta. E lui riesce a scrivere <em>“Sending 0, 1, 2”</em>, senza problema, anche se l'altro non lo sta ricevendo. <em>Perché?</em> Perché il canale è <strong>unbounded</strong>, e quindi in pancia gli possono stare più cose contemporaneamente. Se io gli ne mando 3, se li prende tutti e 3 — se gliene mandassi 300, se li prenderebbe tutti e 300.</p>
<p>In realtà ne prende per un bel po', fino a che non scatterà il <em>quantum normale dei thread</em> — per 10 millisecondi lui produce, finiti i 10 millisecondi probabilmente il sistema operativo fa fare anche cose agli altri tanti programmi che girano all'interno del pc, ma va bene.
A un certo punto lo farà riprendere. Può darsi che quando riprendesse, se gliene facessimo generare veramente tanti, può darsi che quando riprendesse quell'altro thread, il receiver, sia già partito.</p>
<p>Qui stiamo generando talmente poche cose che vediamo che il <strong>sender che finisce ancora prima che qualcos’altro venga schedulato al suo posto, e quindi anche prima del receiver</strong>. Il receiver non è ancora neanche partito, non ha importanza. Quando finalmente riesce a partire si tira fuori il message 0, poi il message 1, poi il message 2. Tranquillamente. Quindi i messaggi ci arrivano nell'ordine con cui li abbiamo mandati.</p>
<p><em><strong>Cosa succede se noi di sender ne facessimo più di uno?</strong></em>
Dobbiamo modificare leggermente il codice del nostro programma, perché così non va bene.</p>
<p><img src="images/concorrenza/image%2060.png" alt="image.png" /></p>
<p>Allora, qua prepariamo un <code>Vec</code> e preparo un <code>for t in 1..4</code> — per 4 volte creo un nuovo thread, e ciascuna <code>JoinHandle</code> la salvo nel <code>Vec</code>, in modo tale che poi me la posso ricordare. Ciascun thread fa ciò che facevamo prima: ciclare 3 volte e mandare qualcosa sul canale.</p>
<p>Modifichiamo poi le stampe così da poter differenziarle, quando provengono da thread diversi.</p>
<p><strong>Attenzione:</strong> non posso in realtà farlo esattamente così. Perché? Perché avendo scritto <code>move</code>, il primo thread si prende possesso di <code>tx</code>, e poi il secondo thread <code>tx</code> non ce l’avrebbe più.</p>
<p><img src="images/concorrenza/image%2061.png" alt="image.png" /></p>
<p>Quindi prima di poter fare questo devo duplicarmi <code>tx</code>: <code>let tx = tx.clone()</code>.
Qui sfrutto il fatto che Rust mi permette di ribattezzare una variabile con un nome già esistente e quindi qui dentro — in questo blocco di graffe del primo <code>for</code> — creo un <code>tx</code> <em>(che sta sempre nello stack)</em> che è <strong>clone</strong> di quell'altro.</p>
<p><em>Al termine di questo</em> <code>for</code><em>, quanti</em> <code>Sender</code> <em>avrò?</em>
Io ho creato il primo alla riga numero 5: <code>let tx, rx = ...</code>.
Poi per ciascuno dei thread abbiamo fatto una copia e quindi abbiamo l'originale e poi <em>n copie</em> (in questo caso 3) e quindi ne ho <em>n più 1</em> — in questo caso abbiamo in totale 4 <code>Sender</code>.
Quindi intravediamo un problema: abbiamo detto che il receiver termina quando vede che non ci sono più sender, ma in questo caso noi abbiamo 4 oggetti <code>Sender</code>, e 3 thread soltanto che effettivamente mandano qualcosa.
In altre parole, quando questi 3 thread finiranno, il receiver non terminerà anch’esso, <strong>perchè c’è ancora il <code>tx</code> originale in giro.</strong></p>
<p><em>Quando quei thread lì finiranno e saranno tutti morti, quante copie di <code>tx</code> mi resteranno?</em> <strong>Una, l'originale</strong>.</p>
<p><em>Il thread t2 potrà finire?</em> No, perché c'è ancora l'originale.</p>
<p><strong>Dunque, dopo aver fatto le copie, l'originale lo devo distruggere.</strong>
Perché per Rust altrimenti esiste. E siccome esiste, lui che ne sa che qualcuno non possa usarlo per mandare cose. Quindi quando i miei 3 thread avranno finito di mandare le loro cose, butteranno via la loro copia e il conteggio scenderà da 4 a 3, poi a 2 e poi a 1. <strong>Ma ce ne sarà ancora uno.</strong></p>
<p>Quindi il thread receiver dopo aver stampato 9 cose <em>(3 per ciascun thread)</em>, starà lì tranquillo ad aspettare. <strong>Se io non butto via l'originale prima di mettermi ad aspettare il thread, di qua non ne veniamo fuori.</strong></p>
<p><img src="images/concorrenza/image%2062.png" alt="image.png" /></p>
<p>Quindi dopo aver creato i 3 thread e aver passato a ciascuno di loro la propria copia di <code>tx</code>, dobbiamo aggiungermi un <code>drop(tx)</code>.
Chiaramente lo devo fare fuori dal <code>for</code>, perché se lo stessi facendo dentro il <code>for</code>, non potrei duplicarlo. Una volta che sono fuori, posso permettermi di buttarlo via.</p>
<p>A questo punto, invece di create il thread receiver come prima con <code>let t2 = ...</code>, scrivo <code>handles.push</code> e lo metto qui — mi salvo sempre nel <code>Vec</code> anche l’handle del thread receiver.</p>
<p>A questo punto, per aspettarli tutti, facciamo semplicemente <code>for h in handles { h.join().unwrap() }</code>. Questa è l'attesa finale — aspetto che finiscano tutti quanti i sender e i receiver.</p>
<p>Nota: <em>non ho certezza dell'ordine</em> con cui le stampe arrivano — se arrivano insieme, possono apparire in qualunque ordine. Se non arrivano insieme, sicuramente appaiono strettamente nell'ordine con cui sono arrivati. L'unico momento di incertezza nasce dall'eventuale contemporaneità, che è possibile proprio per il fatto che ho molti core, su cui possono effettivamente girare contemporaneamente thread diversi. Se avessi un solo core a disposizione, questo non succederebbe.</p>
<p>Proviamo ad eseguire questa cosa.</p>
<p><img src="images/concorrenza/image%2063.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2064.png" alt="image.png" /></p>
<p>Tutto come ci aspettiamo che funzioni.</p>
<p><img src="images/concorrenza/image%2065.png" alt="image.png" /></p>
<p><strong>Attenzione:</strong> se io andassi a rimuovere quella <code>drop(tx)</code> che abbiamo introdotto prima, il programma compila ancora, <strong>ma si pianta.</strong></p>
<p>Il receiver si prende tutti i dati che sono stati mandati dai sender, che alla fine sono terminati, ma siccome c’è ancora il <code>tx</code> originale in vita, il receiver rimane in attesa, e il risultato è che il programma si pianta perchè il main non finisce, perchè sta aspettando che il receiver termini, ma questo non può accadere.</p>
<p>Quel sender non lo sta usando nessuno, ma lui non lo può sapere.</p>
<p>Quindi il programma resta qua per l'eternità e di qua non si muove. Sono tutti in attesa:</p>
<ul>
<li>Il thread ricevitore aspetta che qualcuno gli mandi delle cose</li>
<li>Il thread principale aspetta che il ricevitore finisca</li>
<li>Il sender che rimane ancora vivo nelle mani del thread principale (che neanche sa di avercelo — non se ne fa nulla, non lo sta usando)</li>
</ul>
<p>E quindi il programma è bloccato qua - è un <strong>deadlock</strong>. È una delle tante forme di deadlock che si possono verificare.</p>
<p><strong>Attenzione:</strong> Rust non vi protegge dai deadlock. Non può proteggervi dai deadlock, perché per farlo dovrebbe capire <em>completamente</em> cosa fa semanticamente il vostro programma. Quindi da quella cosa lì dovete proteggervi voi, ragionando. Non è particolarmente difficile in questo caso: bisogna droppare <code>tx</code>.</p>
<p>Il vantaggio dei <em><strong>deadlock</strong></em> è che sono <strong>ripetibili</strong> e quindi li potete debuggare, a differenza delle <em><strong>interferenze</strong></em> che sono irripetibili.</p>
<p>Notate che nella maggior parte dei casi i deadlock sono ripetibili (in questo esempio qui è assolutamente ripetibile), ma possono esserci situazioni in cui <em>ogni tanto</em> va in deadlock.</p>
<p>In quei casi lì bisogna difendersi un po' meglio. L'<em>"ogni tanto va in deadlock"</em> nasce quando cerco di prendere due lock in sequenza — <em>chiedo il primo, chiedo il secondo.</em>
Se c'è qualcun altro che chiede gli stessi due lock in ordine inverso, ecco a quel punto lì ci bloccheremmo: <em>io aspetto che tu rilasci il secondo lock (mentre posseggo il primo), e tu aspetti che io rilasci il primo lock (mentre possiedi il primo), quindi non ne uscieremo mai.</em></p>
<p>In ogni caso, siccome il programma è bloccato, posso connettergli un debugger e andare a vedere dove è bloccato. Potendogli connettere un debugger e andare a vedere dove, mi faccio un'idea del perché si blocca.</p>
<p>Almeno lui è fermo lì, e quindi riesco a vedere in che riga sta aspettando e di lì mi faccio un po' di ragionamenti per vedere come toglierla. Invece le interferenze avvengono al tempo t, ma le loro conseguenze si vedono al tempo t più delta.</p>
<h2 id="52-canali-sincroni"><a class="header" href="#52-canali-sincroni">5.2 Canali sincroni</a></h2>
<p><img src="images/concorrenza/image%2066.png" alt="image.png" /></p>
<p>I canali fatti così sono <em>unbounded</em>. Cioè se invece di mandare tre messaggi ne mandiamo tre milioni, è possibile che il sender scriva tre milioni sul canale prima che il receiver inizi a leggere anche solo il primo. Non ci sono vincoli.</p>
<p>In certe situazioni non è quello che vogliamo, perché potrebbe crearsi una situazione in cui occupiamo una montagna di memoria senza neanche sapere bene per quale motivo. Perché sostanzialmente noi ci aspetteremmo che il receiver parta pressoché subito.</p>
<p>Allora possiamo generare della cosiddetta <em><strong>back pressure</strong></em>, ovvero possiamo fare in modo che se il receiver per qualche motivo è lento, allora chi manda abbia buffer per un po' (perché è giusto per compensare gli sbalzi), ma poi dopo un po' si ferma, perché dice <em>"Ma se tu non le ricevi che senso ha che continuo a mandarteli?".</em></p>
<p>Questo lo facciamo semplicemente usando la funzione <code>sync_channel</code>, invece di usare la funzione <code>channel</code>. Per il resto è tutto identico.</p>
<p><code>sync_channel</code> ha un unico parametro che è un numero: ci dice quanti messaggi possono stare nel buffer al massimo. Se il sender manda più cose dello spazio disponibile si blocca, e aspetta che il canale si svuoti.</p>
<p>Quindi il criterio del <code>sync_channel</code> è semplicemente: <em>nel momento in cui non c'è più spazio, aspetti.</em></p>
<p>Facciamo una prova rapida, tornando all’esempio di prima.</p>
<p><img src="images/concorrenza/image%2067.png" alt="image.png" /></p>
<p>Cambiamo la riga in cui costruiamo il canale, e da <code>channel</code> lo facciamo diventare <code>sync_channel</code>. Gli dobbiamo dire quanti messaggi possono stare nel canale, al massimo. Diciamo uno: al massimo c'è una stringa lì dentro.</p>
<p>Questo ci farà vedere che se adesso lanciamo, necessariamente uno scrive e l'altro legge. In realtà ne vedremo due probabilmente di fila perché noi la <code>println!</code> la facciamo prima di provare a fare <code>tx.send</code>. Quindi può anche darsi che vediamo tre tentativi di scrivere: “Thread 1 sending 0”, “Thread 1 sending 1”, “Thread 1 sending 2”, ma in realtà non sta mandando un bel niente perché poi chiama la <code>send</code>, e lì aspetta perchè il buffer è pieno.
Il fatto che si vedano le stampe di seguito anche se concettualmente non è possibile, è dovuto al fatto che la <code>println!</code> è asincrona rispetto alla console.
E inoltre la stampa <em>“Got Message”</em> del receiver può spuntare <em>dopo</em> una stampa <em>“Thread 1 Sending”</em> successiva.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	let (tx, rx) = sync_channel::&lt;String&gt;(1);
	let mut handles = vec![];
	
	for t in 1..4 {
		let tx = tx.clone();
		
		handles.push(thread::spawn(move || {
			for i in 0..3 {
				println!("Thread {t} sending {}", i);
				if tx.send(format!("Message {}.{}", t, i)).is_err() {
					println!("Aborting...");
					return;
				}
			}
			println!("Thread {t} is done!");
		}));
	}
	
	drop(tx);
	handles.push(thread::spawn(move || { 
		while let Ok(v) = rx.recv() {
			println!("Got {}", v);
		}
		println!("Receiver done!");
	}));
	
	for h in handles {
		j.join().unwrap();
	}
}</code></pre></pre>
<p><img src="images/concorrenza/image%2068.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2069.png" alt="image.png" /></p>
<p>Ok, allora:</p>
<ul>
<li>Thread 1 manda 0</li>
<li>Thread 1 manda 1</li>
<li>Thread 2 manda 0</li>
<li>Thread 3 manda 0</li>
</ul>
<p>Questo ci fa capire che thread 1 ha mandato 0, che è finito nel buffer, e quindi subito dopo ha provato a mandare 1 e si è bloccato. Nel frattempo è partito il thread 2 che ha cercato di inserirci 0 e si è bloccato perché il buffer è ancora occupato. Poi è partito thread 3 che ha cercato di mettere 0 e anche lui si è bloccato.</p>
<p>Nel frattempo si è svegliato il receiver che finalmente si è mangiato il primo messaggio. <strong>Non fa neanche a tempo a scriverlo che se l'è mangiato</strong> (tramite la stampa <code>Got Message 1.0</code>) che l'effetto di esserselo mangiato è che il thread 1, che era lì in coda, è riuscito a infilare 1 nel canale, per procedere poi subito a fare una nuova stampa.</p>
<p>E quindi vediamo qui "Thread 1 Sending 2", che è la conseguenza del fatto che il receiver si è mangiato il messaggio originale, e ce lo stampa alla riga subito dopo <code>Got Message 1.0</code>. E subito dopo ci dice anche <code>Got Message 1.1</code>. E quindi i primi due sono stati consumati.</p>
<p><em>Nel frattempo cosa è capitato?</em>
Che c'erano in coda a spingere sia il <strong>thread 2</strong> che il <strong>thread 3</strong>, che erano già pronti lì con il loro dato, ma non potevano entrare. E gli va bene perché uno dei due, in questo caso <strong>thread 3</strong>, riesce a passare davanti e lo deposita.
Lo deposita e a questo punto prova a depositare il successivo.
Gli va ancora bene perché il receiver è attivo e quindi come lo deposita il receiver lo mangia subito, e quindi thread 3 riesce anche a depositare il secondo. E quindi vediamo <code>Got Message 3.0</code> e <code>3.1</code>.</p>
<p>Nel frattempo il buffer si è di nuovo svuotato, a questo punto <strong>thread 1</strong> ha finito di mandare le sue cose e si è tolto dai piedi. <strong>Thread 3</strong> anche lui è riuscito a mandare buona parte delle cose e riesce a entrare a <strong>thread 2</strong>. Che manda finalmente <code>2.0</code> e poi cercherebbe di mandare <code>2.1</code>, ma nel frattempo c'era il <strong>thread 3</strong> con l'ultimo messaggio che entra, si toglie dai piedi, e a questo punto vediamo <code>2.1</code> e <code>2.2</code>. A quel punto sono morti tutti, e il ricevitore se n'è andato.</p>
<p><strong>Quindi creando un canale così, gli diamo un vincolo.</strong> Io potrei addirittura farlo diventare di <strong>0</strong>.</p>
<p><em>Cosa succede se lo faccio di dimensione <strong>0</strong>?</em>
Succede che <em>non c'è buffer</em>. Se io cerco di scrivere, aspetto fino a che in contemporanea a me non entra anche l'altro che legge: dobbiamo necessariamente incontrarci. Per questo motivo un <code>sync_channel</code> di <strong>0</strong> viene chiamato un <em><strong>rendezvous</strong></em> — <em>un incontro</em>.</p>
<p><em>Ci passiamo l'oggetto di mano: io te lo dò non perché lo appoggio qui e tu lo prendi, ma te lo dò in mano.</em> <em>Quindi dobbiamo essere tutti e due presenti. Finché tu non ci sei io non te lo posso depositare.</em></p>
<h3 id="521-esempio-con-buffer-di-dimensione-0"><a class="header" href="#521-esempio-con-buffer-di-dimensione-0"><strong>5.2.1 Esempio con buffer di dimensione 0</strong></a></h3>
<p><img src="images/concorrenza/image%2070.png" alt="image.png" /></p>
<p><img src="images/concorrenza/image%2071.png" alt="image.png" /></p>
<p>Dopo la ricompilazione, vediamo che tutti e tre i thread provano a mandare e rimangono fermi. In realtà il thread 1 è il primo che è entrato. Quando finalmente arriva il ricevitore, si prende un pezzo - prima da thread 1 e poi da thread 3. Vediamo quindi <code>Got Message 1.0</code>, <code>Got Message 3.0</code>. E thread 1 e thread 3 tornano subito per passare un altro dato (<code>Thread 1 Sending 1</code> e <code>Thread 3 Sending 1</code>).
Poi riesce ad entrare <code>2.0</code>, poi <code>3.1</code>, poi <code>1.1</code>, poi <code>2.1</code> e così via fino alla conclusione.</p>
<p><em>Anche qui potremmo chiederci: ma <code>Got Message 3.0</code> non dovrebbe avvenire prima del <code>Thread 3 Sending 1</code>?</em>
<strong>Attenzione:</strong> <code>Sending</code> lo scriviamo prima della <code>send</code>, mentre <code>Got Message</code> lo facciamo dopo la <code>receive</code>. Quando avviene la receive, si libera lo spazio, <strong>ma può verificarsi un thread switching.</strong>
È quindi possibile vedere prima la stampa che mostra la conseguenza dello spazio liberato (<code>Thread 3 Sending 1</code>) prima che l'altro thread comunichi di aver preso il dato (<code>Got Message 3.0</code>).</p>
<p>Quindi la stampa di 3,1 invia 1, la stampa di 3,3 di 1, e poi 3,1 effettivamente scrive l'1 sul canale. Questo accade perché, guardando il codice, <code>println!</code> è prima della <code>send</code> — quindi può essere eseguita subito, senza vincoli. Poi però il thread si ferma lì (righe 11 e 15).</p>
<h3 id="522-conclusioni-sui-canali-sincroni"><a class="header" href="#522-conclusioni-sui-canali-sincroni">5.2.2 Conclusioni sui canali sincroni</a></h3>
<p><strong>Quindi, i sync channel fissano una dimensione del buffer.</strong>
Ci sono casi in cui si può mettere 0, ma di solito si mette un numero ragionevole: 10, 20, 50. <em>Perché?</em> Perché il buffer serve ad armonizzare <em><strong>l'andamento relativo</strong></em>. Quei numeri lì si trovano di solito per sperimentazione nel momento in cui abbiamo l'algoritmo giusto, e allora si prova a vedere, cambiandoli un po', se si possono migliorare in media le prestazioni. Ma il presupposto è che l'algoritmo sia giusto a priori.</p>
<h2 id="53-la-libreria-crossbeam"><a class="header" href="#53-la-libreria-crossbeam">5.3 La libreria Crossbeam</a></h2>
<p><img src="images/concorrenza/image%2072.png" alt="image.png" /></p>
<p><strong>I canali nella libreria standard di Windows</strong> sono canali strettamente <em>multiple producer, single consumer</em> (<strong>MPSC</strong>).</p>
<p>Altre librerie ci forniscono comportamenti diversi. Qui in particolare diamo spazio a una libreria che si chiama <strong>Crossbeam</strong>, che ha dentro di sé una serie di astrazioni, tutte molto interessanti nel contesto della programmazione concorrente.</p>
<p>L'aspetto su cui vogliamo mettere l'accento, al di là delle tante strutture che sono citate qua dentro, sono i <strong>canali offerti da Crossbeam</strong>. Per poter usare Crossbeam bisogna metterlo tra le dipendenze nel cargo.toml. Nel momento in cui lo aggiungo alle dipendenze, posso usarlo nel progetto. I suoi canali, a differenza di quelli standard che sono <em>multiple producer, <strong>single</strong> consumer</em>, sono di tanti tipi.</p>
<p><img src="images/concorrenza/image%2073.png" alt="image.png" /></p>
<p>In particolare ci sono canali anche <em>multiple producer, <strong>multiple</strong> consumer</em>, dove cioè <strong>anche il ricevitore può essere clonato</strong>.</p>
<p><em>Come funzionano i canali multiple consumer?</em> <strong><em>Il messaggio è sempre consumato una volta sola</em>.</strong> Se ci sono due a leggerlo, quel messaggio lì, a caso, verrà letto o dal lettore 1 o dal lettore 2.
Nel senso che se ci sono più lettori che insieme cercano di mangiarsi quella cosa lì, a caso, oppure il primo che è arrivato, si recupererà il messaggio letto e l'altro aspetta il successivo.</p>
<p>Quindi si usano i multiple receiver in quelle situazioni in cui mi sta bene di non sapere a priori chi è che consuma un certo messaggio.</p>
<p><em>Perché questo è interessante?</em>
Perché mi abilita una serie di <strong>pattern di programmazione concorrente</strong> in cui posso organizzare il mio lavoro. Ce ne sono tre che vediamo qua dentro:</p>
<ul>
<li><strong>Fan-Out / Fan-In</strong></li>
<li><strong>Pipeline</strong></li>
<li><strong>Producer / consumer</strong></li>
</ul>
<h3 id="531-fan-out--fan-in"><a class="header" href="#531-fan-out--fan-in">5.3.1 Fan-Out / Fan-In</a></h3>
<p><img src="images/concorrenza/image%2074.png" alt="image.png" /></p>
<p>Il <strong>Fan-Out / Fan-In</strong> si usa in quelle situazioni in cui io ho una sorgente di dati che produce delle informazioni di qualche tipo.</p>
<p>Qui vediamo un esempio di tali situazioni.
Nel disegno, il filo ad elica è un thread, è il filo del thread che si dipana. Quindi ho un thread che fa da producer e che genera su un canale una sequenza di valori: sono quei quadratini azzurri messi lì nel canale.</p>
<p>Questi valori, prima di poter essere davvero usati, hanno bisogno di subire una qualche trasformazione. Ad esempio, quelli lì potrebbero essere delle <strong>coordinate GPS</strong>. Io ho il <strong>producer</strong>, è un ricevitore GPS, con la sua radio e tutte quelle cose lì, e ogni secondo ti tira fuori una posizione nuova. Io voglio archiviare queste posizioni su un <strong>database</strong>, corredandole però non solo della <em>latitudine e longitudine</em>, che è quello che mi dice il ricevitore GPS, ma anche del <strong>nome della via</strong> e il <strong>numero civico</strong>. Qui è <em>Via Roma 33</em>. Qui invece hai girato, e sei finito in <em>Via Garibaldi 1</em>.</p>
<p>Quindi mi interessa <strong>arricchire</strong> quelle informazioni. Arricchire quelle informazioni è un'operazione <strong>potenzialmente lenta</strong>, perché devo cercare in un grosso database, per cercare di matchare quel punto lì a quali altri punti si trova vicino, e devo selezionare il più vicino di quelli che ho dotato di via e numero civico. E quindi ci può mettere tempo.</p>
<p>Allora, siccome voglio evitare di fare la somma di tutti questi tempi, perché quello che succederebbe è che la coda si riempirebbe, e o vado in <strong>overflow</strong>, se il canale è <em>unbounded</em>, oppure se lo faccio <em>bounded</em>, perdo dei punti dal GPS, perché a un certo punto cerco di depositare una cosa, ma il mio elaboratore non è abbastanza rapido ad arricchirmelo con l'informazione che mi serve, e quindi lo perdo.</p>
<p><em>Allora cosa faccio?</em>
Ipotizzando che il tempo necessario a decorare il mio dato con l'arricchimento sia, diciamo, di <strong>5 volte</strong> il tempo della produzione, mi preparo <strong>6 worker</strong>, o anche 7, o anche 10, <em>in modo da averne un po' di più</em>. Così da, in media, cercare di stare nel tempo voluto.</p>
<p>E cosa fa il <strong>producer</strong>? Il producer scrive strettamente in ordine i suoi numeri, che tanto hanno un timestamp. Poi ho un <strong>gruppo di worker</strong>, cioè un gruppo di thread, ognuno indipendente dagli altri, che lottano per strappare dal canale d'ingresso un messaggio. Appena si appropriano di un messaggio, fanno la <em>ricerca nel database</em>, lo decorano con l'indirizzo, e lo sbattono in uscita.</p>
<p>Ovviamente non è detto che escano nello stesso ordine con cui sono entrati, perché i messaggi io li ho scritti <code>1, 2, 3</code>, poi siccome il tempo di arricchimento può essere variabile per un insieme di motivi, può darsi che mi escano <code>3, 1, 2</code>. Non è un grosso problema. Il <strong>consumer finale</strong> è poi responsabile di riordinarli.</p>
<p>Quindi un pattern del genere mi permette di avere <strong>n worker</strong>, che di per sé sono identici, fanno esattamente lo stesso mestiere, ma siccome lo fanno in parallelo (perché io posso sfruttare <em>n CPU</em> che ho a disposizione), riescono a compensare il fatto che l'operazione che fanno è lenta rispetto al tasso con cui io spedisco delle cose. Quindi in media io ho in uscita un pacchetto ogni volta che ho un pacchetto in ingresso, con il possibile riordinamento.</p>
<blockquote>
<p>💡 <strong>Curiosità sulla gestione dei thread tramite priorità</strong></p>
<p>L’idea di gestire l’ordine con cui i thread fanno le cose con un meccanismo di priorità si può fare, ma in generale è un'idea <strong>pessima</strong>.
Gli scheduler hanno il concetto di <em>priorità</em>. Ma la priorità, nel momento in cui la assegno, mi divide i thread runnable in classi. Ci sono i runnable a priorità massima, che passano sempre e comunque davanti ai runnable di priorità più bassa della loro.</p>
<p>Questa cosa qua sembra banale e ovvia, ma nasconde un <strong>piccolo problema</strong>, che si chiama <em><strong>priority inversion</strong></em>.
Potrebbe capitare in un momento che di cosa d'alta priorità non ce n'è nessuna. Perfetto. E allora guardo quelli di priorità più bassa. A priorità media non c'è di nuovo nessuno. Perfetto di nuovo. Passo a quelli di priorità ancora più bassa. A priorità bassissima ce ne sta uno. Magnifico. Lo lancio, tanto se avessi bisogno di far qualcosa di più urgente, lo sospenderei immediatamente, perché come mi arriva qualcuno più urgente, lo mollo lì e passo all'urgente.</p>
<p>Quello lì a <em>bassa priorità</em> potrebbe prendere un <strong>lock</strong>. Prende il lock e comincia a fare. Mentre possiede il lock, mi arriva uno ad <em>alta priorità</em>. Quindi lui lo congelo lì, con il suo lock in mano, perché non so a che punto è arrivato, e mi metto a prendere in considerazione quello ad alta priorità.</p>
<p>Quello ad <em>alta priorità</em> vuole quello stesso lock. E <strong>non posso darglielo</strong>. Non posso darglielo perché ce l'ha quello a bassa priorità. E quindi, quello ad alta priorità si ferma necessariamente, va in stato <em>non runnable</em>, perché per il momento non c'è il lock, e torna <em>runnable</em> quello a bassa priorità. Mentre sta ancora andando avanti, supponiamo che abbia 3 o 4 cose da fare, mentre sta ancora andando avanti, si presenta uno a <em>media priorità</em>. A questo punto, quello a media priorità, di nuovo, ha la prevalenza su quello a bassa, che di nuovo viene congelato, quindi il lock resta inaccessibile, e quello a media comincia a fare i fatti suoi. Supponiamo ora che quello a media priorità vada avanti per un'ora. <strong>Questo è un grosso problema</strong>.</p>
<p>In questo modo, la prima missione su Marte è fallita. La prima missione su Marte ha mandato un <strong>rover</strong>, che aveva un <strong>sistema operativo real-time a priorità</strong>, e aveva dei task ad <em>alta priorità</em>, a <em>media priorità</em>, a <em>bassa priorità</em>. Il rover è atterrato su Marte, ha cominciato a fare cose, e si è piantato. Ma ci hanno messo <strong>3 giorni</strong> quelli della NASA a capire perché si era piantato: si era verificata la <em><strong>priority inversion</strong></em>.</p>
<p>Per questo motivo i moderni sistemi operativi, la priorità di un thread, la legano <strong>dinamicamente</strong>. Cioè tu lo battezzi a bassa priorità. Nel momento in cui possiedi un <em>lock</em>, e su quel lock si mette in attesa qualcuno a priorità maggiore della tua, temporaneamente ti trasferisce questa cosa. E quindi questo permette al task, che normalmente sarebbe a bassa priorità, poiché sta possedendo un lock su cui c'è in attesa qualcuno più urgente, di dire <em>"va bene, allora, proprio perché questa cosa serve a lui che è più urgente, tu finisci e togliti in fretta dai piedi"</em>. E quello che è medio aspetta. Ma qusta cosa è crea una serie di turbe. Motivo per cui l'uso delle priorità sulle schedulazioni, va fatto con <em>tantissima, tantissima consapevolezza</em>. Questa cosa è costata <strong>qualche milione di dollari</strong> alla NASA.</p>
</blockquote>
<p>Dunque, il meccanismo del <strong>Fan-Out / Fan-In</strong> è: <em>sfrutto il fatto che ho un'operazione lenta, che richiede tempo, che tenderebbe a ritardarmi troppo il canale di ingresso, quindi ne metto una serie in parallelo, in modo tale che il tasso medio di uscita sia compatibile col tasso medio di ingresso.</em>
Se l'operazione fatta dal <strong>worker</strong> dura, diciamo, <em>dieci volte</em> il tempo medio in cui mi entra un nuovo messaggio, io di worker ne devo mettere <strong>venti</strong>, per essere tranquillo.</p>
<p><img src="images/concorrenza/image%2075.png" alt="image.png" /></p>
<p>Qui vediamo come si implementa. In realtà è banale, semplicemente perché con i <strong>canali di Crossbeam</strong>, io non solo posso clonare il <code>tx</code>, posso clonare anche l'<code>rx</code>. E potendo clonare anche l'<code>rx</code>, riesco a farmi quanti ricevitori voglio.</p>
<h3 id="532-pipeline"><a class="header" href="#532-pipeline">5.3.2 Pipeline</a></h3>
<p><img src="images/concorrenza/image%2076.png" alt="image.png" /></p>
<p>Secondo pattern alquanto comune, è il <strong>pattern della pipeline</strong>.</p>
<p>Nella pipeline io ho una serie di fasi. Prendo un oggetto che ha una certa forma, gli faccio delle operazioni, poi lo produco e lo metto in uscita. Su ciascuno di queste cose faccio delle ulteriori trasformazioni e lo passo avanti e così via, fino a dargli l'aspetto finale che mi interessa. Questo mi serve perché le varie <em>fasi intermedie</em> possono avere delle logiche più o meno complesse e quindi io posso tenere ben separati i compiti che sto svolgendo, usando il <strong>buffer dei singoli canali</strong> <strong>come ammortizzatore</strong>. Perché a volte magari <em>stage 1</em> è veloce e <em>stage 2</em> è lento, a volte è il contrario e in media si compensano grazie al fatto che i canali sono abbastanza elastici.</p>
<p>Quando uso la pipeline, mediamente faccio attenzione a generare della <strong>back pressure</strong>. Perché se mai si piantasse uno qualunque degli stadi intermedi o lo stadio finale, il produttore non ne saprebbe niente e continuerebbe a produrre, produrre, produrre, e dopo un po' questa cosa scoppia. Per cui si usano dei <strong>canali sync limitati</strong>, anche grossi, ma comunque limitati.</p>
<p><img src="images/concorrenza/image%2077.png" alt="image.png" /></p>
<p>Qua c'è un esempio. Vedete infatti che qui vengono usati i <em>canali bounded</em>. Nel main vediamo <code>let (tx_input, rx_input) = bounded::&lt;i32&gt;(10)</code> — voglio un canale che trasporta degli interi, che al massimo ne tiene 10. E così via.</p>
<h3 id="533-producer--consumer"><a class="header" href="#533-producer--consumer">5.3.3 Producer / Consumer</a></h3>
<p><img src="images/concorrenza/image%2078.png" alt="image.png" /></p>
<p>Infine, l'ultimo dei pattern che possiamo vedere è quello <em><strong>producer and consumer</strong></em>.</p>
<p>Qua di nuovo sfruttiamo un <strong>canale</strong> come strumento per distribuire del lavoro tra un certo numero di cose. Questo è il pattern che normalmente si usa, ad esempio, per l'implementazione dei <strong>thread pool</strong>.</p>
<p><em>Cos'è un thread pool?</em>
Un thread pool è un <em>insieme di thread</em> che sono destinati a fare il lavoro che altri non vogliono fare. Ovvero, di base, loro aspettano di ricevere una descrizione, diciamo l'indirizzo della funzione da chiamare, su un canale. Aspettano. Nel momento in cui qualcuno gli dice <em>"C'è questa cosa da fare: chiama la funzione a questo indirizzo”</em>. Loro ricevono dal canale l'indirizzo, che alla fine è un numero, e poi invocano quella funzione lì.
Invocandola, la funzione viene eseguita nel contesto del <em>thread ricevitore</em> che fa tutte le sue cose. Normalmente quella lì è una funzione che non ha argomenti e non ritorna un bel niente, quindi ha <strong>effetti collaterali</strong> di varia natura. Ci può richiedere tanto o poco tempo, non ha importanza.
Non appena finiscono di eseguire quella funzione tornano sul canale a vedere se c'è un'altra cosa da fare.</p>
<p>Quindi i thread pool sono i <em>servi dei nostri programmi</em>. Li dimensioniamo con un numero di thread sufficienti per il livello di parallelismo che riteniamo la nostra macchina abbia. Ad esempio il numero di <strong>core fisici</strong>. Se io sto girando su una macchina che ha 4 core, perfetto, creo un thread pool con 4 thread. Che di base sono fermi, perché tutti e 4 cercherebbero di prendere del codice da eseguire e non ricevono nulla. Quando però l'algoritmo principale ha qualcosa da fare, la affida al thread pool: fa una <em>dispatch</em>, cioè manda sul canale l'indirizzo della funzione da chiamare. E a quel punto sa che prima o poi verrà chiamata. Questa funzione normalmente sarà progettata con degli effetti collaterali, in modo che l'algoritmo principale possa capire quando finalmente ha finito. E vanno avanti così.</p>
<p>Allora l'uso dei canali <strong>multiple producer, multiple consumer</strong> va benissimo, perché qualunque thread può affidare cose da fare, può diventare un <em>producer</em>, e tipicamente i thread che formano il thread pool fanno da <em>consumer</em>. Stanno in attesa di ricevere cose da fare.</p>
<p><img src="images/concorrenza/image%2079.png" alt="image.png" /></p>
<p>E qui vediamo l'esempio di questo pattern.</p>
<h3 id="534-il-modello-degli-attori"><a class="header" href="#534-il-modello-degli-attori">5.3.4 Il modello degli attori</a></h3>
<p><img src="images/concorrenza/image%2080.png" alt="image.png" /></p>
<p><strong>Il modello degli attori</strong> è un altro pattern che esiste, anche se oggigiorno è messo un po' in discussione per un insieme di fattori. Questo modello è implementato dalla libreria <strong>Actix</strong>. Actix è una libreria molto grande, che ha varie declinazioni. Più rilevante è la declinazione <strong>Actix web</strong>, che implementa fondamentalmente il comportamento di un web server. Nella declinazione semplice, Actix soltanto, mette a disposizione il modello degli attori, dove l'<em>attore</em> è un oggetto che possiede anche un thread.</p>
<p>Questo modello risale alla <strong>visione originale della programmazione a oggetti</strong>, così come era nata alla fine degli anni '60, inizio degli anni '70, pensando che l'oggetto fosse una cosa attiva che riceve messaggi. Per questo motivo a volte si dice <em>"mando un messaggio a quell'oggetto"</em>, perché nella visione originale gli oggetti avevano un loro thread che consumava messaggi e agiva di conseguenza. E le chiamate tra oggetti non erano in realtà vere invocazioni, come le usiamo oggigiorno, ma erano depositare nella lista delle cose che l'altro doveva fare un messaggio, affinché l'altro poi facesse.</p>
<h1 id="6-riferimenti"><a class="header" href="#6-riferimenti">6. Riferimenti</a></h1>
<p><img src="images/concorrenza/image%2081.png" alt="image.png" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="15-smart_pointer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="17-processi_parte_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="15-smart_pointer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="17-processi_parte_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
